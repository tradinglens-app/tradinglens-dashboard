/**
 * Client
 **/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model CompaniesInfo
 * This table is a partition table and requires additional setup for migrations. Visit https://pris.ly/d/partition-tables for more info.
 */
export type CompaniesInfo =
  $Result.DefaultSelection<Prisma.$CompaniesInfoPayload>;
/**
 * Model FollowNotificationOverrides
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type FollowNotificationOverrides =
  $Result.DefaultSelection<Prisma.$FollowNotificationOverridesPayload>;
/**
 * Model FollowRequests
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type FollowRequests =
  $Result.DefaultSelection<Prisma.$FollowRequestsPayload>;
/**
 * Model Follows
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Follows = $Result.DefaultSelection<Prisma.$FollowsPayload>;
/**
 * Model FollowsCount
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type FollowsCount =
  $Result.DefaultSelection<Prisma.$FollowsCountPayload>;
/**
 * Model Notifications
 * This table is a partition table and requires additional setup for migrations. Visit https://pris.ly/d/partition-tables for more info.
 */
export type Notifications =
  $Result.DefaultSelection<Prisma.$NotificationsPayload>;
/**
 * Model Symbols
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Symbols = $Result.DefaultSelection<Prisma.$SymbolsPayload>;
/**
 * Model ThreadEngagementMetrics
 * This table is a partition table and requires additional setup for migrations. Visit https://pris.ly/d/partition-tables for more info.
 */
export type ThreadEngagementMetrics =
  $Result.DefaultSelection<Prisma.$ThreadEngagementMetricsPayload>;
/**
 * Model ThreadHashtags
 * This table is a partition table and requires additional setup for migrations. Visit https://pris.ly/d/partition-tables for more info.
 */
export type ThreadHashtags =
  $Result.DefaultSelection<Prisma.$ThreadHashtagsPayload>;
/**
 * Model ThreadLikes
 * This table is a partition table and requires additional setup for migrations. Visit https://pris.ly/d/partition-tables for more info.
 */
export type ThreadLikes = $Result.DefaultSelection<Prisma.$ThreadLikesPayload>;
/**
 * Model ThreadMedia
 * This table is a partition table and requires additional setup for migrations. Visit https://pris.ly/d/partition-tables for more info.
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type ThreadMedia = $Result.DefaultSelection<Prisma.$ThreadMediaPayload>;
/**
 * Model ThreadMentions
 * This table is a partition table and requires additional setup for migrations. Visit https://pris.ly/d/partition-tables for more info.
 */
export type ThreadMentions =
  $Result.DefaultSelection<Prisma.$ThreadMentionsPayload>;
/**
 * Model ThreadPins
 * This table is a partition table and requires additional setup for migrations. Visit https://pris.ly/d/partition-tables for more info.
 */
export type ThreadPins = $Result.DefaultSelection<Prisma.$ThreadPinsPayload>;
/**
 * Model ThreadPollOptions
 * This table is a partition table and requires additional setup for migrations. Visit https://pris.ly/d/partition-tables for more info.
 */
export type ThreadPollOptions =
  $Result.DefaultSelection<Prisma.$ThreadPollOptionsPayload>;
/**
 * Model ThreadPollVotes
 * This table is a partition table and requires additional setup for migrations. Visit https://pris.ly/d/partition-tables for more info.
 */
export type ThreadPollVotes =
  $Result.DefaultSelection<Prisma.$ThreadPollVotesPayload>;
/**
 * Model ThreadPolls
 * This table is a partition table and requires additional setup for migrations. Visit https://pris.ly/d/partition-tables for more info.
 */
export type ThreadPolls = $Result.DefaultSelection<Prisma.$ThreadPollsPayload>;
/**
 * Model ThreadReportReasons
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type ThreadReportReasons =
  $Result.DefaultSelection<Prisma.$ThreadReportReasonsPayload>;
/**
 * Model ThreadReports
 * This table is a partition table and requires additional setup for migrations. Visit https://pris.ly/d/partition-tables for more info.
 */
export type ThreadReports =
  $Result.DefaultSelection<Prisma.$ThreadReportsPayload>;
/**
 * Model ThreadReposts
 * This table is a partition table and requires additional setup for migrations. Visit https://pris.ly/d/partition-tables for more info.
 */
export type ThreadReposts =
  $Result.DefaultSelection<Prisma.$ThreadRepostsPayload>;
/**
 * Model Threads
 * This table is a partition table and requires additional setup for migrations. Visit https://pris.ly/d/partition-tables for more info.
 */
export type Threads = $Result.DefaultSelection<Prisma.$ThreadsPayload>;
/**
 * Model UserBlocks
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type UserBlocks = $Result.DefaultSelection<Prisma.$UserBlocksPayload>;
/**
 * Model UserInterestLogs
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type UserInterestLogs =
  $Result.DefaultSelection<Prisma.$UserInterestLogsPayload>;
/**
 * Model UserInterests
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type UserInterests =
  $Result.DefaultSelection<Prisma.$UserInterestsPayload>;
/**
 * Model UserNotificationSettings
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type UserNotificationSettings =
  $Result.DefaultSelection<Prisma.$UserNotificationSettingsPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const assets_type_enum: {
    equity: 'equity';
    etf: 'etf';
    cryptocurrency: 'cryptocurrency';
    index: 'index';
  };

  export type assets_type_enum =
    (typeof assets_type_enum)[keyof typeof assets_type_enum];

  export const media_type_enum: {
    image_heic: 'image_heic';
    image_heif: 'image_heif';
    image_jpeg: 'image_jpeg';
    image_jpg: 'image_jpg';
    image_png: 'image_png';
    image_gif: 'image_gif';
    image_webp: 'image_webp';
    video_mp4: 'video_mp4';
    video_quicktime: 'video_quicktime';
    image: 'image';
    gif: 'gif';
  };

  export type media_type_enum =
    (typeof media_type_enum)[keyof typeof media_type_enum];

  export const notification_type_enum: {
    like: 'like';
    reply: 'reply';
    mention: 'mention';
    follow: 'follow';
    quote: 'quote';
    repost: 'repost';
    system: 'system';
    socials: 'socials';
    breaking_news: 'breaking_news';
    thread_poll: 'thread_poll';
    thread: 'thread';
    follow_request: 'follow_request';
    follow_request_accepted: 'follow_request_accepted';
    new_post: 'new_post';
    new_reply: 'new_reply';
  };

  export type notification_type_enum =
    (typeof notification_type_enum)[keyof typeof notification_type_enum];

  export const tag_type_enum: {
    hashtag: 'hashtag';
    symbol: 'symbol';
  };

  export type tag_type_enum =
    (typeof tag_type_enum)[keyof typeof tag_type_enum];

  export const visibility_enum: {
    public: 'public';
    private: 'private';
    followers_only: 'followers_only';
    following_only: 'following_only';
    followers_and_following_only: 'followers_and_following_only';
  };

  export type visibility_enum =
    (typeof visibility_enum)[keyof typeof visibility_enum];
}

export type assets_type_enum = $Enums.assets_type_enum;

export const assets_type_enum: typeof $Enums.assets_type_enum;

export type media_type_enum = $Enums.media_type_enum;

export const media_type_enum: typeof $Enums.media_type_enum;

export type notification_type_enum = $Enums.notification_type_enum;

export const notification_type_enum: typeof $Enums.notification_type_enum;

export type tag_type_enum = $Enums.tag_type_enum;

export const tag_type_enum: typeof $Enums.tag_type_enum;

export type visibility_enum = $Enums.visibility_enum;

export const visibility_enum: typeof $Enums.visibility_enum;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CompaniesInfos
 * const companiesInfos = await prisma.companiesInfo.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CompaniesInfos
   * const companiesInfos = await prisma.companiesInfo.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent
    ) => void
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.companiesInfo`: Exposes CRUD operations for the **CompaniesInfo** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more CompaniesInfos
   * const companiesInfos = await prisma.companiesInfo.findMany()
   * ```
   */
  get companiesInfo(): Prisma.CompaniesInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.followNotificationOverrides`: Exposes CRUD operations for the **FollowNotificationOverrides** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FollowNotificationOverrides
   * const followNotificationOverrides = await prisma.followNotificationOverrides.findMany()
   * ```
   */
  get followNotificationOverrides(): Prisma.FollowNotificationOverridesDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.followRequests`: Exposes CRUD operations for the **FollowRequests** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FollowRequests
   * const followRequests = await prisma.followRequests.findMany()
   * ```
   */
  get followRequests(): Prisma.FollowRequestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.follows`: Exposes CRUD operations for the **Follows** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Follows
   * const follows = await prisma.follows.findMany()
   * ```
   */
  get follows(): Prisma.FollowsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.followsCount`: Exposes CRUD operations for the **FollowsCount** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FollowsCounts
   * const followsCounts = await prisma.followsCount.findMany()
   * ```
   */
  get followsCount(): Prisma.FollowsCountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **Notifications** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Notifications
   * const notifications = await prisma.notifications.findMany()
   * ```
   */
  get notifications(): Prisma.NotificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.symbols`: Exposes CRUD operations for the **Symbols** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Symbols
   * const symbols = await prisma.symbols.findMany()
   * ```
   */
  get symbols(): Prisma.SymbolsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threadEngagementMetrics`: Exposes CRUD operations for the **ThreadEngagementMetrics** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ThreadEngagementMetrics
   * const threadEngagementMetrics = await prisma.threadEngagementMetrics.findMany()
   * ```
   */
  get threadEngagementMetrics(): Prisma.ThreadEngagementMetricsDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.threadHashtags`: Exposes CRUD operations for the **ThreadHashtags** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ThreadHashtags
   * const threadHashtags = await prisma.threadHashtags.findMany()
   * ```
   */
  get threadHashtags(): Prisma.ThreadHashtagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threadLikes`: Exposes CRUD operations for the **ThreadLikes** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ThreadLikes
   * const threadLikes = await prisma.threadLikes.findMany()
   * ```
   */
  get threadLikes(): Prisma.ThreadLikesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threadMedia`: Exposes CRUD operations for the **ThreadMedia** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ThreadMedias
   * const threadMedias = await prisma.threadMedia.findMany()
   * ```
   */
  get threadMedia(): Prisma.ThreadMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threadMentions`: Exposes CRUD operations for the **ThreadMentions** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ThreadMentions
   * const threadMentions = await prisma.threadMentions.findMany()
   * ```
   */
  get threadMentions(): Prisma.ThreadMentionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threadPins`: Exposes CRUD operations for the **ThreadPins** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ThreadPins
   * const threadPins = await prisma.threadPins.findMany()
   * ```
   */
  get threadPins(): Prisma.ThreadPinsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threadPollOptions`: Exposes CRUD operations for the **ThreadPollOptions** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ThreadPollOptions
   * const threadPollOptions = await prisma.threadPollOptions.findMany()
   * ```
   */
  get threadPollOptions(): Prisma.ThreadPollOptionsDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.threadPollVotes`: Exposes CRUD operations for the **ThreadPollVotes** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ThreadPollVotes
   * const threadPollVotes = await prisma.threadPollVotes.findMany()
   * ```
   */
  get threadPollVotes(): Prisma.ThreadPollVotesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threadPolls`: Exposes CRUD operations for the **ThreadPolls** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ThreadPolls
   * const threadPolls = await prisma.threadPolls.findMany()
   * ```
   */
  get threadPolls(): Prisma.ThreadPollsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threadReportReasons`: Exposes CRUD operations for the **ThreadReportReasons** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ThreadReportReasons
   * const threadReportReasons = await prisma.threadReportReasons.findMany()
   * ```
   */
  get threadReportReasons(): Prisma.ThreadReportReasonsDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.threadReports`: Exposes CRUD operations for the **ThreadReports** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ThreadReports
   * const threadReports = await prisma.threadReports.findMany()
   * ```
   */
  get threadReports(): Prisma.ThreadReportsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threadReposts`: Exposes CRUD operations for the **ThreadReposts** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ThreadReposts
   * const threadReposts = await prisma.threadReposts.findMany()
   * ```
   */
  get threadReposts(): Prisma.ThreadRepostsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threads`: Exposes CRUD operations for the **Threads** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Threads
   * const threads = await prisma.threads.findMany()
   * ```
   */
  get threads(): Prisma.ThreadsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBlocks`: Exposes CRUD operations for the **UserBlocks** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserBlocks
   * const userBlocks = await prisma.userBlocks.findMany()
   * ```
   */
  get userBlocks(): Prisma.UserBlocksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userInterestLogs`: Exposes CRUD operations for the **UserInterestLogs** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserInterestLogs
   * const userInterestLogs = await prisma.userInterestLogs.findMany()
   * ```
   */
  get userInterestLogs(): Prisma.UserInterestLogsDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.userInterests`: Exposes CRUD operations for the **UserInterests** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserInterests
   * const userInterests = await prisma.userInterests.findMany()
   * ```
   */
  get userInterests(): Prisma.UserInterestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userNotificationSettings`: Exposes CRUD operations for the **UserNotificationSettings** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserNotificationSettings
   * const userNotificationSettings = await prisma.userNotificationSettings.findMany()
   * ```
   */
  get userNotificationSettings(): Prisma.UserNotificationSettingsDelegate<
    ExtArgs,
    ClientOptions
  >;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 7.4.0
   * Query Engine version: ab56fe763f921d033a6c195e7ddeb3e255bdbb57
   */
  export type PrismaVersion = {
    client: string;
    engine: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import Bytes = runtime.Bytes;
  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    CompaniesInfo: 'CompaniesInfo';
    FollowNotificationOverrides: 'FollowNotificationOverrides';
    FollowRequests: 'FollowRequests';
    Follows: 'Follows';
    FollowsCount: 'FollowsCount';
    Notifications: 'Notifications';
    Symbols: 'Symbols';
    ThreadEngagementMetrics: 'ThreadEngagementMetrics';
    ThreadHashtags: 'ThreadHashtags';
    ThreadLikes: 'ThreadLikes';
    ThreadMedia: 'ThreadMedia';
    ThreadMentions: 'ThreadMentions';
    ThreadPins: 'ThreadPins';
    ThreadPollOptions: 'ThreadPollOptions';
    ThreadPollVotes: 'ThreadPollVotes';
    ThreadPolls: 'ThreadPolls';
    ThreadReportReasons: 'ThreadReportReasons';
    ThreadReports: 'ThreadReports';
    ThreadReposts: 'ThreadReposts';
    Threads: 'Threads';
    UserBlocks: 'UserBlocks';
    UserInterestLogs: 'UserInterestLogs';
    UserInterests: 'UserInterests';
    UserNotificationSettings: 'UserNotificationSettings';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | 'companiesInfo'
        | 'followNotificationOverrides'
        | 'followRequests'
        | 'follows'
        | 'followsCount'
        | 'notifications'
        | 'symbols'
        | 'threadEngagementMetrics'
        | 'threadHashtags'
        | 'threadLikes'
        | 'threadMedia'
        | 'threadMentions'
        | 'threadPins'
        | 'threadPollOptions'
        | 'threadPollVotes'
        | 'threadPolls'
        | 'threadReportReasons'
        | 'threadReports'
        | 'threadReposts'
        | 'threads'
        | 'userBlocks'
        | 'userInterestLogs'
        | 'userInterests'
        | 'userNotificationSettings';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      CompaniesInfo: {
        payload: Prisma.$CompaniesInfoPayload<ExtArgs>;
        fields: Prisma.CompaniesInfoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CompaniesInfoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompaniesInfoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CompaniesInfoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompaniesInfoPayload>;
          };
          findFirst: {
            args: Prisma.CompaniesInfoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompaniesInfoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CompaniesInfoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompaniesInfoPayload>;
          };
          findMany: {
            args: Prisma.CompaniesInfoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompaniesInfoPayload>[];
          };
          create: {
            args: Prisma.CompaniesInfoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompaniesInfoPayload>;
          };
          createMany: {
            args: Prisma.CompaniesInfoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CompaniesInfoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompaniesInfoPayload>[];
          };
          delete: {
            args: Prisma.CompaniesInfoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompaniesInfoPayload>;
          };
          update: {
            args: Prisma.CompaniesInfoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompaniesInfoPayload>;
          };
          deleteMany: {
            args: Prisma.CompaniesInfoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CompaniesInfoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.CompaniesInfoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompaniesInfoPayload>[];
          };
          upsert: {
            args: Prisma.CompaniesInfoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompaniesInfoPayload>;
          };
          aggregate: {
            args: Prisma.CompaniesInfoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCompaniesInfo>;
          };
          groupBy: {
            args: Prisma.CompaniesInfoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CompaniesInfoGroupByOutputType>[];
          };
          count: {
            args: Prisma.CompaniesInfoCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<CompaniesInfoCountAggregateOutputType>
              | number;
          };
        };
      };
      FollowNotificationOverrides: {
        payload: Prisma.$FollowNotificationOverridesPayload<ExtArgs>;
        fields: Prisma.FollowNotificationOverridesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FollowNotificationOverridesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowNotificationOverridesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FollowNotificationOverridesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowNotificationOverridesPayload>;
          };
          findFirst: {
            args: Prisma.FollowNotificationOverridesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowNotificationOverridesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FollowNotificationOverridesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowNotificationOverridesPayload>;
          };
          findMany: {
            args: Prisma.FollowNotificationOverridesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowNotificationOverridesPayload>[];
          };
          create: {
            args: Prisma.FollowNotificationOverridesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowNotificationOverridesPayload>;
          };
          createMany: {
            args: Prisma.FollowNotificationOverridesCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FollowNotificationOverridesCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowNotificationOverridesPayload>[];
          };
          delete: {
            args: Prisma.FollowNotificationOverridesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowNotificationOverridesPayload>;
          };
          update: {
            args: Prisma.FollowNotificationOverridesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowNotificationOverridesPayload>;
          };
          deleteMany: {
            args: Prisma.FollowNotificationOverridesDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FollowNotificationOverridesUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.FollowNotificationOverridesUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowNotificationOverridesPayload>[];
          };
          upsert: {
            args: Prisma.FollowNotificationOverridesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowNotificationOverridesPayload>;
          };
          aggregate: {
            args: Prisma.FollowNotificationOverridesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFollowNotificationOverrides>;
          };
          groupBy: {
            args: Prisma.FollowNotificationOverridesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FollowNotificationOverridesGroupByOutputType>[];
          };
          count: {
            args: Prisma.FollowNotificationOverridesCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<FollowNotificationOverridesCountAggregateOutputType>
              | number;
          };
        };
      };
      FollowRequests: {
        payload: Prisma.$FollowRequestsPayload<ExtArgs>;
        fields: Prisma.FollowRequestsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FollowRequestsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowRequestsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FollowRequestsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowRequestsPayload>;
          };
          findFirst: {
            args: Prisma.FollowRequestsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowRequestsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FollowRequestsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowRequestsPayload>;
          };
          findMany: {
            args: Prisma.FollowRequestsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowRequestsPayload>[];
          };
          create: {
            args: Prisma.FollowRequestsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowRequestsPayload>;
          };
          createMany: {
            args: Prisma.FollowRequestsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FollowRequestsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowRequestsPayload>[];
          };
          delete: {
            args: Prisma.FollowRequestsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowRequestsPayload>;
          };
          update: {
            args: Prisma.FollowRequestsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowRequestsPayload>;
          };
          deleteMany: {
            args: Prisma.FollowRequestsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FollowRequestsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.FollowRequestsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowRequestsPayload>[];
          };
          upsert: {
            args: Prisma.FollowRequestsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowRequestsPayload>;
          };
          aggregate: {
            args: Prisma.FollowRequestsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFollowRequests>;
          };
          groupBy: {
            args: Prisma.FollowRequestsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FollowRequestsGroupByOutputType>[];
          };
          count: {
            args: Prisma.FollowRequestsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<FollowRequestsCountAggregateOutputType>
              | number;
          };
        };
      };
      Follows: {
        payload: Prisma.$FollowsPayload<ExtArgs>;
        fields: Prisma.FollowsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FollowsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FollowsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsPayload>;
          };
          findFirst: {
            args: Prisma.FollowsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FollowsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsPayload>;
          };
          findMany: {
            args: Prisma.FollowsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsPayload>[];
          };
          create: {
            args: Prisma.FollowsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsPayload>;
          };
          createMany: {
            args: Prisma.FollowsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FollowsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsPayload>[];
          };
          delete: {
            args: Prisma.FollowsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsPayload>;
          };
          update: {
            args: Prisma.FollowsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsPayload>;
          };
          deleteMany: {
            args: Prisma.FollowsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FollowsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.FollowsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsPayload>[];
          };
          upsert: {
            args: Prisma.FollowsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsPayload>;
          };
          aggregate: {
            args: Prisma.FollowsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFollows>;
          };
          groupBy: {
            args: Prisma.FollowsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FollowsGroupByOutputType>[];
          };
          count: {
            args: Prisma.FollowsCountArgs<ExtArgs>;
            result: $Utils.Optional<FollowsCountAggregateOutputType> | number;
          };
        };
      };
      FollowsCount: {
        payload: Prisma.$FollowsCountPayload<ExtArgs>;
        fields: Prisma.FollowsCountFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FollowsCountFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsCountPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FollowsCountFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsCountPayload>;
          };
          findFirst: {
            args: Prisma.FollowsCountFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsCountPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FollowsCountFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsCountPayload>;
          };
          findMany: {
            args: Prisma.FollowsCountFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsCountPayload>[];
          };
          create: {
            args: Prisma.FollowsCountCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsCountPayload>;
          };
          createMany: {
            args: Prisma.FollowsCountCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FollowsCountCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsCountPayload>[];
          };
          delete: {
            args: Prisma.FollowsCountDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsCountPayload>;
          };
          update: {
            args: Prisma.FollowsCountUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsCountPayload>;
          };
          deleteMany: {
            args: Prisma.FollowsCountDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FollowsCountUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.FollowsCountUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsCountPayload>[];
          };
          upsert: {
            args: Prisma.FollowsCountUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FollowsCountPayload>;
          };
          aggregate: {
            args: Prisma.FollowsCountAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFollowsCount>;
          };
          groupBy: {
            args: Prisma.FollowsCountGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FollowsCountGroupByOutputType>[];
          };
          count: {
            args: Prisma.FollowsCountCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<FollowsCountCountAggregateOutputType>
              | number;
          };
        };
      };
      Notifications: {
        payload: Prisma.$NotificationsPayload<ExtArgs>;
        fields: Prisma.NotificationsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>;
          };
          findFirst: {
            args: Prisma.NotificationsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>;
          };
          findMany: {
            args: Prisma.NotificationsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[];
          };
          create: {
            args: Prisma.NotificationsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>;
          };
          createMany: {
            args: Prisma.NotificationsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[];
          };
          delete: {
            args: Prisma.NotificationsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>;
          };
          update: {
            args: Prisma.NotificationsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[];
          };
          upsert: {
            args: Prisma.NotificationsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>;
          };
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotifications>;
          };
          groupBy: {
            args: Prisma.NotificationsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationsGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<NotificationsCountAggregateOutputType>
              | number;
          };
        };
      };
      Symbols: {
        payload: Prisma.$SymbolsPayload<ExtArgs>;
        fields: Prisma.SymbolsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SymbolsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SymbolsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SymbolsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SymbolsPayload>;
          };
          findFirst: {
            args: Prisma.SymbolsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SymbolsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SymbolsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SymbolsPayload>;
          };
          findMany: {
            args: Prisma.SymbolsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SymbolsPayload>[];
          };
          create: {
            args: Prisma.SymbolsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SymbolsPayload>;
          };
          createMany: {
            args: Prisma.SymbolsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SymbolsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SymbolsPayload>[];
          };
          delete: {
            args: Prisma.SymbolsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SymbolsPayload>;
          };
          update: {
            args: Prisma.SymbolsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SymbolsPayload>;
          };
          deleteMany: {
            args: Prisma.SymbolsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SymbolsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SymbolsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SymbolsPayload>[];
          };
          upsert: {
            args: Prisma.SymbolsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SymbolsPayload>;
          };
          aggregate: {
            args: Prisma.SymbolsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSymbols>;
          };
          groupBy: {
            args: Prisma.SymbolsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SymbolsGroupByOutputType>[];
          };
          count: {
            args: Prisma.SymbolsCountArgs<ExtArgs>;
            result: $Utils.Optional<SymbolsCountAggregateOutputType> | number;
          };
        };
      };
      ThreadEngagementMetrics: {
        payload: Prisma.$ThreadEngagementMetricsPayload<ExtArgs>;
        fields: Prisma.ThreadEngagementMetricsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ThreadEngagementMetricsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadEngagementMetricsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ThreadEngagementMetricsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadEngagementMetricsPayload>;
          };
          findFirst: {
            args: Prisma.ThreadEngagementMetricsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadEngagementMetricsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ThreadEngagementMetricsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadEngagementMetricsPayload>;
          };
          findMany: {
            args: Prisma.ThreadEngagementMetricsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadEngagementMetricsPayload>[];
          };
          create: {
            args: Prisma.ThreadEngagementMetricsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadEngagementMetricsPayload>;
          };
          createMany: {
            args: Prisma.ThreadEngagementMetricsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ThreadEngagementMetricsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadEngagementMetricsPayload>[];
          };
          delete: {
            args: Prisma.ThreadEngagementMetricsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadEngagementMetricsPayload>;
          };
          update: {
            args: Prisma.ThreadEngagementMetricsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadEngagementMetricsPayload>;
          };
          deleteMany: {
            args: Prisma.ThreadEngagementMetricsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ThreadEngagementMetricsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ThreadEngagementMetricsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadEngagementMetricsPayload>[];
          };
          upsert: {
            args: Prisma.ThreadEngagementMetricsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadEngagementMetricsPayload>;
          };
          aggregate: {
            args: Prisma.ThreadEngagementMetricsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateThreadEngagementMetrics>;
          };
          groupBy: {
            args: Prisma.ThreadEngagementMetricsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ThreadEngagementMetricsGroupByOutputType>[];
          };
          count: {
            args: Prisma.ThreadEngagementMetricsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ThreadEngagementMetricsCountAggregateOutputType>
              | number;
          };
        };
      };
      ThreadHashtags: {
        payload: Prisma.$ThreadHashtagsPayload<ExtArgs>;
        fields: Prisma.ThreadHashtagsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ThreadHashtagsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadHashtagsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ThreadHashtagsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadHashtagsPayload>;
          };
          findFirst: {
            args: Prisma.ThreadHashtagsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadHashtagsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ThreadHashtagsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadHashtagsPayload>;
          };
          findMany: {
            args: Prisma.ThreadHashtagsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadHashtagsPayload>[];
          };
          create: {
            args: Prisma.ThreadHashtagsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadHashtagsPayload>;
          };
          createMany: {
            args: Prisma.ThreadHashtagsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ThreadHashtagsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadHashtagsPayload>[];
          };
          delete: {
            args: Prisma.ThreadHashtagsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadHashtagsPayload>;
          };
          update: {
            args: Prisma.ThreadHashtagsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadHashtagsPayload>;
          };
          deleteMany: {
            args: Prisma.ThreadHashtagsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ThreadHashtagsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ThreadHashtagsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadHashtagsPayload>[];
          };
          upsert: {
            args: Prisma.ThreadHashtagsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadHashtagsPayload>;
          };
          aggregate: {
            args: Prisma.ThreadHashtagsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateThreadHashtags>;
          };
          groupBy: {
            args: Prisma.ThreadHashtagsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ThreadHashtagsGroupByOutputType>[];
          };
          count: {
            args: Prisma.ThreadHashtagsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ThreadHashtagsCountAggregateOutputType>
              | number;
          };
        };
      };
      ThreadLikes: {
        payload: Prisma.$ThreadLikesPayload<ExtArgs>;
        fields: Prisma.ThreadLikesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ThreadLikesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadLikesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ThreadLikesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadLikesPayload>;
          };
          findFirst: {
            args: Prisma.ThreadLikesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadLikesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ThreadLikesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadLikesPayload>;
          };
          findMany: {
            args: Prisma.ThreadLikesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadLikesPayload>[];
          };
          create: {
            args: Prisma.ThreadLikesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadLikesPayload>;
          };
          createMany: {
            args: Prisma.ThreadLikesCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ThreadLikesCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadLikesPayload>[];
          };
          delete: {
            args: Prisma.ThreadLikesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadLikesPayload>;
          };
          update: {
            args: Prisma.ThreadLikesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadLikesPayload>;
          };
          deleteMany: {
            args: Prisma.ThreadLikesDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ThreadLikesUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ThreadLikesUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadLikesPayload>[];
          };
          upsert: {
            args: Prisma.ThreadLikesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadLikesPayload>;
          };
          aggregate: {
            args: Prisma.ThreadLikesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateThreadLikes>;
          };
          groupBy: {
            args: Prisma.ThreadLikesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ThreadLikesGroupByOutputType>[];
          };
          count: {
            args: Prisma.ThreadLikesCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ThreadLikesCountAggregateOutputType>
              | number;
          };
        };
      };
      ThreadMedia: {
        payload: Prisma.$ThreadMediaPayload<ExtArgs>;
        fields: Prisma.ThreadMediaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ThreadMediaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMediaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ThreadMediaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMediaPayload>;
          };
          findFirst: {
            args: Prisma.ThreadMediaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMediaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ThreadMediaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMediaPayload>;
          };
          findMany: {
            args: Prisma.ThreadMediaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMediaPayload>[];
          };
          create: {
            args: Prisma.ThreadMediaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMediaPayload>;
          };
          createMany: {
            args: Prisma.ThreadMediaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ThreadMediaCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMediaPayload>[];
          };
          delete: {
            args: Prisma.ThreadMediaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMediaPayload>;
          };
          update: {
            args: Prisma.ThreadMediaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMediaPayload>;
          };
          deleteMany: {
            args: Prisma.ThreadMediaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ThreadMediaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ThreadMediaUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMediaPayload>[];
          };
          upsert: {
            args: Prisma.ThreadMediaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMediaPayload>;
          };
          aggregate: {
            args: Prisma.ThreadMediaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateThreadMedia>;
          };
          groupBy: {
            args: Prisma.ThreadMediaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ThreadMediaGroupByOutputType>[];
          };
          count: {
            args: Prisma.ThreadMediaCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ThreadMediaCountAggregateOutputType>
              | number;
          };
        };
      };
      ThreadMentions: {
        payload: Prisma.$ThreadMentionsPayload<ExtArgs>;
        fields: Prisma.ThreadMentionsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ThreadMentionsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMentionsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ThreadMentionsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMentionsPayload>;
          };
          findFirst: {
            args: Prisma.ThreadMentionsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMentionsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ThreadMentionsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMentionsPayload>;
          };
          findMany: {
            args: Prisma.ThreadMentionsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMentionsPayload>[];
          };
          create: {
            args: Prisma.ThreadMentionsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMentionsPayload>;
          };
          createMany: {
            args: Prisma.ThreadMentionsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ThreadMentionsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMentionsPayload>[];
          };
          delete: {
            args: Prisma.ThreadMentionsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMentionsPayload>;
          };
          update: {
            args: Prisma.ThreadMentionsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMentionsPayload>;
          };
          deleteMany: {
            args: Prisma.ThreadMentionsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ThreadMentionsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ThreadMentionsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMentionsPayload>[];
          };
          upsert: {
            args: Prisma.ThreadMentionsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadMentionsPayload>;
          };
          aggregate: {
            args: Prisma.ThreadMentionsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateThreadMentions>;
          };
          groupBy: {
            args: Prisma.ThreadMentionsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ThreadMentionsGroupByOutputType>[];
          };
          count: {
            args: Prisma.ThreadMentionsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ThreadMentionsCountAggregateOutputType>
              | number;
          };
        };
      };
      ThreadPins: {
        payload: Prisma.$ThreadPinsPayload<ExtArgs>;
        fields: Prisma.ThreadPinsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ThreadPinsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPinsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ThreadPinsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPinsPayload>;
          };
          findFirst: {
            args: Prisma.ThreadPinsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPinsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ThreadPinsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPinsPayload>;
          };
          findMany: {
            args: Prisma.ThreadPinsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPinsPayload>[];
          };
          create: {
            args: Prisma.ThreadPinsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPinsPayload>;
          };
          createMany: {
            args: Prisma.ThreadPinsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ThreadPinsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPinsPayload>[];
          };
          delete: {
            args: Prisma.ThreadPinsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPinsPayload>;
          };
          update: {
            args: Prisma.ThreadPinsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPinsPayload>;
          };
          deleteMany: {
            args: Prisma.ThreadPinsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ThreadPinsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ThreadPinsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPinsPayload>[];
          };
          upsert: {
            args: Prisma.ThreadPinsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPinsPayload>;
          };
          aggregate: {
            args: Prisma.ThreadPinsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateThreadPins>;
          };
          groupBy: {
            args: Prisma.ThreadPinsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ThreadPinsGroupByOutputType>[];
          };
          count: {
            args: Prisma.ThreadPinsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ThreadPinsCountAggregateOutputType>
              | number;
          };
        };
      };
      ThreadPollOptions: {
        payload: Prisma.$ThreadPollOptionsPayload<ExtArgs>;
        fields: Prisma.ThreadPollOptionsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ThreadPollOptionsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollOptionsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ThreadPollOptionsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollOptionsPayload>;
          };
          findFirst: {
            args: Prisma.ThreadPollOptionsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollOptionsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ThreadPollOptionsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollOptionsPayload>;
          };
          findMany: {
            args: Prisma.ThreadPollOptionsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollOptionsPayload>[];
          };
          create: {
            args: Prisma.ThreadPollOptionsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollOptionsPayload>;
          };
          createMany: {
            args: Prisma.ThreadPollOptionsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ThreadPollOptionsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollOptionsPayload>[];
          };
          delete: {
            args: Prisma.ThreadPollOptionsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollOptionsPayload>;
          };
          update: {
            args: Prisma.ThreadPollOptionsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollOptionsPayload>;
          };
          deleteMany: {
            args: Prisma.ThreadPollOptionsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ThreadPollOptionsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ThreadPollOptionsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollOptionsPayload>[];
          };
          upsert: {
            args: Prisma.ThreadPollOptionsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollOptionsPayload>;
          };
          aggregate: {
            args: Prisma.ThreadPollOptionsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateThreadPollOptions>;
          };
          groupBy: {
            args: Prisma.ThreadPollOptionsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ThreadPollOptionsGroupByOutputType>[];
          };
          count: {
            args: Prisma.ThreadPollOptionsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ThreadPollOptionsCountAggregateOutputType>
              | number;
          };
        };
      };
      ThreadPollVotes: {
        payload: Prisma.$ThreadPollVotesPayload<ExtArgs>;
        fields: Prisma.ThreadPollVotesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ThreadPollVotesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollVotesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ThreadPollVotesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollVotesPayload>;
          };
          findFirst: {
            args: Prisma.ThreadPollVotesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollVotesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ThreadPollVotesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollVotesPayload>;
          };
          findMany: {
            args: Prisma.ThreadPollVotesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollVotesPayload>[];
          };
          create: {
            args: Prisma.ThreadPollVotesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollVotesPayload>;
          };
          createMany: {
            args: Prisma.ThreadPollVotesCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ThreadPollVotesCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollVotesPayload>[];
          };
          delete: {
            args: Prisma.ThreadPollVotesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollVotesPayload>;
          };
          update: {
            args: Prisma.ThreadPollVotesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollVotesPayload>;
          };
          deleteMany: {
            args: Prisma.ThreadPollVotesDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ThreadPollVotesUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ThreadPollVotesUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollVotesPayload>[];
          };
          upsert: {
            args: Prisma.ThreadPollVotesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollVotesPayload>;
          };
          aggregate: {
            args: Prisma.ThreadPollVotesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateThreadPollVotes>;
          };
          groupBy: {
            args: Prisma.ThreadPollVotesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ThreadPollVotesGroupByOutputType>[];
          };
          count: {
            args: Prisma.ThreadPollVotesCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ThreadPollVotesCountAggregateOutputType>
              | number;
          };
        };
      };
      ThreadPolls: {
        payload: Prisma.$ThreadPollsPayload<ExtArgs>;
        fields: Prisma.ThreadPollsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ThreadPollsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ThreadPollsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollsPayload>;
          };
          findFirst: {
            args: Prisma.ThreadPollsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ThreadPollsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollsPayload>;
          };
          findMany: {
            args: Prisma.ThreadPollsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollsPayload>[];
          };
          create: {
            args: Prisma.ThreadPollsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollsPayload>;
          };
          createMany: {
            args: Prisma.ThreadPollsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ThreadPollsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollsPayload>[];
          };
          delete: {
            args: Prisma.ThreadPollsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollsPayload>;
          };
          update: {
            args: Prisma.ThreadPollsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollsPayload>;
          };
          deleteMany: {
            args: Prisma.ThreadPollsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ThreadPollsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ThreadPollsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollsPayload>[];
          };
          upsert: {
            args: Prisma.ThreadPollsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadPollsPayload>;
          };
          aggregate: {
            args: Prisma.ThreadPollsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateThreadPolls>;
          };
          groupBy: {
            args: Prisma.ThreadPollsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ThreadPollsGroupByOutputType>[];
          };
          count: {
            args: Prisma.ThreadPollsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ThreadPollsCountAggregateOutputType>
              | number;
          };
        };
      };
      ThreadReportReasons: {
        payload: Prisma.$ThreadReportReasonsPayload<ExtArgs>;
        fields: Prisma.ThreadReportReasonsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ThreadReportReasonsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportReasonsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ThreadReportReasonsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportReasonsPayload>;
          };
          findFirst: {
            args: Prisma.ThreadReportReasonsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportReasonsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ThreadReportReasonsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportReasonsPayload>;
          };
          findMany: {
            args: Prisma.ThreadReportReasonsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportReasonsPayload>[];
          };
          create: {
            args: Prisma.ThreadReportReasonsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportReasonsPayload>;
          };
          createMany: {
            args: Prisma.ThreadReportReasonsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ThreadReportReasonsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportReasonsPayload>[];
          };
          delete: {
            args: Prisma.ThreadReportReasonsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportReasonsPayload>;
          };
          update: {
            args: Prisma.ThreadReportReasonsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportReasonsPayload>;
          };
          deleteMany: {
            args: Prisma.ThreadReportReasonsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ThreadReportReasonsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ThreadReportReasonsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportReasonsPayload>[];
          };
          upsert: {
            args: Prisma.ThreadReportReasonsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportReasonsPayload>;
          };
          aggregate: {
            args: Prisma.ThreadReportReasonsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateThreadReportReasons>;
          };
          groupBy: {
            args: Prisma.ThreadReportReasonsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ThreadReportReasonsGroupByOutputType>[];
          };
          count: {
            args: Prisma.ThreadReportReasonsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ThreadReportReasonsCountAggregateOutputType>
              | number;
          };
        };
      };
      ThreadReports: {
        payload: Prisma.$ThreadReportsPayload<ExtArgs>;
        fields: Prisma.ThreadReportsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ThreadReportsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ThreadReportsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportsPayload>;
          };
          findFirst: {
            args: Prisma.ThreadReportsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ThreadReportsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportsPayload>;
          };
          findMany: {
            args: Prisma.ThreadReportsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportsPayload>[];
          };
          create: {
            args: Prisma.ThreadReportsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportsPayload>;
          };
          createMany: {
            args: Prisma.ThreadReportsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ThreadReportsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportsPayload>[];
          };
          delete: {
            args: Prisma.ThreadReportsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportsPayload>;
          };
          update: {
            args: Prisma.ThreadReportsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportsPayload>;
          };
          deleteMany: {
            args: Prisma.ThreadReportsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ThreadReportsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ThreadReportsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportsPayload>[];
          };
          upsert: {
            args: Prisma.ThreadReportsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadReportsPayload>;
          };
          aggregate: {
            args: Prisma.ThreadReportsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateThreadReports>;
          };
          groupBy: {
            args: Prisma.ThreadReportsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ThreadReportsGroupByOutputType>[];
          };
          count: {
            args: Prisma.ThreadReportsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ThreadReportsCountAggregateOutputType>
              | number;
          };
        };
      };
      ThreadReposts: {
        payload: Prisma.$ThreadRepostsPayload<ExtArgs>;
        fields: Prisma.ThreadRepostsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ThreadRepostsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadRepostsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ThreadRepostsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadRepostsPayload>;
          };
          findFirst: {
            args: Prisma.ThreadRepostsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadRepostsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ThreadRepostsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadRepostsPayload>;
          };
          findMany: {
            args: Prisma.ThreadRepostsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadRepostsPayload>[];
          };
          create: {
            args: Prisma.ThreadRepostsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadRepostsPayload>;
          };
          createMany: {
            args: Prisma.ThreadRepostsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ThreadRepostsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadRepostsPayload>[];
          };
          delete: {
            args: Prisma.ThreadRepostsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadRepostsPayload>;
          };
          update: {
            args: Prisma.ThreadRepostsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadRepostsPayload>;
          };
          deleteMany: {
            args: Prisma.ThreadRepostsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ThreadRepostsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ThreadRepostsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadRepostsPayload>[];
          };
          upsert: {
            args: Prisma.ThreadRepostsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadRepostsPayload>;
          };
          aggregate: {
            args: Prisma.ThreadRepostsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateThreadReposts>;
          };
          groupBy: {
            args: Prisma.ThreadRepostsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ThreadRepostsGroupByOutputType>[];
          };
          count: {
            args: Prisma.ThreadRepostsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ThreadRepostsCountAggregateOutputType>
              | number;
          };
        };
      };
      Threads: {
        payload: Prisma.$ThreadsPayload<ExtArgs>;
        fields: Prisma.ThreadsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ThreadsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ThreadsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadsPayload>;
          };
          findFirst: {
            args: Prisma.ThreadsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ThreadsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadsPayload>;
          };
          findMany: {
            args: Prisma.ThreadsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadsPayload>[];
          };
          create: {
            args: Prisma.ThreadsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadsPayload>;
          };
          createMany: {
            args: Prisma.ThreadsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ThreadsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadsPayload>[];
          };
          delete: {
            args: Prisma.ThreadsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadsPayload>;
          };
          update: {
            args: Prisma.ThreadsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadsPayload>;
          };
          deleteMany: {
            args: Prisma.ThreadsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ThreadsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ThreadsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadsPayload>[];
          };
          upsert: {
            args: Prisma.ThreadsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ThreadsPayload>;
          };
          aggregate: {
            args: Prisma.ThreadsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateThreads>;
          };
          groupBy: {
            args: Prisma.ThreadsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ThreadsGroupByOutputType>[];
          };
          count: {
            args: Prisma.ThreadsCountArgs<ExtArgs>;
            result: $Utils.Optional<ThreadsCountAggregateOutputType> | number;
          };
        };
      };
      UserBlocks: {
        payload: Prisma.$UserBlocksPayload<ExtArgs>;
        fields: Prisma.UserBlocksFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserBlocksFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserBlocksPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserBlocksFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserBlocksPayload>;
          };
          findFirst: {
            args: Prisma.UserBlocksFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserBlocksPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserBlocksFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserBlocksPayload>;
          };
          findMany: {
            args: Prisma.UserBlocksFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserBlocksPayload>[];
          };
          create: {
            args: Prisma.UserBlocksCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserBlocksPayload>;
          };
          createMany: {
            args: Prisma.UserBlocksCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserBlocksCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserBlocksPayload>[];
          };
          delete: {
            args: Prisma.UserBlocksDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserBlocksPayload>;
          };
          update: {
            args: Prisma.UserBlocksUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserBlocksPayload>;
          };
          deleteMany: {
            args: Prisma.UserBlocksDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserBlocksUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserBlocksUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserBlocksPayload>[];
          };
          upsert: {
            args: Prisma.UserBlocksUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserBlocksPayload>;
          };
          aggregate: {
            args: Prisma.UserBlocksAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserBlocks>;
          };
          groupBy: {
            args: Prisma.UserBlocksGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserBlocksGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserBlocksCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<UserBlocksCountAggregateOutputType>
              | number;
          };
        };
      };
      UserInterestLogs: {
        payload: Prisma.$UserInterestLogsPayload<ExtArgs>;
        fields: Prisma.UserInterestLogsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserInterestLogsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestLogsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserInterestLogsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestLogsPayload>;
          };
          findFirst: {
            args: Prisma.UserInterestLogsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestLogsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserInterestLogsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestLogsPayload>;
          };
          findMany: {
            args: Prisma.UserInterestLogsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestLogsPayload>[];
          };
          create: {
            args: Prisma.UserInterestLogsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestLogsPayload>;
          };
          createMany: {
            args: Prisma.UserInterestLogsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserInterestLogsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestLogsPayload>[];
          };
          delete: {
            args: Prisma.UserInterestLogsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestLogsPayload>;
          };
          update: {
            args: Prisma.UserInterestLogsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestLogsPayload>;
          };
          deleteMany: {
            args: Prisma.UserInterestLogsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserInterestLogsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserInterestLogsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestLogsPayload>[];
          };
          upsert: {
            args: Prisma.UserInterestLogsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestLogsPayload>;
          };
          aggregate: {
            args: Prisma.UserInterestLogsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserInterestLogs>;
          };
          groupBy: {
            args: Prisma.UserInterestLogsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserInterestLogsGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserInterestLogsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<UserInterestLogsCountAggregateOutputType>
              | number;
          };
        };
      };
      UserInterests: {
        payload: Prisma.$UserInterestsPayload<ExtArgs>;
        fields: Prisma.UserInterestsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserInterestsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserInterestsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestsPayload>;
          };
          findFirst: {
            args: Prisma.UserInterestsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserInterestsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestsPayload>;
          };
          findMany: {
            args: Prisma.UserInterestsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestsPayload>[];
          };
          create: {
            args: Prisma.UserInterestsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestsPayload>;
          };
          createMany: {
            args: Prisma.UserInterestsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserInterestsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestsPayload>[];
          };
          delete: {
            args: Prisma.UserInterestsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestsPayload>;
          };
          update: {
            args: Prisma.UserInterestsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestsPayload>;
          };
          deleteMany: {
            args: Prisma.UserInterestsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserInterestsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserInterestsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestsPayload>[];
          };
          upsert: {
            args: Prisma.UserInterestsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserInterestsPayload>;
          };
          aggregate: {
            args: Prisma.UserInterestsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserInterests>;
          };
          groupBy: {
            args: Prisma.UserInterestsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserInterestsGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserInterestsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<UserInterestsCountAggregateOutputType>
              | number;
          };
        };
      };
      UserNotificationSettings: {
        payload: Prisma.$UserNotificationSettingsPayload<ExtArgs>;
        fields: Prisma.UserNotificationSettingsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserNotificationSettingsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserNotificationSettingsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>;
          };
          findFirst: {
            args: Prisma.UserNotificationSettingsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserNotificationSettingsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>;
          };
          findMany: {
            args: Prisma.UserNotificationSettingsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>[];
          };
          create: {
            args: Prisma.UserNotificationSettingsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>;
          };
          createMany: {
            args: Prisma.UserNotificationSettingsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserNotificationSettingsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>[];
          };
          delete: {
            args: Prisma.UserNotificationSettingsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>;
          };
          update: {
            args: Prisma.UserNotificationSettingsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>;
          };
          deleteMany: {
            args: Prisma.UserNotificationSettingsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserNotificationSettingsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserNotificationSettingsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>[];
          };
          upsert: {
            args: Prisma.UserNotificationSettingsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>;
          };
          aggregate: {
            args: Prisma.UserNotificationSettingsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserNotificationSettings>;
          };
          groupBy: {
            args: Prisma.UserNotificationSettingsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserNotificationSettingsGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserNotificationSettingsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<UserNotificationSettingsCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory;
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string;
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[];
  }
  export type GlobalOmitConfig = {
    companiesInfo?: CompaniesInfoOmit;
    followNotificationOverrides?: FollowNotificationOverridesOmit;
    followRequests?: FollowRequestsOmit;
    follows?: FollowsOmit;
    followsCount?: FollowsCountOmit;
    notifications?: NotificationsOmit;
    symbols?: SymbolsOmit;
    threadEngagementMetrics?: ThreadEngagementMetricsOmit;
    threadHashtags?: ThreadHashtagsOmit;
    threadLikes?: ThreadLikesOmit;
    threadMedia?: ThreadMediaOmit;
    threadMentions?: ThreadMentionsOmit;
    threadPins?: ThreadPinsOmit;
    threadPollOptions?: ThreadPollOptionsOmit;
    threadPollVotes?: ThreadPollVotesOmit;
    threadPolls?: ThreadPollsOmit;
    threadReportReasons?: ThreadReportReasonsOmit;
    threadReports?: ThreadReportsOmit;
    threadReposts?: ThreadRepostsOmit;
    threads?: ThreadsOmit;
    userBlocks?: UserBlocksOmit;
    userInterestLogs?: UserInterestLogsOmit;
    userInterests?: UserInterestsOmit;
    userNotificationSettings?: UserNotificationSettingsOmit;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type ThreadReportReasonsCountOutputType
   */

  export type ThreadReportReasonsCountOutputType = {
    other_ThreadReportReasons: number;
  };

  export type ThreadReportReasonsCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    other_ThreadReportReasons?:
      | boolean
      | ThreadReportReasonsCountOutputTypeCountOther_ThreadReportReasonsArgs;
  };

  // Custom InputTypes
  /**
   * ThreadReportReasonsCountOutputType without action
   */
  export type ThreadReportReasonsCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReportReasonsCountOutputType
     */
    select?: ThreadReportReasonsCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ThreadReportReasonsCountOutputType without action
   */
  export type ThreadReportReasonsCountOutputTypeCountOther_ThreadReportReasonsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ThreadReportReasonsWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model CompaniesInfo
   */

  export type AggregateCompaniesInfo = {
    _count: CompaniesInfoCountAggregateOutputType | null;
    _avg: CompaniesInfoAvgAggregateOutputType | null;
    _sum: CompaniesInfoSumAggregateOutputType | null;
    _min: CompaniesInfoMinAggregateOutputType | null;
    _max: CompaniesInfoMaxAggregateOutputType | null;
  };

  export type CompaniesInfoAvgAggregateOutputType = {
    regular_market_price: number | null;
    regular_market_change: number | null;
    regular_market_change_percent: number | null;
    pre_market_price: number | null;
    pre_market_change: number | null;
    pre_market_change_percent: number | null;
    post_market_price: number | null;
    post_market_change: number | null;
    post_market_change_percent: number | null;
    overnight_market_price: number | null;
    overnight_market_change: number | null;
    overnight_market_change_percent: number | null;
    market_cap: number | null;
    regular_market_time: number | null;
    pre_market_time: number | null;
    post_market_time: number | null;
    overnight_market_time: number | null;
  };

  export type CompaniesInfoSumAggregateOutputType = {
    regular_market_price: number | null;
    regular_market_change: number | null;
    regular_market_change_percent: number | null;
    pre_market_price: number | null;
    pre_market_change: number | null;
    pre_market_change_percent: number | null;
    post_market_price: number | null;
    post_market_change: number | null;
    post_market_change_percent: number | null;
    overnight_market_price: number | null;
    overnight_market_change: number | null;
    overnight_market_change_percent: number | null;
    market_cap: bigint | null;
    regular_market_time: bigint | null;
    pre_market_time: bigint | null;
    post_market_time: bigint | null;
    overnight_market_time: bigint | null;
  };

  export type CompaniesInfoMinAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    symbol: string | null;
    name: string | null;
    market_state: string | null;
    regular_market_price: number | null;
    regular_market_change: number | null;
    regular_market_change_percent: number | null;
    sector: string | null;
    industry: string | null;
    date_at_shares: Date | null;
    assets_type: $Enums.assets_type_enum | null;
    exchange_name: string | null;
    pre_market_price: number | null;
    pre_market_change: number | null;
    pre_market_change_percent: number | null;
    post_market_price: number | null;
    post_market_change: number | null;
    post_market_change_percent: number | null;
    overnight_market_price: number | null;
    overnight_market_change: number | null;
    overnight_market_change_percent: number | null;
    market_cap: bigint | null;
    regular_market_time: bigint | null;
    pre_market_time: bigint | null;
    post_market_time: bigint | null;
    overnight_market_time: bigint | null;
    currency: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type CompaniesInfoMaxAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    symbol: string | null;
    name: string | null;
    market_state: string | null;
    regular_market_price: number | null;
    regular_market_change: number | null;
    regular_market_change_percent: number | null;
    sector: string | null;
    industry: string | null;
    date_at_shares: Date | null;
    assets_type: $Enums.assets_type_enum | null;
    exchange_name: string | null;
    pre_market_price: number | null;
    pre_market_change: number | null;
    pre_market_change_percent: number | null;
    post_market_price: number | null;
    post_market_change: number | null;
    post_market_change_percent: number | null;
    overnight_market_price: number | null;
    overnight_market_change: number | null;
    overnight_market_change_percent: number | null;
    market_cap: bigint | null;
    regular_market_time: bigint | null;
    pre_market_time: bigint | null;
    post_market_time: bigint | null;
    overnight_market_time: bigint | null;
    currency: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type CompaniesInfoCountAggregateOutputType = {
    id: number;
    threads_id: number;
    symbol: number;
    name: number;
    market_state: number;
    regular_market_price: number;
    regular_market_change: number;
    regular_market_change_percent: number;
    sector: number;
    industry: number;
    date_at_shares: number;
    assets_type: number;
    exchange_name: number;
    pre_market_price: number;
    pre_market_change: number;
    pre_market_change_percent: number;
    post_market_price: number;
    post_market_change: number;
    post_market_change_percent: number;
    overnight_market_price: number;
    overnight_market_change: number;
    overnight_market_change_percent: number;
    market_cap: number;
    regular_market_time: number;
    pre_market_time: number;
    post_market_time: number;
    overnight_market_time: number;
    currency: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type CompaniesInfoAvgAggregateInputType = {
    regular_market_price?: true;
    regular_market_change?: true;
    regular_market_change_percent?: true;
    pre_market_price?: true;
    pre_market_change?: true;
    pre_market_change_percent?: true;
    post_market_price?: true;
    post_market_change?: true;
    post_market_change_percent?: true;
    overnight_market_price?: true;
    overnight_market_change?: true;
    overnight_market_change_percent?: true;
    market_cap?: true;
    regular_market_time?: true;
    pre_market_time?: true;
    post_market_time?: true;
    overnight_market_time?: true;
  };

  export type CompaniesInfoSumAggregateInputType = {
    regular_market_price?: true;
    regular_market_change?: true;
    regular_market_change_percent?: true;
    pre_market_price?: true;
    pre_market_change?: true;
    pre_market_change_percent?: true;
    post_market_price?: true;
    post_market_change?: true;
    post_market_change_percent?: true;
    overnight_market_price?: true;
    overnight_market_change?: true;
    overnight_market_change_percent?: true;
    market_cap?: true;
    regular_market_time?: true;
    pre_market_time?: true;
    post_market_time?: true;
    overnight_market_time?: true;
  };

  export type CompaniesInfoMinAggregateInputType = {
    id?: true;
    threads_id?: true;
    symbol?: true;
    name?: true;
    market_state?: true;
    regular_market_price?: true;
    regular_market_change?: true;
    regular_market_change_percent?: true;
    sector?: true;
    industry?: true;
    date_at_shares?: true;
    assets_type?: true;
    exchange_name?: true;
    pre_market_price?: true;
    pre_market_change?: true;
    pre_market_change_percent?: true;
    post_market_price?: true;
    post_market_change?: true;
    post_market_change_percent?: true;
    overnight_market_price?: true;
    overnight_market_change?: true;
    overnight_market_change_percent?: true;
    market_cap?: true;
    regular_market_time?: true;
    pre_market_time?: true;
    post_market_time?: true;
    overnight_market_time?: true;
    currency?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type CompaniesInfoMaxAggregateInputType = {
    id?: true;
    threads_id?: true;
    symbol?: true;
    name?: true;
    market_state?: true;
    regular_market_price?: true;
    regular_market_change?: true;
    regular_market_change_percent?: true;
    sector?: true;
    industry?: true;
    date_at_shares?: true;
    assets_type?: true;
    exchange_name?: true;
    pre_market_price?: true;
    pre_market_change?: true;
    pre_market_change_percent?: true;
    post_market_price?: true;
    post_market_change?: true;
    post_market_change_percent?: true;
    overnight_market_price?: true;
    overnight_market_change?: true;
    overnight_market_change_percent?: true;
    market_cap?: true;
    regular_market_time?: true;
    pre_market_time?: true;
    post_market_time?: true;
    overnight_market_time?: true;
    currency?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type CompaniesInfoCountAggregateInputType = {
    id?: true;
    threads_id?: true;
    symbol?: true;
    name?: true;
    market_state?: true;
    regular_market_price?: true;
    regular_market_change?: true;
    regular_market_change_percent?: true;
    sector?: true;
    industry?: true;
    date_at_shares?: true;
    assets_type?: true;
    exchange_name?: true;
    pre_market_price?: true;
    pre_market_change?: true;
    pre_market_change_percent?: true;
    post_market_price?: true;
    post_market_change?: true;
    post_market_change_percent?: true;
    overnight_market_price?: true;
    overnight_market_change?: true;
    overnight_market_change_percent?: true;
    market_cap?: true;
    regular_market_time?: true;
    pre_market_time?: true;
    post_market_time?: true;
    overnight_market_time?: true;
    currency?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type CompaniesInfoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which CompaniesInfo to aggregate.
     */
    where?: CompaniesInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CompaniesInfos to fetch.
     */
    orderBy?:
      | CompaniesInfoOrderByWithRelationInput
      | CompaniesInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CompaniesInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CompaniesInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CompaniesInfos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CompaniesInfos
     **/
    _count?: true | CompaniesInfoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CompaniesInfoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CompaniesInfoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CompaniesInfoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CompaniesInfoMaxAggregateInputType;
  };

  export type GetCompaniesInfoAggregateType<
    T extends CompaniesInfoAggregateArgs
  > = {
    [P in keyof T & keyof AggregateCompaniesInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompaniesInfo[P]>
      : GetScalarType<T[P], AggregateCompaniesInfo[P]>;
  };

  export type CompaniesInfoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CompaniesInfoWhereInput;
    orderBy?:
      | CompaniesInfoOrderByWithAggregationInput
      | CompaniesInfoOrderByWithAggregationInput[];
    by: CompaniesInfoScalarFieldEnum[] | CompaniesInfoScalarFieldEnum;
    having?: CompaniesInfoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CompaniesInfoCountAggregateInputType | true;
    _avg?: CompaniesInfoAvgAggregateInputType;
    _sum?: CompaniesInfoSumAggregateInputType;
    _min?: CompaniesInfoMinAggregateInputType;
    _max?: CompaniesInfoMaxAggregateInputType;
  };

  export type CompaniesInfoGroupByOutputType = {
    id: string;
    threads_id: string;
    symbol: string;
    name: string;
    market_state: string;
    regular_market_price: number;
    regular_market_change: number;
    regular_market_change_percent: number;
    sector: string;
    industry: string;
    date_at_shares: Date;
    assets_type: $Enums.assets_type_enum;
    exchange_name: string | null;
    pre_market_price: number | null;
    pre_market_change: number | null;
    pre_market_change_percent: number | null;
    post_market_price: number | null;
    post_market_change: number | null;
    post_market_change_percent: number | null;
    overnight_market_price: number | null;
    overnight_market_change: number | null;
    overnight_market_change_percent: number | null;
    market_cap: bigint | null;
    regular_market_time: bigint;
    pre_market_time: bigint | null;
    post_market_time: bigint | null;
    overnight_market_time: bigint | null;
    currency: string;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: CompaniesInfoCountAggregateOutputType | null;
    _avg: CompaniesInfoAvgAggregateOutputType | null;
    _sum: CompaniesInfoSumAggregateOutputType | null;
    _min: CompaniesInfoMinAggregateOutputType | null;
    _max: CompaniesInfoMaxAggregateOutputType | null;
  };

  type GetCompaniesInfoGroupByPayload<T extends CompaniesInfoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CompaniesInfoGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof CompaniesInfoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesInfoGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesInfoGroupByOutputType[P]>;
        }
      >
    >;

  export type CompaniesInfoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      symbol?: boolean;
      name?: boolean;
      market_state?: boolean;
      regular_market_price?: boolean;
      regular_market_change?: boolean;
      regular_market_change_percent?: boolean;
      sector?: boolean;
      industry?: boolean;
      date_at_shares?: boolean;
      assets_type?: boolean;
      exchange_name?: boolean;
      pre_market_price?: boolean;
      pre_market_change?: boolean;
      pre_market_change_percent?: boolean;
      post_market_price?: boolean;
      post_market_change?: boolean;
      post_market_change_percent?: boolean;
      overnight_market_price?: boolean;
      overnight_market_change?: boolean;
      overnight_market_change_percent?: boolean;
      market_cap?: boolean;
      regular_market_time?: boolean;
      pre_market_time?: boolean;
      post_market_time?: boolean;
      overnight_market_time?: boolean;
      currency?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['companiesInfo']
  >;

  export type CompaniesInfoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      symbol?: boolean;
      name?: boolean;
      market_state?: boolean;
      regular_market_price?: boolean;
      regular_market_change?: boolean;
      regular_market_change_percent?: boolean;
      sector?: boolean;
      industry?: boolean;
      date_at_shares?: boolean;
      assets_type?: boolean;
      exchange_name?: boolean;
      pre_market_price?: boolean;
      pre_market_change?: boolean;
      pre_market_change_percent?: boolean;
      post_market_price?: boolean;
      post_market_change?: boolean;
      post_market_change_percent?: boolean;
      overnight_market_price?: boolean;
      overnight_market_change?: boolean;
      overnight_market_change_percent?: boolean;
      market_cap?: boolean;
      regular_market_time?: boolean;
      pre_market_time?: boolean;
      post_market_time?: boolean;
      overnight_market_time?: boolean;
      currency?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['companiesInfo']
  >;

  export type CompaniesInfoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      symbol?: boolean;
      name?: boolean;
      market_state?: boolean;
      regular_market_price?: boolean;
      regular_market_change?: boolean;
      regular_market_change_percent?: boolean;
      sector?: boolean;
      industry?: boolean;
      date_at_shares?: boolean;
      assets_type?: boolean;
      exchange_name?: boolean;
      pre_market_price?: boolean;
      pre_market_change?: boolean;
      pre_market_change_percent?: boolean;
      post_market_price?: boolean;
      post_market_change?: boolean;
      post_market_change_percent?: boolean;
      overnight_market_price?: boolean;
      overnight_market_change?: boolean;
      overnight_market_change_percent?: boolean;
      market_cap?: boolean;
      regular_market_time?: boolean;
      pre_market_time?: boolean;
      post_market_time?: boolean;
      overnight_market_time?: boolean;
      currency?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['companiesInfo']
  >;

  export type CompaniesInfoSelectScalar = {
    id?: boolean;
    threads_id?: boolean;
    symbol?: boolean;
    name?: boolean;
    market_state?: boolean;
    regular_market_price?: boolean;
    regular_market_change?: boolean;
    regular_market_change_percent?: boolean;
    sector?: boolean;
    industry?: boolean;
    date_at_shares?: boolean;
    assets_type?: boolean;
    exchange_name?: boolean;
    pre_market_price?: boolean;
    pre_market_change?: boolean;
    pre_market_change_percent?: boolean;
    post_market_price?: boolean;
    post_market_change?: boolean;
    post_market_change_percent?: boolean;
    overnight_market_price?: boolean;
    overnight_market_change?: boolean;
    overnight_market_change_percent?: boolean;
    market_cap?: boolean;
    regular_market_time?: boolean;
    pre_market_time?: boolean;
    post_market_time?: boolean;
    overnight_market_time?: boolean;
    currency?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type CompaniesInfoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'threads_id'
    | 'symbol'
    | 'name'
    | 'market_state'
    | 'regular_market_price'
    | 'regular_market_change'
    | 'regular_market_change_percent'
    | 'sector'
    | 'industry'
    | 'date_at_shares'
    | 'assets_type'
    | 'exchange_name'
    | 'pre_market_price'
    | 'pre_market_change'
    | 'pre_market_change_percent'
    | 'post_market_price'
    | 'post_market_change'
    | 'post_market_change_percent'
    | 'overnight_market_price'
    | 'overnight_market_change'
    | 'overnight_market_change_percent'
    | 'market_cap'
    | 'regular_market_time'
    | 'pre_market_time'
    | 'post_market_time'
    | 'overnight_market_time'
    | 'currency'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['companiesInfo']
  >;

  export type $CompaniesInfoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'CompaniesInfo';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        threads_id: string;
        symbol: string;
        name: string;
        market_state: string;
        regular_market_price: number;
        regular_market_change: number;
        regular_market_change_percent: number;
        sector: string;
        industry: string;
        date_at_shares: Date;
        assets_type: $Enums.assets_type_enum;
        exchange_name: string | null;
        pre_market_price: number | null;
        pre_market_change: number | null;
        pre_market_change_percent: number | null;
        post_market_price: number | null;
        post_market_change: number | null;
        post_market_change_percent: number | null;
        overnight_market_price: number | null;
        overnight_market_change: number | null;
        overnight_market_change_percent: number | null;
        market_cap: bigint | null;
        regular_market_time: bigint;
        pre_market_time: bigint | null;
        post_market_time: bigint | null;
        overnight_market_time: bigint | null;
        currency: string;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['companiesInfo']
    >;
    composites: {};
  };

  type CompaniesInfoGetPayload<
    S extends boolean | null | undefined | CompaniesInfoDefaultArgs
  > = $Result.GetResult<Prisma.$CompaniesInfoPayload, S>;

  type CompaniesInfoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    CompaniesInfoFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: CompaniesInfoCountAggregateInputType | true;
  };

  export interface CompaniesInfoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['CompaniesInfo'];
      meta: { name: 'CompaniesInfo' };
    };
    /**
     * Find zero or one CompaniesInfo that matches the filter.
     * @param {CompaniesInfoFindUniqueArgs} args - Arguments to find a CompaniesInfo
     * @example
     * // Get one CompaniesInfo
     * const companiesInfo = await prisma.companiesInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompaniesInfoFindUniqueArgs>(
      args: SelectSubset<T, CompaniesInfoFindUniqueArgs<ExtArgs>>
    ): Prisma__CompaniesInfoClient<
      $Result.GetResult<
        Prisma.$CompaniesInfoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one CompaniesInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompaniesInfoFindUniqueOrThrowArgs} args - Arguments to find a CompaniesInfo
     * @example
     * // Get one CompaniesInfo
     * const companiesInfo = await prisma.companiesInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompaniesInfoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CompaniesInfoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CompaniesInfoClient<
      $Result.GetResult<
        Prisma.$CompaniesInfoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CompaniesInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesInfoFindFirstArgs} args - Arguments to find a CompaniesInfo
     * @example
     * // Get one CompaniesInfo
     * const companiesInfo = await prisma.companiesInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompaniesInfoFindFirstArgs>(
      args?: SelectSubset<T, CompaniesInfoFindFirstArgs<ExtArgs>>
    ): Prisma__CompaniesInfoClient<
      $Result.GetResult<
        Prisma.$CompaniesInfoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CompaniesInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesInfoFindFirstOrThrowArgs} args - Arguments to find a CompaniesInfo
     * @example
     * // Get one CompaniesInfo
     * const companiesInfo = await prisma.companiesInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompaniesInfoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CompaniesInfoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CompaniesInfoClient<
      $Result.GetResult<
        Prisma.$CompaniesInfoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more CompaniesInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompaniesInfos
     * const companiesInfos = await prisma.companiesInfo.findMany()
     *
     * // Get first 10 CompaniesInfos
     * const companiesInfos = await prisma.companiesInfo.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const companiesInfoWithIdOnly = await prisma.companiesInfo.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CompaniesInfoFindManyArgs>(
      args?: SelectSubset<T, CompaniesInfoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CompaniesInfoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a CompaniesInfo.
     * @param {CompaniesInfoCreateArgs} args - Arguments to create a CompaniesInfo.
     * @example
     * // Create one CompaniesInfo
     * const CompaniesInfo = await prisma.companiesInfo.create({
     *   data: {
     *     // ... data to create a CompaniesInfo
     *   }
     * })
     *
     */
    create<T extends CompaniesInfoCreateArgs>(
      args: SelectSubset<T, CompaniesInfoCreateArgs<ExtArgs>>
    ): Prisma__CompaniesInfoClient<
      $Result.GetResult<
        Prisma.$CompaniesInfoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many CompaniesInfos.
     * @param {CompaniesInfoCreateManyArgs} args - Arguments to create many CompaniesInfos.
     * @example
     * // Create many CompaniesInfos
     * const companiesInfo = await prisma.companiesInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CompaniesInfoCreateManyArgs>(
      args?: SelectSubset<T, CompaniesInfoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many CompaniesInfos and returns the data saved in the database.
     * @param {CompaniesInfoCreateManyAndReturnArgs} args - Arguments to create many CompaniesInfos.
     * @example
     * // Create many CompaniesInfos
     * const companiesInfo = await prisma.companiesInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CompaniesInfos and only return the `id`
     * const companiesInfoWithIdOnly = await prisma.companiesInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CompaniesInfoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CompaniesInfoCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CompaniesInfoPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a CompaniesInfo.
     * @param {CompaniesInfoDeleteArgs} args - Arguments to delete one CompaniesInfo.
     * @example
     * // Delete one CompaniesInfo
     * const CompaniesInfo = await prisma.companiesInfo.delete({
     *   where: {
     *     // ... filter to delete one CompaniesInfo
     *   }
     * })
     *
     */
    delete<T extends CompaniesInfoDeleteArgs>(
      args: SelectSubset<T, CompaniesInfoDeleteArgs<ExtArgs>>
    ): Prisma__CompaniesInfoClient<
      $Result.GetResult<
        Prisma.$CompaniesInfoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one CompaniesInfo.
     * @param {CompaniesInfoUpdateArgs} args - Arguments to update one CompaniesInfo.
     * @example
     * // Update one CompaniesInfo
     * const companiesInfo = await prisma.companiesInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CompaniesInfoUpdateArgs>(
      args: SelectSubset<T, CompaniesInfoUpdateArgs<ExtArgs>>
    ): Prisma__CompaniesInfoClient<
      $Result.GetResult<
        Prisma.$CompaniesInfoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more CompaniesInfos.
     * @param {CompaniesInfoDeleteManyArgs} args - Arguments to filter CompaniesInfos to delete.
     * @example
     * // Delete a few CompaniesInfos
     * const { count } = await prisma.companiesInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CompaniesInfoDeleteManyArgs>(
      args?: SelectSubset<T, CompaniesInfoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CompaniesInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompaniesInfos
     * const companiesInfo = await prisma.companiesInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CompaniesInfoUpdateManyArgs>(
      args: SelectSubset<T, CompaniesInfoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CompaniesInfos and returns the data updated in the database.
     * @param {CompaniesInfoUpdateManyAndReturnArgs} args - Arguments to update many CompaniesInfos.
     * @example
     * // Update many CompaniesInfos
     * const companiesInfo = await prisma.companiesInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CompaniesInfos and only return the `id`
     * const companiesInfoWithIdOnly = await prisma.companiesInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CompaniesInfoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CompaniesInfoUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CompaniesInfoPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one CompaniesInfo.
     * @param {CompaniesInfoUpsertArgs} args - Arguments to update or create a CompaniesInfo.
     * @example
     * // Update or create a CompaniesInfo
     * const companiesInfo = await prisma.companiesInfo.upsert({
     *   create: {
     *     // ... data to create a CompaniesInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompaniesInfo we want to update
     *   }
     * })
     */
    upsert<T extends CompaniesInfoUpsertArgs>(
      args: SelectSubset<T, CompaniesInfoUpsertArgs<ExtArgs>>
    ): Prisma__CompaniesInfoClient<
      $Result.GetResult<
        Prisma.$CompaniesInfoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of CompaniesInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesInfoCountArgs} args - Arguments to filter CompaniesInfos to count.
     * @example
     * // Count the number of CompaniesInfos
     * const count = await prisma.companiesInfo.count({
     *   where: {
     *     // ... the filter for the CompaniesInfos we want to count
     *   }
     * })
     **/
    count<T extends CompaniesInfoCountArgs>(
      args?: Subset<T, CompaniesInfoCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesInfoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a CompaniesInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CompaniesInfoAggregateArgs>(
      args: Subset<T, CompaniesInfoAggregateArgs>
    ): Prisma.PrismaPromise<GetCompaniesInfoAggregateType<T>>;

    /**
     * Group by CompaniesInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CompaniesInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompaniesInfoGroupByArgs['orderBy'] }
        : { orderBy?: CompaniesInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, CompaniesInfoGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetCompaniesInfoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the CompaniesInfo model
     */
    readonly fields: CompaniesInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompaniesInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompaniesInfoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the CompaniesInfo model
   */
  interface CompaniesInfoFieldRefs {
    readonly id: FieldRef<'CompaniesInfo', 'String'>;
    readonly threads_id: FieldRef<'CompaniesInfo', 'String'>;
    readonly symbol: FieldRef<'CompaniesInfo', 'String'>;
    readonly name: FieldRef<'CompaniesInfo', 'String'>;
    readonly market_state: FieldRef<'CompaniesInfo', 'String'>;
    readonly regular_market_price: FieldRef<'CompaniesInfo', 'Float'>;
    readonly regular_market_change: FieldRef<'CompaniesInfo', 'Float'>;
    readonly regular_market_change_percent: FieldRef<'CompaniesInfo', 'Float'>;
    readonly sector: FieldRef<'CompaniesInfo', 'String'>;
    readonly industry: FieldRef<'CompaniesInfo', 'String'>;
    readonly date_at_shares: FieldRef<'CompaniesInfo', 'DateTime'>;
    readonly assets_type: FieldRef<'CompaniesInfo', 'assets_type_enum'>;
    readonly exchange_name: FieldRef<'CompaniesInfo', 'String'>;
    readonly pre_market_price: FieldRef<'CompaniesInfo', 'Float'>;
    readonly pre_market_change: FieldRef<'CompaniesInfo', 'Float'>;
    readonly pre_market_change_percent: FieldRef<'CompaniesInfo', 'Float'>;
    readonly post_market_price: FieldRef<'CompaniesInfo', 'Float'>;
    readonly post_market_change: FieldRef<'CompaniesInfo', 'Float'>;
    readonly post_market_change_percent: FieldRef<'CompaniesInfo', 'Float'>;
    readonly overnight_market_price: FieldRef<'CompaniesInfo', 'Float'>;
    readonly overnight_market_change: FieldRef<'CompaniesInfo', 'Float'>;
    readonly overnight_market_change_percent: FieldRef<
      'CompaniesInfo',
      'Float'
    >;
    readonly market_cap: FieldRef<'CompaniesInfo', 'BigInt'>;
    readonly regular_market_time: FieldRef<'CompaniesInfo', 'BigInt'>;
    readonly pre_market_time: FieldRef<'CompaniesInfo', 'BigInt'>;
    readonly post_market_time: FieldRef<'CompaniesInfo', 'BigInt'>;
    readonly overnight_market_time: FieldRef<'CompaniesInfo', 'BigInt'>;
    readonly currency: FieldRef<'CompaniesInfo', 'String'>;
    readonly created_at: FieldRef<'CompaniesInfo', 'DateTime'>;
    readonly updated_at: FieldRef<'CompaniesInfo', 'DateTime'>;
    readonly deleted_at: FieldRef<'CompaniesInfo', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * CompaniesInfo findUnique
   */
  export type CompaniesInfoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CompaniesInfo
     */
    select?: CompaniesInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CompaniesInfo
     */
    omit?: CompaniesInfoOmit<ExtArgs> | null;
    /**
     * Filter, which CompaniesInfo to fetch.
     */
    where: CompaniesInfoWhereUniqueInput;
  };

  /**
   * CompaniesInfo findUniqueOrThrow
   */
  export type CompaniesInfoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CompaniesInfo
     */
    select?: CompaniesInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CompaniesInfo
     */
    omit?: CompaniesInfoOmit<ExtArgs> | null;
    /**
     * Filter, which CompaniesInfo to fetch.
     */
    where: CompaniesInfoWhereUniqueInput;
  };

  /**
   * CompaniesInfo findFirst
   */
  export type CompaniesInfoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CompaniesInfo
     */
    select?: CompaniesInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CompaniesInfo
     */
    omit?: CompaniesInfoOmit<ExtArgs> | null;
    /**
     * Filter, which CompaniesInfo to fetch.
     */
    where?: CompaniesInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CompaniesInfos to fetch.
     */
    orderBy?:
      | CompaniesInfoOrderByWithRelationInput
      | CompaniesInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CompaniesInfos.
     */
    cursor?: CompaniesInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CompaniesInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CompaniesInfos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CompaniesInfos.
     */
    distinct?: CompaniesInfoScalarFieldEnum | CompaniesInfoScalarFieldEnum[];
  };

  /**
   * CompaniesInfo findFirstOrThrow
   */
  export type CompaniesInfoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CompaniesInfo
     */
    select?: CompaniesInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CompaniesInfo
     */
    omit?: CompaniesInfoOmit<ExtArgs> | null;
    /**
     * Filter, which CompaniesInfo to fetch.
     */
    where?: CompaniesInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CompaniesInfos to fetch.
     */
    orderBy?:
      | CompaniesInfoOrderByWithRelationInput
      | CompaniesInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CompaniesInfos.
     */
    cursor?: CompaniesInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CompaniesInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CompaniesInfos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CompaniesInfos.
     */
    distinct?: CompaniesInfoScalarFieldEnum | CompaniesInfoScalarFieldEnum[];
  };

  /**
   * CompaniesInfo findMany
   */
  export type CompaniesInfoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CompaniesInfo
     */
    select?: CompaniesInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CompaniesInfo
     */
    omit?: CompaniesInfoOmit<ExtArgs> | null;
    /**
     * Filter, which CompaniesInfos to fetch.
     */
    where?: CompaniesInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CompaniesInfos to fetch.
     */
    orderBy?:
      | CompaniesInfoOrderByWithRelationInput
      | CompaniesInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CompaniesInfos.
     */
    cursor?: CompaniesInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CompaniesInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CompaniesInfos.
     */
    skip?: number;
    distinct?: CompaniesInfoScalarFieldEnum | CompaniesInfoScalarFieldEnum[];
  };

  /**
   * CompaniesInfo create
   */
  export type CompaniesInfoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CompaniesInfo
     */
    select?: CompaniesInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CompaniesInfo
     */
    omit?: CompaniesInfoOmit<ExtArgs> | null;
    /**
     * The data needed to create a CompaniesInfo.
     */
    data: XOR<CompaniesInfoCreateInput, CompaniesInfoUncheckedCreateInput>;
  };

  /**
   * CompaniesInfo createMany
   */
  export type CompaniesInfoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many CompaniesInfos.
     */
    data: CompaniesInfoCreateManyInput | CompaniesInfoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * CompaniesInfo createManyAndReturn
   */
  export type CompaniesInfoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CompaniesInfo
     */
    select?: CompaniesInfoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the CompaniesInfo
     */
    omit?: CompaniesInfoOmit<ExtArgs> | null;
    /**
     * The data used to create many CompaniesInfos.
     */
    data: CompaniesInfoCreateManyInput | CompaniesInfoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * CompaniesInfo update
   */
  export type CompaniesInfoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CompaniesInfo
     */
    select?: CompaniesInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CompaniesInfo
     */
    omit?: CompaniesInfoOmit<ExtArgs> | null;
    /**
     * The data needed to update a CompaniesInfo.
     */
    data: XOR<CompaniesInfoUpdateInput, CompaniesInfoUncheckedUpdateInput>;
    /**
     * Choose, which CompaniesInfo to update.
     */
    where: CompaniesInfoWhereUniqueInput;
  };

  /**
   * CompaniesInfo updateMany
   */
  export type CompaniesInfoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update CompaniesInfos.
     */
    data: XOR<
      CompaniesInfoUpdateManyMutationInput,
      CompaniesInfoUncheckedUpdateManyInput
    >;
    /**
     * Filter which CompaniesInfos to update
     */
    where?: CompaniesInfoWhereInput;
    /**
     * Limit how many CompaniesInfos to update.
     */
    limit?: number;
  };

  /**
   * CompaniesInfo updateManyAndReturn
   */
  export type CompaniesInfoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CompaniesInfo
     */
    select?: CompaniesInfoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the CompaniesInfo
     */
    omit?: CompaniesInfoOmit<ExtArgs> | null;
    /**
     * The data used to update CompaniesInfos.
     */
    data: XOR<
      CompaniesInfoUpdateManyMutationInput,
      CompaniesInfoUncheckedUpdateManyInput
    >;
    /**
     * Filter which CompaniesInfos to update
     */
    where?: CompaniesInfoWhereInput;
    /**
     * Limit how many CompaniesInfos to update.
     */
    limit?: number;
  };

  /**
   * CompaniesInfo upsert
   */
  export type CompaniesInfoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CompaniesInfo
     */
    select?: CompaniesInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CompaniesInfo
     */
    omit?: CompaniesInfoOmit<ExtArgs> | null;
    /**
     * The filter to search for the CompaniesInfo to update in case it exists.
     */
    where: CompaniesInfoWhereUniqueInput;
    /**
     * In case the CompaniesInfo found by the `where` argument doesn't exist, create a new CompaniesInfo with this data.
     */
    create: XOR<CompaniesInfoCreateInput, CompaniesInfoUncheckedCreateInput>;
    /**
     * In case the CompaniesInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompaniesInfoUpdateInput, CompaniesInfoUncheckedUpdateInput>;
  };

  /**
   * CompaniesInfo delete
   */
  export type CompaniesInfoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CompaniesInfo
     */
    select?: CompaniesInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CompaniesInfo
     */
    omit?: CompaniesInfoOmit<ExtArgs> | null;
    /**
     * Filter which CompaniesInfo to delete.
     */
    where: CompaniesInfoWhereUniqueInput;
  };

  /**
   * CompaniesInfo deleteMany
   */
  export type CompaniesInfoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which CompaniesInfos to delete
     */
    where?: CompaniesInfoWhereInput;
    /**
     * Limit how many CompaniesInfos to delete.
     */
    limit?: number;
  };

  /**
   * CompaniesInfo without action
   */
  export type CompaniesInfoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CompaniesInfo
     */
    select?: CompaniesInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CompaniesInfo
     */
    omit?: CompaniesInfoOmit<ExtArgs> | null;
  };

  /**
   * Model FollowNotificationOverrides
   */

  export type AggregateFollowNotificationOverrides = {
    _count: FollowNotificationOverridesCountAggregateOutputType | null;
    _avg: FollowNotificationOverridesAvgAggregateOutputType | null;
    _sum: FollowNotificationOverridesSumAggregateOutputType | null;
    _min: FollowNotificationOverridesMinAggregateOutputType | null;
    _max: FollowNotificationOverridesMaxAggregateOutputType | null;
  };

  export type FollowNotificationOverridesAvgAggregateOutputType = {
    follower_id: number | null;
    following_id: number | null;
  };

  export type FollowNotificationOverridesSumAggregateOutputType = {
    follower_id: number | null;
    following_id: number | null;
  };

  export type FollowNotificationOverridesMinAggregateOutputType = {
    id: string | null;
    follower_id: number | null;
    following_id: number | null;
    mute_all: boolean | null;
    notify_threads: boolean | null;
    notify_replies: boolean | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type FollowNotificationOverridesMaxAggregateOutputType = {
    id: string | null;
    follower_id: number | null;
    following_id: number | null;
    mute_all: boolean | null;
    notify_threads: boolean | null;
    notify_replies: boolean | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type FollowNotificationOverridesCountAggregateOutputType = {
    id: number;
    follower_id: number;
    following_id: number;
    mute_all: number;
    notify_threads: number;
    notify_replies: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type FollowNotificationOverridesAvgAggregateInputType = {
    follower_id?: true;
    following_id?: true;
  };

  export type FollowNotificationOverridesSumAggregateInputType = {
    follower_id?: true;
    following_id?: true;
  };

  export type FollowNotificationOverridesMinAggregateInputType = {
    id?: true;
    follower_id?: true;
    following_id?: true;
    mute_all?: true;
    notify_threads?: true;
    notify_replies?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type FollowNotificationOverridesMaxAggregateInputType = {
    id?: true;
    follower_id?: true;
    following_id?: true;
    mute_all?: true;
    notify_threads?: true;
    notify_replies?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type FollowNotificationOverridesCountAggregateInputType = {
    id?: true;
    follower_id?: true;
    following_id?: true;
    mute_all?: true;
    notify_threads?: true;
    notify_replies?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type FollowNotificationOverridesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which FollowNotificationOverrides to aggregate.
     */
    where?: FollowNotificationOverridesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FollowNotificationOverrides to fetch.
     */
    orderBy?:
      | FollowNotificationOverridesOrderByWithRelationInput
      | FollowNotificationOverridesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FollowNotificationOverridesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FollowNotificationOverrides from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FollowNotificationOverrides.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FollowNotificationOverrides
     **/
    _count?: true | FollowNotificationOverridesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FollowNotificationOverridesAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FollowNotificationOverridesSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FollowNotificationOverridesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FollowNotificationOverridesMaxAggregateInputType;
  };

  export type GetFollowNotificationOverridesAggregateType<
    T extends FollowNotificationOverridesAggregateArgs
  > = {
    [P in keyof T & keyof AggregateFollowNotificationOverrides]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollowNotificationOverrides[P]>
      : GetScalarType<T[P], AggregateFollowNotificationOverrides[P]>;
  };

  export type FollowNotificationOverridesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: FollowNotificationOverridesWhereInput;
    orderBy?:
      | FollowNotificationOverridesOrderByWithAggregationInput
      | FollowNotificationOverridesOrderByWithAggregationInput[];
    by:
      | FollowNotificationOverridesScalarFieldEnum[]
      | FollowNotificationOverridesScalarFieldEnum;
    having?: FollowNotificationOverridesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FollowNotificationOverridesCountAggregateInputType | true;
    _avg?: FollowNotificationOverridesAvgAggregateInputType;
    _sum?: FollowNotificationOverridesSumAggregateInputType;
    _min?: FollowNotificationOverridesMinAggregateInputType;
    _max?: FollowNotificationOverridesMaxAggregateInputType;
  };

  export type FollowNotificationOverridesGroupByOutputType = {
    id: string;
    follower_id: number;
    following_id: number;
    mute_all: boolean;
    notify_threads: boolean;
    notify_replies: boolean;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: FollowNotificationOverridesCountAggregateOutputType | null;
    _avg: FollowNotificationOverridesAvgAggregateOutputType | null;
    _sum: FollowNotificationOverridesSumAggregateOutputType | null;
    _min: FollowNotificationOverridesMinAggregateOutputType | null;
    _max: FollowNotificationOverridesMaxAggregateOutputType | null;
  };

  type GetFollowNotificationOverridesGroupByPayload<
    T extends FollowNotificationOverridesGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowNotificationOverridesGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof FollowNotificationOverridesGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<
                T[P],
                FollowNotificationOverridesGroupByOutputType[P]
              >
          : GetScalarType<
              T[P],
              FollowNotificationOverridesGroupByOutputType[P]
            >;
      }
    >
  >;

  export type FollowNotificationOverridesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      follower_id?: boolean;
      following_id?: boolean;
      mute_all?: boolean;
      notify_threads?: boolean;
      notify_replies?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['followNotificationOverrides']
  >;

  export type FollowNotificationOverridesSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      follower_id?: boolean;
      following_id?: boolean;
      mute_all?: boolean;
      notify_threads?: boolean;
      notify_replies?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['followNotificationOverrides']
  >;

  export type FollowNotificationOverridesSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      follower_id?: boolean;
      following_id?: boolean;
      mute_all?: boolean;
      notify_threads?: boolean;
      notify_replies?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['followNotificationOverrides']
  >;

  export type FollowNotificationOverridesSelectScalar = {
    id?: boolean;
    follower_id?: boolean;
    following_id?: boolean;
    mute_all?: boolean;
    notify_threads?: boolean;
    notify_replies?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type FollowNotificationOverridesOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'follower_id'
    | 'following_id'
    | 'mute_all'
    | 'notify_threads'
    | 'notify_replies'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['followNotificationOverrides']
  >;

  export type $FollowNotificationOverridesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'FollowNotificationOverrides';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        follower_id: number;
        following_id: number;
        mute_all: boolean;
        notify_threads: boolean;
        notify_replies: boolean;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['followNotificationOverrides']
    >;
    composites: {};
  };

  type FollowNotificationOverridesGetPayload<
    S extends
      | boolean
      | null
      | undefined
      | FollowNotificationOverridesDefaultArgs
  > = $Result.GetResult<Prisma.$FollowNotificationOverridesPayload, S>;

  type FollowNotificationOverridesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    FollowNotificationOverridesFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: FollowNotificationOverridesCountAggregateInputType | true;
  };

  export interface FollowNotificationOverridesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FollowNotificationOverrides'];
      meta: { name: 'FollowNotificationOverrides' };
    };
    /**
     * Find zero or one FollowNotificationOverrides that matches the filter.
     * @param {FollowNotificationOverridesFindUniqueArgs} args - Arguments to find a FollowNotificationOverrides
     * @example
     * // Get one FollowNotificationOverrides
     * const followNotificationOverrides = await prisma.followNotificationOverrides.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowNotificationOverridesFindUniqueArgs>(
      args: SelectSubset<T, FollowNotificationOverridesFindUniqueArgs<ExtArgs>>
    ): Prisma__FollowNotificationOverridesClient<
      $Result.GetResult<
        Prisma.$FollowNotificationOverridesPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one FollowNotificationOverrides that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowNotificationOverridesFindUniqueOrThrowArgs} args - Arguments to find a FollowNotificationOverrides
     * @example
     * // Get one FollowNotificationOverrides
     * const followNotificationOverrides = await prisma.followNotificationOverrides.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<
      T extends FollowNotificationOverridesFindUniqueOrThrowArgs
    >(
      args: SelectSubset<
        T,
        FollowNotificationOverridesFindUniqueOrThrowArgs<ExtArgs>
      >
    ): Prisma__FollowNotificationOverridesClient<
      $Result.GetResult<
        Prisma.$FollowNotificationOverridesPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FollowNotificationOverrides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowNotificationOverridesFindFirstArgs} args - Arguments to find a FollowNotificationOverrides
     * @example
     * // Get one FollowNotificationOverrides
     * const followNotificationOverrides = await prisma.followNotificationOverrides.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowNotificationOverridesFindFirstArgs>(
      args?: SelectSubset<T, FollowNotificationOverridesFindFirstArgs<ExtArgs>>
    ): Prisma__FollowNotificationOverridesClient<
      $Result.GetResult<
        Prisma.$FollowNotificationOverridesPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FollowNotificationOverrides that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowNotificationOverridesFindFirstOrThrowArgs} args - Arguments to find a FollowNotificationOverrides
     * @example
     * // Get one FollowNotificationOverrides
     * const followNotificationOverrides = await prisma.followNotificationOverrides.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowNotificationOverridesFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        FollowNotificationOverridesFindFirstOrThrowArgs<ExtArgs>
      >
    ): Prisma__FollowNotificationOverridesClient<
      $Result.GetResult<
        Prisma.$FollowNotificationOverridesPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FollowNotificationOverrides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowNotificationOverridesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FollowNotificationOverrides
     * const followNotificationOverrides = await prisma.followNotificationOverrides.findMany()
     *
     * // Get first 10 FollowNotificationOverrides
     * const followNotificationOverrides = await prisma.followNotificationOverrides.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const followNotificationOverridesWithIdOnly = await prisma.followNotificationOverrides.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FollowNotificationOverridesFindManyArgs>(
      args?: SelectSubset<T, FollowNotificationOverridesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FollowNotificationOverridesPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a FollowNotificationOverrides.
     * @param {FollowNotificationOverridesCreateArgs} args - Arguments to create a FollowNotificationOverrides.
     * @example
     * // Create one FollowNotificationOverrides
     * const FollowNotificationOverrides = await prisma.followNotificationOverrides.create({
     *   data: {
     *     // ... data to create a FollowNotificationOverrides
     *   }
     * })
     *
     */
    create<T extends FollowNotificationOverridesCreateArgs>(
      args: SelectSubset<T, FollowNotificationOverridesCreateArgs<ExtArgs>>
    ): Prisma__FollowNotificationOverridesClient<
      $Result.GetResult<
        Prisma.$FollowNotificationOverridesPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many FollowNotificationOverrides.
     * @param {FollowNotificationOverridesCreateManyArgs} args - Arguments to create many FollowNotificationOverrides.
     * @example
     * // Create many FollowNotificationOverrides
     * const followNotificationOverrides = await prisma.followNotificationOverrides.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FollowNotificationOverridesCreateManyArgs>(
      args?: SelectSubset<T, FollowNotificationOverridesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many FollowNotificationOverrides and returns the data saved in the database.
     * @param {FollowNotificationOverridesCreateManyAndReturnArgs} args - Arguments to create many FollowNotificationOverrides.
     * @example
     * // Create many FollowNotificationOverrides
     * const followNotificationOverrides = await prisma.followNotificationOverrides.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FollowNotificationOverrides and only return the `id`
     * const followNotificationOverridesWithIdOnly = await prisma.followNotificationOverrides.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends FollowNotificationOverridesCreateManyAndReturnArgs
    >(
      args?: SelectSubset<
        T,
        FollowNotificationOverridesCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FollowNotificationOverridesPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a FollowNotificationOverrides.
     * @param {FollowNotificationOverridesDeleteArgs} args - Arguments to delete one FollowNotificationOverrides.
     * @example
     * // Delete one FollowNotificationOverrides
     * const FollowNotificationOverrides = await prisma.followNotificationOverrides.delete({
     *   where: {
     *     // ... filter to delete one FollowNotificationOverrides
     *   }
     * })
     *
     */
    delete<T extends FollowNotificationOverridesDeleteArgs>(
      args: SelectSubset<T, FollowNotificationOverridesDeleteArgs<ExtArgs>>
    ): Prisma__FollowNotificationOverridesClient<
      $Result.GetResult<
        Prisma.$FollowNotificationOverridesPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one FollowNotificationOverrides.
     * @param {FollowNotificationOverridesUpdateArgs} args - Arguments to update one FollowNotificationOverrides.
     * @example
     * // Update one FollowNotificationOverrides
     * const followNotificationOverrides = await prisma.followNotificationOverrides.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FollowNotificationOverridesUpdateArgs>(
      args: SelectSubset<T, FollowNotificationOverridesUpdateArgs<ExtArgs>>
    ): Prisma__FollowNotificationOverridesClient<
      $Result.GetResult<
        Prisma.$FollowNotificationOverridesPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more FollowNotificationOverrides.
     * @param {FollowNotificationOverridesDeleteManyArgs} args - Arguments to filter FollowNotificationOverrides to delete.
     * @example
     * // Delete a few FollowNotificationOverrides
     * const { count } = await prisma.followNotificationOverrides.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FollowNotificationOverridesDeleteManyArgs>(
      args?: SelectSubset<T, FollowNotificationOverridesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FollowNotificationOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowNotificationOverridesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FollowNotificationOverrides
     * const followNotificationOverrides = await prisma.followNotificationOverrides.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FollowNotificationOverridesUpdateManyArgs>(
      args: SelectSubset<T, FollowNotificationOverridesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FollowNotificationOverrides and returns the data updated in the database.
     * @param {FollowNotificationOverridesUpdateManyAndReturnArgs} args - Arguments to update many FollowNotificationOverrides.
     * @example
     * // Update many FollowNotificationOverrides
     * const followNotificationOverrides = await prisma.followNotificationOverrides.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FollowNotificationOverrides and only return the `id`
     * const followNotificationOverridesWithIdOnly = await prisma.followNotificationOverrides.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends FollowNotificationOverridesUpdateManyAndReturnArgs
    >(
      args: SelectSubset<
        T,
        FollowNotificationOverridesUpdateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FollowNotificationOverridesPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one FollowNotificationOverrides.
     * @param {FollowNotificationOverridesUpsertArgs} args - Arguments to update or create a FollowNotificationOverrides.
     * @example
     * // Update or create a FollowNotificationOverrides
     * const followNotificationOverrides = await prisma.followNotificationOverrides.upsert({
     *   create: {
     *     // ... data to create a FollowNotificationOverrides
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FollowNotificationOverrides we want to update
     *   }
     * })
     */
    upsert<T extends FollowNotificationOverridesUpsertArgs>(
      args: SelectSubset<T, FollowNotificationOverridesUpsertArgs<ExtArgs>>
    ): Prisma__FollowNotificationOverridesClient<
      $Result.GetResult<
        Prisma.$FollowNotificationOverridesPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of FollowNotificationOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowNotificationOverridesCountArgs} args - Arguments to filter FollowNotificationOverrides to count.
     * @example
     * // Count the number of FollowNotificationOverrides
     * const count = await prisma.followNotificationOverrides.count({
     *   where: {
     *     // ... the filter for the FollowNotificationOverrides we want to count
     *   }
     * })
     **/
    count<T extends FollowNotificationOverridesCountArgs>(
      args?: Subset<T, FollowNotificationOverridesCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              FollowNotificationOverridesCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FollowNotificationOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowNotificationOverridesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FollowNotificationOverridesAggregateArgs>(
      args: Subset<T, FollowNotificationOverridesAggregateArgs>
    ): Prisma.PrismaPromise<GetFollowNotificationOverridesAggregateType<T>>;

    /**
     * Group by FollowNotificationOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowNotificationOverridesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FollowNotificationOverridesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowNotificationOverridesGroupByArgs['orderBy'] }
        : { orderBy?: FollowNotificationOverridesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<
        T,
        FollowNotificationOverridesGroupByArgs,
        OrderByArg
      > &
        InputErrors
    ): {} extends InputErrors
      ? GetFollowNotificationOverridesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FollowNotificationOverrides model
     */
    readonly fields: FollowNotificationOverridesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FollowNotificationOverrides.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowNotificationOverridesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FollowNotificationOverrides model
   */
  interface FollowNotificationOverridesFieldRefs {
    readonly id: FieldRef<'FollowNotificationOverrides', 'String'>;
    readonly follower_id: FieldRef<'FollowNotificationOverrides', 'Int'>;
    readonly following_id: FieldRef<'FollowNotificationOverrides', 'Int'>;
    readonly mute_all: FieldRef<'FollowNotificationOverrides', 'Boolean'>;
    readonly notify_threads: FieldRef<'FollowNotificationOverrides', 'Boolean'>;
    readonly notify_replies: FieldRef<'FollowNotificationOverrides', 'Boolean'>;
    readonly created_at: FieldRef<'FollowNotificationOverrides', 'DateTime'>;
    readonly updated_at: FieldRef<'FollowNotificationOverrides', 'DateTime'>;
    readonly deleted_at: FieldRef<'FollowNotificationOverrides', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * FollowNotificationOverrides findUnique
   */
  export type FollowNotificationOverridesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowNotificationOverrides
     */
    select?: FollowNotificationOverridesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowNotificationOverrides
     */
    omit?: FollowNotificationOverridesOmit<ExtArgs> | null;
    /**
     * Filter, which FollowNotificationOverrides to fetch.
     */
    where: FollowNotificationOverridesWhereUniqueInput;
  };

  /**
   * FollowNotificationOverrides findUniqueOrThrow
   */
  export type FollowNotificationOverridesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowNotificationOverrides
     */
    select?: FollowNotificationOverridesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowNotificationOverrides
     */
    omit?: FollowNotificationOverridesOmit<ExtArgs> | null;
    /**
     * Filter, which FollowNotificationOverrides to fetch.
     */
    where: FollowNotificationOverridesWhereUniqueInput;
  };

  /**
   * FollowNotificationOverrides findFirst
   */
  export type FollowNotificationOverridesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowNotificationOverrides
     */
    select?: FollowNotificationOverridesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowNotificationOverrides
     */
    omit?: FollowNotificationOverridesOmit<ExtArgs> | null;
    /**
     * Filter, which FollowNotificationOverrides to fetch.
     */
    where?: FollowNotificationOverridesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FollowNotificationOverrides to fetch.
     */
    orderBy?:
      | FollowNotificationOverridesOrderByWithRelationInput
      | FollowNotificationOverridesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FollowNotificationOverrides.
     */
    cursor?: FollowNotificationOverridesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FollowNotificationOverrides from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FollowNotificationOverrides.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FollowNotificationOverrides.
     */
    distinct?:
      | FollowNotificationOverridesScalarFieldEnum
      | FollowNotificationOverridesScalarFieldEnum[];
  };

  /**
   * FollowNotificationOverrides findFirstOrThrow
   */
  export type FollowNotificationOverridesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowNotificationOverrides
     */
    select?: FollowNotificationOverridesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowNotificationOverrides
     */
    omit?: FollowNotificationOverridesOmit<ExtArgs> | null;
    /**
     * Filter, which FollowNotificationOverrides to fetch.
     */
    where?: FollowNotificationOverridesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FollowNotificationOverrides to fetch.
     */
    orderBy?:
      | FollowNotificationOverridesOrderByWithRelationInput
      | FollowNotificationOverridesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FollowNotificationOverrides.
     */
    cursor?: FollowNotificationOverridesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FollowNotificationOverrides from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FollowNotificationOverrides.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FollowNotificationOverrides.
     */
    distinct?:
      | FollowNotificationOverridesScalarFieldEnum
      | FollowNotificationOverridesScalarFieldEnum[];
  };

  /**
   * FollowNotificationOverrides findMany
   */
  export type FollowNotificationOverridesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowNotificationOverrides
     */
    select?: FollowNotificationOverridesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowNotificationOverrides
     */
    omit?: FollowNotificationOverridesOmit<ExtArgs> | null;
    /**
     * Filter, which FollowNotificationOverrides to fetch.
     */
    where?: FollowNotificationOverridesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FollowNotificationOverrides to fetch.
     */
    orderBy?:
      | FollowNotificationOverridesOrderByWithRelationInput
      | FollowNotificationOverridesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FollowNotificationOverrides.
     */
    cursor?: FollowNotificationOverridesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FollowNotificationOverrides from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FollowNotificationOverrides.
     */
    skip?: number;
    distinct?:
      | FollowNotificationOverridesScalarFieldEnum
      | FollowNotificationOverridesScalarFieldEnum[];
  };

  /**
   * FollowNotificationOverrides create
   */
  export type FollowNotificationOverridesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowNotificationOverrides
     */
    select?: FollowNotificationOverridesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowNotificationOverrides
     */
    omit?: FollowNotificationOverridesOmit<ExtArgs> | null;
    /**
     * The data needed to create a FollowNotificationOverrides.
     */
    data: XOR<
      FollowNotificationOverridesCreateInput,
      FollowNotificationOverridesUncheckedCreateInput
    >;
  };

  /**
   * FollowNotificationOverrides createMany
   */
  export type FollowNotificationOverridesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many FollowNotificationOverrides.
     */
    data:
      | FollowNotificationOverridesCreateManyInput
      | FollowNotificationOverridesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FollowNotificationOverrides createManyAndReturn
   */
  export type FollowNotificationOverridesCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowNotificationOverrides
     */
    select?: FollowNotificationOverridesSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowNotificationOverrides
     */
    omit?: FollowNotificationOverridesOmit<ExtArgs> | null;
    /**
     * The data used to create many FollowNotificationOverrides.
     */
    data:
      | FollowNotificationOverridesCreateManyInput
      | FollowNotificationOverridesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FollowNotificationOverrides update
   */
  export type FollowNotificationOverridesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowNotificationOverrides
     */
    select?: FollowNotificationOverridesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowNotificationOverrides
     */
    omit?: FollowNotificationOverridesOmit<ExtArgs> | null;
    /**
     * The data needed to update a FollowNotificationOverrides.
     */
    data: XOR<
      FollowNotificationOverridesUpdateInput,
      FollowNotificationOverridesUncheckedUpdateInput
    >;
    /**
     * Choose, which FollowNotificationOverrides to update.
     */
    where: FollowNotificationOverridesWhereUniqueInput;
  };

  /**
   * FollowNotificationOverrides updateMany
   */
  export type FollowNotificationOverridesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update FollowNotificationOverrides.
     */
    data: XOR<
      FollowNotificationOverridesUpdateManyMutationInput,
      FollowNotificationOverridesUncheckedUpdateManyInput
    >;
    /**
     * Filter which FollowNotificationOverrides to update
     */
    where?: FollowNotificationOverridesWhereInput;
    /**
     * Limit how many FollowNotificationOverrides to update.
     */
    limit?: number;
  };

  /**
   * FollowNotificationOverrides updateManyAndReturn
   */
  export type FollowNotificationOverridesUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowNotificationOverrides
     */
    select?: FollowNotificationOverridesSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowNotificationOverrides
     */
    omit?: FollowNotificationOverridesOmit<ExtArgs> | null;
    /**
     * The data used to update FollowNotificationOverrides.
     */
    data: XOR<
      FollowNotificationOverridesUpdateManyMutationInput,
      FollowNotificationOverridesUncheckedUpdateManyInput
    >;
    /**
     * Filter which FollowNotificationOverrides to update
     */
    where?: FollowNotificationOverridesWhereInput;
    /**
     * Limit how many FollowNotificationOverrides to update.
     */
    limit?: number;
  };

  /**
   * FollowNotificationOverrides upsert
   */
  export type FollowNotificationOverridesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowNotificationOverrides
     */
    select?: FollowNotificationOverridesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowNotificationOverrides
     */
    omit?: FollowNotificationOverridesOmit<ExtArgs> | null;
    /**
     * The filter to search for the FollowNotificationOverrides to update in case it exists.
     */
    where: FollowNotificationOverridesWhereUniqueInput;
    /**
     * In case the FollowNotificationOverrides found by the `where` argument doesn't exist, create a new FollowNotificationOverrides with this data.
     */
    create: XOR<
      FollowNotificationOverridesCreateInput,
      FollowNotificationOverridesUncheckedCreateInput
    >;
    /**
     * In case the FollowNotificationOverrides was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      FollowNotificationOverridesUpdateInput,
      FollowNotificationOverridesUncheckedUpdateInput
    >;
  };

  /**
   * FollowNotificationOverrides delete
   */
  export type FollowNotificationOverridesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowNotificationOverrides
     */
    select?: FollowNotificationOverridesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowNotificationOverrides
     */
    omit?: FollowNotificationOverridesOmit<ExtArgs> | null;
    /**
     * Filter which FollowNotificationOverrides to delete.
     */
    where: FollowNotificationOverridesWhereUniqueInput;
  };

  /**
   * FollowNotificationOverrides deleteMany
   */
  export type FollowNotificationOverridesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which FollowNotificationOverrides to delete
     */
    where?: FollowNotificationOverridesWhereInput;
    /**
     * Limit how many FollowNotificationOverrides to delete.
     */
    limit?: number;
  };

  /**
   * FollowNotificationOverrides without action
   */
  export type FollowNotificationOverridesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowNotificationOverrides
     */
    select?: FollowNotificationOverridesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowNotificationOverrides
     */
    omit?: FollowNotificationOverridesOmit<ExtArgs> | null;
  };

  /**
   * Model FollowRequests
   */

  export type AggregateFollowRequests = {
    _count: FollowRequestsCountAggregateOutputType | null;
    _avg: FollowRequestsAvgAggregateOutputType | null;
    _sum: FollowRequestsSumAggregateOutputType | null;
    _min: FollowRequestsMinAggregateOutputType | null;
    _max: FollowRequestsMaxAggregateOutputType | null;
  };

  export type FollowRequestsAvgAggregateOutputType = {
    requester_id: number | null;
    target_id: number | null;
  };

  export type FollowRequestsSumAggregateOutputType = {
    requester_id: number | null;
    target_id: number | null;
  };

  export type FollowRequestsMinAggregateOutputType = {
    id: string | null;
    requester_id: number | null;
    target_id: number | null;
    status: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type FollowRequestsMaxAggregateOutputType = {
    id: string | null;
    requester_id: number | null;
    target_id: number | null;
    status: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type FollowRequestsCountAggregateOutputType = {
    id: number;
    requester_id: number;
    target_id: number;
    status: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type FollowRequestsAvgAggregateInputType = {
    requester_id?: true;
    target_id?: true;
  };

  export type FollowRequestsSumAggregateInputType = {
    requester_id?: true;
    target_id?: true;
  };

  export type FollowRequestsMinAggregateInputType = {
    id?: true;
    requester_id?: true;
    target_id?: true;
    status?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type FollowRequestsMaxAggregateInputType = {
    id?: true;
    requester_id?: true;
    target_id?: true;
    status?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type FollowRequestsCountAggregateInputType = {
    id?: true;
    requester_id?: true;
    target_id?: true;
    status?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type FollowRequestsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which FollowRequests to aggregate.
     */
    where?: FollowRequestsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FollowRequests to fetch.
     */
    orderBy?:
      | FollowRequestsOrderByWithRelationInput
      | FollowRequestsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FollowRequestsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FollowRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FollowRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FollowRequests
     **/
    _count?: true | FollowRequestsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FollowRequestsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FollowRequestsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FollowRequestsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FollowRequestsMaxAggregateInputType;
  };

  export type GetFollowRequestsAggregateType<
    T extends FollowRequestsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateFollowRequests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollowRequests[P]>
      : GetScalarType<T[P], AggregateFollowRequests[P]>;
  };

  export type FollowRequestsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: FollowRequestsWhereInput;
    orderBy?:
      | FollowRequestsOrderByWithAggregationInput
      | FollowRequestsOrderByWithAggregationInput[];
    by: FollowRequestsScalarFieldEnum[] | FollowRequestsScalarFieldEnum;
    having?: FollowRequestsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FollowRequestsCountAggregateInputType | true;
    _avg?: FollowRequestsAvgAggregateInputType;
    _sum?: FollowRequestsSumAggregateInputType;
    _min?: FollowRequestsMinAggregateInputType;
    _max?: FollowRequestsMaxAggregateInputType;
  };

  export type FollowRequestsGroupByOutputType = {
    id: string;
    requester_id: number;
    target_id: number;
    status: string;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: FollowRequestsCountAggregateOutputType | null;
    _avg: FollowRequestsAvgAggregateOutputType | null;
    _sum: FollowRequestsSumAggregateOutputType | null;
    _min: FollowRequestsMinAggregateOutputType | null;
    _max: FollowRequestsMaxAggregateOutputType | null;
  };

  type GetFollowRequestsGroupByPayload<T extends FollowRequestsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FollowRequestsGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof FollowRequestsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowRequestsGroupByOutputType[P]>
            : GetScalarType<T[P], FollowRequestsGroupByOutputType[P]>;
        }
      >
    >;

  export type FollowRequestsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      requester_id?: boolean;
      target_id?: boolean;
      status?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['followRequests']
  >;

  export type FollowRequestsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      requester_id?: boolean;
      target_id?: boolean;
      status?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['followRequests']
  >;

  export type FollowRequestsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      requester_id?: boolean;
      target_id?: boolean;
      status?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['followRequests']
  >;

  export type FollowRequestsSelectScalar = {
    id?: boolean;
    requester_id?: boolean;
    target_id?: boolean;
    status?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type FollowRequestsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'requester_id'
    | 'target_id'
    | 'status'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['followRequests']
  >;

  export type $FollowRequestsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'FollowRequests';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        requester_id: number;
        target_id: number;
        status: string;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['followRequests']
    >;
    composites: {};
  };

  type FollowRequestsGetPayload<
    S extends boolean | null | undefined | FollowRequestsDefaultArgs
  > = $Result.GetResult<Prisma.$FollowRequestsPayload, S>;

  type FollowRequestsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    FollowRequestsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: FollowRequestsCountAggregateInputType | true;
  };

  export interface FollowRequestsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FollowRequests'];
      meta: { name: 'FollowRequests' };
    };
    /**
     * Find zero or one FollowRequests that matches the filter.
     * @param {FollowRequestsFindUniqueArgs} args - Arguments to find a FollowRequests
     * @example
     * // Get one FollowRequests
     * const followRequests = await prisma.followRequests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowRequestsFindUniqueArgs>(
      args: SelectSubset<T, FollowRequestsFindUniqueArgs<ExtArgs>>
    ): Prisma__FollowRequestsClient<
      $Result.GetResult<
        Prisma.$FollowRequestsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one FollowRequests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowRequestsFindUniqueOrThrowArgs} args - Arguments to find a FollowRequests
     * @example
     * // Get one FollowRequests
     * const followRequests = await prisma.followRequests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowRequestsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FollowRequestsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FollowRequestsClient<
      $Result.GetResult<
        Prisma.$FollowRequestsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FollowRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowRequestsFindFirstArgs} args - Arguments to find a FollowRequests
     * @example
     * // Get one FollowRequests
     * const followRequests = await prisma.followRequests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowRequestsFindFirstArgs>(
      args?: SelectSubset<T, FollowRequestsFindFirstArgs<ExtArgs>>
    ): Prisma__FollowRequestsClient<
      $Result.GetResult<
        Prisma.$FollowRequestsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FollowRequests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowRequestsFindFirstOrThrowArgs} args - Arguments to find a FollowRequests
     * @example
     * // Get one FollowRequests
     * const followRequests = await prisma.followRequests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowRequestsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FollowRequestsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FollowRequestsClient<
      $Result.GetResult<
        Prisma.$FollowRequestsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FollowRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowRequestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FollowRequests
     * const followRequests = await prisma.followRequests.findMany()
     *
     * // Get first 10 FollowRequests
     * const followRequests = await prisma.followRequests.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const followRequestsWithIdOnly = await prisma.followRequests.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FollowRequestsFindManyArgs>(
      args?: SelectSubset<T, FollowRequestsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FollowRequestsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a FollowRequests.
     * @param {FollowRequestsCreateArgs} args - Arguments to create a FollowRequests.
     * @example
     * // Create one FollowRequests
     * const FollowRequests = await prisma.followRequests.create({
     *   data: {
     *     // ... data to create a FollowRequests
     *   }
     * })
     *
     */
    create<T extends FollowRequestsCreateArgs>(
      args: SelectSubset<T, FollowRequestsCreateArgs<ExtArgs>>
    ): Prisma__FollowRequestsClient<
      $Result.GetResult<
        Prisma.$FollowRequestsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many FollowRequests.
     * @param {FollowRequestsCreateManyArgs} args - Arguments to create many FollowRequests.
     * @example
     * // Create many FollowRequests
     * const followRequests = await prisma.followRequests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FollowRequestsCreateManyArgs>(
      args?: SelectSubset<T, FollowRequestsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many FollowRequests and returns the data saved in the database.
     * @param {FollowRequestsCreateManyAndReturnArgs} args - Arguments to create many FollowRequests.
     * @example
     * // Create many FollowRequests
     * const followRequests = await prisma.followRequests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FollowRequests and only return the `id`
     * const followRequestsWithIdOnly = await prisma.followRequests.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FollowRequestsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FollowRequestsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FollowRequestsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a FollowRequests.
     * @param {FollowRequestsDeleteArgs} args - Arguments to delete one FollowRequests.
     * @example
     * // Delete one FollowRequests
     * const FollowRequests = await prisma.followRequests.delete({
     *   where: {
     *     // ... filter to delete one FollowRequests
     *   }
     * })
     *
     */
    delete<T extends FollowRequestsDeleteArgs>(
      args: SelectSubset<T, FollowRequestsDeleteArgs<ExtArgs>>
    ): Prisma__FollowRequestsClient<
      $Result.GetResult<
        Prisma.$FollowRequestsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one FollowRequests.
     * @param {FollowRequestsUpdateArgs} args - Arguments to update one FollowRequests.
     * @example
     * // Update one FollowRequests
     * const followRequests = await prisma.followRequests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FollowRequestsUpdateArgs>(
      args: SelectSubset<T, FollowRequestsUpdateArgs<ExtArgs>>
    ): Prisma__FollowRequestsClient<
      $Result.GetResult<
        Prisma.$FollowRequestsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more FollowRequests.
     * @param {FollowRequestsDeleteManyArgs} args - Arguments to filter FollowRequests to delete.
     * @example
     * // Delete a few FollowRequests
     * const { count } = await prisma.followRequests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FollowRequestsDeleteManyArgs>(
      args?: SelectSubset<T, FollowRequestsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FollowRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowRequestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FollowRequests
     * const followRequests = await prisma.followRequests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FollowRequestsUpdateManyArgs>(
      args: SelectSubset<T, FollowRequestsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FollowRequests and returns the data updated in the database.
     * @param {FollowRequestsUpdateManyAndReturnArgs} args - Arguments to update many FollowRequests.
     * @example
     * // Update many FollowRequests
     * const followRequests = await prisma.followRequests.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FollowRequests and only return the `id`
     * const followRequestsWithIdOnly = await prisma.followRequests.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FollowRequestsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FollowRequestsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FollowRequestsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one FollowRequests.
     * @param {FollowRequestsUpsertArgs} args - Arguments to update or create a FollowRequests.
     * @example
     * // Update or create a FollowRequests
     * const followRequests = await prisma.followRequests.upsert({
     *   create: {
     *     // ... data to create a FollowRequests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FollowRequests we want to update
     *   }
     * })
     */
    upsert<T extends FollowRequestsUpsertArgs>(
      args: SelectSubset<T, FollowRequestsUpsertArgs<ExtArgs>>
    ): Prisma__FollowRequestsClient<
      $Result.GetResult<
        Prisma.$FollowRequestsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of FollowRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowRequestsCountArgs} args - Arguments to filter FollowRequests to count.
     * @example
     * // Count the number of FollowRequests
     * const count = await prisma.followRequests.count({
     *   where: {
     *     // ... the filter for the FollowRequests we want to count
     *   }
     * })
     **/
    count<T extends FollowRequestsCountArgs>(
      args?: Subset<T, FollowRequestsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowRequestsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FollowRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowRequestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FollowRequestsAggregateArgs>(
      args: Subset<T, FollowRequestsAggregateArgs>
    ): Prisma.PrismaPromise<GetFollowRequestsAggregateType<T>>;

    /**
     * Group by FollowRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowRequestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FollowRequestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowRequestsGroupByArgs['orderBy'] }
        : { orderBy?: FollowRequestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, FollowRequestsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetFollowRequestsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FollowRequests model
     */
    readonly fields: FollowRequestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FollowRequests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowRequestsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FollowRequests model
   */
  interface FollowRequestsFieldRefs {
    readonly id: FieldRef<'FollowRequests', 'String'>;
    readonly requester_id: FieldRef<'FollowRequests', 'Int'>;
    readonly target_id: FieldRef<'FollowRequests', 'Int'>;
    readonly status: FieldRef<'FollowRequests', 'String'>;
    readonly created_at: FieldRef<'FollowRequests', 'DateTime'>;
    readonly updated_at: FieldRef<'FollowRequests', 'DateTime'>;
    readonly deleted_at: FieldRef<'FollowRequests', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * FollowRequests findUnique
   */
  export type FollowRequestsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowRequests
     */
    select?: FollowRequestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowRequests
     */
    omit?: FollowRequestsOmit<ExtArgs> | null;
    /**
     * Filter, which FollowRequests to fetch.
     */
    where: FollowRequestsWhereUniqueInput;
  };

  /**
   * FollowRequests findUniqueOrThrow
   */
  export type FollowRequestsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowRequests
     */
    select?: FollowRequestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowRequests
     */
    omit?: FollowRequestsOmit<ExtArgs> | null;
    /**
     * Filter, which FollowRequests to fetch.
     */
    where: FollowRequestsWhereUniqueInput;
  };

  /**
   * FollowRequests findFirst
   */
  export type FollowRequestsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowRequests
     */
    select?: FollowRequestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowRequests
     */
    omit?: FollowRequestsOmit<ExtArgs> | null;
    /**
     * Filter, which FollowRequests to fetch.
     */
    where?: FollowRequestsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FollowRequests to fetch.
     */
    orderBy?:
      | FollowRequestsOrderByWithRelationInput
      | FollowRequestsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FollowRequests.
     */
    cursor?: FollowRequestsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FollowRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FollowRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FollowRequests.
     */
    distinct?: FollowRequestsScalarFieldEnum | FollowRequestsScalarFieldEnum[];
  };

  /**
   * FollowRequests findFirstOrThrow
   */
  export type FollowRequestsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowRequests
     */
    select?: FollowRequestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowRequests
     */
    omit?: FollowRequestsOmit<ExtArgs> | null;
    /**
     * Filter, which FollowRequests to fetch.
     */
    where?: FollowRequestsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FollowRequests to fetch.
     */
    orderBy?:
      | FollowRequestsOrderByWithRelationInput
      | FollowRequestsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FollowRequests.
     */
    cursor?: FollowRequestsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FollowRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FollowRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FollowRequests.
     */
    distinct?: FollowRequestsScalarFieldEnum | FollowRequestsScalarFieldEnum[];
  };

  /**
   * FollowRequests findMany
   */
  export type FollowRequestsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowRequests
     */
    select?: FollowRequestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowRequests
     */
    omit?: FollowRequestsOmit<ExtArgs> | null;
    /**
     * Filter, which FollowRequests to fetch.
     */
    where?: FollowRequestsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FollowRequests to fetch.
     */
    orderBy?:
      | FollowRequestsOrderByWithRelationInput
      | FollowRequestsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FollowRequests.
     */
    cursor?: FollowRequestsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FollowRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FollowRequests.
     */
    skip?: number;
    distinct?: FollowRequestsScalarFieldEnum | FollowRequestsScalarFieldEnum[];
  };

  /**
   * FollowRequests create
   */
  export type FollowRequestsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowRequests
     */
    select?: FollowRequestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowRequests
     */
    omit?: FollowRequestsOmit<ExtArgs> | null;
    /**
     * The data needed to create a FollowRequests.
     */
    data: XOR<FollowRequestsCreateInput, FollowRequestsUncheckedCreateInput>;
  };

  /**
   * FollowRequests createMany
   */
  export type FollowRequestsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many FollowRequests.
     */
    data: FollowRequestsCreateManyInput | FollowRequestsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FollowRequests createManyAndReturn
   */
  export type FollowRequestsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowRequests
     */
    select?: FollowRequestsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowRequests
     */
    omit?: FollowRequestsOmit<ExtArgs> | null;
    /**
     * The data used to create many FollowRequests.
     */
    data: FollowRequestsCreateManyInput | FollowRequestsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FollowRequests update
   */
  export type FollowRequestsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowRequests
     */
    select?: FollowRequestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowRequests
     */
    omit?: FollowRequestsOmit<ExtArgs> | null;
    /**
     * The data needed to update a FollowRequests.
     */
    data: XOR<FollowRequestsUpdateInput, FollowRequestsUncheckedUpdateInput>;
    /**
     * Choose, which FollowRequests to update.
     */
    where: FollowRequestsWhereUniqueInput;
  };

  /**
   * FollowRequests updateMany
   */
  export type FollowRequestsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update FollowRequests.
     */
    data: XOR<
      FollowRequestsUpdateManyMutationInput,
      FollowRequestsUncheckedUpdateManyInput
    >;
    /**
     * Filter which FollowRequests to update
     */
    where?: FollowRequestsWhereInput;
    /**
     * Limit how many FollowRequests to update.
     */
    limit?: number;
  };

  /**
   * FollowRequests updateManyAndReturn
   */
  export type FollowRequestsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowRequests
     */
    select?: FollowRequestsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowRequests
     */
    omit?: FollowRequestsOmit<ExtArgs> | null;
    /**
     * The data used to update FollowRequests.
     */
    data: XOR<
      FollowRequestsUpdateManyMutationInput,
      FollowRequestsUncheckedUpdateManyInput
    >;
    /**
     * Filter which FollowRequests to update
     */
    where?: FollowRequestsWhereInput;
    /**
     * Limit how many FollowRequests to update.
     */
    limit?: number;
  };

  /**
   * FollowRequests upsert
   */
  export type FollowRequestsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowRequests
     */
    select?: FollowRequestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowRequests
     */
    omit?: FollowRequestsOmit<ExtArgs> | null;
    /**
     * The filter to search for the FollowRequests to update in case it exists.
     */
    where: FollowRequestsWhereUniqueInput;
    /**
     * In case the FollowRequests found by the `where` argument doesn't exist, create a new FollowRequests with this data.
     */
    create: XOR<FollowRequestsCreateInput, FollowRequestsUncheckedCreateInput>;
    /**
     * In case the FollowRequests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowRequestsUpdateInput, FollowRequestsUncheckedUpdateInput>;
  };

  /**
   * FollowRequests delete
   */
  export type FollowRequestsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowRequests
     */
    select?: FollowRequestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowRequests
     */
    omit?: FollowRequestsOmit<ExtArgs> | null;
    /**
     * Filter which FollowRequests to delete.
     */
    where: FollowRequestsWhereUniqueInput;
  };

  /**
   * FollowRequests deleteMany
   */
  export type FollowRequestsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which FollowRequests to delete
     */
    where?: FollowRequestsWhereInput;
    /**
     * Limit how many FollowRequests to delete.
     */
    limit?: number;
  };

  /**
   * FollowRequests without action
   */
  export type FollowRequestsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowRequests
     */
    select?: FollowRequestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowRequests
     */
    omit?: FollowRequestsOmit<ExtArgs> | null;
  };

  /**
   * Model Follows
   */

  export type AggregateFollows = {
    _count: FollowsCountAggregateOutputType | null;
    _avg: FollowsAvgAggregateOutputType | null;
    _sum: FollowsSumAggregateOutputType | null;
    _min: FollowsMinAggregateOutputType | null;
    _max: FollowsMaxAggregateOutputType | null;
  };

  export type FollowsAvgAggregateOutputType = {
    follower_id: number | null;
    following_id: number | null;
  };

  export type FollowsSumAggregateOutputType = {
    follower_id: number | null;
    following_id: number | null;
  };

  export type FollowsMinAggregateOutputType = {
    id: string | null;
    follower_id: number | null;
    following_id: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type FollowsMaxAggregateOutputType = {
    id: string | null;
    follower_id: number | null;
    following_id: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type FollowsCountAggregateOutputType = {
    id: number;
    follower_id: number;
    following_id: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type FollowsAvgAggregateInputType = {
    follower_id?: true;
    following_id?: true;
  };

  export type FollowsSumAggregateInputType = {
    follower_id?: true;
    following_id?: true;
  };

  export type FollowsMinAggregateInputType = {
    id?: true;
    follower_id?: true;
    following_id?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type FollowsMaxAggregateInputType = {
    id?: true;
    follower_id?: true;
    following_id?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type FollowsCountAggregateInputType = {
    id?: true;
    follower_id?: true;
    following_id?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type FollowsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Follows to aggregate.
     */
    where?: FollowsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Follows to fetch.
     */
    orderBy?:
      | FollowsOrderByWithRelationInput
      | FollowsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FollowsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Follows.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Follows
     **/
    _count?: true | FollowsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FollowsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FollowsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FollowsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FollowsMaxAggregateInputType;
  };

  export type GetFollowsAggregateType<T extends FollowsAggregateArgs> = {
    [P in keyof T & keyof AggregateFollows]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollows[P]>
      : GetScalarType<T[P], AggregateFollows[P]>;
  };

  export type FollowsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: FollowsWhereInput;
    orderBy?:
      | FollowsOrderByWithAggregationInput
      | FollowsOrderByWithAggregationInput[];
    by: FollowsScalarFieldEnum[] | FollowsScalarFieldEnum;
    having?: FollowsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FollowsCountAggregateInputType | true;
    _avg?: FollowsAvgAggregateInputType;
    _sum?: FollowsSumAggregateInputType;
    _min?: FollowsMinAggregateInputType;
    _max?: FollowsMaxAggregateInputType;
  };

  export type FollowsGroupByOutputType = {
    id: string;
    follower_id: number;
    following_id: number;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: FollowsCountAggregateOutputType | null;
    _avg: FollowsAvgAggregateOutputType | null;
    _sum: FollowsSumAggregateOutputType | null;
    _min: FollowsMinAggregateOutputType | null;
    _max: FollowsMaxAggregateOutputType | null;
  };

  type GetFollowsGroupByPayload<T extends FollowsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FollowsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof FollowsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowsGroupByOutputType[P]>
            : GetScalarType<T[P], FollowsGroupByOutputType[P]>;
        }
      >
    >;

  export type FollowsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      follower_id?: boolean;
      following_id?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['follows']
  >;

  export type FollowsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      follower_id?: boolean;
      following_id?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['follows']
  >;

  export type FollowsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      follower_id?: boolean;
      following_id?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['follows']
  >;

  export type FollowsSelectScalar = {
    id?: boolean;
    follower_id?: boolean;
    following_id?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type FollowsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'follower_id'
    | 'following_id'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['follows']
  >;

  export type $FollowsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Follows';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        follower_id: number;
        following_id: number;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['follows']
    >;
    composites: {};
  };

  type FollowsGetPayload<
    S extends boolean | null | undefined | FollowsDefaultArgs
  > = $Result.GetResult<Prisma.$FollowsPayload, S>;

  type FollowsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<FollowsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: FollowsCountAggregateInputType | true;
  };

  export interface FollowsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Follows'];
      meta: { name: 'Follows' };
    };
    /**
     * Find zero or one Follows that matches the filter.
     * @param {FollowsFindUniqueArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowsFindUniqueArgs>(
      args: SelectSubset<T, FollowsFindUniqueArgs<ExtArgs>>
    ): Prisma__FollowsClient<
      $Result.GetResult<
        Prisma.$FollowsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Follows that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowsFindUniqueOrThrowArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FollowsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FollowsClient<
      $Result.GetResult<
        Prisma.$FollowsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsFindFirstArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowsFindFirstArgs>(
      args?: SelectSubset<T, FollowsFindFirstArgs<ExtArgs>>
    ): Prisma__FollowsClient<
      $Result.GetResult<
        Prisma.$FollowsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Follows that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsFindFirstOrThrowArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FollowsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FollowsClient<
      $Result.GetResult<
        Prisma.$FollowsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follows.findMany()
     *
     * // Get first 10 Follows
     * const follows = await prisma.follows.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const followsWithIdOnly = await prisma.follows.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FollowsFindManyArgs>(
      args?: SelectSubset<T, FollowsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FollowsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Follows.
     * @param {FollowsCreateArgs} args - Arguments to create a Follows.
     * @example
     * // Create one Follows
     * const Follows = await prisma.follows.create({
     *   data: {
     *     // ... data to create a Follows
     *   }
     * })
     *
     */
    create<T extends FollowsCreateArgs>(
      args: SelectSubset<T, FollowsCreateArgs<ExtArgs>>
    ): Prisma__FollowsClient<
      $Result.GetResult<
        Prisma.$FollowsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Follows.
     * @param {FollowsCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follows = await prisma.follows.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FollowsCreateManyArgs>(
      args?: SelectSubset<T, FollowsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Follows and returns the data saved in the database.
     * @param {FollowsCreateManyAndReturnArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follows = await prisma.follows.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Follows and only return the `id`
     * const followsWithIdOnly = await prisma.follows.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FollowsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FollowsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FollowsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Follows.
     * @param {FollowsDeleteArgs} args - Arguments to delete one Follows.
     * @example
     * // Delete one Follows
     * const Follows = await prisma.follows.delete({
     *   where: {
     *     // ... filter to delete one Follows
     *   }
     * })
     *
     */
    delete<T extends FollowsDeleteArgs>(
      args: SelectSubset<T, FollowsDeleteArgs<ExtArgs>>
    ): Prisma__FollowsClient<
      $Result.GetResult<
        Prisma.$FollowsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Follows.
     * @param {FollowsUpdateArgs} args - Arguments to update one Follows.
     * @example
     * // Update one Follows
     * const follows = await prisma.follows.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FollowsUpdateArgs>(
      args: SelectSubset<T, FollowsUpdateArgs<ExtArgs>>
    ): Prisma__FollowsClient<
      $Result.GetResult<
        Prisma.$FollowsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Follows.
     * @param {FollowsDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follows.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FollowsDeleteManyArgs>(
      args?: SelectSubset<T, FollowsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follows = await prisma.follows.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FollowsUpdateManyArgs>(
      args: SelectSubset<T, FollowsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Follows and returns the data updated in the database.
     * @param {FollowsUpdateManyAndReturnArgs} args - Arguments to update many Follows.
     * @example
     * // Update many Follows
     * const follows = await prisma.follows.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Follows and only return the `id`
     * const followsWithIdOnly = await prisma.follows.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FollowsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FollowsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FollowsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Follows.
     * @param {FollowsUpsertArgs} args - Arguments to update or create a Follows.
     * @example
     * // Update or create a Follows
     * const follows = await prisma.follows.upsert({
     *   create: {
     *     // ... data to create a Follows
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follows we want to update
     *   }
     * })
     */
    upsert<T extends FollowsUpsertArgs>(
      args: SelectSubset<T, FollowsUpsertArgs<ExtArgs>>
    ): Prisma__FollowsClient<
      $Result.GetResult<
        Prisma.$FollowsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follows.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
     **/
    count<T extends FollowsCountArgs>(
      args?: Subset<T, FollowsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FollowsAggregateArgs>(
      args: Subset<T, FollowsAggregateArgs>
    ): Prisma.PrismaPromise<GetFollowsAggregateType<T>>;

    /**
     * Group by Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FollowsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowsGroupByArgs['orderBy'] }
        : { orderBy?: FollowsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, FollowsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetFollowsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Follows model
     */
    readonly fields: FollowsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follows.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Follows model
   */
  interface FollowsFieldRefs {
    readonly id: FieldRef<'Follows', 'String'>;
    readonly follower_id: FieldRef<'Follows', 'Int'>;
    readonly following_id: FieldRef<'Follows', 'Int'>;
    readonly created_at: FieldRef<'Follows', 'DateTime'>;
    readonly updated_at: FieldRef<'Follows', 'DateTime'>;
    readonly deleted_at: FieldRef<'Follows', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Follows findUnique
   */
  export type FollowsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follows
     */
    omit?: FollowsOmit<ExtArgs> | null;
    /**
     * Filter, which Follows to fetch.
     */
    where: FollowsWhereUniqueInput;
  };

  /**
   * Follows findUniqueOrThrow
   */
  export type FollowsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follows
     */
    omit?: FollowsOmit<ExtArgs> | null;
    /**
     * Filter, which Follows to fetch.
     */
    where: FollowsWhereUniqueInput;
  };

  /**
   * Follows findFirst
   */
  export type FollowsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follows
     */
    omit?: FollowsOmit<ExtArgs> | null;
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Follows to fetch.
     */
    orderBy?:
      | FollowsOrderByWithRelationInput
      | FollowsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Follows.
     */
    cursor?: FollowsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Follows.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowsScalarFieldEnum | FollowsScalarFieldEnum[];
  };

  /**
   * Follows findFirstOrThrow
   */
  export type FollowsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follows
     */
    omit?: FollowsOmit<ExtArgs> | null;
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Follows to fetch.
     */
    orderBy?:
      | FollowsOrderByWithRelationInput
      | FollowsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Follows.
     */
    cursor?: FollowsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Follows.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowsScalarFieldEnum | FollowsScalarFieldEnum[];
  };

  /**
   * Follows findMany
   */
  export type FollowsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follows
     */
    omit?: FollowsOmit<ExtArgs> | null;
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Follows to fetch.
     */
    orderBy?:
      | FollowsOrderByWithRelationInput
      | FollowsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Follows.
     */
    cursor?: FollowsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Follows.
     */
    skip?: number;
    distinct?: FollowsScalarFieldEnum | FollowsScalarFieldEnum[];
  };

  /**
   * Follows create
   */
  export type FollowsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follows
     */
    omit?: FollowsOmit<ExtArgs> | null;
    /**
     * The data needed to create a Follows.
     */
    data: XOR<FollowsCreateInput, FollowsUncheckedCreateInput>;
  };

  /**
   * Follows createMany
   */
  export type FollowsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Follows.
     */
    data: FollowsCreateManyInput | FollowsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Follows createManyAndReturn
   */
  export type FollowsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Follows
     */
    omit?: FollowsOmit<ExtArgs> | null;
    /**
     * The data used to create many Follows.
     */
    data: FollowsCreateManyInput | FollowsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Follows update
   */
  export type FollowsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follows
     */
    omit?: FollowsOmit<ExtArgs> | null;
    /**
     * The data needed to update a Follows.
     */
    data: XOR<FollowsUpdateInput, FollowsUncheckedUpdateInput>;
    /**
     * Choose, which Follows to update.
     */
    where: FollowsWhereUniqueInput;
  };

  /**
   * Follows updateMany
   */
  export type FollowsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowsUpdateManyMutationInput, FollowsUncheckedUpdateManyInput>;
    /**
     * Filter which Follows to update
     */
    where?: FollowsWhereInput;
    /**
     * Limit how many Follows to update.
     */
    limit?: number;
  };

  /**
   * Follows updateManyAndReturn
   */
  export type FollowsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Follows
     */
    omit?: FollowsOmit<ExtArgs> | null;
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowsUpdateManyMutationInput, FollowsUncheckedUpdateManyInput>;
    /**
     * Filter which Follows to update
     */
    where?: FollowsWhereInput;
    /**
     * Limit how many Follows to update.
     */
    limit?: number;
  };

  /**
   * Follows upsert
   */
  export type FollowsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follows
     */
    omit?: FollowsOmit<ExtArgs> | null;
    /**
     * The filter to search for the Follows to update in case it exists.
     */
    where: FollowsWhereUniqueInput;
    /**
     * In case the Follows found by the `where` argument doesn't exist, create a new Follows with this data.
     */
    create: XOR<FollowsCreateInput, FollowsUncheckedCreateInput>;
    /**
     * In case the Follows was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowsUpdateInput, FollowsUncheckedUpdateInput>;
  };

  /**
   * Follows delete
   */
  export type FollowsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follows
     */
    omit?: FollowsOmit<ExtArgs> | null;
    /**
     * Filter which Follows to delete.
     */
    where: FollowsWhereUniqueInput;
  };

  /**
   * Follows deleteMany
   */
  export type FollowsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowsWhereInput;
    /**
     * Limit how many Follows to delete.
     */
    limit?: number;
  };

  /**
   * Follows without action
   */
  export type FollowsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Follows
     */
    omit?: FollowsOmit<ExtArgs> | null;
  };

  /**
   * Model FollowsCount
   */

  export type AggregateFollowsCount = {
    _count: FollowsCountCountAggregateOutputType | null;
    _avg: FollowsCountAvgAggregateOutputType | null;
    _sum: FollowsCountSumAggregateOutputType | null;
    _min: FollowsCountMinAggregateOutputType | null;
    _max: FollowsCountMaxAggregateOutputType | null;
  };

  export type FollowsCountAvgAggregateOutputType = {
    user_id: number | null;
    followers_count: number | null;
    following_count: number | null;
  };

  export type FollowsCountSumAggregateOutputType = {
    user_id: number | null;
    followers_count: number | null;
    following_count: number | null;
  };

  export type FollowsCountMinAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    followers_count: number | null;
    following_count: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type FollowsCountMaxAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    followers_count: number | null;
    following_count: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type FollowsCountCountAggregateOutputType = {
    id: number;
    user_id: number;
    followers_count: number;
    following_count: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type FollowsCountAvgAggregateInputType = {
    user_id?: true;
    followers_count?: true;
    following_count?: true;
  };

  export type FollowsCountSumAggregateInputType = {
    user_id?: true;
    followers_count?: true;
    following_count?: true;
  };

  export type FollowsCountMinAggregateInputType = {
    id?: true;
    user_id?: true;
    followers_count?: true;
    following_count?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type FollowsCountMaxAggregateInputType = {
    id?: true;
    user_id?: true;
    followers_count?: true;
    following_count?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type FollowsCountCountAggregateInputType = {
    id?: true;
    user_id?: true;
    followers_count?: true;
    following_count?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type FollowsCountAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which FollowsCount to aggregate.
     */
    where?: FollowsCountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FollowsCounts to fetch.
     */
    orderBy?:
      | FollowsCountOrderByWithRelationInput
      | FollowsCountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FollowsCountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FollowsCounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FollowsCounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FollowsCounts
     **/
    _count?: true | FollowsCountCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FollowsCountAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FollowsCountSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FollowsCountMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FollowsCountMaxAggregateInputType;
  };

  export type GetFollowsCountAggregateType<
    T extends FollowsCountAggregateArgs
  > = {
    [P in keyof T & keyof AggregateFollowsCount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollowsCount[P]>
      : GetScalarType<T[P], AggregateFollowsCount[P]>;
  };

  export type FollowsCountGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: FollowsCountWhereInput;
    orderBy?:
      | FollowsCountOrderByWithAggregationInput
      | FollowsCountOrderByWithAggregationInput[];
    by: FollowsCountScalarFieldEnum[] | FollowsCountScalarFieldEnum;
    having?: FollowsCountScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FollowsCountCountAggregateInputType | true;
    _avg?: FollowsCountAvgAggregateInputType;
    _sum?: FollowsCountSumAggregateInputType;
    _min?: FollowsCountMinAggregateInputType;
    _max?: FollowsCountMaxAggregateInputType;
  };

  export type FollowsCountGroupByOutputType = {
    id: string;
    user_id: number;
    followers_count: number;
    following_count: number;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: FollowsCountCountAggregateOutputType | null;
    _avg: FollowsCountAvgAggregateOutputType | null;
    _sum: FollowsCountSumAggregateOutputType | null;
    _min: FollowsCountMinAggregateOutputType | null;
    _max: FollowsCountMaxAggregateOutputType | null;
  };

  type GetFollowsCountGroupByPayload<T extends FollowsCountGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FollowsCountGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof FollowsCountGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowsCountGroupByOutputType[P]>
            : GetScalarType<T[P], FollowsCountGroupByOutputType[P]>;
        }
      >
    >;

  export type FollowsCountSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      followers_count?: boolean;
      following_count?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['followsCount']
  >;

  export type FollowsCountSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      followers_count?: boolean;
      following_count?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['followsCount']
  >;

  export type FollowsCountSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      followers_count?: boolean;
      following_count?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['followsCount']
  >;

  export type FollowsCountSelectScalar = {
    id?: boolean;
    user_id?: boolean;
    followers_count?: boolean;
    following_count?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type FollowsCountOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'user_id'
    | 'followers_count'
    | 'following_count'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['followsCount']
  >;

  export type $FollowsCountPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'FollowsCount';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        user_id: number;
        followers_count: number;
        following_count: number;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['followsCount']
    >;
    composites: {};
  };

  type FollowsCountGetPayload<
    S extends boolean | null | undefined | FollowsCountDefaultArgs
  > = $Result.GetResult<Prisma.$FollowsCountPayload, S>;

  type FollowsCountCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    FollowsCountFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: FollowsCountCountAggregateInputType | true;
  };

  export interface FollowsCountDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FollowsCount'];
      meta: { name: 'FollowsCount' };
    };
    /**
     * Find zero or one FollowsCount that matches the filter.
     * @param {FollowsCountFindUniqueArgs} args - Arguments to find a FollowsCount
     * @example
     * // Get one FollowsCount
     * const followsCount = await prisma.followsCount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowsCountFindUniqueArgs>(
      args: SelectSubset<T, FollowsCountFindUniqueArgs<ExtArgs>>
    ): Prisma__FollowsCountClient<
      $Result.GetResult<
        Prisma.$FollowsCountPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one FollowsCount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowsCountFindUniqueOrThrowArgs} args - Arguments to find a FollowsCount
     * @example
     * // Get one FollowsCount
     * const followsCount = await prisma.followsCount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowsCountFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FollowsCountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FollowsCountClient<
      $Result.GetResult<
        Prisma.$FollowsCountPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FollowsCount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsCountFindFirstArgs} args - Arguments to find a FollowsCount
     * @example
     * // Get one FollowsCount
     * const followsCount = await prisma.followsCount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowsCountFindFirstArgs>(
      args?: SelectSubset<T, FollowsCountFindFirstArgs<ExtArgs>>
    ): Prisma__FollowsCountClient<
      $Result.GetResult<
        Prisma.$FollowsCountPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FollowsCount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsCountFindFirstOrThrowArgs} args - Arguments to find a FollowsCount
     * @example
     * // Get one FollowsCount
     * const followsCount = await prisma.followsCount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowsCountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FollowsCountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FollowsCountClient<
      $Result.GetResult<
        Prisma.$FollowsCountPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FollowsCounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsCountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FollowsCounts
     * const followsCounts = await prisma.followsCount.findMany()
     *
     * // Get first 10 FollowsCounts
     * const followsCounts = await prisma.followsCount.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const followsCountWithIdOnly = await prisma.followsCount.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FollowsCountFindManyArgs>(
      args?: SelectSubset<T, FollowsCountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FollowsCountPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a FollowsCount.
     * @param {FollowsCountCreateArgs} args - Arguments to create a FollowsCount.
     * @example
     * // Create one FollowsCount
     * const FollowsCount = await prisma.followsCount.create({
     *   data: {
     *     // ... data to create a FollowsCount
     *   }
     * })
     *
     */
    create<T extends FollowsCountCreateArgs>(
      args: SelectSubset<T, FollowsCountCreateArgs<ExtArgs>>
    ): Prisma__FollowsCountClient<
      $Result.GetResult<
        Prisma.$FollowsCountPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many FollowsCounts.
     * @param {FollowsCountCreateManyArgs} args - Arguments to create many FollowsCounts.
     * @example
     * // Create many FollowsCounts
     * const followsCount = await prisma.followsCount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FollowsCountCreateManyArgs>(
      args?: SelectSubset<T, FollowsCountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many FollowsCounts and returns the data saved in the database.
     * @param {FollowsCountCreateManyAndReturnArgs} args - Arguments to create many FollowsCounts.
     * @example
     * // Create many FollowsCounts
     * const followsCount = await prisma.followsCount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FollowsCounts and only return the `id`
     * const followsCountWithIdOnly = await prisma.followsCount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FollowsCountCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FollowsCountCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FollowsCountPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a FollowsCount.
     * @param {FollowsCountDeleteArgs} args - Arguments to delete one FollowsCount.
     * @example
     * // Delete one FollowsCount
     * const FollowsCount = await prisma.followsCount.delete({
     *   where: {
     *     // ... filter to delete one FollowsCount
     *   }
     * })
     *
     */
    delete<T extends FollowsCountDeleteArgs>(
      args: SelectSubset<T, FollowsCountDeleteArgs<ExtArgs>>
    ): Prisma__FollowsCountClient<
      $Result.GetResult<
        Prisma.$FollowsCountPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one FollowsCount.
     * @param {FollowsCountUpdateArgs} args - Arguments to update one FollowsCount.
     * @example
     * // Update one FollowsCount
     * const followsCount = await prisma.followsCount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FollowsCountUpdateArgs>(
      args: SelectSubset<T, FollowsCountUpdateArgs<ExtArgs>>
    ): Prisma__FollowsCountClient<
      $Result.GetResult<
        Prisma.$FollowsCountPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more FollowsCounts.
     * @param {FollowsCountDeleteManyArgs} args - Arguments to filter FollowsCounts to delete.
     * @example
     * // Delete a few FollowsCounts
     * const { count } = await prisma.followsCount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FollowsCountDeleteManyArgs>(
      args?: SelectSubset<T, FollowsCountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FollowsCounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsCountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FollowsCounts
     * const followsCount = await prisma.followsCount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FollowsCountUpdateManyArgs>(
      args: SelectSubset<T, FollowsCountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FollowsCounts and returns the data updated in the database.
     * @param {FollowsCountUpdateManyAndReturnArgs} args - Arguments to update many FollowsCounts.
     * @example
     * // Update many FollowsCounts
     * const followsCount = await prisma.followsCount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FollowsCounts and only return the `id`
     * const followsCountWithIdOnly = await prisma.followsCount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FollowsCountUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FollowsCountUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FollowsCountPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one FollowsCount.
     * @param {FollowsCountUpsertArgs} args - Arguments to update or create a FollowsCount.
     * @example
     * // Update or create a FollowsCount
     * const followsCount = await prisma.followsCount.upsert({
     *   create: {
     *     // ... data to create a FollowsCount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FollowsCount we want to update
     *   }
     * })
     */
    upsert<T extends FollowsCountUpsertArgs>(
      args: SelectSubset<T, FollowsCountUpsertArgs<ExtArgs>>
    ): Prisma__FollowsCountClient<
      $Result.GetResult<
        Prisma.$FollowsCountPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of FollowsCounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsCountCountArgs} args - Arguments to filter FollowsCounts to count.
     * @example
     * // Count the number of FollowsCounts
     * const count = await prisma.followsCount.count({
     *   where: {
     *     // ... the filter for the FollowsCounts we want to count
     *   }
     * })
     **/
    count<T extends FollowsCountCountArgs>(
      args?: Subset<T, FollowsCountCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowsCountCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FollowsCount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsCountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FollowsCountAggregateArgs>(
      args: Subset<T, FollowsCountAggregateArgs>
    ): Prisma.PrismaPromise<GetFollowsCountAggregateType<T>>;

    /**
     * Group by FollowsCount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsCountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FollowsCountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowsCountGroupByArgs['orderBy'] }
        : { orderBy?: FollowsCountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, FollowsCountGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetFollowsCountGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FollowsCount model
     */
    readonly fields: FollowsCountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FollowsCount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowsCountClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FollowsCount model
   */
  interface FollowsCountFieldRefs {
    readonly id: FieldRef<'FollowsCount', 'String'>;
    readonly user_id: FieldRef<'FollowsCount', 'Int'>;
    readonly followers_count: FieldRef<'FollowsCount', 'Int'>;
    readonly following_count: FieldRef<'FollowsCount', 'Int'>;
    readonly created_at: FieldRef<'FollowsCount', 'DateTime'>;
    readonly updated_at: FieldRef<'FollowsCount', 'DateTime'>;
    readonly deleted_at: FieldRef<'FollowsCount', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * FollowsCount findUnique
   */
  export type FollowsCountFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowsCount
     */
    select?: FollowsCountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowsCount
     */
    omit?: FollowsCountOmit<ExtArgs> | null;
    /**
     * Filter, which FollowsCount to fetch.
     */
    where: FollowsCountWhereUniqueInput;
  };

  /**
   * FollowsCount findUniqueOrThrow
   */
  export type FollowsCountFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowsCount
     */
    select?: FollowsCountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowsCount
     */
    omit?: FollowsCountOmit<ExtArgs> | null;
    /**
     * Filter, which FollowsCount to fetch.
     */
    where: FollowsCountWhereUniqueInput;
  };

  /**
   * FollowsCount findFirst
   */
  export type FollowsCountFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowsCount
     */
    select?: FollowsCountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowsCount
     */
    omit?: FollowsCountOmit<ExtArgs> | null;
    /**
     * Filter, which FollowsCount to fetch.
     */
    where?: FollowsCountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FollowsCounts to fetch.
     */
    orderBy?:
      | FollowsCountOrderByWithRelationInput
      | FollowsCountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FollowsCounts.
     */
    cursor?: FollowsCountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FollowsCounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FollowsCounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FollowsCounts.
     */
    distinct?: FollowsCountScalarFieldEnum | FollowsCountScalarFieldEnum[];
  };

  /**
   * FollowsCount findFirstOrThrow
   */
  export type FollowsCountFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowsCount
     */
    select?: FollowsCountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowsCount
     */
    omit?: FollowsCountOmit<ExtArgs> | null;
    /**
     * Filter, which FollowsCount to fetch.
     */
    where?: FollowsCountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FollowsCounts to fetch.
     */
    orderBy?:
      | FollowsCountOrderByWithRelationInput
      | FollowsCountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FollowsCounts.
     */
    cursor?: FollowsCountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FollowsCounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FollowsCounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FollowsCounts.
     */
    distinct?: FollowsCountScalarFieldEnum | FollowsCountScalarFieldEnum[];
  };

  /**
   * FollowsCount findMany
   */
  export type FollowsCountFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowsCount
     */
    select?: FollowsCountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowsCount
     */
    omit?: FollowsCountOmit<ExtArgs> | null;
    /**
     * Filter, which FollowsCounts to fetch.
     */
    where?: FollowsCountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FollowsCounts to fetch.
     */
    orderBy?:
      | FollowsCountOrderByWithRelationInput
      | FollowsCountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FollowsCounts.
     */
    cursor?: FollowsCountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FollowsCounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FollowsCounts.
     */
    skip?: number;
    distinct?: FollowsCountScalarFieldEnum | FollowsCountScalarFieldEnum[];
  };

  /**
   * FollowsCount create
   */
  export type FollowsCountCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowsCount
     */
    select?: FollowsCountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowsCount
     */
    omit?: FollowsCountOmit<ExtArgs> | null;
    /**
     * The data needed to create a FollowsCount.
     */
    data: XOR<FollowsCountCreateInput, FollowsCountUncheckedCreateInput>;
  };

  /**
   * FollowsCount createMany
   */
  export type FollowsCountCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many FollowsCounts.
     */
    data: FollowsCountCreateManyInput | FollowsCountCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FollowsCount createManyAndReturn
   */
  export type FollowsCountCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowsCount
     */
    select?: FollowsCountSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowsCount
     */
    omit?: FollowsCountOmit<ExtArgs> | null;
    /**
     * The data used to create many FollowsCounts.
     */
    data: FollowsCountCreateManyInput | FollowsCountCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FollowsCount update
   */
  export type FollowsCountUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowsCount
     */
    select?: FollowsCountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowsCount
     */
    omit?: FollowsCountOmit<ExtArgs> | null;
    /**
     * The data needed to update a FollowsCount.
     */
    data: XOR<FollowsCountUpdateInput, FollowsCountUncheckedUpdateInput>;
    /**
     * Choose, which FollowsCount to update.
     */
    where: FollowsCountWhereUniqueInput;
  };

  /**
   * FollowsCount updateMany
   */
  export type FollowsCountUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update FollowsCounts.
     */
    data: XOR<
      FollowsCountUpdateManyMutationInput,
      FollowsCountUncheckedUpdateManyInput
    >;
    /**
     * Filter which FollowsCounts to update
     */
    where?: FollowsCountWhereInput;
    /**
     * Limit how many FollowsCounts to update.
     */
    limit?: number;
  };

  /**
   * FollowsCount updateManyAndReturn
   */
  export type FollowsCountUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowsCount
     */
    select?: FollowsCountSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowsCount
     */
    omit?: FollowsCountOmit<ExtArgs> | null;
    /**
     * The data used to update FollowsCounts.
     */
    data: XOR<
      FollowsCountUpdateManyMutationInput,
      FollowsCountUncheckedUpdateManyInput
    >;
    /**
     * Filter which FollowsCounts to update
     */
    where?: FollowsCountWhereInput;
    /**
     * Limit how many FollowsCounts to update.
     */
    limit?: number;
  };

  /**
   * FollowsCount upsert
   */
  export type FollowsCountUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowsCount
     */
    select?: FollowsCountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowsCount
     */
    omit?: FollowsCountOmit<ExtArgs> | null;
    /**
     * The filter to search for the FollowsCount to update in case it exists.
     */
    where: FollowsCountWhereUniqueInput;
    /**
     * In case the FollowsCount found by the `where` argument doesn't exist, create a new FollowsCount with this data.
     */
    create: XOR<FollowsCountCreateInput, FollowsCountUncheckedCreateInput>;
    /**
     * In case the FollowsCount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowsCountUpdateInput, FollowsCountUncheckedUpdateInput>;
  };

  /**
   * FollowsCount delete
   */
  export type FollowsCountDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowsCount
     */
    select?: FollowsCountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowsCount
     */
    omit?: FollowsCountOmit<ExtArgs> | null;
    /**
     * Filter which FollowsCount to delete.
     */
    where: FollowsCountWhereUniqueInput;
  };

  /**
   * FollowsCount deleteMany
   */
  export type FollowsCountDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which FollowsCounts to delete
     */
    where?: FollowsCountWhereInput;
    /**
     * Limit how many FollowsCounts to delete.
     */
    limit?: number;
  };

  /**
   * FollowsCount without action
   */
  export type FollowsCountDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the FollowsCount
     */
    select?: FollowsCountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FollowsCount
     */
    omit?: FollowsCountOmit<ExtArgs> | null;
  };

  /**
   * Model Notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null;
    _avg: NotificationsAvgAggregateOutputType | null;
    _sum: NotificationsSumAggregateOutputType | null;
    _min: NotificationsMinAggregateOutputType | null;
    _max: NotificationsMaxAggregateOutputType | null;
  };

  export type NotificationsAvgAggregateOutputType = {
    user_id: number | null;
    sender_id: number | null;
  };

  export type NotificationsSumAggregateOutputType = {
    user_id: number | null;
    sender_id: number | null;
  };

  export type NotificationsMinAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    sender_id: number | null;
    message_th: string | null;
    message_en: string | null;
    is_read: boolean | null;
    type: $Enums.notification_type_enum | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type NotificationsMaxAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    sender_id: number | null;
    message_th: string | null;
    message_en: string | null;
    is_read: boolean | null;
    type: $Enums.notification_type_enum | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type NotificationsCountAggregateOutputType = {
    id: number;
    user_id: number;
    sender_id: number;
    message_th: number;
    message_en: number;
    metadata: number;
    is_read: number;
    type: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type NotificationsAvgAggregateInputType = {
    user_id?: true;
    sender_id?: true;
  };

  export type NotificationsSumAggregateInputType = {
    user_id?: true;
    sender_id?: true;
  };

  export type NotificationsMinAggregateInputType = {
    id?: true;
    user_id?: true;
    sender_id?: true;
    message_th?: true;
    message_en?: true;
    is_read?: true;
    type?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type NotificationsMaxAggregateInputType = {
    id?: true;
    user_id?: true;
    sender_id?: true;
    message_th?: true;
    message_en?: true;
    is_read?: true;
    type?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type NotificationsCountAggregateInputType = {
    id?: true;
    user_id?: true;
    sender_id?: true;
    message_th?: true;
    message_en?: true;
    metadata?: true;
    is_read?: true;
    type?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type NotificationsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Notifications to aggregate.
     */
    where?: NotificationsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationsOrderByWithRelationInput
      | NotificationsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Notifications
     **/
    _count?: true | NotificationsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: NotificationsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: NotificationsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationsMaxAggregateInputType;
  };

  export type GetNotificationsAggregateType<
    T extends NotificationsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>;
  };

  export type NotificationsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: NotificationsWhereInput;
    orderBy?:
      | NotificationsOrderByWithAggregationInput
      | NotificationsOrderByWithAggregationInput[];
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum;
    having?: NotificationsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationsCountAggregateInputType | true;
    _avg?: NotificationsAvgAggregateInputType;
    _sum?: NotificationsSumAggregateInputType;
    _min?: NotificationsMinAggregateInputType;
    _max?: NotificationsMaxAggregateInputType;
  };

  export type NotificationsGroupByOutputType = {
    id: string;
    user_id: number | null;
    sender_id: number | null;
    message_th: string | null;
    message_en: string | null;
    metadata: JsonValue | null;
    is_read: boolean | null;
    type: $Enums.notification_type_enum | null;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: NotificationsCountAggregateOutputType | null;
    _avg: NotificationsAvgAggregateOutputType | null;
    _sum: NotificationsSumAggregateOutputType | null;
    _min: NotificationsMinAggregateOutputType | null;
    _max: NotificationsMaxAggregateOutputType | null;
  };

  type GetNotificationsGroupByPayload<T extends NotificationsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NotificationsGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof NotificationsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>;
        }
      >
    >;

  export type NotificationsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      sender_id?: boolean;
      message_th?: boolean;
      message_en?: boolean;
      metadata?: boolean;
      is_read?: boolean;
      type?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['notifications']
  >;

  export type NotificationsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      sender_id?: boolean;
      message_th?: boolean;
      message_en?: boolean;
      metadata?: boolean;
      is_read?: boolean;
      type?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['notifications']
  >;

  export type NotificationsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      sender_id?: boolean;
      message_th?: boolean;
      message_en?: boolean;
      metadata?: boolean;
      is_read?: boolean;
      type?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['notifications']
  >;

  export type NotificationsSelectScalar = {
    id?: boolean;
    user_id?: boolean;
    sender_id?: boolean;
    message_th?: boolean;
    message_en?: boolean;
    metadata?: boolean;
    is_read?: boolean;
    type?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type NotificationsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'user_id'
    | 'sender_id'
    | 'message_th'
    | 'message_en'
    | 'metadata'
    | 'is_read'
    | 'type'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['notifications']
  >;

  export type $NotificationsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Notifications';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        user_id: number | null;
        sender_id: number | null;
        message_th: string | null;
        message_en: string | null;
        metadata: Prisma.JsonValue | null;
        is_read: boolean | null;
        type: $Enums.notification_type_enum | null;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['notifications']
    >;
    composites: {};
  };

  type NotificationsGetPayload<
    S extends boolean | null | undefined | NotificationsDefaultArgs
  > = $Result.GetResult<Prisma.$NotificationsPayload, S>;

  type NotificationsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    NotificationsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: NotificationsCountAggregateInputType | true;
  };

  export interface NotificationsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Notifications'];
      meta: { name: 'Notifications' };
    };
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {NotificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationsFindUniqueArgs>(
      args: SelectSubset<T, NotificationsFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationsClient<
      $Result.GetResult<
        Prisma.$NotificationsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationsClient<
      $Result.GetResult<
        Prisma.$NotificationsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationsFindFirstArgs>(
      args?: SelectSubset<T, NotificationsFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationsClient<
      $Result.GetResult<
        Prisma.$NotificationsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationsClient<
      $Result.GetResult<
        Prisma.$NotificationsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     *
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationsFindManyArgs>(
      args?: SelectSubset<T, NotificationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Notifications.
     * @param {NotificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     *
     */
    create<T extends NotificationsCreateArgs>(
      args: SelectSubset<T, NotificationsCreateArgs<ExtArgs>>
    ): Prisma__NotificationsClient<
      $Result.GetResult<
        Prisma.$NotificationsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Notifications.
     * @param {NotificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationsCreateManyArgs>(
      args?: SelectSubset<T, NotificationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Notifications.
     * @param {NotificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     *
     */
    delete<T extends NotificationsDeleteArgs>(
      args: SelectSubset<T, NotificationsDeleteArgs<ExtArgs>>
    ): Prisma__NotificationsClient<
      $Result.GetResult<
        Prisma.$NotificationsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Notifications.
     * @param {NotificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationsUpdateArgs>(
      args: SelectSubset<T, NotificationsUpdateArgs<ExtArgs>>
    ): Prisma__NotificationsClient<
      $Result.GetResult<
        Prisma.$NotificationsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Notifications.
     * @param {NotificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationsDeleteManyArgs>(
      args?: SelectSubset<T, NotificationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationsUpdateManyArgs>(
      args: SelectSubset<T, NotificationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationsUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Notifications.
     * @param {NotificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends NotificationsUpsertArgs>(
      args: SelectSubset<T, NotificationsUpsertArgs<ExtArgs>>
    ): Prisma__NotificationsClient<
      $Result.GetResult<
        Prisma.$NotificationsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
     **/
    count<T extends NotificationsCountArgs>(
      args?: Subset<T, NotificationsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationsAggregateArgs>(
      args: Subset<T, NotificationsAggregateArgs>
    ): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>;

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, NotificationsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetNotificationsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Notifications model
     */
    readonly fields: NotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Notifications model
   */
  interface NotificationsFieldRefs {
    readonly id: FieldRef<'Notifications', 'String'>;
    readonly user_id: FieldRef<'Notifications', 'Int'>;
    readonly sender_id: FieldRef<'Notifications', 'Int'>;
    readonly message_th: FieldRef<'Notifications', 'String'>;
    readonly message_en: FieldRef<'Notifications', 'String'>;
    readonly metadata: FieldRef<'Notifications', 'Json'>;
    readonly is_read: FieldRef<'Notifications', 'Boolean'>;
    readonly type: FieldRef<'Notifications', 'notification_type_enum'>;
    readonly created_at: FieldRef<'Notifications', 'DateTime'>;
    readonly updated_at: FieldRef<'Notifications', 'DateTime'>;
    readonly deleted_at: FieldRef<'Notifications', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Notifications findUnique
   */
  export type NotificationsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null;
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput;
  };

  /**
   * Notifications findUniqueOrThrow
   */
  export type NotificationsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null;
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput;
  };

  /**
   * Notifications findFirst
   */
  export type NotificationsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null;
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationsOrderByWithRelationInput
      | NotificationsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[];
  };

  /**
   * Notifications findFirstOrThrow
   */
  export type NotificationsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null;
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationsOrderByWithRelationInput
      | NotificationsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[];
  };

  /**
   * Notifications findMany
   */
  export type NotificationsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null;
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationsOrderByWithRelationInput
      | NotificationsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[];
  };

  /**
   * Notifications create
   */
  export type NotificationsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null;
    /**
     * The data needed to create a Notifications.
     */
    data?: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>;
  };

  /**
   * Notifications createMany
   */
  export type NotificationsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Notifications createManyAndReturn
   */
  export type NotificationsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null;
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Notifications update
   */
  export type NotificationsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null;
    /**
     * The data needed to update a Notifications.
     */
    data: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>;
    /**
     * Choose, which Notifications to update.
     */
    where: NotificationsWhereUniqueInput;
  };

  /**
   * Notifications updateMany
   */
  export type NotificationsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<
      NotificationsUpdateManyMutationInput,
      NotificationsUncheckedUpdateManyInput
    >;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationsWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
  };

  /**
   * Notifications updateManyAndReturn
   */
  export type NotificationsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null;
    /**
     * The data used to update Notifications.
     */
    data: XOR<
      NotificationsUpdateManyMutationInput,
      NotificationsUncheckedUpdateManyInput
    >;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationsWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
  };

  /**
   * Notifications upsert
   */
  export type NotificationsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null;
    /**
     * The filter to search for the Notifications to update in case it exists.
     */
    where: NotificationsWhereUniqueInput;
    /**
     * In case the Notifications found by the `where` argument doesn't exist, create a new Notifications with this data.
     */
    create: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>;
    /**
     * In case the Notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>;
  };

  /**
   * Notifications delete
   */
  export type NotificationsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null;
    /**
     * Filter which Notifications to delete.
     */
    where: NotificationsWhereUniqueInput;
  };

  /**
   * Notifications deleteMany
   */
  export type NotificationsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationsWhereInput;
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number;
  };

  /**
   * Notifications without action
   */
  export type NotificationsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null;
  };

  /**
   * Model Symbols
   */

  export type AggregateSymbols = {
    _count: SymbolsCountAggregateOutputType | null;
    _min: SymbolsMinAggregateOutputType | null;
    _max: SymbolsMaxAggregateOutputType | null;
  };

  export type SymbolsMinAggregateOutputType = {
    id: string | null;
    symbol_code: string | null;
    name: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type SymbolsMaxAggregateOutputType = {
    id: string | null;
    symbol_code: string | null;
    name: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type SymbolsCountAggregateOutputType = {
    id: number;
    symbol_code: number;
    name: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type SymbolsMinAggregateInputType = {
    id?: true;
    symbol_code?: true;
    name?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type SymbolsMaxAggregateInputType = {
    id?: true;
    symbol_code?: true;
    name?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type SymbolsCountAggregateInputType = {
    id?: true;
    symbol_code?: true;
    name?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type SymbolsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Symbols to aggregate.
     */
    where?: SymbolsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Symbols to fetch.
     */
    orderBy?:
      | SymbolsOrderByWithRelationInput
      | SymbolsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SymbolsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Symbols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Symbols.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Symbols
     **/
    _count?: true | SymbolsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SymbolsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SymbolsMaxAggregateInputType;
  };

  export type GetSymbolsAggregateType<T extends SymbolsAggregateArgs> = {
    [P in keyof T & keyof AggregateSymbols]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSymbols[P]>
      : GetScalarType<T[P], AggregateSymbols[P]>;
  };

  export type SymbolsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: SymbolsWhereInput;
    orderBy?:
      | SymbolsOrderByWithAggregationInput
      | SymbolsOrderByWithAggregationInput[];
    by: SymbolsScalarFieldEnum[] | SymbolsScalarFieldEnum;
    having?: SymbolsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SymbolsCountAggregateInputType | true;
    _min?: SymbolsMinAggregateInputType;
    _max?: SymbolsMaxAggregateInputType;
  };

  export type SymbolsGroupByOutputType = {
    id: string;
    symbol_code: string;
    name: string | null;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: SymbolsCountAggregateOutputType | null;
    _min: SymbolsMinAggregateOutputType | null;
    _max: SymbolsMaxAggregateOutputType | null;
  };

  type GetSymbolsGroupByPayload<T extends SymbolsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SymbolsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof SymbolsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SymbolsGroupByOutputType[P]>
            : GetScalarType<T[P], SymbolsGroupByOutputType[P]>;
        }
      >
    >;

  export type SymbolsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      symbol_code?: boolean;
      name?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['symbols']
  >;

  export type SymbolsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      symbol_code?: boolean;
      name?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['symbols']
  >;

  export type SymbolsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      symbol_code?: boolean;
      name?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['symbols']
  >;

  export type SymbolsSelectScalar = {
    id?: boolean;
    symbol_code?: boolean;
    name?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type SymbolsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id' | 'symbol_code' | 'name' | 'created_at' | 'updated_at' | 'deleted_at',
    ExtArgs['result']['symbols']
  >;

  export type $SymbolsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Symbols';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        symbol_code: string;
        name: string | null;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['symbols']
    >;
    composites: {};
  };

  type SymbolsGetPayload<
    S extends boolean | null | undefined | SymbolsDefaultArgs
  > = $Result.GetResult<Prisma.$SymbolsPayload, S>;

  type SymbolsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<SymbolsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: SymbolsCountAggregateInputType | true;
  };

  export interface SymbolsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Symbols'];
      meta: { name: 'Symbols' };
    };
    /**
     * Find zero or one Symbols that matches the filter.
     * @param {SymbolsFindUniqueArgs} args - Arguments to find a Symbols
     * @example
     * // Get one Symbols
     * const symbols = await prisma.symbols.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SymbolsFindUniqueArgs>(
      args: SelectSubset<T, SymbolsFindUniqueArgs<ExtArgs>>
    ): Prisma__SymbolsClient<
      $Result.GetResult<
        Prisma.$SymbolsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Symbols that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SymbolsFindUniqueOrThrowArgs} args - Arguments to find a Symbols
     * @example
     * // Get one Symbols
     * const symbols = await prisma.symbols.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SymbolsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SymbolsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SymbolsClient<
      $Result.GetResult<
        Prisma.$SymbolsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Symbols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolsFindFirstArgs} args - Arguments to find a Symbols
     * @example
     * // Get one Symbols
     * const symbols = await prisma.symbols.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SymbolsFindFirstArgs>(
      args?: SelectSubset<T, SymbolsFindFirstArgs<ExtArgs>>
    ): Prisma__SymbolsClient<
      $Result.GetResult<
        Prisma.$SymbolsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Symbols that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolsFindFirstOrThrowArgs} args - Arguments to find a Symbols
     * @example
     * // Get one Symbols
     * const symbols = await prisma.symbols.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SymbolsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SymbolsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SymbolsClient<
      $Result.GetResult<
        Prisma.$SymbolsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Symbols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Symbols
     * const symbols = await prisma.symbols.findMany()
     *
     * // Get first 10 Symbols
     * const symbols = await prisma.symbols.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const symbolsWithIdOnly = await prisma.symbols.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SymbolsFindManyArgs>(
      args?: SelectSubset<T, SymbolsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SymbolsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Symbols.
     * @param {SymbolsCreateArgs} args - Arguments to create a Symbols.
     * @example
     * // Create one Symbols
     * const Symbols = await prisma.symbols.create({
     *   data: {
     *     // ... data to create a Symbols
     *   }
     * })
     *
     */
    create<T extends SymbolsCreateArgs>(
      args: SelectSubset<T, SymbolsCreateArgs<ExtArgs>>
    ): Prisma__SymbolsClient<
      $Result.GetResult<
        Prisma.$SymbolsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Symbols.
     * @param {SymbolsCreateManyArgs} args - Arguments to create many Symbols.
     * @example
     * // Create many Symbols
     * const symbols = await prisma.symbols.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SymbolsCreateManyArgs>(
      args?: SelectSubset<T, SymbolsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Symbols and returns the data saved in the database.
     * @param {SymbolsCreateManyAndReturnArgs} args - Arguments to create many Symbols.
     * @example
     * // Create many Symbols
     * const symbols = await prisma.symbols.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Symbols and only return the `id`
     * const symbolsWithIdOnly = await prisma.symbols.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SymbolsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SymbolsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SymbolsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Symbols.
     * @param {SymbolsDeleteArgs} args - Arguments to delete one Symbols.
     * @example
     * // Delete one Symbols
     * const Symbols = await prisma.symbols.delete({
     *   where: {
     *     // ... filter to delete one Symbols
     *   }
     * })
     *
     */
    delete<T extends SymbolsDeleteArgs>(
      args: SelectSubset<T, SymbolsDeleteArgs<ExtArgs>>
    ): Prisma__SymbolsClient<
      $Result.GetResult<
        Prisma.$SymbolsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Symbols.
     * @param {SymbolsUpdateArgs} args - Arguments to update one Symbols.
     * @example
     * // Update one Symbols
     * const symbols = await prisma.symbols.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SymbolsUpdateArgs>(
      args: SelectSubset<T, SymbolsUpdateArgs<ExtArgs>>
    ): Prisma__SymbolsClient<
      $Result.GetResult<
        Prisma.$SymbolsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Symbols.
     * @param {SymbolsDeleteManyArgs} args - Arguments to filter Symbols to delete.
     * @example
     * // Delete a few Symbols
     * const { count } = await prisma.symbols.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SymbolsDeleteManyArgs>(
      args?: SelectSubset<T, SymbolsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Symbols
     * const symbols = await prisma.symbols.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SymbolsUpdateManyArgs>(
      args: SelectSubset<T, SymbolsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Symbols and returns the data updated in the database.
     * @param {SymbolsUpdateManyAndReturnArgs} args - Arguments to update many Symbols.
     * @example
     * // Update many Symbols
     * const symbols = await prisma.symbols.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Symbols and only return the `id`
     * const symbolsWithIdOnly = await prisma.symbols.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SymbolsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SymbolsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SymbolsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Symbols.
     * @param {SymbolsUpsertArgs} args - Arguments to update or create a Symbols.
     * @example
     * // Update or create a Symbols
     * const symbols = await prisma.symbols.upsert({
     *   create: {
     *     // ... data to create a Symbols
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Symbols we want to update
     *   }
     * })
     */
    upsert<T extends SymbolsUpsertArgs>(
      args: SelectSubset<T, SymbolsUpsertArgs<ExtArgs>>
    ): Prisma__SymbolsClient<
      $Result.GetResult<
        Prisma.$SymbolsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolsCountArgs} args - Arguments to filter Symbols to count.
     * @example
     * // Count the number of Symbols
     * const count = await prisma.symbols.count({
     *   where: {
     *     // ... the filter for the Symbols we want to count
     *   }
     * })
     **/
    count<T extends SymbolsCountArgs>(
      args?: Subset<T, SymbolsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SymbolsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SymbolsAggregateArgs>(
      args: Subset<T, SymbolsAggregateArgs>
    ): Prisma.PrismaPromise<GetSymbolsAggregateType<T>>;

    /**
     * Group by Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SymbolsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SymbolsGroupByArgs['orderBy'] }
        : { orderBy?: SymbolsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, SymbolsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetSymbolsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Symbols model
     */
    readonly fields: SymbolsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Symbols.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SymbolsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Symbols model
   */
  interface SymbolsFieldRefs {
    readonly id: FieldRef<'Symbols', 'String'>;
    readonly symbol_code: FieldRef<'Symbols', 'String'>;
    readonly name: FieldRef<'Symbols', 'String'>;
    readonly created_at: FieldRef<'Symbols', 'DateTime'>;
    readonly updated_at: FieldRef<'Symbols', 'DateTime'>;
    readonly deleted_at: FieldRef<'Symbols', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Symbols findUnique
   */
  export type SymbolsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Symbols
     */
    select?: SymbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Symbols
     */
    omit?: SymbolsOmit<ExtArgs> | null;
    /**
     * Filter, which Symbols to fetch.
     */
    where: SymbolsWhereUniqueInput;
  };

  /**
   * Symbols findUniqueOrThrow
   */
  export type SymbolsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Symbols
     */
    select?: SymbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Symbols
     */
    omit?: SymbolsOmit<ExtArgs> | null;
    /**
     * Filter, which Symbols to fetch.
     */
    where: SymbolsWhereUniqueInput;
  };

  /**
   * Symbols findFirst
   */
  export type SymbolsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Symbols
     */
    select?: SymbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Symbols
     */
    omit?: SymbolsOmit<ExtArgs> | null;
    /**
     * Filter, which Symbols to fetch.
     */
    where?: SymbolsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Symbols to fetch.
     */
    orderBy?:
      | SymbolsOrderByWithRelationInput
      | SymbolsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Symbols.
     */
    cursor?: SymbolsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Symbols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Symbols.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Symbols.
     */
    distinct?: SymbolsScalarFieldEnum | SymbolsScalarFieldEnum[];
  };

  /**
   * Symbols findFirstOrThrow
   */
  export type SymbolsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Symbols
     */
    select?: SymbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Symbols
     */
    omit?: SymbolsOmit<ExtArgs> | null;
    /**
     * Filter, which Symbols to fetch.
     */
    where?: SymbolsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Symbols to fetch.
     */
    orderBy?:
      | SymbolsOrderByWithRelationInput
      | SymbolsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Symbols.
     */
    cursor?: SymbolsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Symbols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Symbols.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Symbols.
     */
    distinct?: SymbolsScalarFieldEnum | SymbolsScalarFieldEnum[];
  };

  /**
   * Symbols findMany
   */
  export type SymbolsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Symbols
     */
    select?: SymbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Symbols
     */
    omit?: SymbolsOmit<ExtArgs> | null;
    /**
     * Filter, which Symbols to fetch.
     */
    where?: SymbolsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Symbols to fetch.
     */
    orderBy?:
      | SymbolsOrderByWithRelationInput
      | SymbolsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Symbols.
     */
    cursor?: SymbolsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Symbols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Symbols.
     */
    skip?: number;
    distinct?: SymbolsScalarFieldEnum | SymbolsScalarFieldEnum[];
  };

  /**
   * Symbols create
   */
  export type SymbolsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Symbols
     */
    select?: SymbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Symbols
     */
    omit?: SymbolsOmit<ExtArgs> | null;
    /**
     * The data needed to create a Symbols.
     */
    data: XOR<SymbolsCreateInput, SymbolsUncheckedCreateInput>;
  };

  /**
   * Symbols createMany
   */
  export type SymbolsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Symbols.
     */
    data: SymbolsCreateManyInput | SymbolsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Symbols createManyAndReturn
   */
  export type SymbolsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Symbols
     */
    select?: SymbolsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Symbols
     */
    omit?: SymbolsOmit<ExtArgs> | null;
    /**
     * The data used to create many Symbols.
     */
    data: SymbolsCreateManyInput | SymbolsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Symbols update
   */
  export type SymbolsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Symbols
     */
    select?: SymbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Symbols
     */
    omit?: SymbolsOmit<ExtArgs> | null;
    /**
     * The data needed to update a Symbols.
     */
    data: XOR<SymbolsUpdateInput, SymbolsUncheckedUpdateInput>;
    /**
     * Choose, which Symbols to update.
     */
    where: SymbolsWhereUniqueInput;
  };

  /**
   * Symbols updateMany
   */
  export type SymbolsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Symbols.
     */
    data: XOR<SymbolsUpdateManyMutationInput, SymbolsUncheckedUpdateManyInput>;
    /**
     * Filter which Symbols to update
     */
    where?: SymbolsWhereInput;
    /**
     * Limit how many Symbols to update.
     */
    limit?: number;
  };

  /**
   * Symbols updateManyAndReturn
   */
  export type SymbolsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Symbols
     */
    select?: SymbolsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Symbols
     */
    omit?: SymbolsOmit<ExtArgs> | null;
    /**
     * The data used to update Symbols.
     */
    data: XOR<SymbolsUpdateManyMutationInput, SymbolsUncheckedUpdateManyInput>;
    /**
     * Filter which Symbols to update
     */
    where?: SymbolsWhereInput;
    /**
     * Limit how many Symbols to update.
     */
    limit?: number;
  };

  /**
   * Symbols upsert
   */
  export type SymbolsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Symbols
     */
    select?: SymbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Symbols
     */
    omit?: SymbolsOmit<ExtArgs> | null;
    /**
     * The filter to search for the Symbols to update in case it exists.
     */
    where: SymbolsWhereUniqueInput;
    /**
     * In case the Symbols found by the `where` argument doesn't exist, create a new Symbols with this data.
     */
    create: XOR<SymbolsCreateInput, SymbolsUncheckedCreateInput>;
    /**
     * In case the Symbols was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SymbolsUpdateInput, SymbolsUncheckedUpdateInput>;
  };

  /**
   * Symbols delete
   */
  export type SymbolsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Symbols
     */
    select?: SymbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Symbols
     */
    omit?: SymbolsOmit<ExtArgs> | null;
    /**
     * Filter which Symbols to delete.
     */
    where: SymbolsWhereUniqueInput;
  };

  /**
   * Symbols deleteMany
   */
  export type SymbolsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Symbols to delete
     */
    where?: SymbolsWhereInput;
    /**
     * Limit how many Symbols to delete.
     */
    limit?: number;
  };

  /**
   * Symbols without action
   */
  export type SymbolsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Symbols
     */
    select?: SymbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Symbols
     */
    omit?: SymbolsOmit<ExtArgs> | null;
  };

  /**
   * Model ThreadEngagementMetrics
   */

  export type AggregateThreadEngagementMetrics = {
    _count: ThreadEngagementMetricsCountAggregateOutputType | null;
    _avg: ThreadEngagementMetricsAvgAggregateOutputType | null;
    _sum: ThreadEngagementMetricsSumAggregateOutputType | null;
    _min: ThreadEngagementMetricsMinAggregateOutputType | null;
    _max: ThreadEngagementMetricsMaxAggregateOutputType | null;
  };

  export type ThreadEngagementMetricsAvgAggregateOutputType = {
    viewed_count: Decimal | null;
    replied_count: number | null;
    reposted_count: number | null;
    quoted_count: number | null;
    liked_count: number | null;
    reported_count: number | null;
  };

  export type ThreadEngagementMetricsSumAggregateOutputType = {
    viewed_count: Decimal | null;
    replied_count: number | null;
    reposted_count: number | null;
    quoted_count: number | null;
    liked_count: number | null;
    reported_count: number | null;
  };

  export type ThreadEngagementMetricsMinAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    viewed_count: Decimal | null;
    replied_count: number | null;
    reposted_count: number | null;
    quoted_count: number | null;
    liked_count: number | null;
    reported_count: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadEngagementMetricsMaxAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    viewed_count: Decimal | null;
    replied_count: number | null;
    reposted_count: number | null;
    quoted_count: number | null;
    liked_count: number | null;
    reported_count: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadEngagementMetricsCountAggregateOutputType = {
    id: number;
    threads_id: number;
    viewed_count: number;
    replied_count: number;
    reposted_count: number;
    quoted_count: number;
    liked_count: number;
    reported_count: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type ThreadEngagementMetricsAvgAggregateInputType = {
    viewed_count?: true;
    replied_count?: true;
    reposted_count?: true;
    quoted_count?: true;
    liked_count?: true;
    reported_count?: true;
  };

  export type ThreadEngagementMetricsSumAggregateInputType = {
    viewed_count?: true;
    replied_count?: true;
    reposted_count?: true;
    quoted_count?: true;
    liked_count?: true;
    reported_count?: true;
  };

  export type ThreadEngagementMetricsMinAggregateInputType = {
    id?: true;
    threads_id?: true;
    viewed_count?: true;
    replied_count?: true;
    reposted_count?: true;
    quoted_count?: true;
    liked_count?: true;
    reported_count?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadEngagementMetricsMaxAggregateInputType = {
    id?: true;
    threads_id?: true;
    viewed_count?: true;
    replied_count?: true;
    reposted_count?: true;
    quoted_count?: true;
    liked_count?: true;
    reported_count?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadEngagementMetricsCountAggregateInputType = {
    id?: true;
    threads_id?: true;
    viewed_count?: true;
    replied_count?: true;
    reposted_count?: true;
    quoted_count?: true;
    liked_count?: true;
    reported_count?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type ThreadEngagementMetricsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadEngagementMetrics to aggregate.
     */
    where?: ThreadEngagementMetricsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadEngagementMetrics to fetch.
     */
    orderBy?:
      | ThreadEngagementMetricsOrderByWithRelationInput
      | ThreadEngagementMetricsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ThreadEngagementMetricsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadEngagementMetrics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadEngagementMetrics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ThreadEngagementMetrics
     **/
    _count?: true | ThreadEngagementMetricsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ThreadEngagementMetricsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ThreadEngagementMetricsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ThreadEngagementMetricsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ThreadEngagementMetricsMaxAggregateInputType;
  };

  export type GetThreadEngagementMetricsAggregateType<
    T extends ThreadEngagementMetricsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateThreadEngagementMetrics]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreadEngagementMetrics[P]>
      : GetScalarType<T[P], AggregateThreadEngagementMetrics[P]>;
  };

  export type ThreadEngagementMetricsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ThreadEngagementMetricsWhereInput;
    orderBy?:
      | ThreadEngagementMetricsOrderByWithAggregationInput
      | ThreadEngagementMetricsOrderByWithAggregationInput[];
    by:
      | ThreadEngagementMetricsScalarFieldEnum[]
      | ThreadEngagementMetricsScalarFieldEnum;
    having?: ThreadEngagementMetricsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ThreadEngagementMetricsCountAggregateInputType | true;
    _avg?: ThreadEngagementMetricsAvgAggregateInputType;
    _sum?: ThreadEngagementMetricsSumAggregateInputType;
    _min?: ThreadEngagementMetricsMinAggregateInputType;
    _max?: ThreadEngagementMetricsMaxAggregateInputType;
  };

  export type ThreadEngagementMetricsGroupByOutputType = {
    id: string;
    threads_id: string;
    viewed_count: Decimal;
    replied_count: number;
    reposted_count: number;
    quoted_count: number;
    liked_count: number;
    reported_count: number;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: ThreadEngagementMetricsCountAggregateOutputType | null;
    _avg: ThreadEngagementMetricsAvgAggregateOutputType | null;
    _sum: ThreadEngagementMetricsSumAggregateOutputType | null;
    _min: ThreadEngagementMetricsMinAggregateOutputType | null;
    _max: ThreadEngagementMetricsMaxAggregateOutputType | null;
  };

  type GetThreadEngagementMetricsGroupByPayload<
    T extends ThreadEngagementMetricsGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThreadEngagementMetricsGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof ThreadEngagementMetricsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ThreadEngagementMetricsGroupByOutputType[P]>
          : GetScalarType<T[P], ThreadEngagementMetricsGroupByOutputType[P]>;
      }
    >
  >;

  export type ThreadEngagementMetricsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      viewed_count?: boolean;
      replied_count?: boolean;
      reposted_count?: boolean;
      quoted_count?: boolean;
      liked_count?: boolean;
      reported_count?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadEngagementMetrics']
  >;

  export type ThreadEngagementMetricsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      viewed_count?: boolean;
      replied_count?: boolean;
      reposted_count?: boolean;
      quoted_count?: boolean;
      liked_count?: boolean;
      reported_count?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadEngagementMetrics']
  >;

  export type ThreadEngagementMetricsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      viewed_count?: boolean;
      replied_count?: boolean;
      reposted_count?: boolean;
      quoted_count?: boolean;
      liked_count?: boolean;
      reported_count?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadEngagementMetrics']
  >;

  export type ThreadEngagementMetricsSelectScalar = {
    id?: boolean;
    threads_id?: boolean;
    viewed_count?: boolean;
    replied_count?: boolean;
    reposted_count?: boolean;
    quoted_count?: boolean;
    liked_count?: boolean;
    reported_count?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type ThreadEngagementMetricsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'threads_id'
    | 'viewed_count'
    | 'replied_count'
    | 'reposted_count'
    | 'quoted_count'
    | 'liked_count'
    | 'reported_count'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['threadEngagementMetrics']
  >;

  export type $ThreadEngagementMetricsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ThreadEngagementMetrics';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        threads_id: string;
        viewed_count: Prisma.Decimal;
        replied_count: number;
        reposted_count: number;
        quoted_count: number;
        liked_count: number;
        reported_count: number;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['threadEngagementMetrics']
    >;
    composites: {};
  };

  type ThreadEngagementMetricsGetPayload<
    S extends boolean | null | undefined | ThreadEngagementMetricsDefaultArgs
  > = $Result.GetResult<Prisma.$ThreadEngagementMetricsPayload, S>;

  type ThreadEngagementMetricsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    ThreadEngagementMetricsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ThreadEngagementMetricsCountAggregateInputType | true;
  };

  export interface ThreadEngagementMetricsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ThreadEngagementMetrics'];
      meta: { name: 'ThreadEngagementMetrics' };
    };
    /**
     * Find zero or one ThreadEngagementMetrics that matches the filter.
     * @param {ThreadEngagementMetricsFindUniqueArgs} args - Arguments to find a ThreadEngagementMetrics
     * @example
     * // Get one ThreadEngagementMetrics
     * const threadEngagementMetrics = await prisma.threadEngagementMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadEngagementMetricsFindUniqueArgs>(
      args: SelectSubset<T, ThreadEngagementMetricsFindUniqueArgs<ExtArgs>>
    ): Prisma__ThreadEngagementMetricsClient<
      $Result.GetResult<
        Prisma.$ThreadEngagementMetricsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ThreadEngagementMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadEngagementMetricsFindUniqueOrThrowArgs} args - Arguments to find a ThreadEngagementMetrics
     * @example
     * // Get one ThreadEngagementMetrics
     * const threadEngagementMetrics = await prisma.threadEngagementMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadEngagementMetricsFindUniqueOrThrowArgs>(
      args: SelectSubset<
        T,
        ThreadEngagementMetricsFindUniqueOrThrowArgs<ExtArgs>
      >
    ): Prisma__ThreadEngagementMetricsClient<
      $Result.GetResult<
        Prisma.$ThreadEngagementMetricsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadEngagementMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadEngagementMetricsFindFirstArgs} args - Arguments to find a ThreadEngagementMetrics
     * @example
     * // Get one ThreadEngagementMetrics
     * const threadEngagementMetrics = await prisma.threadEngagementMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadEngagementMetricsFindFirstArgs>(
      args?: SelectSubset<T, ThreadEngagementMetricsFindFirstArgs<ExtArgs>>
    ): Prisma__ThreadEngagementMetricsClient<
      $Result.GetResult<
        Prisma.$ThreadEngagementMetricsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadEngagementMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadEngagementMetricsFindFirstOrThrowArgs} args - Arguments to find a ThreadEngagementMetrics
     * @example
     * // Get one ThreadEngagementMetrics
     * const threadEngagementMetrics = await prisma.threadEngagementMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadEngagementMetricsFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        ThreadEngagementMetricsFindFirstOrThrowArgs<ExtArgs>
      >
    ): Prisma__ThreadEngagementMetricsClient<
      $Result.GetResult<
        Prisma.$ThreadEngagementMetricsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ThreadEngagementMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadEngagementMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadEngagementMetrics
     * const threadEngagementMetrics = await prisma.threadEngagementMetrics.findMany()
     *
     * // Get first 10 ThreadEngagementMetrics
     * const threadEngagementMetrics = await prisma.threadEngagementMetrics.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const threadEngagementMetricsWithIdOnly = await prisma.threadEngagementMetrics.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ThreadEngagementMetricsFindManyArgs>(
      args?: SelectSubset<T, ThreadEngagementMetricsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadEngagementMetricsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ThreadEngagementMetrics.
     * @param {ThreadEngagementMetricsCreateArgs} args - Arguments to create a ThreadEngagementMetrics.
     * @example
     * // Create one ThreadEngagementMetrics
     * const ThreadEngagementMetrics = await prisma.threadEngagementMetrics.create({
     *   data: {
     *     // ... data to create a ThreadEngagementMetrics
     *   }
     * })
     *
     */
    create<T extends ThreadEngagementMetricsCreateArgs>(
      args: SelectSubset<T, ThreadEngagementMetricsCreateArgs<ExtArgs>>
    ): Prisma__ThreadEngagementMetricsClient<
      $Result.GetResult<
        Prisma.$ThreadEngagementMetricsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ThreadEngagementMetrics.
     * @param {ThreadEngagementMetricsCreateManyArgs} args - Arguments to create many ThreadEngagementMetrics.
     * @example
     * // Create many ThreadEngagementMetrics
     * const threadEngagementMetrics = await prisma.threadEngagementMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ThreadEngagementMetricsCreateManyArgs>(
      args?: SelectSubset<T, ThreadEngagementMetricsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ThreadEngagementMetrics and returns the data saved in the database.
     * @param {ThreadEngagementMetricsCreateManyAndReturnArgs} args - Arguments to create many ThreadEngagementMetrics.
     * @example
     * // Create many ThreadEngagementMetrics
     * const threadEngagementMetrics = await prisma.threadEngagementMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ThreadEngagementMetrics and only return the `id`
     * const threadEngagementMetricsWithIdOnly = await prisma.threadEngagementMetrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends ThreadEngagementMetricsCreateManyAndReturnArgs
    >(
      args?: SelectSubset<
        T,
        ThreadEngagementMetricsCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadEngagementMetricsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ThreadEngagementMetrics.
     * @param {ThreadEngagementMetricsDeleteArgs} args - Arguments to delete one ThreadEngagementMetrics.
     * @example
     * // Delete one ThreadEngagementMetrics
     * const ThreadEngagementMetrics = await prisma.threadEngagementMetrics.delete({
     *   where: {
     *     // ... filter to delete one ThreadEngagementMetrics
     *   }
     * })
     *
     */
    delete<T extends ThreadEngagementMetricsDeleteArgs>(
      args: SelectSubset<T, ThreadEngagementMetricsDeleteArgs<ExtArgs>>
    ): Prisma__ThreadEngagementMetricsClient<
      $Result.GetResult<
        Prisma.$ThreadEngagementMetricsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ThreadEngagementMetrics.
     * @param {ThreadEngagementMetricsUpdateArgs} args - Arguments to update one ThreadEngagementMetrics.
     * @example
     * // Update one ThreadEngagementMetrics
     * const threadEngagementMetrics = await prisma.threadEngagementMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ThreadEngagementMetricsUpdateArgs>(
      args: SelectSubset<T, ThreadEngagementMetricsUpdateArgs<ExtArgs>>
    ): Prisma__ThreadEngagementMetricsClient<
      $Result.GetResult<
        Prisma.$ThreadEngagementMetricsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ThreadEngagementMetrics.
     * @param {ThreadEngagementMetricsDeleteManyArgs} args - Arguments to filter ThreadEngagementMetrics to delete.
     * @example
     * // Delete a few ThreadEngagementMetrics
     * const { count } = await prisma.threadEngagementMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ThreadEngagementMetricsDeleteManyArgs>(
      args?: SelectSubset<T, ThreadEngagementMetricsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadEngagementMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadEngagementMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadEngagementMetrics
     * const threadEngagementMetrics = await prisma.threadEngagementMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ThreadEngagementMetricsUpdateManyArgs>(
      args: SelectSubset<T, ThreadEngagementMetricsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadEngagementMetrics and returns the data updated in the database.
     * @param {ThreadEngagementMetricsUpdateManyAndReturnArgs} args - Arguments to update many ThreadEngagementMetrics.
     * @example
     * // Update many ThreadEngagementMetrics
     * const threadEngagementMetrics = await prisma.threadEngagementMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ThreadEngagementMetrics and only return the `id`
     * const threadEngagementMetricsWithIdOnly = await prisma.threadEngagementMetrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends ThreadEngagementMetricsUpdateManyAndReturnArgs
    >(
      args: SelectSubset<
        T,
        ThreadEngagementMetricsUpdateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadEngagementMetricsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ThreadEngagementMetrics.
     * @param {ThreadEngagementMetricsUpsertArgs} args - Arguments to update or create a ThreadEngagementMetrics.
     * @example
     * // Update or create a ThreadEngagementMetrics
     * const threadEngagementMetrics = await prisma.threadEngagementMetrics.upsert({
     *   create: {
     *     // ... data to create a ThreadEngagementMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadEngagementMetrics we want to update
     *   }
     * })
     */
    upsert<T extends ThreadEngagementMetricsUpsertArgs>(
      args: SelectSubset<T, ThreadEngagementMetricsUpsertArgs<ExtArgs>>
    ): Prisma__ThreadEngagementMetricsClient<
      $Result.GetResult<
        Prisma.$ThreadEngagementMetricsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ThreadEngagementMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadEngagementMetricsCountArgs} args - Arguments to filter ThreadEngagementMetrics to count.
     * @example
     * // Count the number of ThreadEngagementMetrics
     * const count = await prisma.threadEngagementMetrics.count({
     *   where: {
     *     // ... the filter for the ThreadEngagementMetrics we want to count
     *   }
     * })
     **/
    count<T extends ThreadEngagementMetricsCountArgs>(
      args?: Subset<T, ThreadEngagementMetricsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              ThreadEngagementMetricsCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ThreadEngagementMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadEngagementMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ThreadEngagementMetricsAggregateArgs>(
      args: Subset<T, ThreadEngagementMetricsAggregateArgs>
    ): Prisma.PrismaPromise<GetThreadEngagementMetricsAggregateType<T>>;

    /**
     * Group by ThreadEngagementMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadEngagementMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ThreadEngagementMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadEngagementMetricsGroupByArgs['orderBy'] }
        : { orderBy?: ThreadEngagementMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<
        T,
        ThreadEngagementMetricsGroupByArgs,
        OrderByArg
      > &
        InputErrors
    ): {} extends InputErrors
      ? GetThreadEngagementMetricsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ThreadEngagementMetrics model
     */
    readonly fields: ThreadEngagementMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadEngagementMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadEngagementMetricsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ThreadEngagementMetrics model
   */
  interface ThreadEngagementMetricsFieldRefs {
    readonly id: FieldRef<'ThreadEngagementMetrics', 'String'>;
    readonly threads_id: FieldRef<'ThreadEngagementMetrics', 'String'>;
    readonly viewed_count: FieldRef<'ThreadEngagementMetrics', 'Decimal'>;
    readonly replied_count: FieldRef<'ThreadEngagementMetrics', 'Int'>;
    readonly reposted_count: FieldRef<'ThreadEngagementMetrics', 'Int'>;
    readonly quoted_count: FieldRef<'ThreadEngagementMetrics', 'Int'>;
    readonly liked_count: FieldRef<'ThreadEngagementMetrics', 'Int'>;
    readonly reported_count: FieldRef<'ThreadEngagementMetrics', 'Int'>;
    readonly created_at: FieldRef<'ThreadEngagementMetrics', 'DateTime'>;
    readonly updated_at: FieldRef<'ThreadEngagementMetrics', 'DateTime'>;
    readonly deleted_at: FieldRef<'ThreadEngagementMetrics', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ThreadEngagementMetrics findUnique
   */
  export type ThreadEngagementMetricsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadEngagementMetrics
     */
    select?: ThreadEngagementMetricsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadEngagementMetrics
     */
    omit?: ThreadEngagementMetricsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadEngagementMetrics to fetch.
     */
    where: ThreadEngagementMetricsWhereUniqueInput;
  };

  /**
   * ThreadEngagementMetrics findUniqueOrThrow
   */
  export type ThreadEngagementMetricsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadEngagementMetrics
     */
    select?: ThreadEngagementMetricsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadEngagementMetrics
     */
    omit?: ThreadEngagementMetricsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadEngagementMetrics to fetch.
     */
    where: ThreadEngagementMetricsWhereUniqueInput;
  };

  /**
   * ThreadEngagementMetrics findFirst
   */
  export type ThreadEngagementMetricsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadEngagementMetrics
     */
    select?: ThreadEngagementMetricsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadEngagementMetrics
     */
    omit?: ThreadEngagementMetricsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadEngagementMetrics to fetch.
     */
    where?: ThreadEngagementMetricsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadEngagementMetrics to fetch.
     */
    orderBy?:
      | ThreadEngagementMetricsOrderByWithRelationInput
      | ThreadEngagementMetricsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadEngagementMetrics.
     */
    cursor?: ThreadEngagementMetricsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadEngagementMetrics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadEngagementMetrics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadEngagementMetrics.
     */
    distinct?:
      | ThreadEngagementMetricsScalarFieldEnum
      | ThreadEngagementMetricsScalarFieldEnum[];
  };

  /**
   * ThreadEngagementMetrics findFirstOrThrow
   */
  export type ThreadEngagementMetricsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadEngagementMetrics
     */
    select?: ThreadEngagementMetricsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadEngagementMetrics
     */
    omit?: ThreadEngagementMetricsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadEngagementMetrics to fetch.
     */
    where?: ThreadEngagementMetricsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadEngagementMetrics to fetch.
     */
    orderBy?:
      | ThreadEngagementMetricsOrderByWithRelationInput
      | ThreadEngagementMetricsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadEngagementMetrics.
     */
    cursor?: ThreadEngagementMetricsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadEngagementMetrics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadEngagementMetrics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadEngagementMetrics.
     */
    distinct?:
      | ThreadEngagementMetricsScalarFieldEnum
      | ThreadEngagementMetricsScalarFieldEnum[];
  };

  /**
   * ThreadEngagementMetrics findMany
   */
  export type ThreadEngagementMetricsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadEngagementMetrics
     */
    select?: ThreadEngagementMetricsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadEngagementMetrics
     */
    omit?: ThreadEngagementMetricsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadEngagementMetrics to fetch.
     */
    where?: ThreadEngagementMetricsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadEngagementMetrics to fetch.
     */
    orderBy?:
      | ThreadEngagementMetricsOrderByWithRelationInput
      | ThreadEngagementMetricsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ThreadEngagementMetrics.
     */
    cursor?: ThreadEngagementMetricsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadEngagementMetrics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadEngagementMetrics.
     */
    skip?: number;
    distinct?:
      | ThreadEngagementMetricsScalarFieldEnum
      | ThreadEngagementMetricsScalarFieldEnum[];
  };

  /**
   * ThreadEngagementMetrics create
   */
  export type ThreadEngagementMetricsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadEngagementMetrics
     */
    select?: ThreadEngagementMetricsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadEngagementMetrics
     */
    omit?: ThreadEngagementMetricsOmit<ExtArgs> | null;
    /**
     * The data needed to create a ThreadEngagementMetrics.
     */
    data: XOR<
      ThreadEngagementMetricsCreateInput,
      ThreadEngagementMetricsUncheckedCreateInput
    >;
  };

  /**
   * ThreadEngagementMetrics createMany
   */
  export type ThreadEngagementMetricsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ThreadEngagementMetrics.
     */
    data:
      | ThreadEngagementMetricsCreateManyInput
      | ThreadEngagementMetricsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadEngagementMetrics createManyAndReturn
   */
  export type ThreadEngagementMetricsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadEngagementMetrics
     */
    select?: ThreadEngagementMetricsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadEngagementMetrics
     */
    omit?: ThreadEngagementMetricsOmit<ExtArgs> | null;
    /**
     * The data used to create many ThreadEngagementMetrics.
     */
    data:
      | ThreadEngagementMetricsCreateManyInput
      | ThreadEngagementMetricsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadEngagementMetrics update
   */
  export type ThreadEngagementMetricsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadEngagementMetrics
     */
    select?: ThreadEngagementMetricsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadEngagementMetrics
     */
    omit?: ThreadEngagementMetricsOmit<ExtArgs> | null;
    /**
     * The data needed to update a ThreadEngagementMetrics.
     */
    data: XOR<
      ThreadEngagementMetricsUpdateInput,
      ThreadEngagementMetricsUncheckedUpdateInput
    >;
    /**
     * Choose, which ThreadEngagementMetrics to update.
     */
    where: ThreadEngagementMetricsWhereUniqueInput;
  };

  /**
   * ThreadEngagementMetrics updateMany
   */
  export type ThreadEngagementMetricsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ThreadEngagementMetrics.
     */
    data: XOR<
      ThreadEngagementMetricsUpdateManyMutationInput,
      ThreadEngagementMetricsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadEngagementMetrics to update
     */
    where?: ThreadEngagementMetricsWhereInput;
    /**
     * Limit how many ThreadEngagementMetrics to update.
     */
    limit?: number;
  };

  /**
   * ThreadEngagementMetrics updateManyAndReturn
   */
  export type ThreadEngagementMetricsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadEngagementMetrics
     */
    select?: ThreadEngagementMetricsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadEngagementMetrics
     */
    omit?: ThreadEngagementMetricsOmit<ExtArgs> | null;
    /**
     * The data used to update ThreadEngagementMetrics.
     */
    data: XOR<
      ThreadEngagementMetricsUpdateManyMutationInput,
      ThreadEngagementMetricsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadEngagementMetrics to update
     */
    where?: ThreadEngagementMetricsWhereInput;
    /**
     * Limit how many ThreadEngagementMetrics to update.
     */
    limit?: number;
  };

  /**
   * ThreadEngagementMetrics upsert
   */
  export type ThreadEngagementMetricsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadEngagementMetrics
     */
    select?: ThreadEngagementMetricsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadEngagementMetrics
     */
    omit?: ThreadEngagementMetricsOmit<ExtArgs> | null;
    /**
     * The filter to search for the ThreadEngagementMetrics to update in case it exists.
     */
    where: ThreadEngagementMetricsWhereUniqueInput;
    /**
     * In case the ThreadEngagementMetrics found by the `where` argument doesn't exist, create a new ThreadEngagementMetrics with this data.
     */
    create: XOR<
      ThreadEngagementMetricsCreateInput,
      ThreadEngagementMetricsUncheckedCreateInput
    >;
    /**
     * In case the ThreadEngagementMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      ThreadEngagementMetricsUpdateInput,
      ThreadEngagementMetricsUncheckedUpdateInput
    >;
  };

  /**
   * ThreadEngagementMetrics delete
   */
  export type ThreadEngagementMetricsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadEngagementMetrics
     */
    select?: ThreadEngagementMetricsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadEngagementMetrics
     */
    omit?: ThreadEngagementMetricsOmit<ExtArgs> | null;
    /**
     * Filter which ThreadEngagementMetrics to delete.
     */
    where: ThreadEngagementMetricsWhereUniqueInput;
  };

  /**
   * ThreadEngagementMetrics deleteMany
   */
  export type ThreadEngagementMetricsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadEngagementMetrics to delete
     */
    where?: ThreadEngagementMetricsWhereInput;
    /**
     * Limit how many ThreadEngagementMetrics to delete.
     */
    limit?: number;
  };

  /**
   * ThreadEngagementMetrics without action
   */
  export type ThreadEngagementMetricsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadEngagementMetrics
     */
    select?: ThreadEngagementMetricsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadEngagementMetrics
     */
    omit?: ThreadEngagementMetricsOmit<ExtArgs> | null;
  };

  /**
   * Model ThreadHashtags
   */

  export type AggregateThreadHashtags = {
    _count: ThreadHashtagsCountAggregateOutputType | null;
    _min: ThreadHashtagsMinAggregateOutputType | null;
    _max: ThreadHashtagsMaxAggregateOutputType | null;
  };

  export type ThreadHashtagsMinAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    tag: string | null;
    type: $Enums.tag_type_enum | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadHashtagsMaxAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    tag: string | null;
    type: $Enums.tag_type_enum | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadHashtagsCountAggregateOutputType = {
    id: number;
    threads_id: number;
    tag: number;
    type: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type ThreadHashtagsMinAggregateInputType = {
    id?: true;
    threads_id?: true;
    tag?: true;
    type?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadHashtagsMaxAggregateInputType = {
    id?: true;
    threads_id?: true;
    tag?: true;
    type?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadHashtagsCountAggregateInputType = {
    id?: true;
    threads_id?: true;
    tag?: true;
    type?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type ThreadHashtagsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadHashtags to aggregate.
     */
    where?: ThreadHashtagsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadHashtags to fetch.
     */
    orderBy?:
      | ThreadHashtagsOrderByWithRelationInput
      | ThreadHashtagsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ThreadHashtagsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadHashtags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadHashtags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ThreadHashtags
     **/
    _count?: true | ThreadHashtagsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ThreadHashtagsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ThreadHashtagsMaxAggregateInputType;
  };

  export type GetThreadHashtagsAggregateType<
    T extends ThreadHashtagsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateThreadHashtags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreadHashtags[P]>
      : GetScalarType<T[P], AggregateThreadHashtags[P]>;
  };

  export type ThreadHashtagsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ThreadHashtagsWhereInput;
    orderBy?:
      | ThreadHashtagsOrderByWithAggregationInput
      | ThreadHashtagsOrderByWithAggregationInput[];
    by: ThreadHashtagsScalarFieldEnum[] | ThreadHashtagsScalarFieldEnum;
    having?: ThreadHashtagsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ThreadHashtagsCountAggregateInputType | true;
    _min?: ThreadHashtagsMinAggregateInputType;
    _max?: ThreadHashtagsMaxAggregateInputType;
  };

  export type ThreadHashtagsGroupByOutputType = {
    id: string;
    threads_id: string;
    tag: string;
    type: $Enums.tag_type_enum;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: ThreadHashtagsCountAggregateOutputType | null;
    _min: ThreadHashtagsMinAggregateOutputType | null;
    _max: ThreadHashtagsMaxAggregateOutputType | null;
  };

  type GetThreadHashtagsGroupByPayload<T extends ThreadHashtagsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ThreadHashtagsGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof ThreadHashtagsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadHashtagsGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadHashtagsGroupByOutputType[P]>;
        }
      >
    >;

  export type ThreadHashtagsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      tag?: boolean;
      type?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadHashtags']
  >;

  export type ThreadHashtagsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      tag?: boolean;
      type?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadHashtags']
  >;

  export type ThreadHashtagsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      tag?: boolean;
      type?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadHashtags']
  >;

  export type ThreadHashtagsSelectScalar = {
    id?: boolean;
    threads_id?: boolean;
    tag?: boolean;
    type?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type ThreadHashtagsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'threads_id'
    | 'tag'
    | 'type'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['threadHashtags']
  >;

  export type $ThreadHashtagsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ThreadHashtags';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        threads_id: string;
        tag: string;
        type: $Enums.tag_type_enum;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['threadHashtags']
    >;
    composites: {};
  };

  type ThreadHashtagsGetPayload<
    S extends boolean | null | undefined | ThreadHashtagsDefaultArgs
  > = $Result.GetResult<Prisma.$ThreadHashtagsPayload, S>;

  type ThreadHashtagsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    ThreadHashtagsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ThreadHashtagsCountAggregateInputType | true;
  };

  export interface ThreadHashtagsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ThreadHashtags'];
      meta: { name: 'ThreadHashtags' };
    };
    /**
     * Find zero or one ThreadHashtags that matches the filter.
     * @param {ThreadHashtagsFindUniqueArgs} args - Arguments to find a ThreadHashtags
     * @example
     * // Get one ThreadHashtags
     * const threadHashtags = await prisma.threadHashtags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadHashtagsFindUniqueArgs>(
      args: SelectSubset<T, ThreadHashtagsFindUniqueArgs<ExtArgs>>
    ): Prisma__ThreadHashtagsClient<
      $Result.GetResult<
        Prisma.$ThreadHashtagsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ThreadHashtags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadHashtagsFindUniqueOrThrowArgs} args - Arguments to find a ThreadHashtags
     * @example
     * // Get one ThreadHashtags
     * const threadHashtags = await prisma.threadHashtags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadHashtagsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ThreadHashtagsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadHashtagsClient<
      $Result.GetResult<
        Prisma.$ThreadHashtagsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadHashtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadHashtagsFindFirstArgs} args - Arguments to find a ThreadHashtags
     * @example
     * // Get one ThreadHashtags
     * const threadHashtags = await prisma.threadHashtags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadHashtagsFindFirstArgs>(
      args?: SelectSubset<T, ThreadHashtagsFindFirstArgs<ExtArgs>>
    ): Prisma__ThreadHashtagsClient<
      $Result.GetResult<
        Prisma.$ThreadHashtagsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadHashtags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadHashtagsFindFirstOrThrowArgs} args - Arguments to find a ThreadHashtags
     * @example
     * // Get one ThreadHashtags
     * const threadHashtags = await prisma.threadHashtags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadHashtagsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadHashtagsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadHashtagsClient<
      $Result.GetResult<
        Prisma.$ThreadHashtagsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ThreadHashtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadHashtagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadHashtags
     * const threadHashtags = await prisma.threadHashtags.findMany()
     *
     * // Get first 10 ThreadHashtags
     * const threadHashtags = await prisma.threadHashtags.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const threadHashtagsWithIdOnly = await prisma.threadHashtags.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ThreadHashtagsFindManyArgs>(
      args?: SelectSubset<T, ThreadHashtagsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadHashtagsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ThreadHashtags.
     * @param {ThreadHashtagsCreateArgs} args - Arguments to create a ThreadHashtags.
     * @example
     * // Create one ThreadHashtags
     * const ThreadHashtags = await prisma.threadHashtags.create({
     *   data: {
     *     // ... data to create a ThreadHashtags
     *   }
     * })
     *
     */
    create<T extends ThreadHashtagsCreateArgs>(
      args: SelectSubset<T, ThreadHashtagsCreateArgs<ExtArgs>>
    ): Prisma__ThreadHashtagsClient<
      $Result.GetResult<
        Prisma.$ThreadHashtagsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ThreadHashtags.
     * @param {ThreadHashtagsCreateManyArgs} args - Arguments to create many ThreadHashtags.
     * @example
     * // Create many ThreadHashtags
     * const threadHashtags = await prisma.threadHashtags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ThreadHashtagsCreateManyArgs>(
      args?: SelectSubset<T, ThreadHashtagsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ThreadHashtags and returns the data saved in the database.
     * @param {ThreadHashtagsCreateManyAndReturnArgs} args - Arguments to create many ThreadHashtags.
     * @example
     * // Create many ThreadHashtags
     * const threadHashtags = await prisma.threadHashtags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ThreadHashtags and only return the `id`
     * const threadHashtagsWithIdOnly = await prisma.threadHashtags.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ThreadHashtagsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ThreadHashtagsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadHashtagsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ThreadHashtags.
     * @param {ThreadHashtagsDeleteArgs} args - Arguments to delete one ThreadHashtags.
     * @example
     * // Delete one ThreadHashtags
     * const ThreadHashtags = await prisma.threadHashtags.delete({
     *   where: {
     *     // ... filter to delete one ThreadHashtags
     *   }
     * })
     *
     */
    delete<T extends ThreadHashtagsDeleteArgs>(
      args: SelectSubset<T, ThreadHashtagsDeleteArgs<ExtArgs>>
    ): Prisma__ThreadHashtagsClient<
      $Result.GetResult<
        Prisma.$ThreadHashtagsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ThreadHashtags.
     * @param {ThreadHashtagsUpdateArgs} args - Arguments to update one ThreadHashtags.
     * @example
     * // Update one ThreadHashtags
     * const threadHashtags = await prisma.threadHashtags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ThreadHashtagsUpdateArgs>(
      args: SelectSubset<T, ThreadHashtagsUpdateArgs<ExtArgs>>
    ): Prisma__ThreadHashtagsClient<
      $Result.GetResult<
        Prisma.$ThreadHashtagsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ThreadHashtags.
     * @param {ThreadHashtagsDeleteManyArgs} args - Arguments to filter ThreadHashtags to delete.
     * @example
     * // Delete a few ThreadHashtags
     * const { count } = await prisma.threadHashtags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ThreadHashtagsDeleteManyArgs>(
      args?: SelectSubset<T, ThreadHashtagsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadHashtagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadHashtags
     * const threadHashtags = await prisma.threadHashtags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ThreadHashtagsUpdateManyArgs>(
      args: SelectSubset<T, ThreadHashtagsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadHashtags and returns the data updated in the database.
     * @param {ThreadHashtagsUpdateManyAndReturnArgs} args - Arguments to update many ThreadHashtags.
     * @example
     * // Update many ThreadHashtags
     * const threadHashtags = await prisma.threadHashtags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ThreadHashtags and only return the `id`
     * const threadHashtagsWithIdOnly = await prisma.threadHashtags.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ThreadHashtagsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ThreadHashtagsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadHashtagsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ThreadHashtags.
     * @param {ThreadHashtagsUpsertArgs} args - Arguments to update or create a ThreadHashtags.
     * @example
     * // Update or create a ThreadHashtags
     * const threadHashtags = await prisma.threadHashtags.upsert({
     *   create: {
     *     // ... data to create a ThreadHashtags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadHashtags we want to update
     *   }
     * })
     */
    upsert<T extends ThreadHashtagsUpsertArgs>(
      args: SelectSubset<T, ThreadHashtagsUpsertArgs<ExtArgs>>
    ): Prisma__ThreadHashtagsClient<
      $Result.GetResult<
        Prisma.$ThreadHashtagsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ThreadHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadHashtagsCountArgs} args - Arguments to filter ThreadHashtags to count.
     * @example
     * // Count the number of ThreadHashtags
     * const count = await prisma.threadHashtags.count({
     *   where: {
     *     // ... the filter for the ThreadHashtags we want to count
     *   }
     * })
     **/
    count<T extends ThreadHashtagsCountArgs>(
      args?: Subset<T, ThreadHashtagsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadHashtagsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ThreadHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadHashtagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ThreadHashtagsAggregateArgs>(
      args: Subset<T, ThreadHashtagsAggregateArgs>
    ): Prisma.PrismaPromise<GetThreadHashtagsAggregateType<T>>;

    /**
     * Group by ThreadHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadHashtagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ThreadHashtagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadHashtagsGroupByArgs['orderBy'] }
        : { orderBy?: ThreadHashtagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ThreadHashtagsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetThreadHashtagsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ThreadHashtags model
     */
    readonly fields: ThreadHashtagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadHashtags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadHashtagsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ThreadHashtags model
   */
  interface ThreadHashtagsFieldRefs {
    readonly id: FieldRef<'ThreadHashtags', 'String'>;
    readonly threads_id: FieldRef<'ThreadHashtags', 'String'>;
    readonly tag: FieldRef<'ThreadHashtags', 'String'>;
    readonly type: FieldRef<'ThreadHashtags', 'tag_type_enum'>;
    readonly created_at: FieldRef<'ThreadHashtags', 'DateTime'>;
    readonly updated_at: FieldRef<'ThreadHashtags', 'DateTime'>;
    readonly deleted_at: FieldRef<'ThreadHashtags', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ThreadHashtags findUnique
   */
  export type ThreadHashtagsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadHashtags
     */
    select?: ThreadHashtagsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadHashtags
     */
    omit?: ThreadHashtagsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadHashtags to fetch.
     */
    where: ThreadHashtagsWhereUniqueInput;
  };

  /**
   * ThreadHashtags findUniqueOrThrow
   */
  export type ThreadHashtagsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadHashtags
     */
    select?: ThreadHashtagsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadHashtags
     */
    omit?: ThreadHashtagsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadHashtags to fetch.
     */
    where: ThreadHashtagsWhereUniqueInput;
  };

  /**
   * ThreadHashtags findFirst
   */
  export type ThreadHashtagsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadHashtags
     */
    select?: ThreadHashtagsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadHashtags
     */
    omit?: ThreadHashtagsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadHashtags to fetch.
     */
    where?: ThreadHashtagsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadHashtags to fetch.
     */
    orderBy?:
      | ThreadHashtagsOrderByWithRelationInput
      | ThreadHashtagsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadHashtags.
     */
    cursor?: ThreadHashtagsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadHashtags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadHashtags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadHashtags.
     */
    distinct?: ThreadHashtagsScalarFieldEnum | ThreadHashtagsScalarFieldEnum[];
  };

  /**
   * ThreadHashtags findFirstOrThrow
   */
  export type ThreadHashtagsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadHashtags
     */
    select?: ThreadHashtagsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadHashtags
     */
    omit?: ThreadHashtagsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadHashtags to fetch.
     */
    where?: ThreadHashtagsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadHashtags to fetch.
     */
    orderBy?:
      | ThreadHashtagsOrderByWithRelationInput
      | ThreadHashtagsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadHashtags.
     */
    cursor?: ThreadHashtagsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadHashtags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadHashtags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadHashtags.
     */
    distinct?: ThreadHashtagsScalarFieldEnum | ThreadHashtagsScalarFieldEnum[];
  };

  /**
   * ThreadHashtags findMany
   */
  export type ThreadHashtagsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadHashtags
     */
    select?: ThreadHashtagsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadHashtags
     */
    omit?: ThreadHashtagsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadHashtags to fetch.
     */
    where?: ThreadHashtagsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadHashtags to fetch.
     */
    orderBy?:
      | ThreadHashtagsOrderByWithRelationInput
      | ThreadHashtagsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ThreadHashtags.
     */
    cursor?: ThreadHashtagsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadHashtags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadHashtags.
     */
    skip?: number;
    distinct?: ThreadHashtagsScalarFieldEnum | ThreadHashtagsScalarFieldEnum[];
  };

  /**
   * ThreadHashtags create
   */
  export type ThreadHashtagsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadHashtags
     */
    select?: ThreadHashtagsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadHashtags
     */
    omit?: ThreadHashtagsOmit<ExtArgs> | null;
    /**
     * The data needed to create a ThreadHashtags.
     */
    data: XOR<ThreadHashtagsCreateInput, ThreadHashtagsUncheckedCreateInput>;
  };

  /**
   * ThreadHashtags createMany
   */
  export type ThreadHashtagsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ThreadHashtags.
     */
    data: ThreadHashtagsCreateManyInput | ThreadHashtagsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadHashtags createManyAndReturn
   */
  export type ThreadHashtagsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadHashtags
     */
    select?: ThreadHashtagsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadHashtags
     */
    omit?: ThreadHashtagsOmit<ExtArgs> | null;
    /**
     * The data used to create many ThreadHashtags.
     */
    data: ThreadHashtagsCreateManyInput | ThreadHashtagsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadHashtags update
   */
  export type ThreadHashtagsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadHashtags
     */
    select?: ThreadHashtagsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadHashtags
     */
    omit?: ThreadHashtagsOmit<ExtArgs> | null;
    /**
     * The data needed to update a ThreadHashtags.
     */
    data: XOR<ThreadHashtagsUpdateInput, ThreadHashtagsUncheckedUpdateInput>;
    /**
     * Choose, which ThreadHashtags to update.
     */
    where: ThreadHashtagsWhereUniqueInput;
  };

  /**
   * ThreadHashtags updateMany
   */
  export type ThreadHashtagsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ThreadHashtags.
     */
    data: XOR<
      ThreadHashtagsUpdateManyMutationInput,
      ThreadHashtagsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadHashtags to update
     */
    where?: ThreadHashtagsWhereInput;
    /**
     * Limit how many ThreadHashtags to update.
     */
    limit?: number;
  };

  /**
   * ThreadHashtags updateManyAndReturn
   */
  export type ThreadHashtagsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadHashtags
     */
    select?: ThreadHashtagsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadHashtags
     */
    omit?: ThreadHashtagsOmit<ExtArgs> | null;
    /**
     * The data used to update ThreadHashtags.
     */
    data: XOR<
      ThreadHashtagsUpdateManyMutationInput,
      ThreadHashtagsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadHashtags to update
     */
    where?: ThreadHashtagsWhereInput;
    /**
     * Limit how many ThreadHashtags to update.
     */
    limit?: number;
  };

  /**
   * ThreadHashtags upsert
   */
  export type ThreadHashtagsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadHashtags
     */
    select?: ThreadHashtagsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadHashtags
     */
    omit?: ThreadHashtagsOmit<ExtArgs> | null;
    /**
     * The filter to search for the ThreadHashtags to update in case it exists.
     */
    where: ThreadHashtagsWhereUniqueInput;
    /**
     * In case the ThreadHashtags found by the `where` argument doesn't exist, create a new ThreadHashtags with this data.
     */
    create: XOR<ThreadHashtagsCreateInput, ThreadHashtagsUncheckedCreateInput>;
    /**
     * In case the ThreadHashtags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadHashtagsUpdateInput, ThreadHashtagsUncheckedUpdateInput>;
  };

  /**
   * ThreadHashtags delete
   */
  export type ThreadHashtagsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadHashtags
     */
    select?: ThreadHashtagsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadHashtags
     */
    omit?: ThreadHashtagsOmit<ExtArgs> | null;
    /**
     * Filter which ThreadHashtags to delete.
     */
    where: ThreadHashtagsWhereUniqueInput;
  };

  /**
   * ThreadHashtags deleteMany
   */
  export type ThreadHashtagsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadHashtags to delete
     */
    where?: ThreadHashtagsWhereInput;
    /**
     * Limit how many ThreadHashtags to delete.
     */
    limit?: number;
  };

  /**
   * ThreadHashtags without action
   */
  export type ThreadHashtagsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadHashtags
     */
    select?: ThreadHashtagsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadHashtags
     */
    omit?: ThreadHashtagsOmit<ExtArgs> | null;
  };

  /**
   * Model ThreadLikes
   */

  export type AggregateThreadLikes = {
    _count: ThreadLikesCountAggregateOutputType | null;
    _avg: ThreadLikesAvgAggregateOutputType | null;
    _sum: ThreadLikesSumAggregateOutputType | null;
    _min: ThreadLikesMinAggregateOutputType | null;
    _max: ThreadLikesMaxAggregateOutputType | null;
  };

  export type ThreadLikesAvgAggregateOutputType = {
    user_id: number | null;
  };

  export type ThreadLikesSumAggregateOutputType = {
    user_id: number | null;
  };

  export type ThreadLikesMinAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    user_id: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadLikesMaxAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    user_id: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadLikesCountAggregateOutputType = {
    id: number;
    threads_id: number;
    user_id: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type ThreadLikesAvgAggregateInputType = {
    user_id?: true;
  };

  export type ThreadLikesSumAggregateInputType = {
    user_id?: true;
  };

  export type ThreadLikesMinAggregateInputType = {
    id?: true;
    threads_id?: true;
    user_id?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadLikesMaxAggregateInputType = {
    id?: true;
    threads_id?: true;
    user_id?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadLikesCountAggregateInputType = {
    id?: true;
    threads_id?: true;
    user_id?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type ThreadLikesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadLikes to aggregate.
     */
    where?: ThreadLikesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadLikes to fetch.
     */
    orderBy?:
      | ThreadLikesOrderByWithRelationInput
      | ThreadLikesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ThreadLikesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadLikes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadLikes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ThreadLikes
     **/
    _count?: true | ThreadLikesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ThreadLikesAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ThreadLikesSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ThreadLikesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ThreadLikesMaxAggregateInputType;
  };

  export type GetThreadLikesAggregateType<T extends ThreadLikesAggregateArgs> =
    {
      [P in keyof T & keyof AggregateThreadLikes]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateThreadLikes[P]>
        : GetScalarType<T[P], AggregateThreadLikes[P]>;
    };

  export type ThreadLikesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ThreadLikesWhereInput;
    orderBy?:
      | ThreadLikesOrderByWithAggregationInput
      | ThreadLikesOrderByWithAggregationInput[];
    by: ThreadLikesScalarFieldEnum[] | ThreadLikesScalarFieldEnum;
    having?: ThreadLikesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ThreadLikesCountAggregateInputType | true;
    _avg?: ThreadLikesAvgAggregateInputType;
    _sum?: ThreadLikesSumAggregateInputType;
    _min?: ThreadLikesMinAggregateInputType;
    _max?: ThreadLikesMaxAggregateInputType;
  };

  export type ThreadLikesGroupByOutputType = {
    id: string;
    threads_id: string;
    user_id: number;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: ThreadLikesCountAggregateOutputType | null;
    _avg: ThreadLikesAvgAggregateOutputType | null;
    _sum: ThreadLikesSumAggregateOutputType | null;
    _min: ThreadLikesMinAggregateOutputType | null;
    _max: ThreadLikesMaxAggregateOutputType | null;
  };

  type GetThreadLikesGroupByPayload<T extends ThreadLikesGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ThreadLikesGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof ThreadLikesGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadLikesGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadLikesGroupByOutputType[P]>;
        }
      >
    >;

  export type ThreadLikesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      user_id?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadLikes']
  >;

  export type ThreadLikesSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      user_id?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadLikes']
  >;

  export type ThreadLikesSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      user_id?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadLikes']
  >;

  export type ThreadLikesSelectScalar = {
    id?: boolean;
    threads_id?: boolean;
    user_id?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type ThreadLikesOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'threads_id'
    | 'user_id'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['threadLikes']
  >;

  export type $ThreadLikesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ThreadLikes';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        threads_id: string;
        user_id: number;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['threadLikes']
    >;
    composites: {};
  };

  type ThreadLikesGetPayload<
    S extends boolean | null | undefined | ThreadLikesDefaultArgs
  > = $Result.GetResult<Prisma.$ThreadLikesPayload, S>;

  type ThreadLikesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    ThreadLikesFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ThreadLikesCountAggregateInputType | true;
  };

  export interface ThreadLikesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ThreadLikes'];
      meta: { name: 'ThreadLikes' };
    };
    /**
     * Find zero or one ThreadLikes that matches the filter.
     * @param {ThreadLikesFindUniqueArgs} args - Arguments to find a ThreadLikes
     * @example
     * // Get one ThreadLikes
     * const threadLikes = await prisma.threadLikes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadLikesFindUniqueArgs>(
      args: SelectSubset<T, ThreadLikesFindUniqueArgs<ExtArgs>>
    ): Prisma__ThreadLikesClient<
      $Result.GetResult<
        Prisma.$ThreadLikesPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ThreadLikes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadLikesFindUniqueOrThrowArgs} args - Arguments to find a ThreadLikes
     * @example
     * // Get one ThreadLikes
     * const threadLikes = await prisma.threadLikes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadLikesFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ThreadLikesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadLikesClient<
      $Result.GetResult<
        Prisma.$ThreadLikesPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadLikesFindFirstArgs} args - Arguments to find a ThreadLikes
     * @example
     * // Get one ThreadLikes
     * const threadLikes = await prisma.threadLikes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadLikesFindFirstArgs>(
      args?: SelectSubset<T, ThreadLikesFindFirstArgs<ExtArgs>>
    ): Prisma__ThreadLikesClient<
      $Result.GetResult<
        Prisma.$ThreadLikesPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadLikes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadLikesFindFirstOrThrowArgs} args - Arguments to find a ThreadLikes
     * @example
     * // Get one ThreadLikes
     * const threadLikes = await prisma.threadLikes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadLikesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadLikesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadLikesClient<
      $Result.GetResult<
        Prisma.$ThreadLikesPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ThreadLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadLikesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadLikes
     * const threadLikes = await prisma.threadLikes.findMany()
     *
     * // Get first 10 ThreadLikes
     * const threadLikes = await prisma.threadLikes.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const threadLikesWithIdOnly = await prisma.threadLikes.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ThreadLikesFindManyArgs>(
      args?: SelectSubset<T, ThreadLikesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadLikesPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ThreadLikes.
     * @param {ThreadLikesCreateArgs} args - Arguments to create a ThreadLikes.
     * @example
     * // Create one ThreadLikes
     * const ThreadLikes = await prisma.threadLikes.create({
     *   data: {
     *     // ... data to create a ThreadLikes
     *   }
     * })
     *
     */
    create<T extends ThreadLikesCreateArgs>(
      args: SelectSubset<T, ThreadLikesCreateArgs<ExtArgs>>
    ): Prisma__ThreadLikesClient<
      $Result.GetResult<
        Prisma.$ThreadLikesPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ThreadLikes.
     * @param {ThreadLikesCreateManyArgs} args - Arguments to create many ThreadLikes.
     * @example
     * // Create many ThreadLikes
     * const threadLikes = await prisma.threadLikes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ThreadLikesCreateManyArgs>(
      args?: SelectSubset<T, ThreadLikesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ThreadLikes and returns the data saved in the database.
     * @param {ThreadLikesCreateManyAndReturnArgs} args - Arguments to create many ThreadLikes.
     * @example
     * // Create many ThreadLikes
     * const threadLikes = await prisma.threadLikes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ThreadLikes and only return the `id`
     * const threadLikesWithIdOnly = await prisma.threadLikes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ThreadLikesCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ThreadLikesCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadLikesPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ThreadLikes.
     * @param {ThreadLikesDeleteArgs} args - Arguments to delete one ThreadLikes.
     * @example
     * // Delete one ThreadLikes
     * const ThreadLikes = await prisma.threadLikes.delete({
     *   where: {
     *     // ... filter to delete one ThreadLikes
     *   }
     * })
     *
     */
    delete<T extends ThreadLikesDeleteArgs>(
      args: SelectSubset<T, ThreadLikesDeleteArgs<ExtArgs>>
    ): Prisma__ThreadLikesClient<
      $Result.GetResult<
        Prisma.$ThreadLikesPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ThreadLikes.
     * @param {ThreadLikesUpdateArgs} args - Arguments to update one ThreadLikes.
     * @example
     * // Update one ThreadLikes
     * const threadLikes = await prisma.threadLikes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ThreadLikesUpdateArgs>(
      args: SelectSubset<T, ThreadLikesUpdateArgs<ExtArgs>>
    ): Prisma__ThreadLikesClient<
      $Result.GetResult<
        Prisma.$ThreadLikesPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ThreadLikes.
     * @param {ThreadLikesDeleteManyArgs} args - Arguments to filter ThreadLikes to delete.
     * @example
     * // Delete a few ThreadLikes
     * const { count } = await prisma.threadLikes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ThreadLikesDeleteManyArgs>(
      args?: SelectSubset<T, ThreadLikesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadLikesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadLikes
     * const threadLikes = await prisma.threadLikes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ThreadLikesUpdateManyArgs>(
      args: SelectSubset<T, ThreadLikesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadLikes and returns the data updated in the database.
     * @param {ThreadLikesUpdateManyAndReturnArgs} args - Arguments to update many ThreadLikes.
     * @example
     * // Update many ThreadLikes
     * const threadLikes = await prisma.threadLikes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ThreadLikes and only return the `id`
     * const threadLikesWithIdOnly = await prisma.threadLikes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ThreadLikesUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ThreadLikesUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadLikesPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ThreadLikes.
     * @param {ThreadLikesUpsertArgs} args - Arguments to update or create a ThreadLikes.
     * @example
     * // Update or create a ThreadLikes
     * const threadLikes = await prisma.threadLikes.upsert({
     *   create: {
     *     // ... data to create a ThreadLikes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadLikes we want to update
     *   }
     * })
     */
    upsert<T extends ThreadLikesUpsertArgs>(
      args: SelectSubset<T, ThreadLikesUpsertArgs<ExtArgs>>
    ): Prisma__ThreadLikesClient<
      $Result.GetResult<
        Prisma.$ThreadLikesPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ThreadLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadLikesCountArgs} args - Arguments to filter ThreadLikes to count.
     * @example
     * // Count the number of ThreadLikes
     * const count = await prisma.threadLikes.count({
     *   where: {
     *     // ... the filter for the ThreadLikes we want to count
     *   }
     * })
     **/
    count<T extends ThreadLikesCountArgs>(
      args?: Subset<T, ThreadLikesCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadLikesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ThreadLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadLikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ThreadLikesAggregateArgs>(
      args: Subset<T, ThreadLikesAggregateArgs>
    ): Prisma.PrismaPromise<GetThreadLikesAggregateType<T>>;

    /**
     * Group by ThreadLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadLikesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ThreadLikesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadLikesGroupByArgs['orderBy'] }
        : { orderBy?: ThreadLikesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ThreadLikesGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetThreadLikesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ThreadLikes model
     */
    readonly fields: ThreadLikesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadLikes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadLikesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ThreadLikes model
   */
  interface ThreadLikesFieldRefs {
    readonly id: FieldRef<'ThreadLikes', 'String'>;
    readonly threads_id: FieldRef<'ThreadLikes', 'String'>;
    readonly user_id: FieldRef<'ThreadLikes', 'Int'>;
    readonly created_at: FieldRef<'ThreadLikes', 'DateTime'>;
    readonly updated_at: FieldRef<'ThreadLikes', 'DateTime'>;
    readonly deleted_at: FieldRef<'ThreadLikes', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ThreadLikes findUnique
   */
  export type ThreadLikesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadLikes
     */
    select?: ThreadLikesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadLikes
     */
    omit?: ThreadLikesOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadLikes to fetch.
     */
    where: ThreadLikesWhereUniqueInput;
  };

  /**
   * ThreadLikes findUniqueOrThrow
   */
  export type ThreadLikesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadLikes
     */
    select?: ThreadLikesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadLikes
     */
    omit?: ThreadLikesOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadLikes to fetch.
     */
    where: ThreadLikesWhereUniqueInput;
  };

  /**
   * ThreadLikes findFirst
   */
  export type ThreadLikesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadLikes
     */
    select?: ThreadLikesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadLikes
     */
    omit?: ThreadLikesOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadLikes to fetch.
     */
    where?: ThreadLikesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadLikes to fetch.
     */
    orderBy?:
      | ThreadLikesOrderByWithRelationInput
      | ThreadLikesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadLikes.
     */
    cursor?: ThreadLikesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadLikes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadLikes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadLikes.
     */
    distinct?: ThreadLikesScalarFieldEnum | ThreadLikesScalarFieldEnum[];
  };

  /**
   * ThreadLikes findFirstOrThrow
   */
  export type ThreadLikesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadLikes
     */
    select?: ThreadLikesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadLikes
     */
    omit?: ThreadLikesOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadLikes to fetch.
     */
    where?: ThreadLikesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadLikes to fetch.
     */
    orderBy?:
      | ThreadLikesOrderByWithRelationInput
      | ThreadLikesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadLikes.
     */
    cursor?: ThreadLikesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadLikes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadLikes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadLikes.
     */
    distinct?: ThreadLikesScalarFieldEnum | ThreadLikesScalarFieldEnum[];
  };

  /**
   * ThreadLikes findMany
   */
  export type ThreadLikesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadLikes
     */
    select?: ThreadLikesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadLikes
     */
    omit?: ThreadLikesOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadLikes to fetch.
     */
    where?: ThreadLikesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadLikes to fetch.
     */
    orderBy?:
      | ThreadLikesOrderByWithRelationInput
      | ThreadLikesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ThreadLikes.
     */
    cursor?: ThreadLikesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadLikes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadLikes.
     */
    skip?: number;
    distinct?: ThreadLikesScalarFieldEnum | ThreadLikesScalarFieldEnum[];
  };

  /**
   * ThreadLikes create
   */
  export type ThreadLikesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadLikes
     */
    select?: ThreadLikesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadLikes
     */
    omit?: ThreadLikesOmit<ExtArgs> | null;
    /**
     * The data needed to create a ThreadLikes.
     */
    data: XOR<ThreadLikesCreateInput, ThreadLikesUncheckedCreateInput>;
  };

  /**
   * ThreadLikes createMany
   */
  export type ThreadLikesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ThreadLikes.
     */
    data: ThreadLikesCreateManyInput | ThreadLikesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadLikes createManyAndReturn
   */
  export type ThreadLikesCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadLikes
     */
    select?: ThreadLikesSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadLikes
     */
    omit?: ThreadLikesOmit<ExtArgs> | null;
    /**
     * The data used to create many ThreadLikes.
     */
    data: ThreadLikesCreateManyInput | ThreadLikesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadLikes update
   */
  export type ThreadLikesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadLikes
     */
    select?: ThreadLikesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadLikes
     */
    omit?: ThreadLikesOmit<ExtArgs> | null;
    /**
     * The data needed to update a ThreadLikes.
     */
    data: XOR<ThreadLikesUpdateInput, ThreadLikesUncheckedUpdateInput>;
    /**
     * Choose, which ThreadLikes to update.
     */
    where: ThreadLikesWhereUniqueInput;
  };

  /**
   * ThreadLikes updateMany
   */
  export type ThreadLikesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ThreadLikes.
     */
    data: XOR<
      ThreadLikesUpdateManyMutationInput,
      ThreadLikesUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadLikes to update
     */
    where?: ThreadLikesWhereInput;
    /**
     * Limit how many ThreadLikes to update.
     */
    limit?: number;
  };

  /**
   * ThreadLikes updateManyAndReturn
   */
  export type ThreadLikesUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadLikes
     */
    select?: ThreadLikesSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadLikes
     */
    omit?: ThreadLikesOmit<ExtArgs> | null;
    /**
     * The data used to update ThreadLikes.
     */
    data: XOR<
      ThreadLikesUpdateManyMutationInput,
      ThreadLikesUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadLikes to update
     */
    where?: ThreadLikesWhereInput;
    /**
     * Limit how many ThreadLikes to update.
     */
    limit?: number;
  };

  /**
   * ThreadLikes upsert
   */
  export type ThreadLikesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadLikes
     */
    select?: ThreadLikesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadLikes
     */
    omit?: ThreadLikesOmit<ExtArgs> | null;
    /**
     * The filter to search for the ThreadLikes to update in case it exists.
     */
    where: ThreadLikesWhereUniqueInput;
    /**
     * In case the ThreadLikes found by the `where` argument doesn't exist, create a new ThreadLikes with this data.
     */
    create: XOR<ThreadLikesCreateInput, ThreadLikesUncheckedCreateInput>;
    /**
     * In case the ThreadLikes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadLikesUpdateInput, ThreadLikesUncheckedUpdateInput>;
  };

  /**
   * ThreadLikes delete
   */
  export type ThreadLikesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadLikes
     */
    select?: ThreadLikesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadLikes
     */
    omit?: ThreadLikesOmit<ExtArgs> | null;
    /**
     * Filter which ThreadLikes to delete.
     */
    where: ThreadLikesWhereUniqueInput;
  };

  /**
   * ThreadLikes deleteMany
   */
  export type ThreadLikesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadLikes to delete
     */
    where?: ThreadLikesWhereInput;
    /**
     * Limit how many ThreadLikes to delete.
     */
    limit?: number;
  };

  /**
   * ThreadLikes without action
   */
  export type ThreadLikesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadLikes
     */
    select?: ThreadLikesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadLikes
     */
    omit?: ThreadLikesOmit<ExtArgs> | null;
  };

  /**
   * Model ThreadMedia
   */

  export type AggregateThreadMedia = {
    _count: ThreadMediaCountAggregateOutputType | null;
    _avg: ThreadMediaAvgAggregateOutputType | null;
    _sum: ThreadMediaSumAggregateOutputType | null;
    _min: ThreadMediaMinAggregateOutputType | null;
    _max: ThreadMediaMaxAggregateOutputType | null;
  };

  export type ThreadMediaAvgAggregateOutputType = {
    width: number | null;
    height: number | null;
    size: number | null;
    duration: number | null;
  };

  export type ThreadMediaSumAggregateOutputType = {
    width: number | null;
    height: number | null;
    size: number | null;
    duration: number | null;
  };

  export type ThreadMediaMinAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    media_type: $Enums.media_type_enum | null;
    media_url: string | null;
    thumbnail_url: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
    width: number | null;
    height: number | null;
    size: number | null;
    duration: number | null;
    object_key: string | null;
  };

  export type ThreadMediaMaxAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    media_type: $Enums.media_type_enum | null;
    media_url: string | null;
    thumbnail_url: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
    width: number | null;
    height: number | null;
    size: number | null;
    duration: number | null;
    object_key: string | null;
  };

  export type ThreadMediaCountAggregateOutputType = {
    id: number;
    threads_id: number;
    media_type: number;
    media_url: number;
    thumbnail_url: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    width: number;
    height: number;
    size: number;
    duration: number;
    object_key: number;
    _all: number;
  };

  export type ThreadMediaAvgAggregateInputType = {
    width?: true;
    height?: true;
    size?: true;
    duration?: true;
  };

  export type ThreadMediaSumAggregateInputType = {
    width?: true;
    height?: true;
    size?: true;
    duration?: true;
  };

  export type ThreadMediaMinAggregateInputType = {
    id?: true;
    threads_id?: true;
    media_type?: true;
    media_url?: true;
    thumbnail_url?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    width?: true;
    height?: true;
    size?: true;
    duration?: true;
    object_key?: true;
  };

  export type ThreadMediaMaxAggregateInputType = {
    id?: true;
    threads_id?: true;
    media_type?: true;
    media_url?: true;
    thumbnail_url?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    width?: true;
    height?: true;
    size?: true;
    duration?: true;
    object_key?: true;
  };

  export type ThreadMediaCountAggregateInputType = {
    id?: true;
    threads_id?: true;
    media_type?: true;
    media_url?: true;
    thumbnail_url?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    width?: true;
    height?: true;
    size?: true;
    duration?: true;
    object_key?: true;
    _all?: true;
  };

  export type ThreadMediaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadMedia to aggregate.
     */
    where?: ThreadMediaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadMedias to fetch.
     */
    orderBy?:
      | ThreadMediaOrderByWithRelationInput
      | ThreadMediaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ThreadMediaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadMedias from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadMedias.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ThreadMedias
     **/
    _count?: true | ThreadMediaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ThreadMediaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ThreadMediaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ThreadMediaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ThreadMediaMaxAggregateInputType;
  };

  export type GetThreadMediaAggregateType<T extends ThreadMediaAggregateArgs> =
    {
      [P in keyof T & keyof AggregateThreadMedia]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateThreadMedia[P]>
        : GetScalarType<T[P], AggregateThreadMedia[P]>;
    };

  export type ThreadMediaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ThreadMediaWhereInput;
    orderBy?:
      | ThreadMediaOrderByWithAggregationInput
      | ThreadMediaOrderByWithAggregationInput[];
    by: ThreadMediaScalarFieldEnum[] | ThreadMediaScalarFieldEnum;
    having?: ThreadMediaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ThreadMediaCountAggregateInputType | true;
    _avg?: ThreadMediaAvgAggregateInputType;
    _sum?: ThreadMediaSumAggregateInputType;
    _min?: ThreadMediaMinAggregateInputType;
    _max?: ThreadMediaMaxAggregateInputType;
  };

  export type ThreadMediaGroupByOutputType = {
    id: string;
    threads_id: string;
    media_type: $Enums.media_type_enum | null;
    media_url: string | null;
    thumbnail_url: string | null;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    width: number | null;
    height: number | null;
    size: number | null;
    duration: number | null;
    object_key: string | null;
    _count: ThreadMediaCountAggregateOutputType | null;
    _avg: ThreadMediaAvgAggregateOutputType | null;
    _sum: ThreadMediaSumAggregateOutputType | null;
    _min: ThreadMediaMinAggregateOutputType | null;
    _max: ThreadMediaMaxAggregateOutputType | null;
  };

  type GetThreadMediaGroupByPayload<T extends ThreadMediaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ThreadMediaGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof ThreadMediaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadMediaGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadMediaGroupByOutputType[P]>;
        }
      >
    >;

  export type ThreadMediaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      media_type?: boolean;
      media_url?: boolean;
      thumbnail_url?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
      width?: boolean;
      height?: boolean;
      size?: boolean;
      duration?: boolean;
      object_key?: boolean;
    },
    ExtArgs['result']['threadMedia']
  >;

  export type ThreadMediaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      media_type?: boolean;
      media_url?: boolean;
      thumbnail_url?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
      width?: boolean;
      height?: boolean;
      size?: boolean;
      duration?: boolean;
      object_key?: boolean;
    },
    ExtArgs['result']['threadMedia']
  >;

  export type ThreadMediaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      media_type?: boolean;
      media_url?: boolean;
      thumbnail_url?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
      width?: boolean;
      height?: boolean;
      size?: boolean;
      duration?: boolean;
      object_key?: boolean;
    },
    ExtArgs['result']['threadMedia']
  >;

  export type ThreadMediaSelectScalar = {
    id?: boolean;
    threads_id?: boolean;
    media_type?: boolean;
    media_url?: boolean;
    thumbnail_url?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
    width?: boolean;
    height?: boolean;
    size?: boolean;
    duration?: boolean;
    object_key?: boolean;
  };

  export type ThreadMediaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'threads_id'
    | 'media_type'
    | 'media_url'
    | 'thumbnail_url'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at'
    | 'width'
    | 'height'
    | 'size'
    | 'duration'
    | 'object_key',
    ExtArgs['result']['threadMedia']
  >;

  export type $ThreadMediaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ThreadMedia';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        threads_id: string;
        media_type: $Enums.media_type_enum | null;
        media_url: string | null;
        thumbnail_url: string | null;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
        width: number | null;
        height: number | null;
        size: number | null;
        duration: number | null;
        object_key: string | null;
      },
      ExtArgs['result']['threadMedia']
    >;
    composites: {};
  };

  type ThreadMediaGetPayload<
    S extends boolean | null | undefined | ThreadMediaDefaultArgs
  > = $Result.GetResult<Prisma.$ThreadMediaPayload, S>;

  type ThreadMediaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    ThreadMediaFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ThreadMediaCountAggregateInputType | true;
  };

  export interface ThreadMediaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ThreadMedia'];
      meta: { name: 'ThreadMedia' };
    };
    /**
     * Find zero or one ThreadMedia that matches the filter.
     * @param {ThreadMediaFindUniqueArgs} args - Arguments to find a ThreadMedia
     * @example
     * // Get one ThreadMedia
     * const threadMedia = await prisma.threadMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadMediaFindUniqueArgs>(
      args: SelectSubset<T, ThreadMediaFindUniqueArgs<ExtArgs>>
    ): Prisma__ThreadMediaClient<
      $Result.GetResult<
        Prisma.$ThreadMediaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ThreadMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadMediaFindUniqueOrThrowArgs} args - Arguments to find a ThreadMedia
     * @example
     * // Get one ThreadMedia
     * const threadMedia = await prisma.threadMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadMediaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ThreadMediaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadMediaClient<
      $Result.GetResult<
        Prisma.$ThreadMediaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMediaFindFirstArgs} args - Arguments to find a ThreadMedia
     * @example
     * // Get one ThreadMedia
     * const threadMedia = await prisma.threadMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadMediaFindFirstArgs>(
      args?: SelectSubset<T, ThreadMediaFindFirstArgs<ExtArgs>>
    ): Prisma__ThreadMediaClient<
      $Result.GetResult<
        Prisma.$ThreadMediaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMediaFindFirstOrThrowArgs} args - Arguments to find a ThreadMedia
     * @example
     * // Get one ThreadMedia
     * const threadMedia = await prisma.threadMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadMediaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadMediaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadMediaClient<
      $Result.GetResult<
        Prisma.$ThreadMediaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ThreadMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadMedias
     * const threadMedias = await prisma.threadMedia.findMany()
     *
     * // Get first 10 ThreadMedias
     * const threadMedias = await prisma.threadMedia.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const threadMediaWithIdOnly = await prisma.threadMedia.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ThreadMediaFindManyArgs>(
      args?: SelectSubset<T, ThreadMediaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadMediaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ThreadMedia.
     * @param {ThreadMediaCreateArgs} args - Arguments to create a ThreadMedia.
     * @example
     * // Create one ThreadMedia
     * const ThreadMedia = await prisma.threadMedia.create({
     *   data: {
     *     // ... data to create a ThreadMedia
     *   }
     * })
     *
     */
    create<T extends ThreadMediaCreateArgs>(
      args: SelectSubset<T, ThreadMediaCreateArgs<ExtArgs>>
    ): Prisma__ThreadMediaClient<
      $Result.GetResult<
        Prisma.$ThreadMediaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ThreadMedias.
     * @param {ThreadMediaCreateManyArgs} args - Arguments to create many ThreadMedias.
     * @example
     * // Create many ThreadMedias
     * const threadMedia = await prisma.threadMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ThreadMediaCreateManyArgs>(
      args?: SelectSubset<T, ThreadMediaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ThreadMedias and returns the data saved in the database.
     * @param {ThreadMediaCreateManyAndReturnArgs} args - Arguments to create many ThreadMedias.
     * @example
     * // Create many ThreadMedias
     * const threadMedia = await prisma.threadMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ThreadMedias and only return the `id`
     * const threadMediaWithIdOnly = await prisma.threadMedia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ThreadMediaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ThreadMediaCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadMediaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ThreadMedia.
     * @param {ThreadMediaDeleteArgs} args - Arguments to delete one ThreadMedia.
     * @example
     * // Delete one ThreadMedia
     * const ThreadMedia = await prisma.threadMedia.delete({
     *   where: {
     *     // ... filter to delete one ThreadMedia
     *   }
     * })
     *
     */
    delete<T extends ThreadMediaDeleteArgs>(
      args: SelectSubset<T, ThreadMediaDeleteArgs<ExtArgs>>
    ): Prisma__ThreadMediaClient<
      $Result.GetResult<
        Prisma.$ThreadMediaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ThreadMedia.
     * @param {ThreadMediaUpdateArgs} args - Arguments to update one ThreadMedia.
     * @example
     * // Update one ThreadMedia
     * const threadMedia = await prisma.threadMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ThreadMediaUpdateArgs>(
      args: SelectSubset<T, ThreadMediaUpdateArgs<ExtArgs>>
    ): Prisma__ThreadMediaClient<
      $Result.GetResult<
        Prisma.$ThreadMediaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ThreadMedias.
     * @param {ThreadMediaDeleteManyArgs} args - Arguments to filter ThreadMedias to delete.
     * @example
     * // Delete a few ThreadMedias
     * const { count } = await prisma.threadMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ThreadMediaDeleteManyArgs>(
      args?: SelectSubset<T, ThreadMediaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadMedias
     * const threadMedia = await prisma.threadMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ThreadMediaUpdateManyArgs>(
      args: SelectSubset<T, ThreadMediaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadMedias and returns the data updated in the database.
     * @param {ThreadMediaUpdateManyAndReturnArgs} args - Arguments to update many ThreadMedias.
     * @example
     * // Update many ThreadMedias
     * const threadMedia = await prisma.threadMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ThreadMedias and only return the `id`
     * const threadMediaWithIdOnly = await prisma.threadMedia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ThreadMediaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ThreadMediaUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadMediaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ThreadMedia.
     * @param {ThreadMediaUpsertArgs} args - Arguments to update or create a ThreadMedia.
     * @example
     * // Update or create a ThreadMedia
     * const threadMedia = await prisma.threadMedia.upsert({
     *   create: {
     *     // ... data to create a ThreadMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadMedia we want to update
     *   }
     * })
     */
    upsert<T extends ThreadMediaUpsertArgs>(
      args: SelectSubset<T, ThreadMediaUpsertArgs<ExtArgs>>
    ): Prisma__ThreadMediaClient<
      $Result.GetResult<
        Prisma.$ThreadMediaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ThreadMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMediaCountArgs} args - Arguments to filter ThreadMedias to count.
     * @example
     * // Count the number of ThreadMedias
     * const count = await prisma.threadMedia.count({
     *   where: {
     *     // ... the filter for the ThreadMedias we want to count
     *   }
     * })
     **/
    count<T extends ThreadMediaCountArgs>(
      args?: Subset<T, ThreadMediaCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadMediaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ThreadMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ThreadMediaAggregateArgs>(
      args: Subset<T, ThreadMediaAggregateArgs>
    ): Prisma.PrismaPromise<GetThreadMediaAggregateType<T>>;

    /**
     * Group by ThreadMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ThreadMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadMediaGroupByArgs['orderBy'] }
        : { orderBy?: ThreadMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ThreadMediaGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetThreadMediaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ThreadMedia model
     */
    readonly fields: ThreadMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadMediaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ThreadMedia model
   */
  interface ThreadMediaFieldRefs {
    readonly id: FieldRef<'ThreadMedia', 'String'>;
    readonly threads_id: FieldRef<'ThreadMedia', 'String'>;
    readonly media_type: FieldRef<'ThreadMedia', 'media_type_enum'>;
    readonly media_url: FieldRef<'ThreadMedia', 'String'>;
    readonly thumbnail_url: FieldRef<'ThreadMedia', 'String'>;
    readonly created_at: FieldRef<'ThreadMedia', 'DateTime'>;
    readonly updated_at: FieldRef<'ThreadMedia', 'DateTime'>;
    readonly deleted_at: FieldRef<'ThreadMedia', 'DateTime'>;
    readonly width: FieldRef<'ThreadMedia', 'Int'>;
    readonly height: FieldRef<'ThreadMedia', 'Int'>;
    readonly size: FieldRef<'ThreadMedia', 'Int'>;
    readonly duration: FieldRef<'ThreadMedia', 'Int'>;
    readonly object_key: FieldRef<'ThreadMedia', 'String'>;
  }

  // Custom InputTypes
  /**
   * ThreadMedia findUnique
   */
  export type ThreadMediaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMedia
     */
    select?: ThreadMediaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMedia
     */
    omit?: ThreadMediaOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadMedia to fetch.
     */
    where: ThreadMediaWhereUniqueInput;
  };

  /**
   * ThreadMedia findUniqueOrThrow
   */
  export type ThreadMediaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMedia
     */
    select?: ThreadMediaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMedia
     */
    omit?: ThreadMediaOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadMedia to fetch.
     */
    where: ThreadMediaWhereUniqueInput;
  };

  /**
   * ThreadMedia findFirst
   */
  export type ThreadMediaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMedia
     */
    select?: ThreadMediaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMedia
     */
    omit?: ThreadMediaOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadMedia to fetch.
     */
    where?: ThreadMediaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadMedias to fetch.
     */
    orderBy?:
      | ThreadMediaOrderByWithRelationInput
      | ThreadMediaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadMedias.
     */
    cursor?: ThreadMediaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadMedias from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadMedias.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadMedias.
     */
    distinct?: ThreadMediaScalarFieldEnum | ThreadMediaScalarFieldEnum[];
  };

  /**
   * ThreadMedia findFirstOrThrow
   */
  export type ThreadMediaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMedia
     */
    select?: ThreadMediaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMedia
     */
    omit?: ThreadMediaOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadMedia to fetch.
     */
    where?: ThreadMediaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadMedias to fetch.
     */
    orderBy?:
      | ThreadMediaOrderByWithRelationInput
      | ThreadMediaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadMedias.
     */
    cursor?: ThreadMediaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadMedias from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadMedias.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadMedias.
     */
    distinct?: ThreadMediaScalarFieldEnum | ThreadMediaScalarFieldEnum[];
  };

  /**
   * ThreadMedia findMany
   */
  export type ThreadMediaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMedia
     */
    select?: ThreadMediaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMedia
     */
    omit?: ThreadMediaOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadMedias to fetch.
     */
    where?: ThreadMediaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadMedias to fetch.
     */
    orderBy?:
      | ThreadMediaOrderByWithRelationInput
      | ThreadMediaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ThreadMedias.
     */
    cursor?: ThreadMediaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadMedias from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadMedias.
     */
    skip?: number;
    distinct?: ThreadMediaScalarFieldEnum | ThreadMediaScalarFieldEnum[];
  };

  /**
   * ThreadMedia create
   */
  export type ThreadMediaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMedia
     */
    select?: ThreadMediaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMedia
     */
    omit?: ThreadMediaOmit<ExtArgs> | null;
    /**
     * The data needed to create a ThreadMedia.
     */
    data: XOR<ThreadMediaCreateInput, ThreadMediaUncheckedCreateInput>;
  };

  /**
   * ThreadMedia createMany
   */
  export type ThreadMediaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ThreadMedias.
     */
    data: ThreadMediaCreateManyInput | ThreadMediaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadMedia createManyAndReturn
   */
  export type ThreadMediaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMedia
     */
    select?: ThreadMediaSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMedia
     */
    omit?: ThreadMediaOmit<ExtArgs> | null;
    /**
     * The data used to create many ThreadMedias.
     */
    data: ThreadMediaCreateManyInput | ThreadMediaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadMedia update
   */
  export type ThreadMediaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMedia
     */
    select?: ThreadMediaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMedia
     */
    omit?: ThreadMediaOmit<ExtArgs> | null;
    /**
     * The data needed to update a ThreadMedia.
     */
    data: XOR<ThreadMediaUpdateInput, ThreadMediaUncheckedUpdateInput>;
    /**
     * Choose, which ThreadMedia to update.
     */
    where: ThreadMediaWhereUniqueInput;
  };

  /**
   * ThreadMedia updateMany
   */
  export type ThreadMediaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ThreadMedias.
     */
    data: XOR<
      ThreadMediaUpdateManyMutationInput,
      ThreadMediaUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadMedias to update
     */
    where?: ThreadMediaWhereInput;
    /**
     * Limit how many ThreadMedias to update.
     */
    limit?: number;
  };

  /**
   * ThreadMedia updateManyAndReturn
   */
  export type ThreadMediaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMedia
     */
    select?: ThreadMediaSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMedia
     */
    omit?: ThreadMediaOmit<ExtArgs> | null;
    /**
     * The data used to update ThreadMedias.
     */
    data: XOR<
      ThreadMediaUpdateManyMutationInput,
      ThreadMediaUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadMedias to update
     */
    where?: ThreadMediaWhereInput;
    /**
     * Limit how many ThreadMedias to update.
     */
    limit?: number;
  };

  /**
   * ThreadMedia upsert
   */
  export type ThreadMediaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMedia
     */
    select?: ThreadMediaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMedia
     */
    omit?: ThreadMediaOmit<ExtArgs> | null;
    /**
     * The filter to search for the ThreadMedia to update in case it exists.
     */
    where: ThreadMediaWhereUniqueInput;
    /**
     * In case the ThreadMedia found by the `where` argument doesn't exist, create a new ThreadMedia with this data.
     */
    create: XOR<ThreadMediaCreateInput, ThreadMediaUncheckedCreateInput>;
    /**
     * In case the ThreadMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadMediaUpdateInput, ThreadMediaUncheckedUpdateInput>;
  };

  /**
   * ThreadMedia delete
   */
  export type ThreadMediaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMedia
     */
    select?: ThreadMediaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMedia
     */
    omit?: ThreadMediaOmit<ExtArgs> | null;
    /**
     * Filter which ThreadMedia to delete.
     */
    where: ThreadMediaWhereUniqueInput;
  };

  /**
   * ThreadMedia deleteMany
   */
  export type ThreadMediaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadMedias to delete
     */
    where?: ThreadMediaWhereInput;
    /**
     * Limit how many ThreadMedias to delete.
     */
    limit?: number;
  };

  /**
   * ThreadMedia without action
   */
  export type ThreadMediaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMedia
     */
    select?: ThreadMediaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMedia
     */
    omit?: ThreadMediaOmit<ExtArgs> | null;
  };

  /**
   * Model ThreadMentions
   */

  export type AggregateThreadMentions = {
    _count: ThreadMentionsCountAggregateOutputType | null;
    _avg: ThreadMentionsAvgAggregateOutputType | null;
    _sum: ThreadMentionsSumAggregateOutputType | null;
    _min: ThreadMentionsMinAggregateOutputType | null;
    _max: ThreadMentionsMaxAggregateOutputType | null;
  };

  export type ThreadMentionsAvgAggregateOutputType = {
    mentioned_user_id: number | null;
    position: number | null;
  };

  export type ThreadMentionsSumAggregateOutputType = {
    mentioned_user_id: number | null;
    position: number | null;
  };

  export type ThreadMentionsMinAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    mentioned_user_id: number | null;
    position: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadMentionsMaxAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    mentioned_user_id: number | null;
    position: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadMentionsCountAggregateOutputType = {
    id: number;
    threads_id: number;
    mentioned_user_id: number;
    position: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type ThreadMentionsAvgAggregateInputType = {
    mentioned_user_id?: true;
    position?: true;
  };

  export type ThreadMentionsSumAggregateInputType = {
    mentioned_user_id?: true;
    position?: true;
  };

  export type ThreadMentionsMinAggregateInputType = {
    id?: true;
    threads_id?: true;
    mentioned_user_id?: true;
    position?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadMentionsMaxAggregateInputType = {
    id?: true;
    threads_id?: true;
    mentioned_user_id?: true;
    position?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadMentionsCountAggregateInputType = {
    id?: true;
    threads_id?: true;
    mentioned_user_id?: true;
    position?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type ThreadMentionsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadMentions to aggregate.
     */
    where?: ThreadMentionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadMentions to fetch.
     */
    orderBy?:
      | ThreadMentionsOrderByWithRelationInput
      | ThreadMentionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ThreadMentionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadMentions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadMentions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ThreadMentions
     **/
    _count?: true | ThreadMentionsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ThreadMentionsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ThreadMentionsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ThreadMentionsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ThreadMentionsMaxAggregateInputType;
  };

  export type GetThreadMentionsAggregateType<
    T extends ThreadMentionsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateThreadMentions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreadMentions[P]>
      : GetScalarType<T[P], AggregateThreadMentions[P]>;
  };

  export type ThreadMentionsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ThreadMentionsWhereInput;
    orderBy?:
      | ThreadMentionsOrderByWithAggregationInput
      | ThreadMentionsOrderByWithAggregationInput[];
    by: ThreadMentionsScalarFieldEnum[] | ThreadMentionsScalarFieldEnum;
    having?: ThreadMentionsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ThreadMentionsCountAggregateInputType | true;
    _avg?: ThreadMentionsAvgAggregateInputType;
    _sum?: ThreadMentionsSumAggregateInputType;
    _min?: ThreadMentionsMinAggregateInputType;
    _max?: ThreadMentionsMaxAggregateInputType;
  };

  export type ThreadMentionsGroupByOutputType = {
    id: string;
    threads_id: string;
    mentioned_user_id: number;
    position: number;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: ThreadMentionsCountAggregateOutputType | null;
    _avg: ThreadMentionsAvgAggregateOutputType | null;
    _sum: ThreadMentionsSumAggregateOutputType | null;
    _min: ThreadMentionsMinAggregateOutputType | null;
    _max: ThreadMentionsMaxAggregateOutputType | null;
  };

  type GetThreadMentionsGroupByPayload<T extends ThreadMentionsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ThreadMentionsGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof ThreadMentionsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadMentionsGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadMentionsGroupByOutputType[P]>;
        }
      >
    >;

  export type ThreadMentionsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      mentioned_user_id?: boolean;
      position?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadMentions']
  >;

  export type ThreadMentionsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      mentioned_user_id?: boolean;
      position?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadMentions']
  >;

  export type ThreadMentionsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      mentioned_user_id?: boolean;
      position?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadMentions']
  >;

  export type ThreadMentionsSelectScalar = {
    id?: boolean;
    threads_id?: boolean;
    mentioned_user_id?: boolean;
    position?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type ThreadMentionsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'threads_id'
    | 'mentioned_user_id'
    | 'position'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['threadMentions']
  >;

  export type $ThreadMentionsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ThreadMentions';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        threads_id: string;
        mentioned_user_id: number;
        position: number;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['threadMentions']
    >;
    composites: {};
  };

  type ThreadMentionsGetPayload<
    S extends boolean | null | undefined | ThreadMentionsDefaultArgs
  > = $Result.GetResult<Prisma.$ThreadMentionsPayload, S>;

  type ThreadMentionsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    ThreadMentionsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ThreadMentionsCountAggregateInputType | true;
  };

  export interface ThreadMentionsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ThreadMentions'];
      meta: { name: 'ThreadMentions' };
    };
    /**
     * Find zero or one ThreadMentions that matches the filter.
     * @param {ThreadMentionsFindUniqueArgs} args - Arguments to find a ThreadMentions
     * @example
     * // Get one ThreadMentions
     * const threadMentions = await prisma.threadMentions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadMentionsFindUniqueArgs>(
      args: SelectSubset<T, ThreadMentionsFindUniqueArgs<ExtArgs>>
    ): Prisma__ThreadMentionsClient<
      $Result.GetResult<
        Prisma.$ThreadMentionsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ThreadMentions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadMentionsFindUniqueOrThrowArgs} args - Arguments to find a ThreadMentions
     * @example
     * // Get one ThreadMentions
     * const threadMentions = await prisma.threadMentions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadMentionsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ThreadMentionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadMentionsClient<
      $Result.GetResult<
        Prisma.$ThreadMentionsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadMentions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMentionsFindFirstArgs} args - Arguments to find a ThreadMentions
     * @example
     * // Get one ThreadMentions
     * const threadMentions = await prisma.threadMentions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadMentionsFindFirstArgs>(
      args?: SelectSubset<T, ThreadMentionsFindFirstArgs<ExtArgs>>
    ): Prisma__ThreadMentionsClient<
      $Result.GetResult<
        Prisma.$ThreadMentionsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadMentions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMentionsFindFirstOrThrowArgs} args - Arguments to find a ThreadMentions
     * @example
     * // Get one ThreadMentions
     * const threadMentions = await prisma.threadMentions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadMentionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadMentionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadMentionsClient<
      $Result.GetResult<
        Prisma.$ThreadMentionsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ThreadMentions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMentionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadMentions
     * const threadMentions = await prisma.threadMentions.findMany()
     *
     * // Get first 10 ThreadMentions
     * const threadMentions = await prisma.threadMentions.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const threadMentionsWithIdOnly = await prisma.threadMentions.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ThreadMentionsFindManyArgs>(
      args?: SelectSubset<T, ThreadMentionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadMentionsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ThreadMentions.
     * @param {ThreadMentionsCreateArgs} args - Arguments to create a ThreadMentions.
     * @example
     * // Create one ThreadMentions
     * const ThreadMentions = await prisma.threadMentions.create({
     *   data: {
     *     // ... data to create a ThreadMentions
     *   }
     * })
     *
     */
    create<T extends ThreadMentionsCreateArgs>(
      args: SelectSubset<T, ThreadMentionsCreateArgs<ExtArgs>>
    ): Prisma__ThreadMentionsClient<
      $Result.GetResult<
        Prisma.$ThreadMentionsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ThreadMentions.
     * @param {ThreadMentionsCreateManyArgs} args - Arguments to create many ThreadMentions.
     * @example
     * // Create many ThreadMentions
     * const threadMentions = await prisma.threadMentions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ThreadMentionsCreateManyArgs>(
      args?: SelectSubset<T, ThreadMentionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ThreadMentions and returns the data saved in the database.
     * @param {ThreadMentionsCreateManyAndReturnArgs} args - Arguments to create many ThreadMentions.
     * @example
     * // Create many ThreadMentions
     * const threadMentions = await prisma.threadMentions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ThreadMentions and only return the `id`
     * const threadMentionsWithIdOnly = await prisma.threadMentions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ThreadMentionsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ThreadMentionsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadMentionsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ThreadMentions.
     * @param {ThreadMentionsDeleteArgs} args - Arguments to delete one ThreadMentions.
     * @example
     * // Delete one ThreadMentions
     * const ThreadMentions = await prisma.threadMentions.delete({
     *   where: {
     *     // ... filter to delete one ThreadMentions
     *   }
     * })
     *
     */
    delete<T extends ThreadMentionsDeleteArgs>(
      args: SelectSubset<T, ThreadMentionsDeleteArgs<ExtArgs>>
    ): Prisma__ThreadMentionsClient<
      $Result.GetResult<
        Prisma.$ThreadMentionsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ThreadMentions.
     * @param {ThreadMentionsUpdateArgs} args - Arguments to update one ThreadMentions.
     * @example
     * // Update one ThreadMentions
     * const threadMentions = await prisma.threadMentions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ThreadMentionsUpdateArgs>(
      args: SelectSubset<T, ThreadMentionsUpdateArgs<ExtArgs>>
    ): Prisma__ThreadMentionsClient<
      $Result.GetResult<
        Prisma.$ThreadMentionsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ThreadMentions.
     * @param {ThreadMentionsDeleteManyArgs} args - Arguments to filter ThreadMentions to delete.
     * @example
     * // Delete a few ThreadMentions
     * const { count } = await prisma.threadMentions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ThreadMentionsDeleteManyArgs>(
      args?: SelectSubset<T, ThreadMentionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadMentions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMentionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadMentions
     * const threadMentions = await prisma.threadMentions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ThreadMentionsUpdateManyArgs>(
      args: SelectSubset<T, ThreadMentionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadMentions and returns the data updated in the database.
     * @param {ThreadMentionsUpdateManyAndReturnArgs} args - Arguments to update many ThreadMentions.
     * @example
     * // Update many ThreadMentions
     * const threadMentions = await prisma.threadMentions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ThreadMentions and only return the `id`
     * const threadMentionsWithIdOnly = await prisma.threadMentions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ThreadMentionsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ThreadMentionsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadMentionsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ThreadMentions.
     * @param {ThreadMentionsUpsertArgs} args - Arguments to update or create a ThreadMentions.
     * @example
     * // Update or create a ThreadMentions
     * const threadMentions = await prisma.threadMentions.upsert({
     *   create: {
     *     // ... data to create a ThreadMentions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadMentions we want to update
     *   }
     * })
     */
    upsert<T extends ThreadMentionsUpsertArgs>(
      args: SelectSubset<T, ThreadMentionsUpsertArgs<ExtArgs>>
    ): Prisma__ThreadMentionsClient<
      $Result.GetResult<
        Prisma.$ThreadMentionsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ThreadMentions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMentionsCountArgs} args - Arguments to filter ThreadMentions to count.
     * @example
     * // Count the number of ThreadMentions
     * const count = await prisma.threadMentions.count({
     *   where: {
     *     // ... the filter for the ThreadMentions we want to count
     *   }
     * })
     **/
    count<T extends ThreadMentionsCountArgs>(
      args?: Subset<T, ThreadMentionsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadMentionsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ThreadMentions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMentionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ThreadMentionsAggregateArgs>(
      args: Subset<T, ThreadMentionsAggregateArgs>
    ): Prisma.PrismaPromise<GetThreadMentionsAggregateType<T>>;

    /**
     * Group by ThreadMentions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMentionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ThreadMentionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadMentionsGroupByArgs['orderBy'] }
        : { orderBy?: ThreadMentionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ThreadMentionsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetThreadMentionsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ThreadMentions model
     */
    readonly fields: ThreadMentionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadMentions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadMentionsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ThreadMentions model
   */
  interface ThreadMentionsFieldRefs {
    readonly id: FieldRef<'ThreadMentions', 'String'>;
    readonly threads_id: FieldRef<'ThreadMentions', 'String'>;
    readonly mentioned_user_id: FieldRef<'ThreadMentions', 'Int'>;
    readonly position: FieldRef<'ThreadMentions', 'Int'>;
    readonly created_at: FieldRef<'ThreadMentions', 'DateTime'>;
    readonly updated_at: FieldRef<'ThreadMentions', 'DateTime'>;
    readonly deleted_at: FieldRef<'ThreadMentions', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ThreadMentions findUnique
   */
  export type ThreadMentionsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMentions
     */
    select?: ThreadMentionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMentions
     */
    omit?: ThreadMentionsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadMentions to fetch.
     */
    where: ThreadMentionsWhereUniqueInput;
  };

  /**
   * ThreadMentions findUniqueOrThrow
   */
  export type ThreadMentionsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMentions
     */
    select?: ThreadMentionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMentions
     */
    omit?: ThreadMentionsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadMentions to fetch.
     */
    where: ThreadMentionsWhereUniqueInput;
  };

  /**
   * ThreadMentions findFirst
   */
  export type ThreadMentionsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMentions
     */
    select?: ThreadMentionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMentions
     */
    omit?: ThreadMentionsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadMentions to fetch.
     */
    where?: ThreadMentionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadMentions to fetch.
     */
    orderBy?:
      | ThreadMentionsOrderByWithRelationInput
      | ThreadMentionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadMentions.
     */
    cursor?: ThreadMentionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadMentions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadMentions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadMentions.
     */
    distinct?: ThreadMentionsScalarFieldEnum | ThreadMentionsScalarFieldEnum[];
  };

  /**
   * ThreadMentions findFirstOrThrow
   */
  export type ThreadMentionsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMentions
     */
    select?: ThreadMentionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMentions
     */
    omit?: ThreadMentionsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadMentions to fetch.
     */
    where?: ThreadMentionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadMentions to fetch.
     */
    orderBy?:
      | ThreadMentionsOrderByWithRelationInput
      | ThreadMentionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadMentions.
     */
    cursor?: ThreadMentionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadMentions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadMentions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadMentions.
     */
    distinct?: ThreadMentionsScalarFieldEnum | ThreadMentionsScalarFieldEnum[];
  };

  /**
   * ThreadMentions findMany
   */
  export type ThreadMentionsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMentions
     */
    select?: ThreadMentionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMentions
     */
    omit?: ThreadMentionsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadMentions to fetch.
     */
    where?: ThreadMentionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadMentions to fetch.
     */
    orderBy?:
      | ThreadMentionsOrderByWithRelationInput
      | ThreadMentionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ThreadMentions.
     */
    cursor?: ThreadMentionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadMentions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadMentions.
     */
    skip?: number;
    distinct?: ThreadMentionsScalarFieldEnum | ThreadMentionsScalarFieldEnum[];
  };

  /**
   * ThreadMentions create
   */
  export type ThreadMentionsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMentions
     */
    select?: ThreadMentionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMentions
     */
    omit?: ThreadMentionsOmit<ExtArgs> | null;
    /**
     * The data needed to create a ThreadMentions.
     */
    data: XOR<ThreadMentionsCreateInput, ThreadMentionsUncheckedCreateInput>;
  };

  /**
   * ThreadMentions createMany
   */
  export type ThreadMentionsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ThreadMentions.
     */
    data: ThreadMentionsCreateManyInput | ThreadMentionsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadMentions createManyAndReturn
   */
  export type ThreadMentionsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMentions
     */
    select?: ThreadMentionsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMentions
     */
    omit?: ThreadMentionsOmit<ExtArgs> | null;
    /**
     * The data used to create many ThreadMentions.
     */
    data: ThreadMentionsCreateManyInput | ThreadMentionsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadMentions update
   */
  export type ThreadMentionsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMentions
     */
    select?: ThreadMentionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMentions
     */
    omit?: ThreadMentionsOmit<ExtArgs> | null;
    /**
     * The data needed to update a ThreadMentions.
     */
    data: XOR<ThreadMentionsUpdateInput, ThreadMentionsUncheckedUpdateInput>;
    /**
     * Choose, which ThreadMentions to update.
     */
    where: ThreadMentionsWhereUniqueInput;
  };

  /**
   * ThreadMentions updateMany
   */
  export type ThreadMentionsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ThreadMentions.
     */
    data: XOR<
      ThreadMentionsUpdateManyMutationInput,
      ThreadMentionsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadMentions to update
     */
    where?: ThreadMentionsWhereInput;
    /**
     * Limit how many ThreadMentions to update.
     */
    limit?: number;
  };

  /**
   * ThreadMentions updateManyAndReturn
   */
  export type ThreadMentionsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMentions
     */
    select?: ThreadMentionsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMentions
     */
    omit?: ThreadMentionsOmit<ExtArgs> | null;
    /**
     * The data used to update ThreadMentions.
     */
    data: XOR<
      ThreadMentionsUpdateManyMutationInput,
      ThreadMentionsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadMentions to update
     */
    where?: ThreadMentionsWhereInput;
    /**
     * Limit how many ThreadMentions to update.
     */
    limit?: number;
  };

  /**
   * ThreadMentions upsert
   */
  export type ThreadMentionsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMentions
     */
    select?: ThreadMentionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMentions
     */
    omit?: ThreadMentionsOmit<ExtArgs> | null;
    /**
     * The filter to search for the ThreadMentions to update in case it exists.
     */
    where: ThreadMentionsWhereUniqueInput;
    /**
     * In case the ThreadMentions found by the `where` argument doesn't exist, create a new ThreadMentions with this data.
     */
    create: XOR<ThreadMentionsCreateInput, ThreadMentionsUncheckedCreateInput>;
    /**
     * In case the ThreadMentions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadMentionsUpdateInput, ThreadMentionsUncheckedUpdateInput>;
  };

  /**
   * ThreadMentions delete
   */
  export type ThreadMentionsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMentions
     */
    select?: ThreadMentionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMentions
     */
    omit?: ThreadMentionsOmit<ExtArgs> | null;
    /**
     * Filter which ThreadMentions to delete.
     */
    where: ThreadMentionsWhereUniqueInput;
  };

  /**
   * ThreadMentions deleteMany
   */
  export type ThreadMentionsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadMentions to delete
     */
    where?: ThreadMentionsWhereInput;
    /**
     * Limit how many ThreadMentions to delete.
     */
    limit?: number;
  };

  /**
   * ThreadMentions without action
   */
  export type ThreadMentionsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadMentions
     */
    select?: ThreadMentionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadMentions
     */
    omit?: ThreadMentionsOmit<ExtArgs> | null;
  };

  /**
   * Model ThreadPins
   */

  export type AggregateThreadPins = {
    _count: ThreadPinsCountAggregateOutputType | null;
    _avg: ThreadPinsAvgAggregateOutputType | null;
    _sum: ThreadPinsSumAggregateOutputType | null;
    _min: ThreadPinsMinAggregateOutputType | null;
    _max: ThreadPinsMaxAggregateOutputType | null;
  };

  export type ThreadPinsAvgAggregateOutputType = {
    user_id: number | null;
  };

  export type ThreadPinsSumAggregateOutputType = {
    user_id: number | null;
  };

  export type ThreadPinsMinAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    threads_id: string | null;
    pinned_at: Date | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadPinsMaxAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    threads_id: string | null;
    pinned_at: Date | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadPinsCountAggregateOutputType = {
    id: number;
    user_id: number;
    threads_id: number;
    pinned_at: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type ThreadPinsAvgAggregateInputType = {
    user_id?: true;
  };

  export type ThreadPinsSumAggregateInputType = {
    user_id?: true;
  };

  export type ThreadPinsMinAggregateInputType = {
    id?: true;
    user_id?: true;
    threads_id?: true;
    pinned_at?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadPinsMaxAggregateInputType = {
    id?: true;
    user_id?: true;
    threads_id?: true;
    pinned_at?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadPinsCountAggregateInputType = {
    id?: true;
    user_id?: true;
    threads_id?: true;
    pinned_at?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type ThreadPinsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadPins to aggregate.
     */
    where?: ThreadPinsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPins to fetch.
     */
    orderBy?:
      | ThreadPinsOrderByWithRelationInput
      | ThreadPinsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ThreadPinsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPins from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPins.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ThreadPins
     **/
    _count?: true | ThreadPinsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ThreadPinsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ThreadPinsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ThreadPinsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ThreadPinsMaxAggregateInputType;
  };

  export type GetThreadPinsAggregateType<T extends ThreadPinsAggregateArgs> = {
    [P in keyof T & keyof AggregateThreadPins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreadPins[P]>
      : GetScalarType<T[P], AggregateThreadPins[P]>;
  };

  export type ThreadPinsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ThreadPinsWhereInput;
    orderBy?:
      | ThreadPinsOrderByWithAggregationInput
      | ThreadPinsOrderByWithAggregationInput[];
    by: ThreadPinsScalarFieldEnum[] | ThreadPinsScalarFieldEnum;
    having?: ThreadPinsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ThreadPinsCountAggregateInputType | true;
    _avg?: ThreadPinsAvgAggregateInputType;
    _sum?: ThreadPinsSumAggregateInputType;
    _min?: ThreadPinsMinAggregateInputType;
    _max?: ThreadPinsMaxAggregateInputType;
  };

  export type ThreadPinsGroupByOutputType = {
    id: string;
    user_id: number;
    threads_id: string;
    pinned_at: Date;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: ThreadPinsCountAggregateOutputType | null;
    _avg: ThreadPinsAvgAggregateOutputType | null;
    _sum: ThreadPinsSumAggregateOutputType | null;
    _min: ThreadPinsMinAggregateOutputType | null;
    _max: ThreadPinsMaxAggregateOutputType | null;
  };

  type GetThreadPinsGroupByPayload<T extends ThreadPinsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ThreadPinsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ThreadPinsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadPinsGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadPinsGroupByOutputType[P]>;
        }
      >
    >;

  export type ThreadPinsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      threads_id?: boolean;
      pinned_at?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadPins']
  >;

  export type ThreadPinsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      threads_id?: boolean;
      pinned_at?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadPins']
  >;

  export type ThreadPinsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      threads_id?: boolean;
      pinned_at?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadPins']
  >;

  export type ThreadPinsSelectScalar = {
    id?: boolean;
    user_id?: boolean;
    threads_id?: boolean;
    pinned_at?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type ThreadPinsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'user_id'
    | 'threads_id'
    | 'pinned_at'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['threadPins']
  >;

  export type $ThreadPinsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ThreadPins';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        user_id: number;
        threads_id: string;
        pinned_at: Date;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['threadPins']
    >;
    composites: {};
  };

  type ThreadPinsGetPayload<
    S extends boolean | null | undefined | ThreadPinsDefaultArgs
  > = $Result.GetResult<Prisma.$ThreadPinsPayload, S>;

  type ThreadPinsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    ThreadPinsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ThreadPinsCountAggregateInputType | true;
  };

  export interface ThreadPinsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ThreadPins'];
      meta: { name: 'ThreadPins' };
    };
    /**
     * Find zero or one ThreadPins that matches the filter.
     * @param {ThreadPinsFindUniqueArgs} args - Arguments to find a ThreadPins
     * @example
     * // Get one ThreadPins
     * const threadPins = await prisma.threadPins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadPinsFindUniqueArgs>(
      args: SelectSubset<T, ThreadPinsFindUniqueArgs<ExtArgs>>
    ): Prisma__ThreadPinsClient<
      $Result.GetResult<
        Prisma.$ThreadPinsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ThreadPins that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadPinsFindUniqueOrThrowArgs} args - Arguments to find a ThreadPins
     * @example
     * // Get one ThreadPins
     * const threadPins = await prisma.threadPins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadPinsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ThreadPinsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadPinsClient<
      $Result.GetResult<
        Prisma.$ThreadPinsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadPins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPinsFindFirstArgs} args - Arguments to find a ThreadPins
     * @example
     * // Get one ThreadPins
     * const threadPins = await prisma.threadPins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadPinsFindFirstArgs>(
      args?: SelectSubset<T, ThreadPinsFindFirstArgs<ExtArgs>>
    ): Prisma__ThreadPinsClient<
      $Result.GetResult<
        Prisma.$ThreadPinsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadPins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPinsFindFirstOrThrowArgs} args - Arguments to find a ThreadPins
     * @example
     * // Get one ThreadPins
     * const threadPins = await prisma.threadPins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadPinsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadPinsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadPinsClient<
      $Result.GetResult<
        Prisma.$ThreadPinsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ThreadPins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPinsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadPins
     * const threadPins = await prisma.threadPins.findMany()
     *
     * // Get first 10 ThreadPins
     * const threadPins = await prisma.threadPins.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const threadPinsWithIdOnly = await prisma.threadPins.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ThreadPinsFindManyArgs>(
      args?: SelectSubset<T, ThreadPinsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadPinsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ThreadPins.
     * @param {ThreadPinsCreateArgs} args - Arguments to create a ThreadPins.
     * @example
     * // Create one ThreadPins
     * const ThreadPins = await prisma.threadPins.create({
     *   data: {
     *     // ... data to create a ThreadPins
     *   }
     * })
     *
     */
    create<T extends ThreadPinsCreateArgs>(
      args: SelectSubset<T, ThreadPinsCreateArgs<ExtArgs>>
    ): Prisma__ThreadPinsClient<
      $Result.GetResult<
        Prisma.$ThreadPinsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ThreadPins.
     * @param {ThreadPinsCreateManyArgs} args - Arguments to create many ThreadPins.
     * @example
     * // Create many ThreadPins
     * const threadPins = await prisma.threadPins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ThreadPinsCreateManyArgs>(
      args?: SelectSubset<T, ThreadPinsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ThreadPins and returns the data saved in the database.
     * @param {ThreadPinsCreateManyAndReturnArgs} args - Arguments to create many ThreadPins.
     * @example
     * // Create many ThreadPins
     * const threadPins = await prisma.threadPins.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ThreadPins and only return the `id`
     * const threadPinsWithIdOnly = await prisma.threadPins.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ThreadPinsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ThreadPinsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadPinsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ThreadPins.
     * @param {ThreadPinsDeleteArgs} args - Arguments to delete one ThreadPins.
     * @example
     * // Delete one ThreadPins
     * const ThreadPins = await prisma.threadPins.delete({
     *   where: {
     *     // ... filter to delete one ThreadPins
     *   }
     * })
     *
     */
    delete<T extends ThreadPinsDeleteArgs>(
      args: SelectSubset<T, ThreadPinsDeleteArgs<ExtArgs>>
    ): Prisma__ThreadPinsClient<
      $Result.GetResult<
        Prisma.$ThreadPinsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ThreadPins.
     * @param {ThreadPinsUpdateArgs} args - Arguments to update one ThreadPins.
     * @example
     * // Update one ThreadPins
     * const threadPins = await prisma.threadPins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ThreadPinsUpdateArgs>(
      args: SelectSubset<T, ThreadPinsUpdateArgs<ExtArgs>>
    ): Prisma__ThreadPinsClient<
      $Result.GetResult<
        Prisma.$ThreadPinsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ThreadPins.
     * @param {ThreadPinsDeleteManyArgs} args - Arguments to filter ThreadPins to delete.
     * @example
     * // Delete a few ThreadPins
     * const { count } = await prisma.threadPins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ThreadPinsDeleteManyArgs>(
      args?: SelectSubset<T, ThreadPinsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadPins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPinsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadPins
     * const threadPins = await prisma.threadPins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ThreadPinsUpdateManyArgs>(
      args: SelectSubset<T, ThreadPinsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadPins and returns the data updated in the database.
     * @param {ThreadPinsUpdateManyAndReturnArgs} args - Arguments to update many ThreadPins.
     * @example
     * // Update many ThreadPins
     * const threadPins = await prisma.threadPins.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ThreadPins and only return the `id`
     * const threadPinsWithIdOnly = await prisma.threadPins.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ThreadPinsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ThreadPinsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadPinsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ThreadPins.
     * @param {ThreadPinsUpsertArgs} args - Arguments to update or create a ThreadPins.
     * @example
     * // Update or create a ThreadPins
     * const threadPins = await prisma.threadPins.upsert({
     *   create: {
     *     // ... data to create a ThreadPins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadPins we want to update
     *   }
     * })
     */
    upsert<T extends ThreadPinsUpsertArgs>(
      args: SelectSubset<T, ThreadPinsUpsertArgs<ExtArgs>>
    ): Prisma__ThreadPinsClient<
      $Result.GetResult<
        Prisma.$ThreadPinsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ThreadPins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPinsCountArgs} args - Arguments to filter ThreadPins to count.
     * @example
     * // Count the number of ThreadPins
     * const count = await prisma.threadPins.count({
     *   where: {
     *     // ... the filter for the ThreadPins we want to count
     *   }
     * })
     **/
    count<T extends ThreadPinsCountArgs>(
      args?: Subset<T, ThreadPinsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadPinsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ThreadPins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPinsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ThreadPinsAggregateArgs>(
      args: Subset<T, ThreadPinsAggregateArgs>
    ): Prisma.PrismaPromise<GetThreadPinsAggregateType<T>>;

    /**
     * Group by ThreadPins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPinsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ThreadPinsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadPinsGroupByArgs['orderBy'] }
        : { orderBy?: ThreadPinsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ThreadPinsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetThreadPinsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ThreadPins model
     */
    readonly fields: ThreadPinsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadPins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadPinsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ThreadPins model
   */
  interface ThreadPinsFieldRefs {
    readonly id: FieldRef<'ThreadPins', 'String'>;
    readonly user_id: FieldRef<'ThreadPins', 'Int'>;
    readonly threads_id: FieldRef<'ThreadPins', 'String'>;
    readonly pinned_at: FieldRef<'ThreadPins', 'DateTime'>;
    readonly created_at: FieldRef<'ThreadPins', 'DateTime'>;
    readonly updated_at: FieldRef<'ThreadPins', 'DateTime'>;
    readonly deleted_at: FieldRef<'ThreadPins', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ThreadPins findUnique
   */
  export type ThreadPinsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPins
     */
    select?: ThreadPinsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPins
     */
    omit?: ThreadPinsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPins to fetch.
     */
    where: ThreadPinsWhereUniqueInput;
  };

  /**
   * ThreadPins findUniqueOrThrow
   */
  export type ThreadPinsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPins
     */
    select?: ThreadPinsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPins
     */
    omit?: ThreadPinsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPins to fetch.
     */
    where: ThreadPinsWhereUniqueInput;
  };

  /**
   * ThreadPins findFirst
   */
  export type ThreadPinsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPins
     */
    select?: ThreadPinsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPins
     */
    omit?: ThreadPinsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPins to fetch.
     */
    where?: ThreadPinsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPins to fetch.
     */
    orderBy?:
      | ThreadPinsOrderByWithRelationInput
      | ThreadPinsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadPins.
     */
    cursor?: ThreadPinsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPins from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPins.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadPins.
     */
    distinct?: ThreadPinsScalarFieldEnum | ThreadPinsScalarFieldEnum[];
  };

  /**
   * ThreadPins findFirstOrThrow
   */
  export type ThreadPinsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPins
     */
    select?: ThreadPinsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPins
     */
    omit?: ThreadPinsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPins to fetch.
     */
    where?: ThreadPinsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPins to fetch.
     */
    orderBy?:
      | ThreadPinsOrderByWithRelationInput
      | ThreadPinsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadPins.
     */
    cursor?: ThreadPinsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPins from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPins.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadPins.
     */
    distinct?: ThreadPinsScalarFieldEnum | ThreadPinsScalarFieldEnum[];
  };

  /**
   * ThreadPins findMany
   */
  export type ThreadPinsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPins
     */
    select?: ThreadPinsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPins
     */
    omit?: ThreadPinsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPins to fetch.
     */
    where?: ThreadPinsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPins to fetch.
     */
    orderBy?:
      | ThreadPinsOrderByWithRelationInput
      | ThreadPinsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ThreadPins.
     */
    cursor?: ThreadPinsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPins from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPins.
     */
    skip?: number;
    distinct?: ThreadPinsScalarFieldEnum | ThreadPinsScalarFieldEnum[];
  };

  /**
   * ThreadPins create
   */
  export type ThreadPinsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPins
     */
    select?: ThreadPinsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPins
     */
    omit?: ThreadPinsOmit<ExtArgs> | null;
    /**
     * The data needed to create a ThreadPins.
     */
    data: XOR<ThreadPinsCreateInput, ThreadPinsUncheckedCreateInput>;
  };

  /**
   * ThreadPins createMany
   */
  export type ThreadPinsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ThreadPins.
     */
    data: ThreadPinsCreateManyInput | ThreadPinsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadPins createManyAndReturn
   */
  export type ThreadPinsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPins
     */
    select?: ThreadPinsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPins
     */
    omit?: ThreadPinsOmit<ExtArgs> | null;
    /**
     * The data used to create many ThreadPins.
     */
    data: ThreadPinsCreateManyInput | ThreadPinsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadPins update
   */
  export type ThreadPinsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPins
     */
    select?: ThreadPinsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPins
     */
    omit?: ThreadPinsOmit<ExtArgs> | null;
    /**
     * The data needed to update a ThreadPins.
     */
    data: XOR<ThreadPinsUpdateInput, ThreadPinsUncheckedUpdateInput>;
    /**
     * Choose, which ThreadPins to update.
     */
    where: ThreadPinsWhereUniqueInput;
  };

  /**
   * ThreadPins updateMany
   */
  export type ThreadPinsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ThreadPins.
     */
    data: XOR<
      ThreadPinsUpdateManyMutationInput,
      ThreadPinsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadPins to update
     */
    where?: ThreadPinsWhereInput;
    /**
     * Limit how many ThreadPins to update.
     */
    limit?: number;
  };

  /**
   * ThreadPins updateManyAndReturn
   */
  export type ThreadPinsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPins
     */
    select?: ThreadPinsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPins
     */
    omit?: ThreadPinsOmit<ExtArgs> | null;
    /**
     * The data used to update ThreadPins.
     */
    data: XOR<
      ThreadPinsUpdateManyMutationInput,
      ThreadPinsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadPins to update
     */
    where?: ThreadPinsWhereInput;
    /**
     * Limit how many ThreadPins to update.
     */
    limit?: number;
  };

  /**
   * ThreadPins upsert
   */
  export type ThreadPinsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPins
     */
    select?: ThreadPinsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPins
     */
    omit?: ThreadPinsOmit<ExtArgs> | null;
    /**
     * The filter to search for the ThreadPins to update in case it exists.
     */
    where: ThreadPinsWhereUniqueInput;
    /**
     * In case the ThreadPins found by the `where` argument doesn't exist, create a new ThreadPins with this data.
     */
    create: XOR<ThreadPinsCreateInput, ThreadPinsUncheckedCreateInput>;
    /**
     * In case the ThreadPins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadPinsUpdateInput, ThreadPinsUncheckedUpdateInput>;
  };

  /**
   * ThreadPins delete
   */
  export type ThreadPinsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPins
     */
    select?: ThreadPinsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPins
     */
    omit?: ThreadPinsOmit<ExtArgs> | null;
    /**
     * Filter which ThreadPins to delete.
     */
    where: ThreadPinsWhereUniqueInput;
  };

  /**
   * ThreadPins deleteMany
   */
  export type ThreadPinsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadPins to delete
     */
    where?: ThreadPinsWhereInput;
    /**
     * Limit how many ThreadPins to delete.
     */
    limit?: number;
  };

  /**
   * ThreadPins without action
   */
  export type ThreadPinsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPins
     */
    select?: ThreadPinsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPins
     */
    omit?: ThreadPinsOmit<ExtArgs> | null;
  };

  /**
   * Model ThreadPollOptions
   */

  export type AggregateThreadPollOptions = {
    _count: ThreadPollOptionsCountAggregateOutputType | null;
    _avg: ThreadPollOptionsAvgAggregateOutputType | null;
    _sum: ThreadPollOptionsSumAggregateOutputType | null;
    _min: ThreadPollOptionsMinAggregateOutputType | null;
    _max: ThreadPollOptionsMaxAggregateOutputType | null;
  };

  export type ThreadPollOptionsAvgAggregateOutputType = {
    voted_count: number | null;
  };

  export type ThreadPollOptionsSumAggregateOutputType = {
    voted_count: number | null;
  };

  export type ThreadPollOptionsMinAggregateOutputType = {
    id: string | null;
    poll_id: string | null;
    option_text: string | null;
    voted_count: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadPollOptionsMaxAggregateOutputType = {
    id: string | null;
    poll_id: string | null;
    option_text: string | null;
    voted_count: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadPollOptionsCountAggregateOutputType = {
    id: number;
    poll_id: number;
    option_text: number;
    voted_count: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type ThreadPollOptionsAvgAggregateInputType = {
    voted_count?: true;
  };

  export type ThreadPollOptionsSumAggregateInputType = {
    voted_count?: true;
  };

  export type ThreadPollOptionsMinAggregateInputType = {
    id?: true;
    poll_id?: true;
    option_text?: true;
    voted_count?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadPollOptionsMaxAggregateInputType = {
    id?: true;
    poll_id?: true;
    option_text?: true;
    voted_count?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadPollOptionsCountAggregateInputType = {
    id?: true;
    poll_id?: true;
    option_text?: true;
    voted_count?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type ThreadPollOptionsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadPollOptions to aggregate.
     */
    where?: ThreadPollOptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPollOptions to fetch.
     */
    orderBy?:
      | ThreadPollOptionsOrderByWithRelationInput
      | ThreadPollOptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ThreadPollOptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPollOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPollOptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ThreadPollOptions
     **/
    _count?: true | ThreadPollOptionsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ThreadPollOptionsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ThreadPollOptionsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ThreadPollOptionsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ThreadPollOptionsMaxAggregateInputType;
  };

  export type GetThreadPollOptionsAggregateType<
    T extends ThreadPollOptionsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateThreadPollOptions]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreadPollOptions[P]>
      : GetScalarType<T[P], AggregateThreadPollOptions[P]>;
  };

  export type ThreadPollOptionsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ThreadPollOptionsWhereInput;
    orderBy?:
      | ThreadPollOptionsOrderByWithAggregationInput
      | ThreadPollOptionsOrderByWithAggregationInput[];
    by: ThreadPollOptionsScalarFieldEnum[] | ThreadPollOptionsScalarFieldEnum;
    having?: ThreadPollOptionsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ThreadPollOptionsCountAggregateInputType | true;
    _avg?: ThreadPollOptionsAvgAggregateInputType;
    _sum?: ThreadPollOptionsSumAggregateInputType;
    _min?: ThreadPollOptionsMinAggregateInputType;
    _max?: ThreadPollOptionsMaxAggregateInputType;
  };

  export type ThreadPollOptionsGroupByOutputType = {
    id: string;
    poll_id: string;
    option_text: string;
    voted_count: number;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: ThreadPollOptionsCountAggregateOutputType | null;
    _avg: ThreadPollOptionsAvgAggregateOutputType | null;
    _sum: ThreadPollOptionsSumAggregateOutputType | null;
    _min: ThreadPollOptionsMinAggregateOutputType | null;
    _max: ThreadPollOptionsMaxAggregateOutputType | null;
  };

  type GetThreadPollOptionsGroupByPayload<
    T extends ThreadPollOptionsGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThreadPollOptionsGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof ThreadPollOptionsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ThreadPollOptionsGroupByOutputType[P]>
          : GetScalarType<T[P], ThreadPollOptionsGroupByOutputType[P]>;
      }
    >
  >;

  export type ThreadPollOptionsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      poll_id?: boolean;
      option_text?: boolean;
      voted_count?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadPollOptions']
  >;

  export type ThreadPollOptionsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      poll_id?: boolean;
      option_text?: boolean;
      voted_count?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadPollOptions']
  >;

  export type ThreadPollOptionsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      poll_id?: boolean;
      option_text?: boolean;
      voted_count?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadPollOptions']
  >;

  export type ThreadPollOptionsSelectScalar = {
    id?: boolean;
    poll_id?: boolean;
    option_text?: boolean;
    voted_count?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type ThreadPollOptionsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'poll_id'
    | 'option_text'
    | 'voted_count'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['threadPollOptions']
  >;

  export type $ThreadPollOptionsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ThreadPollOptions';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        poll_id: string;
        option_text: string;
        voted_count: number;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['threadPollOptions']
    >;
    composites: {};
  };

  type ThreadPollOptionsGetPayload<
    S extends boolean | null | undefined | ThreadPollOptionsDefaultArgs
  > = $Result.GetResult<Prisma.$ThreadPollOptionsPayload, S>;

  type ThreadPollOptionsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    ThreadPollOptionsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ThreadPollOptionsCountAggregateInputType | true;
  };

  export interface ThreadPollOptionsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ThreadPollOptions'];
      meta: { name: 'ThreadPollOptions' };
    };
    /**
     * Find zero or one ThreadPollOptions that matches the filter.
     * @param {ThreadPollOptionsFindUniqueArgs} args - Arguments to find a ThreadPollOptions
     * @example
     * // Get one ThreadPollOptions
     * const threadPollOptions = await prisma.threadPollOptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadPollOptionsFindUniqueArgs>(
      args: SelectSubset<T, ThreadPollOptionsFindUniqueArgs<ExtArgs>>
    ): Prisma__ThreadPollOptionsClient<
      $Result.GetResult<
        Prisma.$ThreadPollOptionsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ThreadPollOptions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadPollOptionsFindUniqueOrThrowArgs} args - Arguments to find a ThreadPollOptions
     * @example
     * // Get one ThreadPollOptions
     * const threadPollOptions = await prisma.threadPollOptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadPollOptionsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ThreadPollOptionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadPollOptionsClient<
      $Result.GetResult<
        Prisma.$ThreadPollOptionsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadPollOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollOptionsFindFirstArgs} args - Arguments to find a ThreadPollOptions
     * @example
     * // Get one ThreadPollOptions
     * const threadPollOptions = await prisma.threadPollOptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadPollOptionsFindFirstArgs>(
      args?: SelectSubset<T, ThreadPollOptionsFindFirstArgs<ExtArgs>>
    ): Prisma__ThreadPollOptionsClient<
      $Result.GetResult<
        Prisma.$ThreadPollOptionsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadPollOptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollOptionsFindFirstOrThrowArgs} args - Arguments to find a ThreadPollOptions
     * @example
     * // Get one ThreadPollOptions
     * const threadPollOptions = await prisma.threadPollOptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadPollOptionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadPollOptionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadPollOptionsClient<
      $Result.GetResult<
        Prisma.$ThreadPollOptionsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ThreadPollOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollOptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadPollOptions
     * const threadPollOptions = await prisma.threadPollOptions.findMany()
     *
     * // Get first 10 ThreadPollOptions
     * const threadPollOptions = await prisma.threadPollOptions.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const threadPollOptionsWithIdOnly = await prisma.threadPollOptions.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ThreadPollOptionsFindManyArgs>(
      args?: SelectSubset<T, ThreadPollOptionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadPollOptionsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ThreadPollOptions.
     * @param {ThreadPollOptionsCreateArgs} args - Arguments to create a ThreadPollOptions.
     * @example
     * // Create one ThreadPollOptions
     * const ThreadPollOptions = await prisma.threadPollOptions.create({
     *   data: {
     *     // ... data to create a ThreadPollOptions
     *   }
     * })
     *
     */
    create<T extends ThreadPollOptionsCreateArgs>(
      args: SelectSubset<T, ThreadPollOptionsCreateArgs<ExtArgs>>
    ): Prisma__ThreadPollOptionsClient<
      $Result.GetResult<
        Prisma.$ThreadPollOptionsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ThreadPollOptions.
     * @param {ThreadPollOptionsCreateManyArgs} args - Arguments to create many ThreadPollOptions.
     * @example
     * // Create many ThreadPollOptions
     * const threadPollOptions = await prisma.threadPollOptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ThreadPollOptionsCreateManyArgs>(
      args?: SelectSubset<T, ThreadPollOptionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ThreadPollOptions and returns the data saved in the database.
     * @param {ThreadPollOptionsCreateManyAndReturnArgs} args - Arguments to create many ThreadPollOptions.
     * @example
     * // Create many ThreadPollOptions
     * const threadPollOptions = await prisma.threadPollOptions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ThreadPollOptions and only return the `id`
     * const threadPollOptionsWithIdOnly = await prisma.threadPollOptions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ThreadPollOptionsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ThreadPollOptionsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadPollOptionsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ThreadPollOptions.
     * @param {ThreadPollOptionsDeleteArgs} args - Arguments to delete one ThreadPollOptions.
     * @example
     * // Delete one ThreadPollOptions
     * const ThreadPollOptions = await prisma.threadPollOptions.delete({
     *   where: {
     *     // ... filter to delete one ThreadPollOptions
     *   }
     * })
     *
     */
    delete<T extends ThreadPollOptionsDeleteArgs>(
      args: SelectSubset<T, ThreadPollOptionsDeleteArgs<ExtArgs>>
    ): Prisma__ThreadPollOptionsClient<
      $Result.GetResult<
        Prisma.$ThreadPollOptionsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ThreadPollOptions.
     * @param {ThreadPollOptionsUpdateArgs} args - Arguments to update one ThreadPollOptions.
     * @example
     * // Update one ThreadPollOptions
     * const threadPollOptions = await prisma.threadPollOptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ThreadPollOptionsUpdateArgs>(
      args: SelectSubset<T, ThreadPollOptionsUpdateArgs<ExtArgs>>
    ): Prisma__ThreadPollOptionsClient<
      $Result.GetResult<
        Prisma.$ThreadPollOptionsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ThreadPollOptions.
     * @param {ThreadPollOptionsDeleteManyArgs} args - Arguments to filter ThreadPollOptions to delete.
     * @example
     * // Delete a few ThreadPollOptions
     * const { count } = await prisma.threadPollOptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ThreadPollOptionsDeleteManyArgs>(
      args?: SelectSubset<T, ThreadPollOptionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadPollOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollOptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadPollOptions
     * const threadPollOptions = await prisma.threadPollOptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ThreadPollOptionsUpdateManyArgs>(
      args: SelectSubset<T, ThreadPollOptionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadPollOptions and returns the data updated in the database.
     * @param {ThreadPollOptionsUpdateManyAndReturnArgs} args - Arguments to update many ThreadPollOptions.
     * @example
     * // Update many ThreadPollOptions
     * const threadPollOptions = await prisma.threadPollOptions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ThreadPollOptions and only return the `id`
     * const threadPollOptionsWithIdOnly = await prisma.threadPollOptions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ThreadPollOptionsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ThreadPollOptionsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadPollOptionsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ThreadPollOptions.
     * @param {ThreadPollOptionsUpsertArgs} args - Arguments to update or create a ThreadPollOptions.
     * @example
     * // Update or create a ThreadPollOptions
     * const threadPollOptions = await prisma.threadPollOptions.upsert({
     *   create: {
     *     // ... data to create a ThreadPollOptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadPollOptions we want to update
     *   }
     * })
     */
    upsert<T extends ThreadPollOptionsUpsertArgs>(
      args: SelectSubset<T, ThreadPollOptionsUpsertArgs<ExtArgs>>
    ): Prisma__ThreadPollOptionsClient<
      $Result.GetResult<
        Prisma.$ThreadPollOptionsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ThreadPollOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollOptionsCountArgs} args - Arguments to filter ThreadPollOptions to count.
     * @example
     * // Count the number of ThreadPollOptions
     * const count = await prisma.threadPollOptions.count({
     *   where: {
     *     // ... the filter for the ThreadPollOptions we want to count
     *   }
     * })
     **/
    count<T extends ThreadPollOptionsCountArgs>(
      args?: Subset<T, ThreadPollOptionsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              ThreadPollOptionsCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ThreadPollOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollOptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ThreadPollOptionsAggregateArgs>(
      args: Subset<T, ThreadPollOptionsAggregateArgs>
    ): Prisma.PrismaPromise<GetThreadPollOptionsAggregateType<T>>;

    /**
     * Group by ThreadPollOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollOptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ThreadPollOptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadPollOptionsGroupByArgs['orderBy'] }
        : { orderBy?: ThreadPollOptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ThreadPollOptionsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetThreadPollOptionsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ThreadPollOptions model
     */
    readonly fields: ThreadPollOptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadPollOptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadPollOptionsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ThreadPollOptions model
   */
  interface ThreadPollOptionsFieldRefs {
    readonly id: FieldRef<'ThreadPollOptions', 'String'>;
    readonly poll_id: FieldRef<'ThreadPollOptions', 'String'>;
    readonly option_text: FieldRef<'ThreadPollOptions', 'String'>;
    readonly voted_count: FieldRef<'ThreadPollOptions', 'Int'>;
    readonly created_at: FieldRef<'ThreadPollOptions', 'DateTime'>;
    readonly updated_at: FieldRef<'ThreadPollOptions', 'DateTime'>;
    readonly deleted_at: FieldRef<'ThreadPollOptions', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ThreadPollOptions findUnique
   */
  export type ThreadPollOptionsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollOptions
     */
    select?: ThreadPollOptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollOptions
     */
    omit?: ThreadPollOptionsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPollOptions to fetch.
     */
    where: ThreadPollOptionsWhereUniqueInput;
  };

  /**
   * ThreadPollOptions findUniqueOrThrow
   */
  export type ThreadPollOptionsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollOptions
     */
    select?: ThreadPollOptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollOptions
     */
    omit?: ThreadPollOptionsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPollOptions to fetch.
     */
    where: ThreadPollOptionsWhereUniqueInput;
  };

  /**
   * ThreadPollOptions findFirst
   */
  export type ThreadPollOptionsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollOptions
     */
    select?: ThreadPollOptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollOptions
     */
    omit?: ThreadPollOptionsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPollOptions to fetch.
     */
    where?: ThreadPollOptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPollOptions to fetch.
     */
    orderBy?:
      | ThreadPollOptionsOrderByWithRelationInput
      | ThreadPollOptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadPollOptions.
     */
    cursor?: ThreadPollOptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPollOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPollOptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadPollOptions.
     */
    distinct?:
      | ThreadPollOptionsScalarFieldEnum
      | ThreadPollOptionsScalarFieldEnum[];
  };

  /**
   * ThreadPollOptions findFirstOrThrow
   */
  export type ThreadPollOptionsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollOptions
     */
    select?: ThreadPollOptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollOptions
     */
    omit?: ThreadPollOptionsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPollOptions to fetch.
     */
    where?: ThreadPollOptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPollOptions to fetch.
     */
    orderBy?:
      | ThreadPollOptionsOrderByWithRelationInput
      | ThreadPollOptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadPollOptions.
     */
    cursor?: ThreadPollOptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPollOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPollOptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadPollOptions.
     */
    distinct?:
      | ThreadPollOptionsScalarFieldEnum
      | ThreadPollOptionsScalarFieldEnum[];
  };

  /**
   * ThreadPollOptions findMany
   */
  export type ThreadPollOptionsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollOptions
     */
    select?: ThreadPollOptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollOptions
     */
    omit?: ThreadPollOptionsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPollOptions to fetch.
     */
    where?: ThreadPollOptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPollOptions to fetch.
     */
    orderBy?:
      | ThreadPollOptionsOrderByWithRelationInput
      | ThreadPollOptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ThreadPollOptions.
     */
    cursor?: ThreadPollOptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPollOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPollOptions.
     */
    skip?: number;
    distinct?:
      | ThreadPollOptionsScalarFieldEnum
      | ThreadPollOptionsScalarFieldEnum[];
  };

  /**
   * ThreadPollOptions create
   */
  export type ThreadPollOptionsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollOptions
     */
    select?: ThreadPollOptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollOptions
     */
    omit?: ThreadPollOptionsOmit<ExtArgs> | null;
    /**
     * The data needed to create a ThreadPollOptions.
     */
    data: XOR<
      ThreadPollOptionsCreateInput,
      ThreadPollOptionsUncheckedCreateInput
    >;
  };

  /**
   * ThreadPollOptions createMany
   */
  export type ThreadPollOptionsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ThreadPollOptions.
     */
    data: ThreadPollOptionsCreateManyInput | ThreadPollOptionsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadPollOptions createManyAndReturn
   */
  export type ThreadPollOptionsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollOptions
     */
    select?: ThreadPollOptionsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollOptions
     */
    omit?: ThreadPollOptionsOmit<ExtArgs> | null;
    /**
     * The data used to create many ThreadPollOptions.
     */
    data: ThreadPollOptionsCreateManyInput | ThreadPollOptionsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadPollOptions update
   */
  export type ThreadPollOptionsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollOptions
     */
    select?: ThreadPollOptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollOptions
     */
    omit?: ThreadPollOptionsOmit<ExtArgs> | null;
    /**
     * The data needed to update a ThreadPollOptions.
     */
    data: XOR<
      ThreadPollOptionsUpdateInput,
      ThreadPollOptionsUncheckedUpdateInput
    >;
    /**
     * Choose, which ThreadPollOptions to update.
     */
    where: ThreadPollOptionsWhereUniqueInput;
  };

  /**
   * ThreadPollOptions updateMany
   */
  export type ThreadPollOptionsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ThreadPollOptions.
     */
    data: XOR<
      ThreadPollOptionsUpdateManyMutationInput,
      ThreadPollOptionsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadPollOptions to update
     */
    where?: ThreadPollOptionsWhereInput;
    /**
     * Limit how many ThreadPollOptions to update.
     */
    limit?: number;
  };

  /**
   * ThreadPollOptions updateManyAndReturn
   */
  export type ThreadPollOptionsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollOptions
     */
    select?: ThreadPollOptionsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollOptions
     */
    omit?: ThreadPollOptionsOmit<ExtArgs> | null;
    /**
     * The data used to update ThreadPollOptions.
     */
    data: XOR<
      ThreadPollOptionsUpdateManyMutationInput,
      ThreadPollOptionsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadPollOptions to update
     */
    where?: ThreadPollOptionsWhereInput;
    /**
     * Limit how many ThreadPollOptions to update.
     */
    limit?: number;
  };

  /**
   * ThreadPollOptions upsert
   */
  export type ThreadPollOptionsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollOptions
     */
    select?: ThreadPollOptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollOptions
     */
    omit?: ThreadPollOptionsOmit<ExtArgs> | null;
    /**
     * The filter to search for the ThreadPollOptions to update in case it exists.
     */
    where: ThreadPollOptionsWhereUniqueInput;
    /**
     * In case the ThreadPollOptions found by the `where` argument doesn't exist, create a new ThreadPollOptions with this data.
     */
    create: XOR<
      ThreadPollOptionsCreateInput,
      ThreadPollOptionsUncheckedCreateInput
    >;
    /**
     * In case the ThreadPollOptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      ThreadPollOptionsUpdateInput,
      ThreadPollOptionsUncheckedUpdateInput
    >;
  };

  /**
   * ThreadPollOptions delete
   */
  export type ThreadPollOptionsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollOptions
     */
    select?: ThreadPollOptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollOptions
     */
    omit?: ThreadPollOptionsOmit<ExtArgs> | null;
    /**
     * Filter which ThreadPollOptions to delete.
     */
    where: ThreadPollOptionsWhereUniqueInput;
  };

  /**
   * ThreadPollOptions deleteMany
   */
  export type ThreadPollOptionsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadPollOptions to delete
     */
    where?: ThreadPollOptionsWhereInput;
    /**
     * Limit how many ThreadPollOptions to delete.
     */
    limit?: number;
  };

  /**
   * ThreadPollOptions without action
   */
  export type ThreadPollOptionsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollOptions
     */
    select?: ThreadPollOptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollOptions
     */
    omit?: ThreadPollOptionsOmit<ExtArgs> | null;
  };

  /**
   * Model ThreadPollVotes
   */

  export type AggregateThreadPollVotes = {
    _count: ThreadPollVotesCountAggregateOutputType | null;
    _avg: ThreadPollVotesAvgAggregateOutputType | null;
    _sum: ThreadPollVotesSumAggregateOutputType | null;
    _min: ThreadPollVotesMinAggregateOutputType | null;
    _max: ThreadPollVotesMaxAggregateOutputType | null;
  };

  export type ThreadPollVotesAvgAggregateOutputType = {
    user_id: number | null;
  };

  export type ThreadPollVotesSumAggregateOutputType = {
    user_id: number | null;
  };

  export type ThreadPollVotesMinAggregateOutputType = {
    id: string | null;
    option_id: string | null;
    user_id: number | null;
    voted_at: Date | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadPollVotesMaxAggregateOutputType = {
    id: string | null;
    option_id: string | null;
    user_id: number | null;
    voted_at: Date | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadPollVotesCountAggregateOutputType = {
    id: number;
    option_id: number;
    user_id: number;
    voted_at: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type ThreadPollVotesAvgAggregateInputType = {
    user_id?: true;
  };

  export type ThreadPollVotesSumAggregateInputType = {
    user_id?: true;
  };

  export type ThreadPollVotesMinAggregateInputType = {
    id?: true;
    option_id?: true;
    user_id?: true;
    voted_at?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadPollVotesMaxAggregateInputType = {
    id?: true;
    option_id?: true;
    user_id?: true;
    voted_at?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadPollVotesCountAggregateInputType = {
    id?: true;
    option_id?: true;
    user_id?: true;
    voted_at?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type ThreadPollVotesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadPollVotes to aggregate.
     */
    where?: ThreadPollVotesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPollVotes to fetch.
     */
    orderBy?:
      | ThreadPollVotesOrderByWithRelationInput
      | ThreadPollVotesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ThreadPollVotesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPollVotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPollVotes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ThreadPollVotes
     **/
    _count?: true | ThreadPollVotesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ThreadPollVotesAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ThreadPollVotesSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ThreadPollVotesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ThreadPollVotesMaxAggregateInputType;
  };

  export type GetThreadPollVotesAggregateType<
    T extends ThreadPollVotesAggregateArgs
  > = {
    [P in keyof T & keyof AggregateThreadPollVotes]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreadPollVotes[P]>
      : GetScalarType<T[P], AggregateThreadPollVotes[P]>;
  };

  export type ThreadPollVotesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ThreadPollVotesWhereInput;
    orderBy?:
      | ThreadPollVotesOrderByWithAggregationInput
      | ThreadPollVotesOrderByWithAggregationInput[];
    by: ThreadPollVotesScalarFieldEnum[] | ThreadPollVotesScalarFieldEnum;
    having?: ThreadPollVotesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ThreadPollVotesCountAggregateInputType | true;
    _avg?: ThreadPollVotesAvgAggregateInputType;
    _sum?: ThreadPollVotesSumAggregateInputType;
    _min?: ThreadPollVotesMinAggregateInputType;
    _max?: ThreadPollVotesMaxAggregateInputType;
  };

  export type ThreadPollVotesGroupByOutputType = {
    id: string;
    option_id: string;
    user_id: number;
    voted_at: Date;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: ThreadPollVotesCountAggregateOutputType | null;
    _avg: ThreadPollVotesAvgAggregateOutputType | null;
    _sum: ThreadPollVotesSumAggregateOutputType | null;
    _min: ThreadPollVotesMinAggregateOutputType | null;
    _max: ThreadPollVotesMaxAggregateOutputType | null;
  };

  type GetThreadPollVotesGroupByPayload<T extends ThreadPollVotesGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ThreadPollVotesGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof ThreadPollVotesGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadPollVotesGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadPollVotesGroupByOutputType[P]>;
        }
      >
    >;

  export type ThreadPollVotesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      option_id?: boolean;
      user_id?: boolean;
      voted_at?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadPollVotes']
  >;

  export type ThreadPollVotesSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      option_id?: boolean;
      user_id?: boolean;
      voted_at?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadPollVotes']
  >;

  export type ThreadPollVotesSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      option_id?: boolean;
      user_id?: boolean;
      voted_at?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadPollVotes']
  >;

  export type ThreadPollVotesSelectScalar = {
    id?: boolean;
    option_id?: boolean;
    user_id?: boolean;
    voted_at?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type ThreadPollVotesOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'option_id'
    | 'user_id'
    | 'voted_at'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['threadPollVotes']
  >;

  export type $ThreadPollVotesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ThreadPollVotes';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        option_id: string;
        user_id: number;
        voted_at: Date;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['threadPollVotes']
    >;
    composites: {};
  };

  type ThreadPollVotesGetPayload<
    S extends boolean | null | undefined | ThreadPollVotesDefaultArgs
  > = $Result.GetResult<Prisma.$ThreadPollVotesPayload, S>;

  type ThreadPollVotesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    ThreadPollVotesFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ThreadPollVotesCountAggregateInputType | true;
  };

  export interface ThreadPollVotesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ThreadPollVotes'];
      meta: { name: 'ThreadPollVotes' };
    };
    /**
     * Find zero or one ThreadPollVotes that matches the filter.
     * @param {ThreadPollVotesFindUniqueArgs} args - Arguments to find a ThreadPollVotes
     * @example
     * // Get one ThreadPollVotes
     * const threadPollVotes = await prisma.threadPollVotes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadPollVotesFindUniqueArgs>(
      args: SelectSubset<T, ThreadPollVotesFindUniqueArgs<ExtArgs>>
    ): Prisma__ThreadPollVotesClient<
      $Result.GetResult<
        Prisma.$ThreadPollVotesPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ThreadPollVotes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadPollVotesFindUniqueOrThrowArgs} args - Arguments to find a ThreadPollVotes
     * @example
     * // Get one ThreadPollVotes
     * const threadPollVotes = await prisma.threadPollVotes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadPollVotesFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ThreadPollVotesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadPollVotesClient<
      $Result.GetResult<
        Prisma.$ThreadPollVotesPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadPollVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollVotesFindFirstArgs} args - Arguments to find a ThreadPollVotes
     * @example
     * // Get one ThreadPollVotes
     * const threadPollVotes = await prisma.threadPollVotes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadPollVotesFindFirstArgs>(
      args?: SelectSubset<T, ThreadPollVotesFindFirstArgs<ExtArgs>>
    ): Prisma__ThreadPollVotesClient<
      $Result.GetResult<
        Prisma.$ThreadPollVotesPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadPollVotes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollVotesFindFirstOrThrowArgs} args - Arguments to find a ThreadPollVotes
     * @example
     * // Get one ThreadPollVotes
     * const threadPollVotes = await prisma.threadPollVotes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadPollVotesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadPollVotesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadPollVotesClient<
      $Result.GetResult<
        Prisma.$ThreadPollVotesPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ThreadPollVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollVotesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadPollVotes
     * const threadPollVotes = await prisma.threadPollVotes.findMany()
     *
     * // Get first 10 ThreadPollVotes
     * const threadPollVotes = await prisma.threadPollVotes.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const threadPollVotesWithIdOnly = await prisma.threadPollVotes.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ThreadPollVotesFindManyArgs>(
      args?: SelectSubset<T, ThreadPollVotesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadPollVotesPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ThreadPollVotes.
     * @param {ThreadPollVotesCreateArgs} args - Arguments to create a ThreadPollVotes.
     * @example
     * // Create one ThreadPollVotes
     * const ThreadPollVotes = await prisma.threadPollVotes.create({
     *   data: {
     *     // ... data to create a ThreadPollVotes
     *   }
     * })
     *
     */
    create<T extends ThreadPollVotesCreateArgs>(
      args: SelectSubset<T, ThreadPollVotesCreateArgs<ExtArgs>>
    ): Prisma__ThreadPollVotesClient<
      $Result.GetResult<
        Prisma.$ThreadPollVotesPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ThreadPollVotes.
     * @param {ThreadPollVotesCreateManyArgs} args - Arguments to create many ThreadPollVotes.
     * @example
     * // Create many ThreadPollVotes
     * const threadPollVotes = await prisma.threadPollVotes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ThreadPollVotesCreateManyArgs>(
      args?: SelectSubset<T, ThreadPollVotesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ThreadPollVotes and returns the data saved in the database.
     * @param {ThreadPollVotesCreateManyAndReturnArgs} args - Arguments to create many ThreadPollVotes.
     * @example
     * // Create many ThreadPollVotes
     * const threadPollVotes = await prisma.threadPollVotes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ThreadPollVotes and only return the `id`
     * const threadPollVotesWithIdOnly = await prisma.threadPollVotes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ThreadPollVotesCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ThreadPollVotesCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadPollVotesPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ThreadPollVotes.
     * @param {ThreadPollVotesDeleteArgs} args - Arguments to delete one ThreadPollVotes.
     * @example
     * // Delete one ThreadPollVotes
     * const ThreadPollVotes = await prisma.threadPollVotes.delete({
     *   where: {
     *     // ... filter to delete one ThreadPollVotes
     *   }
     * })
     *
     */
    delete<T extends ThreadPollVotesDeleteArgs>(
      args: SelectSubset<T, ThreadPollVotesDeleteArgs<ExtArgs>>
    ): Prisma__ThreadPollVotesClient<
      $Result.GetResult<
        Prisma.$ThreadPollVotesPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ThreadPollVotes.
     * @param {ThreadPollVotesUpdateArgs} args - Arguments to update one ThreadPollVotes.
     * @example
     * // Update one ThreadPollVotes
     * const threadPollVotes = await prisma.threadPollVotes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ThreadPollVotesUpdateArgs>(
      args: SelectSubset<T, ThreadPollVotesUpdateArgs<ExtArgs>>
    ): Prisma__ThreadPollVotesClient<
      $Result.GetResult<
        Prisma.$ThreadPollVotesPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ThreadPollVotes.
     * @param {ThreadPollVotesDeleteManyArgs} args - Arguments to filter ThreadPollVotes to delete.
     * @example
     * // Delete a few ThreadPollVotes
     * const { count } = await prisma.threadPollVotes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ThreadPollVotesDeleteManyArgs>(
      args?: SelectSubset<T, ThreadPollVotesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadPollVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollVotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadPollVotes
     * const threadPollVotes = await prisma.threadPollVotes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ThreadPollVotesUpdateManyArgs>(
      args: SelectSubset<T, ThreadPollVotesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadPollVotes and returns the data updated in the database.
     * @param {ThreadPollVotesUpdateManyAndReturnArgs} args - Arguments to update many ThreadPollVotes.
     * @example
     * // Update many ThreadPollVotes
     * const threadPollVotes = await prisma.threadPollVotes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ThreadPollVotes and only return the `id`
     * const threadPollVotesWithIdOnly = await prisma.threadPollVotes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ThreadPollVotesUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ThreadPollVotesUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadPollVotesPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ThreadPollVotes.
     * @param {ThreadPollVotesUpsertArgs} args - Arguments to update or create a ThreadPollVotes.
     * @example
     * // Update or create a ThreadPollVotes
     * const threadPollVotes = await prisma.threadPollVotes.upsert({
     *   create: {
     *     // ... data to create a ThreadPollVotes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadPollVotes we want to update
     *   }
     * })
     */
    upsert<T extends ThreadPollVotesUpsertArgs>(
      args: SelectSubset<T, ThreadPollVotesUpsertArgs<ExtArgs>>
    ): Prisma__ThreadPollVotesClient<
      $Result.GetResult<
        Prisma.$ThreadPollVotesPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ThreadPollVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollVotesCountArgs} args - Arguments to filter ThreadPollVotes to count.
     * @example
     * // Count the number of ThreadPollVotes
     * const count = await prisma.threadPollVotes.count({
     *   where: {
     *     // ... the filter for the ThreadPollVotes we want to count
     *   }
     * })
     **/
    count<T extends ThreadPollVotesCountArgs>(
      args?: Subset<T, ThreadPollVotesCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadPollVotesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ThreadPollVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollVotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ThreadPollVotesAggregateArgs>(
      args: Subset<T, ThreadPollVotesAggregateArgs>
    ): Prisma.PrismaPromise<GetThreadPollVotesAggregateType<T>>;

    /**
     * Group by ThreadPollVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollVotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ThreadPollVotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadPollVotesGroupByArgs['orderBy'] }
        : { orderBy?: ThreadPollVotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ThreadPollVotesGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetThreadPollVotesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ThreadPollVotes model
     */
    readonly fields: ThreadPollVotesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadPollVotes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadPollVotesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ThreadPollVotes model
   */
  interface ThreadPollVotesFieldRefs {
    readonly id: FieldRef<'ThreadPollVotes', 'String'>;
    readonly option_id: FieldRef<'ThreadPollVotes', 'String'>;
    readonly user_id: FieldRef<'ThreadPollVotes', 'Int'>;
    readonly voted_at: FieldRef<'ThreadPollVotes', 'DateTime'>;
    readonly created_at: FieldRef<'ThreadPollVotes', 'DateTime'>;
    readonly updated_at: FieldRef<'ThreadPollVotes', 'DateTime'>;
    readonly deleted_at: FieldRef<'ThreadPollVotes', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ThreadPollVotes findUnique
   */
  export type ThreadPollVotesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollVotes
     */
    select?: ThreadPollVotesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollVotes
     */
    omit?: ThreadPollVotesOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPollVotes to fetch.
     */
    where: ThreadPollVotesWhereUniqueInput;
  };

  /**
   * ThreadPollVotes findUniqueOrThrow
   */
  export type ThreadPollVotesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollVotes
     */
    select?: ThreadPollVotesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollVotes
     */
    omit?: ThreadPollVotesOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPollVotes to fetch.
     */
    where: ThreadPollVotesWhereUniqueInput;
  };

  /**
   * ThreadPollVotes findFirst
   */
  export type ThreadPollVotesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollVotes
     */
    select?: ThreadPollVotesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollVotes
     */
    omit?: ThreadPollVotesOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPollVotes to fetch.
     */
    where?: ThreadPollVotesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPollVotes to fetch.
     */
    orderBy?:
      | ThreadPollVotesOrderByWithRelationInput
      | ThreadPollVotesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadPollVotes.
     */
    cursor?: ThreadPollVotesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPollVotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPollVotes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadPollVotes.
     */
    distinct?:
      | ThreadPollVotesScalarFieldEnum
      | ThreadPollVotesScalarFieldEnum[];
  };

  /**
   * ThreadPollVotes findFirstOrThrow
   */
  export type ThreadPollVotesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollVotes
     */
    select?: ThreadPollVotesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollVotes
     */
    omit?: ThreadPollVotesOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPollVotes to fetch.
     */
    where?: ThreadPollVotesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPollVotes to fetch.
     */
    orderBy?:
      | ThreadPollVotesOrderByWithRelationInput
      | ThreadPollVotesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadPollVotes.
     */
    cursor?: ThreadPollVotesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPollVotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPollVotes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadPollVotes.
     */
    distinct?:
      | ThreadPollVotesScalarFieldEnum
      | ThreadPollVotesScalarFieldEnum[];
  };

  /**
   * ThreadPollVotes findMany
   */
  export type ThreadPollVotesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollVotes
     */
    select?: ThreadPollVotesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollVotes
     */
    omit?: ThreadPollVotesOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPollVotes to fetch.
     */
    where?: ThreadPollVotesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPollVotes to fetch.
     */
    orderBy?:
      | ThreadPollVotesOrderByWithRelationInput
      | ThreadPollVotesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ThreadPollVotes.
     */
    cursor?: ThreadPollVotesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPollVotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPollVotes.
     */
    skip?: number;
    distinct?:
      | ThreadPollVotesScalarFieldEnum
      | ThreadPollVotesScalarFieldEnum[];
  };

  /**
   * ThreadPollVotes create
   */
  export type ThreadPollVotesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollVotes
     */
    select?: ThreadPollVotesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollVotes
     */
    omit?: ThreadPollVotesOmit<ExtArgs> | null;
    /**
     * The data needed to create a ThreadPollVotes.
     */
    data: XOR<ThreadPollVotesCreateInput, ThreadPollVotesUncheckedCreateInput>;
  };

  /**
   * ThreadPollVotes createMany
   */
  export type ThreadPollVotesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ThreadPollVotes.
     */
    data: ThreadPollVotesCreateManyInput | ThreadPollVotesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadPollVotes createManyAndReturn
   */
  export type ThreadPollVotesCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollVotes
     */
    select?: ThreadPollVotesSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollVotes
     */
    omit?: ThreadPollVotesOmit<ExtArgs> | null;
    /**
     * The data used to create many ThreadPollVotes.
     */
    data: ThreadPollVotesCreateManyInput | ThreadPollVotesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadPollVotes update
   */
  export type ThreadPollVotesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollVotes
     */
    select?: ThreadPollVotesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollVotes
     */
    omit?: ThreadPollVotesOmit<ExtArgs> | null;
    /**
     * The data needed to update a ThreadPollVotes.
     */
    data: XOR<ThreadPollVotesUpdateInput, ThreadPollVotesUncheckedUpdateInput>;
    /**
     * Choose, which ThreadPollVotes to update.
     */
    where: ThreadPollVotesWhereUniqueInput;
  };

  /**
   * ThreadPollVotes updateMany
   */
  export type ThreadPollVotesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ThreadPollVotes.
     */
    data: XOR<
      ThreadPollVotesUpdateManyMutationInput,
      ThreadPollVotesUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadPollVotes to update
     */
    where?: ThreadPollVotesWhereInput;
    /**
     * Limit how many ThreadPollVotes to update.
     */
    limit?: number;
  };

  /**
   * ThreadPollVotes updateManyAndReturn
   */
  export type ThreadPollVotesUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollVotes
     */
    select?: ThreadPollVotesSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollVotes
     */
    omit?: ThreadPollVotesOmit<ExtArgs> | null;
    /**
     * The data used to update ThreadPollVotes.
     */
    data: XOR<
      ThreadPollVotesUpdateManyMutationInput,
      ThreadPollVotesUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadPollVotes to update
     */
    where?: ThreadPollVotesWhereInput;
    /**
     * Limit how many ThreadPollVotes to update.
     */
    limit?: number;
  };

  /**
   * ThreadPollVotes upsert
   */
  export type ThreadPollVotesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollVotes
     */
    select?: ThreadPollVotesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollVotes
     */
    omit?: ThreadPollVotesOmit<ExtArgs> | null;
    /**
     * The filter to search for the ThreadPollVotes to update in case it exists.
     */
    where: ThreadPollVotesWhereUniqueInput;
    /**
     * In case the ThreadPollVotes found by the `where` argument doesn't exist, create a new ThreadPollVotes with this data.
     */
    create: XOR<
      ThreadPollVotesCreateInput,
      ThreadPollVotesUncheckedCreateInput
    >;
    /**
     * In case the ThreadPollVotes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      ThreadPollVotesUpdateInput,
      ThreadPollVotesUncheckedUpdateInput
    >;
  };

  /**
   * ThreadPollVotes delete
   */
  export type ThreadPollVotesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollVotes
     */
    select?: ThreadPollVotesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollVotes
     */
    omit?: ThreadPollVotesOmit<ExtArgs> | null;
    /**
     * Filter which ThreadPollVotes to delete.
     */
    where: ThreadPollVotesWhereUniqueInput;
  };

  /**
   * ThreadPollVotes deleteMany
   */
  export type ThreadPollVotesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadPollVotes to delete
     */
    where?: ThreadPollVotesWhereInput;
    /**
     * Limit how many ThreadPollVotes to delete.
     */
    limit?: number;
  };

  /**
   * ThreadPollVotes without action
   */
  export type ThreadPollVotesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPollVotes
     */
    select?: ThreadPollVotesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPollVotes
     */
    omit?: ThreadPollVotesOmit<ExtArgs> | null;
  };

  /**
   * Model ThreadPolls
   */

  export type AggregateThreadPolls = {
    _count: ThreadPollsCountAggregateOutputType | null;
    _avg: ThreadPollsAvgAggregateOutputType | null;
    _sum: ThreadPollsSumAggregateOutputType | null;
    _min: ThreadPollsMinAggregateOutputType | null;
    _max: ThreadPollsMaxAggregateOutputType | null;
  };

  export type ThreadPollsAvgAggregateOutputType = {
    total_voted: number | null;
  };

  export type ThreadPollsSumAggregateOutputType = {
    total_voted: number | null;
  };

  export type ThreadPollsMinAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    question: string | null;
    total_voted: number | null;
    expires_at: Date | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadPollsMaxAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    question: string | null;
    total_voted: number | null;
    expires_at: Date | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadPollsCountAggregateOutputType = {
    id: number;
    threads_id: number;
    question: number;
    total_voted: number;
    expires_at: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type ThreadPollsAvgAggregateInputType = {
    total_voted?: true;
  };

  export type ThreadPollsSumAggregateInputType = {
    total_voted?: true;
  };

  export type ThreadPollsMinAggregateInputType = {
    id?: true;
    threads_id?: true;
    question?: true;
    total_voted?: true;
    expires_at?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadPollsMaxAggregateInputType = {
    id?: true;
    threads_id?: true;
    question?: true;
    total_voted?: true;
    expires_at?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadPollsCountAggregateInputType = {
    id?: true;
    threads_id?: true;
    question?: true;
    total_voted?: true;
    expires_at?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type ThreadPollsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadPolls to aggregate.
     */
    where?: ThreadPollsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPolls to fetch.
     */
    orderBy?:
      | ThreadPollsOrderByWithRelationInput
      | ThreadPollsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ThreadPollsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPolls from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPolls.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ThreadPolls
     **/
    _count?: true | ThreadPollsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ThreadPollsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ThreadPollsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ThreadPollsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ThreadPollsMaxAggregateInputType;
  };

  export type GetThreadPollsAggregateType<T extends ThreadPollsAggregateArgs> =
    {
      [P in keyof T & keyof AggregateThreadPolls]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateThreadPolls[P]>
        : GetScalarType<T[P], AggregateThreadPolls[P]>;
    };

  export type ThreadPollsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ThreadPollsWhereInput;
    orderBy?:
      | ThreadPollsOrderByWithAggregationInput
      | ThreadPollsOrderByWithAggregationInput[];
    by: ThreadPollsScalarFieldEnum[] | ThreadPollsScalarFieldEnum;
    having?: ThreadPollsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ThreadPollsCountAggregateInputType | true;
    _avg?: ThreadPollsAvgAggregateInputType;
    _sum?: ThreadPollsSumAggregateInputType;
    _min?: ThreadPollsMinAggregateInputType;
    _max?: ThreadPollsMaxAggregateInputType;
  };

  export type ThreadPollsGroupByOutputType = {
    id: string;
    threads_id: string;
    question: string;
    total_voted: number;
    expires_at: Date;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: ThreadPollsCountAggregateOutputType | null;
    _avg: ThreadPollsAvgAggregateOutputType | null;
    _sum: ThreadPollsSumAggregateOutputType | null;
    _min: ThreadPollsMinAggregateOutputType | null;
    _max: ThreadPollsMaxAggregateOutputType | null;
  };

  type GetThreadPollsGroupByPayload<T extends ThreadPollsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ThreadPollsGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof ThreadPollsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadPollsGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadPollsGroupByOutputType[P]>;
        }
      >
    >;

  export type ThreadPollsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      question?: boolean;
      total_voted?: boolean;
      expires_at?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadPolls']
  >;

  export type ThreadPollsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      question?: boolean;
      total_voted?: boolean;
      expires_at?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadPolls']
  >;

  export type ThreadPollsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      question?: boolean;
      total_voted?: boolean;
      expires_at?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadPolls']
  >;

  export type ThreadPollsSelectScalar = {
    id?: boolean;
    threads_id?: boolean;
    question?: boolean;
    total_voted?: boolean;
    expires_at?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type ThreadPollsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'threads_id'
    | 'question'
    | 'total_voted'
    | 'expires_at'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['threadPolls']
  >;

  export type $ThreadPollsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ThreadPolls';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        threads_id: string;
        question: string;
        total_voted: number;
        expires_at: Date;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['threadPolls']
    >;
    composites: {};
  };

  type ThreadPollsGetPayload<
    S extends boolean | null | undefined | ThreadPollsDefaultArgs
  > = $Result.GetResult<Prisma.$ThreadPollsPayload, S>;

  type ThreadPollsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    ThreadPollsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ThreadPollsCountAggregateInputType | true;
  };

  export interface ThreadPollsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ThreadPolls'];
      meta: { name: 'ThreadPolls' };
    };
    /**
     * Find zero or one ThreadPolls that matches the filter.
     * @param {ThreadPollsFindUniqueArgs} args - Arguments to find a ThreadPolls
     * @example
     * // Get one ThreadPolls
     * const threadPolls = await prisma.threadPolls.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadPollsFindUniqueArgs>(
      args: SelectSubset<T, ThreadPollsFindUniqueArgs<ExtArgs>>
    ): Prisma__ThreadPollsClient<
      $Result.GetResult<
        Prisma.$ThreadPollsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ThreadPolls that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadPollsFindUniqueOrThrowArgs} args - Arguments to find a ThreadPolls
     * @example
     * // Get one ThreadPolls
     * const threadPolls = await prisma.threadPolls.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadPollsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ThreadPollsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadPollsClient<
      $Result.GetResult<
        Prisma.$ThreadPollsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadPolls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollsFindFirstArgs} args - Arguments to find a ThreadPolls
     * @example
     * // Get one ThreadPolls
     * const threadPolls = await prisma.threadPolls.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadPollsFindFirstArgs>(
      args?: SelectSubset<T, ThreadPollsFindFirstArgs<ExtArgs>>
    ): Prisma__ThreadPollsClient<
      $Result.GetResult<
        Prisma.$ThreadPollsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadPolls that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollsFindFirstOrThrowArgs} args - Arguments to find a ThreadPolls
     * @example
     * // Get one ThreadPolls
     * const threadPolls = await prisma.threadPolls.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadPollsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadPollsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadPollsClient<
      $Result.GetResult<
        Prisma.$ThreadPollsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ThreadPolls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadPolls
     * const threadPolls = await prisma.threadPolls.findMany()
     *
     * // Get first 10 ThreadPolls
     * const threadPolls = await prisma.threadPolls.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const threadPollsWithIdOnly = await prisma.threadPolls.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ThreadPollsFindManyArgs>(
      args?: SelectSubset<T, ThreadPollsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadPollsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ThreadPolls.
     * @param {ThreadPollsCreateArgs} args - Arguments to create a ThreadPolls.
     * @example
     * // Create one ThreadPolls
     * const ThreadPolls = await prisma.threadPolls.create({
     *   data: {
     *     // ... data to create a ThreadPolls
     *   }
     * })
     *
     */
    create<T extends ThreadPollsCreateArgs>(
      args: SelectSubset<T, ThreadPollsCreateArgs<ExtArgs>>
    ): Prisma__ThreadPollsClient<
      $Result.GetResult<
        Prisma.$ThreadPollsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ThreadPolls.
     * @param {ThreadPollsCreateManyArgs} args - Arguments to create many ThreadPolls.
     * @example
     * // Create many ThreadPolls
     * const threadPolls = await prisma.threadPolls.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ThreadPollsCreateManyArgs>(
      args?: SelectSubset<T, ThreadPollsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ThreadPolls and returns the data saved in the database.
     * @param {ThreadPollsCreateManyAndReturnArgs} args - Arguments to create many ThreadPolls.
     * @example
     * // Create many ThreadPolls
     * const threadPolls = await prisma.threadPolls.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ThreadPolls and only return the `id`
     * const threadPollsWithIdOnly = await prisma.threadPolls.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ThreadPollsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ThreadPollsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadPollsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ThreadPolls.
     * @param {ThreadPollsDeleteArgs} args - Arguments to delete one ThreadPolls.
     * @example
     * // Delete one ThreadPolls
     * const ThreadPolls = await prisma.threadPolls.delete({
     *   where: {
     *     // ... filter to delete one ThreadPolls
     *   }
     * })
     *
     */
    delete<T extends ThreadPollsDeleteArgs>(
      args: SelectSubset<T, ThreadPollsDeleteArgs<ExtArgs>>
    ): Prisma__ThreadPollsClient<
      $Result.GetResult<
        Prisma.$ThreadPollsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ThreadPolls.
     * @param {ThreadPollsUpdateArgs} args - Arguments to update one ThreadPolls.
     * @example
     * // Update one ThreadPolls
     * const threadPolls = await prisma.threadPolls.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ThreadPollsUpdateArgs>(
      args: SelectSubset<T, ThreadPollsUpdateArgs<ExtArgs>>
    ): Prisma__ThreadPollsClient<
      $Result.GetResult<
        Prisma.$ThreadPollsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ThreadPolls.
     * @param {ThreadPollsDeleteManyArgs} args - Arguments to filter ThreadPolls to delete.
     * @example
     * // Delete a few ThreadPolls
     * const { count } = await prisma.threadPolls.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ThreadPollsDeleteManyArgs>(
      args?: SelectSubset<T, ThreadPollsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadPolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadPolls
     * const threadPolls = await prisma.threadPolls.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ThreadPollsUpdateManyArgs>(
      args: SelectSubset<T, ThreadPollsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadPolls and returns the data updated in the database.
     * @param {ThreadPollsUpdateManyAndReturnArgs} args - Arguments to update many ThreadPolls.
     * @example
     * // Update many ThreadPolls
     * const threadPolls = await prisma.threadPolls.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ThreadPolls and only return the `id`
     * const threadPollsWithIdOnly = await prisma.threadPolls.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ThreadPollsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ThreadPollsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadPollsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ThreadPolls.
     * @param {ThreadPollsUpsertArgs} args - Arguments to update or create a ThreadPolls.
     * @example
     * // Update or create a ThreadPolls
     * const threadPolls = await prisma.threadPolls.upsert({
     *   create: {
     *     // ... data to create a ThreadPolls
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadPolls we want to update
     *   }
     * })
     */
    upsert<T extends ThreadPollsUpsertArgs>(
      args: SelectSubset<T, ThreadPollsUpsertArgs<ExtArgs>>
    ): Prisma__ThreadPollsClient<
      $Result.GetResult<
        Prisma.$ThreadPollsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ThreadPolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollsCountArgs} args - Arguments to filter ThreadPolls to count.
     * @example
     * // Count the number of ThreadPolls
     * const count = await prisma.threadPolls.count({
     *   where: {
     *     // ... the filter for the ThreadPolls we want to count
     *   }
     * })
     **/
    count<T extends ThreadPollsCountArgs>(
      args?: Subset<T, ThreadPollsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadPollsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ThreadPolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ThreadPollsAggregateArgs>(
      args: Subset<T, ThreadPollsAggregateArgs>
    ): Prisma.PrismaPromise<GetThreadPollsAggregateType<T>>;

    /**
     * Group by ThreadPolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadPollsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ThreadPollsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadPollsGroupByArgs['orderBy'] }
        : { orderBy?: ThreadPollsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ThreadPollsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetThreadPollsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ThreadPolls model
     */
    readonly fields: ThreadPollsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadPolls.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadPollsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ThreadPolls model
   */
  interface ThreadPollsFieldRefs {
    readonly id: FieldRef<'ThreadPolls', 'String'>;
    readonly threads_id: FieldRef<'ThreadPolls', 'String'>;
    readonly question: FieldRef<'ThreadPolls', 'String'>;
    readonly total_voted: FieldRef<'ThreadPolls', 'Int'>;
    readonly expires_at: FieldRef<'ThreadPolls', 'DateTime'>;
    readonly created_at: FieldRef<'ThreadPolls', 'DateTime'>;
    readonly updated_at: FieldRef<'ThreadPolls', 'DateTime'>;
    readonly deleted_at: FieldRef<'ThreadPolls', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ThreadPolls findUnique
   */
  export type ThreadPollsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPolls
     */
    select?: ThreadPollsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPolls
     */
    omit?: ThreadPollsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPolls to fetch.
     */
    where: ThreadPollsWhereUniqueInput;
  };

  /**
   * ThreadPolls findUniqueOrThrow
   */
  export type ThreadPollsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPolls
     */
    select?: ThreadPollsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPolls
     */
    omit?: ThreadPollsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPolls to fetch.
     */
    where: ThreadPollsWhereUniqueInput;
  };

  /**
   * ThreadPolls findFirst
   */
  export type ThreadPollsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPolls
     */
    select?: ThreadPollsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPolls
     */
    omit?: ThreadPollsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPolls to fetch.
     */
    where?: ThreadPollsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPolls to fetch.
     */
    orderBy?:
      | ThreadPollsOrderByWithRelationInput
      | ThreadPollsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadPolls.
     */
    cursor?: ThreadPollsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPolls from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPolls.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadPolls.
     */
    distinct?: ThreadPollsScalarFieldEnum | ThreadPollsScalarFieldEnum[];
  };

  /**
   * ThreadPolls findFirstOrThrow
   */
  export type ThreadPollsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPolls
     */
    select?: ThreadPollsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPolls
     */
    omit?: ThreadPollsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPolls to fetch.
     */
    where?: ThreadPollsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPolls to fetch.
     */
    orderBy?:
      | ThreadPollsOrderByWithRelationInput
      | ThreadPollsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadPolls.
     */
    cursor?: ThreadPollsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPolls from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPolls.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadPolls.
     */
    distinct?: ThreadPollsScalarFieldEnum | ThreadPollsScalarFieldEnum[];
  };

  /**
   * ThreadPolls findMany
   */
  export type ThreadPollsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPolls
     */
    select?: ThreadPollsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPolls
     */
    omit?: ThreadPollsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadPolls to fetch.
     */
    where?: ThreadPollsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadPolls to fetch.
     */
    orderBy?:
      | ThreadPollsOrderByWithRelationInput
      | ThreadPollsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ThreadPolls.
     */
    cursor?: ThreadPollsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadPolls from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadPolls.
     */
    skip?: number;
    distinct?: ThreadPollsScalarFieldEnum | ThreadPollsScalarFieldEnum[];
  };

  /**
   * ThreadPolls create
   */
  export type ThreadPollsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPolls
     */
    select?: ThreadPollsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPolls
     */
    omit?: ThreadPollsOmit<ExtArgs> | null;
    /**
     * The data needed to create a ThreadPolls.
     */
    data: XOR<ThreadPollsCreateInput, ThreadPollsUncheckedCreateInput>;
  };

  /**
   * ThreadPolls createMany
   */
  export type ThreadPollsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ThreadPolls.
     */
    data: ThreadPollsCreateManyInput | ThreadPollsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadPolls createManyAndReturn
   */
  export type ThreadPollsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPolls
     */
    select?: ThreadPollsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPolls
     */
    omit?: ThreadPollsOmit<ExtArgs> | null;
    /**
     * The data used to create many ThreadPolls.
     */
    data: ThreadPollsCreateManyInput | ThreadPollsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadPolls update
   */
  export type ThreadPollsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPolls
     */
    select?: ThreadPollsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPolls
     */
    omit?: ThreadPollsOmit<ExtArgs> | null;
    /**
     * The data needed to update a ThreadPolls.
     */
    data: XOR<ThreadPollsUpdateInput, ThreadPollsUncheckedUpdateInput>;
    /**
     * Choose, which ThreadPolls to update.
     */
    where: ThreadPollsWhereUniqueInput;
  };

  /**
   * ThreadPolls updateMany
   */
  export type ThreadPollsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ThreadPolls.
     */
    data: XOR<
      ThreadPollsUpdateManyMutationInput,
      ThreadPollsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadPolls to update
     */
    where?: ThreadPollsWhereInput;
    /**
     * Limit how many ThreadPolls to update.
     */
    limit?: number;
  };

  /**
   * ThreadPolls updateManyAndReturn
   */
  export type ThreadPollsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPolls
     */
    select?: ThreadPollsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPolls
     */
    omit?: ThreadPollsOmit<ExtArgs> | null;
    /**
     * The data used to update ThreadPolls.
     */
    data: XOR<
      ThreadPollsUpdateManyMutationInput,
      ThreadPollsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadPolls to update
     */
    where?: ThreadPollsWhereInput;
    /**
     * Limit how many ThreadPolls to update.
     */
    limit?: number;
  };

  /**
   * ThreadPolls upsert
   */
  export type ThreadPollsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPolls
     */
    select?: ThreadPollsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPolls
     */
    omit?: ThreadPollsOmit<ExtArgs> | null;
    /**
     * The filter to search for the ThreadPolls to update in case it exists.
     */
    where: ThreadPollsWhereUniqueInput;
    /**
     * In case the ThreadPolls found by the `where` argument doesn't exist, create a new ThreadPolls with this data.
     */
    create: XOR<ThreadPollsCreateInput, ThreadPollsUncheckedCreateInput>;
    /**
     * In case the ThreadPolls was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadPollsUpdateInput, ThreadPollsUncheckedUpdateInput>;
  };

  /**
   * ThreadPolls delete
   */
  export type ThreadPollsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPolls
     */
    select?: ThreadPollsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPolls
     */
    omit?: ThreadPollsOmit<ExtArgs> | null;
    /**
     * Filter which ThreadPolls to delete.
     */
    where: ThreadPollsWhereUniqueInput;
  };

  /**
   * ThreadPolls deleteMany
   */
  export type ThreadPollsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadPolls to delete
     */
    where?: ThreadPollsWhereInput;
    /**
     * Limit how many ThreadPolls to delete.
     */
    limit?: number;
  };

  /**
   * ThreadPolls without action
   */
  export type ThreadPollsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadPolls
     */
    select?: ThreadPollsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadPolls
     */
    omit?: ThreadPollsOmit<ExtArgs> | null;
  };

  /**
   * Model ThreadReportReasons
   */

  export type AggregateThreadReportReasons = {
    _count: ThreadReportReasonsCountAggregateOutputType | null;
    _avg: ThreadReportReasonsAvgAggregateOutputType | null;
    _sum: ThreadReportReasonsSumAggregateOutputType | null;
    _min: ThreadReportReasonsMinAggregateOutputType | null;
    _max: ThreadReportReasonsMaxAggregateOutputType | null;
  };

  export type ThreadReportReasonsAvgAggregateOutputType = {
    level: number | null;
    sort_order: number | null;
  };

  export type ThreadReportReasonsSumAggregateOutputType = {
    level: number | null;
    sort_order: number | null;
  };

  export type ThreadReportReasonsMinAggregateOutputType = {
    id: string | null;
    parent_id: string | null;
    code: string | null;
    level: number | null;
    is_leaf: boolean | null;
    is_active: boolean | null;
    sort_order: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadReportReasonsMaxAggregateOutputType = {
    id: string | null;
    parent_id: string | null;
    code: string | null;
    level: number | null;
    is_leaf: boolean | null;
    is_active: boolean | null;
    sort_order: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadReportReasonsCountAggregateOutputType = {
    id: number;
    parent_id: number;
    code: number;
    level: number;
    is_leaf: number;
    translations: number;
    is_active: number;
    sort_order: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type ThreadReportReasonsAvgAggregateInputType = {
    level?: true;
    sort_order?: true;
  };

  export type ThreadReportReasonsSumAggregateInputType = {
    level?: true;
    sort_order?: true;
  };

  export type ThreadReportReasonsMinAggregateInputType = {
    id?: true;
    parent_id?: true;
    code?: true;
    level?: true;
    is_leaf?: true;
    is_active?: true;
    sort_order?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadReportReasonsMaxAggregateInputType = {
    id?: true;
    parent_id?: true;
    code?: true;
    level?: true;
    is_leaf?: true;
    is_active?: true;
    sort_order?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadReportReasonsCountAggregateInputType = {
    id?: true;
    parent_id?: true;
    code?: true;
    level?: true;
    is_leaf?: true;
    translations?: true;
    is_active?: true;
    sort_order?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type ThreadReportReasonsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadReportReasons to aggregate.
     */
    where?: ThreadReportReasonsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadReportReasons to fetch.
     */
    orderBy?:
      | ThreadReportReasonsOrderByWithRelationInput
      | ThreadReportReasonsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ThreadReportReasonsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadReportReasons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadReportReasons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ThreadReportReasons
     **/
    _count?: true | ThreadReportReasonsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ThreadReportReasonsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ThreadReportReasonsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ThreadReportReasonsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ThreadReportReasonsMaxAggregateInputType;
  };

  export type GetThreadReportReasonsAggregateType<
    T extends ThreadReportReasonsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateThreadReportReasons]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreadReportReasons[P]>
      : GetScalarType<T[P], AggregateThreadReportReasons[P]>;
  };

  export type ThreadReportReasonsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ThreadReportReasonsWhereInput;
    orderBy?:
      | ThreadReportReasonsOrderByWithAggregationInput
      | ThreadReportReasonsOrderByWithAggregationInput[];
    by:
      | ThreadReportReasonsScalarFieldEnum[]
      | ThreadReportReasonsScalarFieldEnum;
    having?: ThreadReportReasonsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ThreadReportReasonsCountAggregateInputType | true;
    _avg?: ThreadReportReasonsAvgAggregateInputType;
    _sum?: ThreadReportReasonsSumAggregateInputType;
    _min?: ThreadReportReasonsMinAggregateInputType;
    _max?: ThreadReportReasonsMaxAggregateInputType;
  };

  export type ThreadReportReasonsGroupByOutputType = {
    id: string;
    parent_id: string | null;
    code: string;
    level: number;
    is_leaf: boolean;
    translations: JsonValue;
    is_active: boolean;
    sort_order: number;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: ThreadReportReasonsCountAggregateOutputType | null;
    _avg: ThreadReportReasonsAvgAggregateOutputType | null;
    _sum: ThreadReportReasonsSumAggregateOutputType | null;
    _min: ThreadReportReasonsMinAggregateOutputType | null;
    _max: ThreadReportReasonsMaxAggregateOutputType | null;
  };

  type GetThreadReportReasonsGroupByPayload<
    T extends ThreadReportReasonsGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThreadReportReasonsGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof ThreadReportReasonsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ThreadReportReasonsGroupByOutputType[P]>
          : GetScalarType<T[P], ThreadReportReasonsGroupByOutputType[P]>;
      }
    >
  >;

  export type ThreadReportReasonsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      parent_id?: boolean;
      code?: boolean;
      level?: boolean;
      is_leaf?: boolean;
      translations?: boolean;
      is_active?: boolean;
      sort_order?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
      ThreadReportReasons?:
        | boolean
        | ThreadReportReasons$ThreadReportReasonsArgs<ExtArgs>;
      other_ThreadReportReasons?:
        | boolean
        | ThreadReportReasons$other_ThreadReportReasonsArgs<ExtArgs>;
      _count?: boolean | ThreadReportReasonsCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['threadReportReasons']
  >;

  export type ThreadReportReasonsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      parent_id?: boolean;
      code?: boolean;
      level?: boolean;
      is_leaf?: boolean;
      translations?: boolean;
      is_active?: boolean;
      sort_order?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
      ThreadReportReasons?:
        | boolean
        | ThreadReportReasons$ThreadReportReasonsArgs<ExtArgs>;
    },
    ExtArgs['result']['threadReportReasons']
  >;

  export type ThreadReportReasonsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      parent_id?: boolean;
      code?: boolean;
      level?: boolean;
      is_leaf?: boolean;
      translations?: boolean;
      is_active?: boolean;
      sort_order?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
      ThreadReportReasons?:
        | boolean
        | ThreadReportReasons$ThreadReportReasonsArgs<ExtArgs>;
    },
    ExtArgs['result']['threadReportReasons']
  >;

  export type ThreadReportReasonsSelectScalar = {
    id?: boolean;
    parent_id?: boolean;
    code?: boolean;
    level?: boolean;
    is_leaf?: boolean;
    translations?: boolean;
    is_active?: boolean;
    sort_order?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type ThreadReportReasonsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'parent_id'
    | 'code'
    | 'level'
    | 'is_leaf'
    | 'translations'
    | 'is_active'
    | 'sort_order'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['threadReportReasons']
  >;
  export type ThreadReportReasonsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    ThreadReportReasons?:
      | boolean
      | ThreadReportReasons$ThreadReportReasonsArgs<ExtArgs>;
    other_ThreadReportReasons?:
      | boolean
      | ThreadReportReasons$other_ThreadReportReasonsArgs<ExtArgs>;
    _count?: boolean | ThreadReportReasonsCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ThreadReportReasonsIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    ThreadReportReasons?:
      | boolean
      | ThreadReportReasons$ThreadReportReasonsArgs<ExtArgs>;
  };
  export type ThreadReportReasonsIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    ThreadReportReasons?:
      | boolean
      | ThreadReportReasons$ThreadReportReasonsArgs<ExtArgs>;
  };

  export type $ThreadReportReasonsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ThreadReportReasons';
    objects: {
      ThreadReportReasons: Prisma.$ThreadReportReasonsPayload<ExtArgs> | null;
      other_ThreadReportReasons: Prisma.$ThreadReportReasonsPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        parent_id: string | null;
        code: string;
        level: number;
        is_leaf: boolean;
        translations: Prisma.JsonValue;
        is_active: boolean;
        sort_order: number;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['threadReportReasons']
    >;
    composites: {};
  };

  type ThreadReportReasonsGetPayload<
    S extends boolean | null | undefined | ThreadReportReasonsDefaultArgs
  > = $Result.GetResult<Prisma.$ThreadReportReasonsPayload, S>;

  type ThreadReportReasonsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    ThreadReportReasonsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ThreadReportReasonsCountAggregateInputType | true;
  };

  export interface ThreadReportReasonsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ThreadReportReasons'];
      meta: { name: 'ThreadReportReasons' };
    };
    /**
     * Find zero or one ThreadReportReasons that matches the filter.
     * @param {ThreadReportReasonsFindUniqueArgs} args - Arguments to find a ThreadReportReasons
     * @example
     * // Get one ThreadReportReasons
     * const threadReportReasons = await prisma.threadReportReasons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadReportReasonsFindUniqueArgs>(
      args: SelectSubset<T, ThreadReportReasonsFindUniqueArgs<ExtArgs>>
    ): Prisma__ThreadReportReasonsClient<
      $Result.GetResult<
        Prisma.$ThreadReportReasonsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ThreadReportReasons that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadReportReasonsFindUniqueOrThrowArgs} args - Arguments to find a ThreadReportReasons
     * @example
     * // Get one ThreadReportReasons
     * const threadReportReasons = await prisma.threadReportReasons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadReportReasonsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ThreadReportReasonsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadReportReasonsClient<
      $Result.GetResult<
        Prisma.$ThreadReportReasonsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadReportReasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadReportReasonsFindFirstArgs} args - Arguments to find a ThreadReportReasons
     * @example
     * // Get one ThreadReportReasons
     * const threadReportReasons = await prisma.threadReportReasons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadReportReasonsFindFirstArgs>(
      args?: SelectSubset<T, ThreadReportReasonsFindFirstArgs<ExtArgs>>
    ): Prisma__ThreadReportReasonsClient<
      $Result.GetResult<
        Prisma.$ThreadReportReasonsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadReportReasons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadReportReasonsFindFirstOrThrowArgs} args - Arguments to find a ThreadReportReasons
     * @example
     * // Get one ThreadReportReasons
     * const threadReportReasons = await prisma.threadReportReasons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadReportReasonsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadReportReasonsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadReportReasonsClient<
      $Result.GetResult<
        Prisma.$ThreadReportReasonsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ThreadReportReasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadReportReasonsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadReportReasons
     * const threadReportReasons = await prisma.threadReportReasons.findMany()
     *
     * // Get first 10 ThreadReportReasons
     * const threadReportReasons = await prisma.threadReportReasons.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const threadReportReasonsWithIdOnly = await prisma.threadReportReasons.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ThreadReportReasonsFindManyArgs>(
      args?: SelectSubset<T, ThreadReportReasonsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadReportReasonsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ThreadReportReasons.
     * @param {ThreadReportReasonsCreateArgs} args - Arguments to create a ThreadReportReasons.
     * @example
     * // Create one ThreadReportReasons
     * const ThreadReportReasons = await prisma.threadReportReasons.create({
     *   data: {
     *     // ... data to create a ThreadReportReasons
     *   }
     * })
     *
     */
    create<T extends ThreadReportReasonsCreateArgs>(
      args: SelectSubset<T, ThreadReportReasonsCreateArgs<ExtArgs>>
    ): Prisma__ThreadReportReasonsClient<
      $Result.GetResult<
        Prisma.$ThreadReportReasonsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ThreadReportReasons.
     * @param {ThreadReportReasonsCreateManyArgs} args - Arguments to create many ThreadReportReasons.
     * @example
     * // Create many ThreadReportReasons
     * const threadReportReasons = await prisma.threadReportReasons.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ThreadReportReasonsCreateManyArgs>(
      args?: SelectSubset<T, ThreadReportReasonsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ThreadReportReasons and returns the data saved in the database.
     * @param {ThreadReportReasonsCreateManyAndReturnArgs} args - Arguments to create many ThreadReportReasons.
     * @example
     * // Create many ThreadReportReasons
     * const threadReportReasons = await prisma.threadReportReasons.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ThreadReportReasons and only return the `id`
     * const threadReportReasonsWithIdOnly = await prisma.threadReportReasons.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ThreadReportReasonsCreateManyAndReturnArgs>(
      args?: SelectSubset<
        T,
        ThreadReportReasonsCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadReportReasonsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ThreadReportReasons.
     * @param {ThreadReportReasonsDeleteArgs} args - Arguments to delete one ThreadReportReasons.
     * @example
     * // Delete one ThreadReportReasons
     * const ThreadReportReasons = await prisma.threadReportReasons.delete({
     *   where: {
     *     // ... filter to delete one ThreadReportReasons
     *   }
     * })
     *
     */
    delete<T extends ThreadReportReasonsDeleteArgs>(
      args: SelectSubset<T, ThreadReportReasonsDeleteArgs<ExtArgs>>
    ): Prisma__ThreadReportReasonsClient<
      $Result.GetResult<
        Prisma.$ThreadReportReasonsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ThreadReportReasons.
     * @param {ThreadReportReasonsUpdateArgs} args - Arguments to update one ThreadReportReasons.
     * @example
     * // Update one ThreadReportReasons
     * const threadReportReasons = await prisma.threadReportReasons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ThreadReportReasonsUpdateArgs>(
      args: SelectSubset<T, ThreadReportReasonsUpdateArgs<ExtArgs>>
    ): Prisma__ThreadReportReasonsClient<
      $Result.GetResult<
        Prisma.$ThreadReportReasonsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ThreadReportReasons.
     * @param {ThreadReportReasonsDeleteManyArgs} args - Arguments to filter ThreadReportReasons to delete.
     * @example
     * // Delete a few ThreadReportReasons
     * const { count } = await prisma.threadReportReasons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ThreadReportReasonsDeleteManyArgs>(
      args?: SelectSubset<T, ThreadReportReasonsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadReportReasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadReportReasonsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadReportReasons
     * const threadReportReasons = await prisma.threadReportReasons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ThreadReportReasonsUpdateManyArgs>(
      args: SelectSubset<T, ThreadReportReasonsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadReportReasons and returns the data updated in the database.
     * @param {ThreadReportReasonsUpdateManyAndReturnArgs} args - Arguments to update many ThreadReportReasons.
     * @example
     * // Update many ThreadReportReasons
     * const threadReportReasons = await prisma.threadReportReasons.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ThreadReportReasons and only return the `id`
     * const threadReportReasonsWithIdOnly = await prisma.threadReportReasons.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ThreadReportReasonsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ThreadReportReasonsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadReportReasonsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ThreadReportReasons.
     * @param {ThreadReportReasonsUpsertArgs} args - Arguments to update or create a ThreadReportReasons.
     * @example
     * // Update or create a ThreadReportReasons
     * const threadReportReasons = await prisma.threadReportReasons.upsert({
     *   create: {
     *     // ... data to create a ThreadReportReasons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadReportReasons we want to update
     *   }
     * })
     */
    upsert<T extends ThreadReportReasonsUpsertArgs>(
      args: SelectSubset<T, ThreadReportReasonsUpsertArgs<ExtArgs>>
    ): Prisma__ThreadReportReasonsClient<
      $Result.GetResult<
        Prisma.$ThreadReportReasonsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ThreadReportReasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadReportReasonsCountArgs} args - Arguments to filter ThreadReportReasons to count.
     * @example
     * // Count the number of ThreadReportReasons
     * const count = await prisma.threadReportReasons.count({
     *   where: {
     *     // ... the filter for the ThreadReportReasons we want to count
     *   }
     * })
     **/
    count<T extends ThreadReportReasonsCountArgs>(
      args?: Subset<T, ThreadReportReasonsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              ThreadReportReasonsCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ThreadReportReasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadReportReasonsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ThreadReportReasonsAggregateArgs>(
      args: Subset<T, ThreadReportReasonsAggregateArgs>
    ): Prisma.PrismaPromise<GetThreadReportReasonsAggregateType<T>>;

    /**
     * Group by ThreadReportReasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadReportReasonsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ThreadReportReasonsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadReportReasonsGroupByArgs['orderBy'] }
        : { orderBy?: ThreadReportReasonsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ThreadReportReasonsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetThreadReportReasonsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ThreadReportReasons model
     */
    readonly fields: ThreadReportReasonsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadReportReasons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadReportReasonsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    ThreadReportReasons<
      T extends ThreadReportReasons$ThreadReportReasonsArgs<ExtArgs> = {}
    >(
      args?: Subset<T, ThreadReportReasons$ThreadReportReasonsArgs<ExtArgs>>
    ): Prisma__ThreadReportReasonsClient<
      $Result.GetResult<
        Prisma.$ThreadReportReasonsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    other_ThreadReportReasons<
      T extends ThreadReportReasons$other_ThreadReportReasonsArgs<ExtArgs> = {}
    >(
      args?: Subset<
        T,
        ThreadReportReasons$other_ThreadReportReasonsArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ThreadReportReasonsPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ThreadReportReasons model
   */
  interface ThreadReportReasonsFieldRefs {
    readonly id: FieldRef<'ThreadReportReasons', 'String'>;
    readonly parent_id: FieldRef<'ThreadReportReasons', 'String'>;
    readonly code: FieldRef<'ThreadReportReasons', 'String'>;
    readonly level: FieldRef<'ThreadReportReasons', 'Int'>;
    readonly is_leaf: FieldRef<'ThreadReportReasons', 'Boolean'>;
    readonly translations: FieldRef<'ThreadReportReasons', 'Json'>;
    readonly is_active: FieldRef<'ThreadReportReasons', 'Boolean'>;
    readonly sort_order: FieldRef<'ThreadReportReasons', 'Int'>;
    readonly created_at: FieldRef<'ThreadReportReasons', 'DateTime'>;
    readonly updated_at: FieldRef<'ThreadReportReasons', 'DateTime'>;
    readonly deleted_at: FieldRef<'ThreadReportReasons', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ThreadReportReasons findUnique
   */
  export type ThreadReportReasonsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReportReasons
     */
    select?: ThreadReportReasonsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReportReasons
     */
    omit?: ThreadReportReasonsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadReportReasonsInclude<ExtArgs> | null;
    /**
     * Filter, which ThreadReportReasons to fetch.
     */
    where: ThreadReportReasonsWhereUniqueInput;
  };

  /**
   * ThreadReportReasons findUniqueOrThrow
   */
  export type ThreadReportReasonsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReportReasons
     */
    select?: ThreadReportReasonsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReportReasons
     */
    omit?: ThreadReportReasonsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadReportReasonsInclude<ExtArgs> | null;
    /**
     * Filter, which ThreadReportReasons to fetch.
     */
    where: ThreadReportReasonsWhereUniqueInput;
  };

  /**
   * ThreadReportReasons findFirst
   */
  export type ThreadReportReasonsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReportReasons
     */
    select?: ThreadReportReasonsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReportReasons
     */
    omit?: ThreadReportReasonsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadReportReasonsInclude<ExtArgs> | null;
    /**
     * Filter, which ThreadReportReasons to fetch.
     */
    where?: ThreadReportReasonsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadReportReasons to fetch.
     */
    orderBy?:
      | ThreadReportReasonsOrderByWithRelationInput
      | ThreadReportReasonsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadReportReasons.
     */
    cursor?: ThreadReportReasonsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadReportReasons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadReportReasons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadReportReasons.
     */
    distinct?:
      | ThreadReportReasonsScalarFieldEnum
      | ThreadReportReasonsScalarFieldEnum[];
  };

  /**
   * ThreadReportReasons findFirstOrThrow
   */
  export type ThreadReportReasonsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReportReasons
     */
    select?: ThreadReportReasonsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReportReasons
     */
    omit?: ThreadReportReasonsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadReportReasonsInclude<ExtArgs> | null;
    /**
     * Filter, which ThreadReportReasons to fetch.
     */
    where?: ThreadReportReasonsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadReportReasons to fetch.
     */
    orderBy?:
      | ThreadReportReasonsOrderByWithRelationInput
      | ThreadReportReasonsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadReportReasons.
     */
    cursor?: ThreadReportReasonsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadReportReasons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadReportReasons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadReportReasons.
     */
    distinct?:
      | ThreadReportReasonsScalarFieldEnum
      | ThreadReportReasonsScalarFieldEnum[];
  };

  /**
   * ThreadReportReasons findMany
   */
  export type ThreadReportReasonsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReportReasons
     */
    select?: ThreadReportReasonsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReportReasons
     */
    omit?: ThreadReportReasonsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadReportReasonsInclude<ExtArgs> | null;
    /**
     * Filter, which ThreadReportReasons to fetch.
     */
    where?: ThreadReportReasonsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadReportReasons to fetch.
     */
    orderBy?:
      | ThreadReportReasonsOrderByWithRelationInput
      | ThreadReportReasonsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ThreadReportReasons.
     */
    cursor?: ThreadReportReasonsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadReportReasons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadReportReasons.
     */
    skip?: number;
    distinct?:
      | ThreadReportReasonsScalarFieldEnum
      | ThreadReportReasonsScalarFieldEnum[];
  };

  /**
   * ThreadReportReasons create
   */
  export type ThreadReportReasonsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReportReasons
     */
    select?: ThreadReportReasonsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReportReasons
     */
    omit?: ThreadReportReasonsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadReportReasonsInclude<ExtArgs> | null;
    /**
     * The data needed to create a ThreadReportReasons.
     */
    data: XOR<
      ThreadReportReasonsCreateInput,
      ThreadReportReasonsUncheckedCreateInput
    >;
  };

  /**
   * ThreadReportReasons createMany
   */
  export type ThreadReportReasonsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ThreadReportReasons.
     */
    data:
      | ThreadReportReasonsCreateManyInput
      | ThreadReportReasonsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadReportReasons createManyAndReturn
   */
  export type ThreadReportReasonsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReportReasons
     */
    select?: ThreadReportReasonsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReportReasons
     */
    omit?: ThreadReportReasonsOmit<ExtArgs> | null;
    /**
     * The data used to create many ThreadReportReasons.
     */
    data:
      | ThreadReportReasonsCreateManyInput
      | ThreadReportReasonsCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadReportReasonsIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ThreadReportReasons update
   */
  export type ThreadReportReasonsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReportReasons
     */
    select?: ThreadReportReasonsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReportReasons
     */
    omit?: ThreadReportReasonsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadReportReasonsInclude<ExtArgs> | null;
    /**
     * The data needed to update a ThreadReportReasons.
     */
    data: XOR<
      ThreadReportReasonsUpdateInput,
      ThreadReportReasonsUncheckedUpdateInput
    >;
    /**
     * Choose, which ThreadReportReasons to update.
     */
    where: ThreadReportReasonsWhereUniqueInput;
  };

  /**
   * ThreadReportReasons updateMany
   */
  export type ThreadReportReasonsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ThreadReportReasons.
     */
    data: XOR<
      ThreadReportReasonsUpdateManyMutationInput,
      ThreadReportReasonsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadReportReasons to update
     */
    where?: ThreadReportReasonsWhereInput;
    /**
     * Limit how many ThreadReportReasons to update.
     */
    limit?: number;
  };

  /**
   * ThreadReportReasons updateManyAndReturn
   */
  export type ThreadReportReasonsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReportReasons
     */
    select?: ThreadReportReasonsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReportReasons
     */
    omit?: ThreadReportReasonsOmit<ExtArgs> | null;
    /**
     * The data used to update ThreadReportReasons.
     */
    data: XOR<
      ThreadReportReasonsUpdateManyMutationInput,
      ThreadReportReasonsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadReportReasons to update
     */
    where?: ThreadReportReasonsWhereInput;
    /**
     * Limit how many ThreadReportReasons to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadReportReasonsIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ThreadReportReasons upsert
   */
  export type ThreadReportReasonsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReportReasons
     */
    select?: ThreadReportReasonsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReportReasons
     */
    omit?: ThreadReportReasonsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadReportReasonsInclude<ExtArgs> | null;
    /**
     * The filter to search for the ThreadReportReasons to update in case it exists.
     */
    where: ThreadReportReasonsWhereUniqueInput;
    /**
     * In case the ThreadReportReasons found by the `where` argument doesn't exist, create a new ThreadReportReasons with this data.
     */
    create: XOR<
      ThreadReportReasonsCreateInput,
      ThreadReportReasonsUncheckedCreateInput
    >;
    /**
     * In case the ThreadReportReasons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      ThreadReportReasonsUpdateInput,
      ThreadReportReasonsUncheckedUpdateInput
    >;
  };

  /**
   * ThreadReportReasons delete
   */
  export type ThreadReportReasonsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReportReasons
     */
    select?: ThreadReportReasonsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReportReasons
     */
    omit?: ThreadReportReasonsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadReportReasonsInclude<ExtArgs> | null;
    /**
     * Filter which ThreadReportReasons to delete.
     */
    where: ThreadReportReasonsWhereUniqueInput;
  };

  /**
   * ThreadReportReasons deleteMany
   */
  export type ThreadReportReasonsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadReportReasons to delete
     */
    where?: ThreadReportReasonsWhereInput;
    /**
     * Limit how many ThreadReportReasons to delete.
     */
    limit?: number;
  };

  /**
   * ThreadReportReasons.ThreadReportReasons
   */
  export type ThreadReportReasons$ThreadReportReasonsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReportReasons
     */
    select?: ThreadReportReasonsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReportReasons
     */
    omit?: ThreadReportReasonsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadReportReasonsInclude<ExtArgs> | null;
    where?: ThreadReportReasonsWhereInput;
  };

  /**
   * ThreadReportReasons.other_ThreadReportReasons
   */
  export type ThreadReportReasons$other_ThreadReportReasonsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReportReasons
     */
    select?: ThreadReportReasonsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReportReasons
     */
    omit?: ThreadReportReasonsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadReportReasonsInclude<ExtArgs> | null;
    where?: ThreadReportReasonsWhereInput;
    orderBy?:
      | ThreadReportReasonsOrderByWithRelationInput
      | ThreadReportReasonsOrderByWithRelationInput[];
    cursor?: ThreadReportReasonsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | ThreadReportReasonsScalarFieldEnum
      | ThreadReportReasonsScalarFieldEnum[];
  };

  /**
   * ThreadReportReasons without action
   */
  export type ThreadReportReasonsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReportReasons
     */
    select?: ThreadReportReasonsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReportReasons
     */
    omit?: ThreadReportReasonsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadReportReasonsInclude<ExtArgs> | null;
  };

  /**
   * Model ThreadReports
   */

  export type AggregateThreadReports = {
    _count: ThreadReportsCountAggregateOutputType | null;
    _avg: ThreadReportsAvgAggregateOutputType | null;
    _sum: ThreadReportsSumAggregateOutputType | null;
    _min: ThreadReportsMinAggregateOutputType | null;
    _max: ThreadReportsMaxAggregateOutputType | null;
  };

  export type ThreadReportsAvgAggregateOutputType = {
    reported_by: number | null;
  };

  export type ThreadReportsSumAggregateOutputType = {
    reported_by: number | null;
  };

  export type ThreadReportsMinAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    reported_by: number | null;
    reason: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadReportsMaxAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    reported_by: number | null;
    reason: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadReportsCountAggregateOutputType = {
    id: number;
    threads_id: number;
    reported_by: number;
    reason: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type ThreadReportsAvgAggregateInputType = {
    reported_by?: true;
  };

  export type ThreadReportsSumAggregateInputType = {
    reported_by?: true;
  };

  export type ThreadReportsMinAggregateInputType = {
    id?: true;
    threads_id?: true;
    reported_by?: true;
    reason?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadReportsMaxAggregateInputType = {
    id?: true;
    threads_id?: true;
    reported_by?: true;
    reason?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadReportsCountAggregateInputType = {
    id?: true;
    threads_id?: true;
    reported_by?: true;
    reason?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type ThreadReportsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadReports to aggregate.
     */
    where?: ThreadReportsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadReports to fetch.
     */
    orderBy?:
      | ThreadReportsOrderByWithRelationInput
      | ThreadReportsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ThreadReportsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadReports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadReports.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ThreadReports
     **/
    _count?: true | ThreadReportsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ThreadReportsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ThreadReportsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ThreadReportsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ThreadReportsMaxAggregateInputType;
  };

  export type GetThreadReportsAggregateType<
    T extends ThreadReportsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateThreadReports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreadReports[P]>
      : GetScalarType<T[P], AggregateThreadReports[P]>;
  };

  export type ThreadReportsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ThreadReportsWhereInput;
    orderBy?:
      | ThreadReportsOrderByWithAggregationInput
      | ThreadReportsOrderByWithAggregationInput[];
    by: ThreadReportsScalarFieldEnum[] | ThreadReportsScalarFieldEnum;
    having?: ThreadReportsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ThreadReportsCountAggregateInputType | true;
    _avg?: ThreadReportsAvgAggregateInputType;
    _sum?: ThreadReportsSumAggregateInputType;
    _min?: ThreadReportsMinAggregateInputType;
    _max?: ThreadReportsMaxAggregateInputType;
  };

  export type ThreadReportsGroupByOutputType = {
    id: string;
    threads_id: string;
    reported_by: number | null;
    reason: string | null;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: ThreadReportsCountAggregateOutputType | null;
    _avg: ThreadReportsAvgAggregateOutputType | null;
    _sum: ThreadReportsSumAggregateOutputType | null;
    _min: ThreadReportsMinAggregateOutputType | null;
    _max: ThreadReportsMaxAggregateOutputType | null;
  };

  type GetThreadReportsGroupByPayload<T extends ThreadReportsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ThreadReportsGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof ThreadReportsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadReportsGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadReportsGroupByOutputType[P]>;
        }
      >
    >;

  export type ThreadReportsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      reported_by?: boolean;
      reason?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadReports']
  >;

  export type ThreadReportsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      reported_by?: boolean;
      reason?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadReports']
  >;

  export type ThreadReportsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      reported_by?: boolean;
      reason?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadReports']
  >;

  export type ThreadReportsSelectScalar = {
    id?: boolean;
    threads_id?: boolean;
    reported_by?: boolean;
    reason?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type ThreadReportsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'threads_id'
    | 'reported_by'
    | 'reason'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['threadReports']
  >;

  export type $ThreadReportsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ThreadReports';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        threads_id: string;
        reported_by: number | null;
        reason: string | null;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['threadReports']
    >;
    composites: {};
  };

  type ThreadReportsGetPayload<
    S extends boolean | null | undefined | ThreadReportsDefaultArgs
  > = $Result.GetResult<Prisma.$ThreadReportsPayload, S>;

  type ThreadReportsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    ThreadReportsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ThreadReportsCountAggregateInputType | true;
  };

  export interface ThreadReportsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ThreadReports'];
      meta: { name: 'ThreadReports' };
    };
    /**
     * Find zero or one ThreadReports that matches the filter.
     * @param {ThreadReportsFindUniqueArgs} args - Arguments to find a ThreadReports
     * @example
     * // Get one ThreadReports
     * const threadReports = await prisma.threadReports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadReportsFindUniqueArgs>(
      args: SelectSubset<T, ThreadReportsFindUniqueArgs<ExtArgs>>
    ): Prisma__ThreadReportsClient<
      $Result.GetResult<
        Prisma.$ThreadReportsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ThreadReports that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadReportsFindUniqueOrThrowArgs} args - Arguments to find a ThreadReports
     * @example
     * // Get one ThreadReports
     * const threadReports = await prisma.threadReports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadReportsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ThreadReportsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadReportsClient<
      $Result.GetResult<
        Prisma.$ThreadReportsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadReportsFindFirstArgs} args - Arguments to find a ThreadReports
     * @example
     * // Get one ThreadReports
     * const threadReports = await prisma.threadReports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadReportsFindFirstArgs>(
      args?: SelectSubset<T, ThreadReportsFindFirstArgs<ExtArgs>>
    ): Prisma__ThreadReportsClient<
      $Result.GetResult<
        Prisma.$ThreadReportsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadReports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadReportsFindFirstOrThrowArgs} args - Arguments to find a ThreadReports
     * @example
     * // Get one ThreadReports
     * const threadReports = await prisma.threadReports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadReportsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadReportsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadReportsClient<
      $Result.GetResult<
        Prisma.$ThreadReportsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ThreadReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadReportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadReports
     * const threadReports = await prisma.threadReports.findMany()
     *
     * // Get first 10 ThreadReports
     * const threadReports = await prisma.threadReports.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const threadReportsWithIdOnly = await prisma.threadReports.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ThreadReportsFindManyArgs>(
      args?: SelectSubset<T, ThreadReportsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadReportsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ThreadReports.
     * @param {ThreadReportsCreateArgs} args - Arguments to create a ThreadReports.
     * @example
     * // Create one ThreadReports
     * const ThreadReports = await prisma.threadReports.create({
     *   data: {
     *     // ... data to create a ThreadReports
     *   }
     * })
     *
     */
    create<T extends ThreadReportsCreateArgs>(
      args: SelectSubset<T, ThreadReportsCreateArgs<ExtArgs>>
    ): Prisma__ThreadReportsClient<
      $Result.GetResult<
        Prisma.$ThreadReportsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ThreadReports.
     * @param {ThreadReportsCreateManyArgs} args - Arguments to create many ThreadReports.
     * @example
     * // Create many ThreadReports
     * const threadReports = await prisma.threadReports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ThreadReportsCreateManyArgs>(
      args?: SelectSubset<T, ThreadReportsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ThreadReports and returns the data saved in the database.
     * @param {ThreadReportsCreateManyAndReturnArgs} args - Arguments to create many ThreadReports.
     * @example
     * // Create many ThreadReports
     * const threadReports = await prisma.threadReports.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ThreadReports and only return the `id`
     * const threadReportsWithIdOnly = await prisma.threadReports.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ThreadReportsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ThreadReportsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadReportsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ThreadReports.
     * @param {ThreadReportsDeleteArgs} args - Arguments to delete one ThreadReports.
     * @example
     * // Delete one ThreadReports
     * const ThreadReports = await prisma.threadReports.delete({
     *   where: {
     *     // ... filter to delete one ThreadReports
     *   }
     * })
     *
     */
    delete<T extends ThreadReportsDeleteArgs>(
      args: SelectSubset<T, ThreadReportsDeleteArgs<ExtArgs>>
    ): Prisma__ThreadReportsClient<
      $Result.GetResult<
        Prisma.$ThreadReportsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ThreadReports.
     * @param {ThreadReportsUpdateArgs} args - Arguments to update one ThreadReports.
     * @example
     * // Update one ThreadReports
     * const threadReports = await prisma.threadReports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ThreadReportsUpdateArgs>(
      args: SelectSubset<T, ThreadReportsUpdateArgs<ExtArgs>>
    ): Prisma__ThreadReportsClient<
      $Result.GetResult<
        Prisma.$ThreadReportsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ThreadReports.
     * @param {ThreadReportsDeleteManyArgs} args - Arguments to filter ThreadReports to delete.
     * @example
     * // Delete a few ThreadReports
     * const { count } = await prisma.threadReports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ThreadReportsDeleteManyArgs>(
      args?: SelectSubset<T, ThreadReportsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadReportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadReports
     * const threadReports = await prisma.threadReports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ThreadReportsUpdateManyArgs>(
      args: SelectSubset<T, ThreadReportsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadReports and returns the data updated in the database.
     * @param {ThreadReportsUpdateManyAndReturnArgs} args - Arguments to update many ThreadReports.
     * @example
     * // Update many ThreadReports
     * const threadReports = await prisma.threadReports.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ThreadReports and only return the `id`
     * const threadReportsWithIdOnly = await prisma.threadReports.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ThreadReportsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ThreadReportsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadReportsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ThreadReports.
     * @param {ThreadReportsUpsertArgs} args - Arguments to update or create a ThreadReports.
     * @example
     * // Update or create a ThreadReports
     * const threadReports = await prisma.threadReports.upsert({
     *   create: {
     *     // ... data to create a ThreadReports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadReports we want to update
     *   }
     * })
     */
    upsert<T extends ThreadReportsUpsertArgs>(
      args: SelectSubset<T, ThreadReportsUpsertArgs<ExtArgs>>
    ): Prisma__ThreadReportsClient<
      $Result.GetResult<
        Prisma.$ThreadReportsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ThreadReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadReportsCountArgs} args - Arguments to filter ThreadReports to count.
     * @example
     * // Count the number of ThreadReports
     * const count = await prisma.threadReports.count({
     *   where: {
     *     // ... the filter for the ThreadReports we want to count
     *   }
     * })
     **/
    count<T extends ThreadReportsCountArgs>(
      args?: Subset<T, ThreadReportsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadReportsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ThreadReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ThreadReportsAggregateArgs>(
      args: Subset<T, ThreadReportsAggregateArgs>
    ): Prisma.PrismaPromise<GetThreadReportsAggregateType<T>>;

    /**
     * Group by ThreadReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadReportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ThreadReportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadReportsGroupByArgs['orderBy'] }
        : { orderBy?: ThreadReportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ThreadReportsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetThreadReportsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ThreadReports model
     */
    readonly fields: ThreadReportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadReports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadReportsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ThreadReports model
   */
  interface ThreadReportsFieldRefs {
    readonly id: FieldRef<'ThreadReports', 'String'>;
    readonly threads_id: FieldRef<'ThreadReports', 'String'>;
    readonly reported_by: FieldRef<'ThreadReports', 'Int'>;
    readonly reason: FieldRef<'ThreadReports', 'String'>;
    readonly created_at: FieldRef<'ThreadReports', 'DateTime'>;
    readonly updated_at: FieldRef<'ThreadReports', 'DateTime'>;
    readonly deleted_at: FieldRef<'ThreadReports', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ThreadReports findUnique
   */
  export type ThreadReportsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReports
     */
    select?: ThreadReportsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReports
     */
    omit?: ThreadReportsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadReports to fetch.
     */
    where: ThreadReportsWhereUniqueInput;
  };

  /**
   * ThreadReports findUniqueOrThrow
   */
  export type ThreadReportsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReports
     */
    select?: ThreadReportsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReports
     */
    omit?: ThreadReportsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadReports to fetch.
     */
    where: ThreadReportsWhereUniqueInput;
  };

  /**
   * ThreadReports findFirst
   */
  export type ThreadReportsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReports
     */
    select?: ThreadReportsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReports
     */
    omit?: ThreadReportsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadReports to fetch.
     */
    where?: ThreadReportsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadReports to fetch.
     */
    orderBy?:
      | ThreadReportsOrderByWithRelationInput
      | ThreadReportsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadReports.
     */
    cursor?: ThreadReportsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadReports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadReports.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadReports.
     */
    distinct?: ThreadReportsScalarFieldEnum | ThreadReportsScalarFieldEnum[];
  };

  /**
   * ThreadReports findFirstOrThrow
   */
  export type ThreadReportsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReports
     */
    select?: ThreadReportsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReports
     */
    omit?: ThreadReportsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadReports to fetch.
     */
    where?: ThreadReportsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadReports to fetch.
     */
    orderBy?:
      | ThreadReportsOrderByWithRelationInput
      | ThreadReportsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadReports.
     */
    cursor?: ThreadReportsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadReports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadReports.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadReports.
     */
    distinct?: ThreadReportsScalarFieldEnum | ThreadReportsScalarFieldEnum[];
  };

  /**
   * ThreadReports findMany
   */
  export type ThreadReportsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReports
     */
    select?: ThreadReportsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReports
     */
    omit?: ThreadReportsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadReports to fetch.
     */
    where?: ThreadReportsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadReports to fetch.
     */
    orderBy?:
      | ThreadReportsOrderByWithRelationInput
      | ThreadReportsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ThreadReports.
     */
    cursor?: ThreadReportsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadReports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadReports.
     */
    skip?: number;
    distinct?: ThreadReportsScalarFieldEnum | ThreadReportsScalarFieldEnum[];
  };

  /**
   * ThreadReports create
   */
  export type ThreadReportsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReports
     */
    select?: ThreadReportsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReports
     */
    omit?: ThreadReportsOmit<ExtArgs> | null;
    /**
     * The data needed to create a ThreadReports.
     */
    data: XOR<ThreadReportsCreateInput, ThreadReportsUncheckedCreateInput>;
  };

  /**
   * ThreadReports createMany
   */
  export type ThreadReportsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ThreadReports.
     */
    data: ThreadReportsCreateManyInput | ThreadReportsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadReports createManyAndReturn
   */
  export type ThreadReportsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReports
     */
    select?: ThreadReportsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReports
     */
    omit?: ThreadReportsOmit<ExtArgs> | null;
    /**
     * The data used to create many ThreadReports.
     */
    data: ThreadReportsCreateManyInput | ThreadReportsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadReports update
   */
  export type ThreadReportsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReports
     */
    select?: ThreadReportsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReports
     */
    omit?: ThreadReportsOmit<ExtArgs> | null;
    /**
     * The data needed to update a ThreadReports.
     */
    data: XOR<ThreadReportsUpdateInput, ThreadReportsUncheckedUpdateInput>;
    /**
     * Choose, which ThreadReports to update.
     */
    where: ThreadReportsWhereUniqueInput;
  };

  /**
   * ThreadReports updateMany
   */
  export type ThreadReportsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ThreadReports.
     */
    data: XOR<
      ThreadReportsUpdateManyMutationInput,
      ThreadReportsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadReports to update
     */
    where?: ThreadReportsWhereInput;
    /**
     * Limit how many ThreadReports to update.
     */
    limit?: number;
  };

  /**
   * ThreadReports updateManyAndReturn
   */
  export type ThreadReportsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReports
     */
    select?: ThreadReportsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReports
     */
    omit?: ThreadReportsOmit<ExtArgs> | null;
    /**
     * The data used to update ThreadReports.
     */
    data: XOR<
      ThreadReportsUpdateManyMutationInput,
      ThreadReportsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadReports to update
     */
    where?: ThreadReportsWhereInput;
    /**
     * Limit how many ThreadReports to update.
     */
    limit?: number;
  };

  /**
   * ThreadReports upsert
   */
  export type ThreadReportsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReports
     */
    select?: ThreadReportsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReports
     */
    omit?: ThreadReportsOmit<ExtArgs> | null;
    /**
     * The filter to search for the ThreadReports to update in case it exists.
     */
    where: ThreadReportsWhereUniqueInput;
    /**
     * In case the ThreadReports found by the `where` argument doesn't exist, create a new ThreadReports with this data.
     */
    create: XOR<ThreadReportsCreateInput, ThreadReportsUncheckedCreateInput>;
    /**
     * In case the ThreadReports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadReportsUpdateInput, ThreadReportsUncheckedUpdateInput>;
  };

  /**
   * ThreadReports delete
   */
  export type ThreadReportsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReports
     */
    select?: ThreadReportsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReports
     */
    omit?: ThreadReportsOmit<ExtArgs> | null;
    /**
     * Filter which ThreadReports to delete.
     */
    where: ThreadReportsWhereUniqueInput;
  };

  /**
   * ThreadReports deleteMany
   */
  export type ThreadReportsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadReports to delete
     */
    where?: ThreadReportsWhereInput;
    /**
     * Limit how many ThreadReports to delete.
     */
    limit?: number;
  };

  /**
   * ThreadReports without action
   */
  export type ThreadReportsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReports
     */
    select?: ThreadReportsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReports
     */
    omit?: ThreadReportsOmit<ExtArgs> | null;
  };

  /**
   * Model ThreadReposts
   */

  export type AggregateThreadReposts = {
    _count: ThreadRepostsCountAggregateOutputType | null;
    _avg: ThreadRepostsAvgAggregateOutputType | null;
    _sum: ThreadRepostsSumAggregateOutputType | null;
    _min: ThreadRepostsMinAggregateOutputType | null;
    _max: ThreadRepostsMaxAggregateOutputType | null;
  };

  export type ThreadRepostsAvgAggregateOutputType = {
    user_id: number | null;
  };

  export type ThreadRepostsSumAggregateOutputType = {
    user_id: number | null;
  };

  export type ThreadRepostsMinAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    user_id: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadRepostsMaxAggregateOutputType = {
    id: string | null;
    threads_id: string | null;
    user_id: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type ThreadRepostsCountAggregateOutputType = {
    id: number;
    threads_id: number;
    user_id: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type ThreadRepostsAvgAggregateInputType = {
    user_id?: true;
  };

  export type ThreadRepostsSumAggregateInputType = {
    user_id?: true;
  };

  export type ThreadRepostsMinAggregateInputType = {
    id?: true;
    threads_id?: true;
    user_id?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadRepostsMaxAggregateInputType = {
    id?: true;
    threads_id?: true;
    user_id?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type ThreadRepostsCountAggregateInputType = {
    id?: true;
    threads_id?: true;
    user_id?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type ThreadRepostsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadReposts to aggregate.
     */
    where?: ThreadRepostsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadReposts to fetch.
     */
    orderBy?:
      | ThreadRepostsOrderByWithRelationInput
      | ThreadRepostsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ThreadRepostsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadReposts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadReposts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ThreadReposts
     **/
    _count?: true | ThreadRepostsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ThreadRepostsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ThreadRepostsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ThreadRepostsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ThreadRepostsMaxAggregateInputType;
  };

  export type GetThreadRepostsAggregateType<
    T extends ThreadRepostsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateThreadReposts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreadReposts[P]>
      : GetScalarType<T[P], AggregateThreadReposts[P]>;
  };

  export type ThreadRepostsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ThreadRepostsWhereInput;
    orderBy?:
      | ThreadRepostsOrderByWithAggregationInput
      | ThreadRepostsOrderByWithAggregationInput[];
    by: ThreadRepostsScalarFieldEnum[] | ThreadRepostsScalarFieldEnum;
    having?: ThreadRepostsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ThreadRepostsCountAggregateInputType | true;
    _avg?: ThreadRepostsAvgAggregateInputType;
    _sum?: ThreadRepostsSumAggregateInputType;
    _min?: ThreadRepostsMinAggregateInputType;
    _max?: ThreadRepostsMaxAggregateInputType;
  };

  export type ThreadRepostsGroupByOutputType = {
    id: string;
    threads_id: string;
    user_id: number;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: ThreadRepostsCountAggregateOutputType | null;
    _avg: ThreadRepostsAvgAggregateOutputType | null;
    _sum: ThreadRepostsSumAggregateOutputType | null;
    _min: ThreadRepostsMinAggregateOutputType | null;
    _max: ThreadRepostsMaxAggregateOutputType | null;
  };

  type GetThreadRepostsGroupByPayload<T extends ThreadRepostsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ThreadRepostsGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof ThreadRepostsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadRepostsGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadRepostsGroupByOutputType[P]>;
        }
      >
    >;

  export type ThreadRepostsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      user_id?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadReposts']
  >;

  export type ThreadRepostsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      user_id?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadReposts']
  >;

  export type ThreadRepostsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threads_id?: boolean;
      user_id?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['threadReposts']
  >;

  export type ThreadRepostsSelectScalar = {
    id?: boolean;
    threads_id?: boolean;
    user_id?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type ThreadRepostsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'threads_id'
    | 'user_id'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['threadReposts']
  >;

  export type $ThreadRepostsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ThreadReposts';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        threads_id: string;
        user_id: number;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['threadReposts']
    >;
    composites: {};
  };

  type ThreadRepostsGetPayload<
    S extends boolean | null | undefined | ThreadRepostsDefaultArgs
  > = $Result.GetResult<Prisma.$ThreadRepostsPayload, S>;

  type ThreadRepostsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    ThreadRepostsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ThreadRepostsCountAggregateInputType | true;
  };

  export interface ThreadRepostsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ThreadReposts'];
      meta: { name: 'ThreadReposts' };
    };
    /**
     * Find zero or one ThreadReposts that matches the filter.
     * @param {ThreadRepostsFindUniqueArgs} args - Arguments to find a ThreadReposts
     * @example
     * // Get one ThreadReposts
     * const threadReposts = await prisma.threadReposts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadRepostsFindUniqueArgs>(
      args: SelectSubset<T, ThreadRepostsFindUniqueArgs<ExtArgs>>
    ): Prisma__ThreadRepostsClient<
      $Result.GetResult<
        Prisma.$ThreadRepostsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ThreadReposts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadRepostsFindUniqueOrThrowArgs} args - Arguments to find a ThreadReposts
     * @example
     * // Get one ThreadReposts
     * const threadReposts = await prisma.threadReposts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadRepostsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ThreadRepostsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadRepostsClient<
      $Result.GetResult<
        Prisma.$ThreadRepostsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadReposts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadRepostsFindFirstArgs} args - Arguments to find a ThreadReposts
     * @example
     * // Get one ThreadReposts
     * const threadReposts = await prisma.threadReposts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadRepostsFindFirstArgs>(
      args?: SelectSubset<T, ThreadRepostsFindFirstArgs<ExtArgs>>
    ): Prisma__ThreadRepostsClient<
      $Result.GetResult<
        Prisma.$ThreadRepostsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ThreadReposts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadRepostsFindFirstOrThrowArgs} args - Arguments to find a ThreadReposts
     * @example
     * // Get one ThreadReposts
     * const threadReposts = await prisma.threadReposts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadRepostsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadRepostsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadRepostsClient<
      $Result.GetResult<
        Prisma.$ThreadRepostsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ThreadReposts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadRepostsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadReposts
     * const threadReposts = await prisma.threadReposts.findMany()
     *
     * // Get first 10 ThreadReposts
     * const threadReposts = await prisma.threadReposts.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const threadRepostsWithIdOnly = await prisma.threadReposts.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ThreadRepostsFindManyArgs>(
      args?: SelectSubset<T, ThreadRepostsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadRepostsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ThreadReposts.
     * @param {ThreadRepostsCreateArgs} args - Arguments to create a ThreadReposts.
     * @example
     * // Create one ThreadReposts
     * const ThreadReposts = await prisma.threadReposts.create({
     *   data: {
     *     // ... data to create a ThreadReposts
     *   }
     * })
     *
     */
    create<T extends ThreadRepostsCreateArgs>(
      args: SelectSubset<T, ThreadRepostsCreateArgs<ExtArgs>>
    ): Prisma__ThreadRepostsClient<
      $Result.GetResult<
        Prisma.$ThreadRepostsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ThreadReposts.
     * @param {ThreadRepostsCreateManyArgs} args - Arguments to create many ThreadReposts.
     * @example
     * // Create many ThreadReposts
     * const threadReposts = await prisma.threadReposts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ThreadRepostsCreateManyArgs>(
      args?: SelectSubset<T, ThreadRepostsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ThreadReposts and returns the data saved in the database.
     * @param {ThreadRepostsCreateManyAndReturnArgs} args - Arguments to create many ThreadReposts.
     * @example
     * // Create many ThreadReposts
     * const threadReposts = await prisma.threadReposts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ThreadReposts and only return the `id`
     * const threadRepostsWithIdOnly = await prisma.threadReposts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ThreadRepostsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ThreadRepostsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadRepostsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ThreadReposts.
     * @param {ThreadRepostsDeleteArgs} args - Arguments to delete one ThreadReposts.
     * @example
     * // Delete one ThreadReposts
     * const ThreadReposts = await prisma.threadReposts.delete({
     *   where: {
     *     // ... filter to delete one ThreadReposts
     *   }
     * })
     *
     */
    delete<T extends ThreadRepostsDeleteArgs>(
      args: SelectSubset<T, ThreadRepostsDeleteArgs<ExtArgs>>
    ): Prisma__ThreadRepostsClient<
      $Result.GetResult<
        Prisma.$ThreadRepostsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ThreadReposts.
     * @param {ThreadRepostsUpdateArgs} args - Arguments to update one ThreadReposts.
     * @example
     * // Update one ThreadReposts
     * const threadReposts = await prisma.threadReposts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ThreadRepostsUpdateArgs>(
      args: SelectSubset<T, ThreadRepostsUpdateArgs<ExtArgs>>
    ): Prisma__ThreadRepostsClient<
      $Result.GetResult<
        Prisma.$ThreadRepostsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ThreadReposts.
     * @param {ThreadRepostsDeleteManyArgs} args - Arguments to filter ThreadReposts to delete.
     * @example
     * // Delete a few ThreadReposts
     * const { count } = await prisma.threadReposts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ThreadRepostsDeleteManyArgs>(
      args?: SelectSubset<T, ThreadRepostsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadReposts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadRepostsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadReposts
     * const threadReposts = await prisma.threadReposts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ThreadRepostsUpdateManyArgs>(
      args: SelectSubset<T, ThreadRepostsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ThreadReposts and returns the data updated in the database.
     * @param {ThreadRepostsUpdateManyAndReturnArgs} args - Arguments to update many ThreadReposts.
     * @example
     * // Update many ThreadReposts
     * const threadReposts = await prisma.threadReposts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ThreadReposts and only return the `id`
     * const threadRepostsWithIdOnly = await prisma.threadReposts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ThreadRepostsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ThreadRepostsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadRepostsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ThreadReposts.
     * @param {ThreadRepostsUpsertArgs} args - Arguments to update or create a ThreadReposts.
     * @example
     * // Update or create a ThreadReposts
     * const threadReposts = await prisma.threadReposts.upsert({
     *   create: {
     *     // ... data to create a ThreadReposts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadReposts we want to update
     *   }
     * })
     */
    upsert<T extends ThreadRepostsUpsertArgs>(
      args: SelectSubset<T, ThreadRepostsUpsertArgs<ExtArgs>>
    ): Prisma__ThreadRepostsClient<
      $Result.GetResult<
        Prisma.$ThreadRepostsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ThreadReposts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadRepostsCountArgs} args - Arguments to filter ThreadReposts to count.
     * @example
     * // Count the number of ThreadReposts
     * const count = await prisma.threadReposts.count({
     *   where: {
     *     // ... the filter for the ThreadReposts we want to count
     *   }
     * })
     **/
    count<T extends ThreadRepostsCountArgs>(
      args?: Subset<T, ThreadRepostsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadRepostsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ThreadReposts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadRepostsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ThreadRepostsAggregateArgs>(
      args: Subset<T, ThreadRepostsAggregateArgs>
    ): Prisma.PrismaPromise<GetThreadRepostsAggregateType<T>>;

    /**
     * Group by ThreadReposts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadRepostsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ThreadRepostsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadRepostsGroupByArgs['orderBy'] }
        : { orderBy?: ThreadRepostsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ThreadRepostsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetThreadRepostsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ThreadReposts model
     */
    readonly fields: ThreadRepostsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadReposts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadRepostsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ThreadReposts model
   */
  interface ThreadRepostsFieldRefs {
    readonly id: FieldRef<'ThreadReposts', 'String'>;
    readonly threads_id: FieldRef<'ThreadReposts', 'String'>;
    readonly user_id: FieldRef<'ThreadReposts', 'Int'>;
    readonly created_at: FieldRef<'ThreadReposts', 'DateTime'>;
    readonly updated_at: FieldRef<'ThreadReposts', 'DateTime'>;
    readonly deleted_at: FieldRef<'ThreadReposts', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ThreadReposts findUnique
   */
  export type ThreadRepostsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReposts
     */
    select?: ThreadRepostsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReposts
     */
    omit?: ThreadRepostsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadReposts to fetch.
     */
    where: ThreadRepostsWhereUniqueInput;
  };

  /**
   * ThreadReposts findUniqueOrThrow
   */
  export type ThreadRepostsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReposts
     */
    select?: ThreadRepostsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReposts
     */
    omit?: ThreadRepostsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadReposts to fetch.
     */
    where: ThreadRepostsWhereUniqueInput;
  };

  /**
   * ThreadReposts findFirst
   */
  export type ThreadRepostsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReposts
     */
    select?: ThreadRepostsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReposts
     */
    omit?: ThreadRepostsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadReposts to fetch.
     */
    where?: ThreadRepostsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadReposts to fetch.
     */
    orderBy?:
      | ThreadRepostsOrderByWithRelationInput
      | ThreadRepostsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadReposts.
     */
    cursor?: ThreadRepostsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadReposts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadReposts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadReposts.
     */
    distinct?: ThreadRepostsScalarFieldEnum | ThreadRepostsScalarFieldEnum[];
  };

  /**
   * ThreadReposts findFirstOrThrow
   */
  export type ThreadRepostsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReposts
     */
    select?: ThreadRepostsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReposts
     */
    omit?: ThreadRepostsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadReposts to fetch.
     */
    where?: ThreadRepostsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadReposts to fetch.
     */
    orderBy?:
      | ThreadRepostsOrderByWithRelationInput
      | ThreadRepostsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ThreadReposts.
     */
    cursor?: ThreadRepostsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadReposts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadReposts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ThreadReposts.
     */
    distinct?: ThreadRepostsScalarFieldEnum | ThreadRepostsScalarFieldEnum[];
  };

  /**
   * ThreadReposts findMany
   */
  export type ThreadRepostsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReposts
     */
    select?: ThreadRepostsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReposts
     */
    omit?: ThreadRepostsOmit<ExtArgs> | null;
    /**
     * Filter, which ThreadReposts to fetch.
     */
    where?: ThreadRepostsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ThreadReposts to fetch.
     */
    orderBy?:
      | ThreadRepostsOrderByWithRelationInput
      | ThreadRepostsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ThreadReposts.
     */
    cursor?: ThreadRepostsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ThreadReposts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ThreadReposts.
     */
    skip?: number;
    distinct?: ThreadRepostsScalarFieldEnum | ThreadRepostsScalarFieldEnum[];
  };

  /**
   * ThreadReposts create
   */
  export type ThreadRepostsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReposts
     */
    select?: ThreadRepostsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReposts
     */
    omit?: ThreadRepostsOmit<ExtArgs> | null;
    /**
     * The data needed to create a ThreadReposts.
     */
    data: XOR<ThreadRepostsCreateInput, ThreadRepostsUncheckedCreateInput>;
  };

  /**
   * ThreadReposts createMany
   */
  export type ThreadRepostsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ThreadReposts.
     */
    data: ThreadRepostsCreateManyInput | ThreadRepostsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadReposts createManyAndReturn
   */
  export type ThreadRepostsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReposts
     */
    select?: ThreadRepostsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReposts
     */
    omit?: ThreadRepostsOmit<ExtArgs> | null;
    /**
     * The data used to create many ThreadReposts.
     */
    data: ThreadRepostsCreateManyInput | ThreadRepostsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ThreadReposts update
   */
  export type ThreadRepostsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReposts
     */
    select?: ThreadRepostsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReposts
     */
    omit?: ThreadRepostsOmit<ExtArgs> | null;
    /**
     * The data needed to update a ThreadReposts.
     */
    data: XOR<ThreadRepostsUpdateInput, ThreadRepostsUncheckedUpdateInput>;
    /**
     * Choose, which ThreadReposts to update.
     */
    where: ThreadRepostsWhereUniqueInput;
  };

  /**
   * ThreadReposts updateMany
   */
  export type ThreadRepostsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ThreadReposts.
     */
    data: XOR<
      ThreadRepostsUpdateManyMutationInput,
      ThreadRepostsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadReposts to update
     */
    where?: ThreadRepostsWhereInput;
    /**
     * Limit how many ThreadReposts to update.
     */
    limit?: number;
  };

  /**
   * ThreadReposts updateManyAndReturn
   */
  export type ThreadRepostsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReposts
     */
    select?: ThreadRepostsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReposts
     */
    omit?: ThreadRepostsOmit<ExtArgs> | null;
    /**
     * The data used to update ThreadReposts.
     */
    data: XOR<
      ThreadRepostsUpdateManyMutationInput,
      ThreadRepostsUncheckedUpdateManyInput
    >;
    /**
     * Filter which ThreadReposts to update
     */
    where?: ThreadRepostsWhereInput;
    /**
     * Limit how many ThreadReposts to update.
     */
    limit?: number;
  };

  /**
   * ThreadReposts upsert
   */
  export type ThreadRepostsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReposts
     */
    select?: ThreadRepostsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReposts
     */
    omit?: ThreadRepostsOmit<ExtArgs> | null;
    /**
     * The filter to search for the ThreadReposts to update in case it exists.
     */
    where: ThreadRepostsWhereUniqueInput;
    /**
     * In case the ThreadReposts found by the `where` argument doesn't exist, create a new ThreadReposts with this data.
     */
    create: XOR<ThreadRepostsCreateInput, ThreadRepostsUncheckedCreateInput>;
    /**
     * In case the ThreadReposts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadRepostsUpdateInput, ThreadRepostsUncheckedUpdateInput>;
  };

  /**
   * ThreadReposts delete
   */
  export type ThreadRepostsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReposts
     */
    select?: ThreadRepostsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReposts
     */
    omit?: ThreadRepostsOmit<ExtArgs> | null;
    /**
     * Filter which ThreadReposts to delete.
     */
    where: ThreadRepostsWhereUniqueInput;
  };

  /**
   * ThreadReposts deleteMany
   */
  export type ThreadRepostsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ThreadReposts to delete
     */
    where?: ThreadRepostsWhereInput;
    /**
     * Limit how many ThreadReposts to delete.
     */
    limit?: number;
  };

  /**
   * ThreadReposts without action
   */
  export type ThreadRepostsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ThreadReposts
     */
    select?: ThreadRepostsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ThreadReposts
     */
    omit?: ThreadRepostsOmit<ExtArgs> | null;
  };

  /**
   * Model Threads
   */

  export type AggregateThreads = {
    _count: ThreadsCountAggregateOutputType | null;
    _avg: ThreadsAvgAggregateOutputType | null;
    _sum: ThreadsSumAggregateOutputType | null;
    _min: ThreadsMinAggregateOutputType | null;
    _max: ThreadsMaxAggregateOutputType | null;
  };

  export type ThreadsAvgAggregateOutputType = {
    user_id: number | null;
    parent_level: number | null;
  };

  export type ThreadsSumAggregateOutputType = {
    user_id: number | null;
    parent_level: number | null;
  };

  export type ThreadsMinAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    content: string | null;
    visibility: $Enums.visibility_enum | null;
    start_thread_id: string | null;
    poll_id: string | null;
    parent_thread_id: string | null;
    quoted_thread_id: string | null;
    company_info_id: string | null;
    parent_level: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
    news_id: string | null;
  };

  export type ThreadsMaxAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    content: string | null;
    visibility: $Enums.visibility_enum | null;
    start_thread_id: string | null;
    poll_id: string | null;
    parent_thread_id: string | null;
    quoted_thread_id: string | null;
    company_info_id: string | null;
    parent_level: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
    news_id: string | null;
  };

  export type ThreadsCountAggregateOutputType = {
    id: number;
    user_id: number;
    content: number;
    visibility: number;
    start_thread_id: number;
    poll_id: number;
    parent_thread_id: number;
    quoted_thread_id: number;
    company_info_id: number;
    parent_level: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    news_id: number;
    _all: number;
  };

  export type ThreadsAvgAggregateInputType = {
    user_id?: true;
    parent_level?: true;
  };

  export type ThreadsSumAggregateInputType = {
    user_id?: true;
    parent_level?: true;
  };

  export type ThreadsMinAggregateInputType = {
    id?: true;
    user_id?: true;
    content?: true;
    visibility?: true;
    start_thread_id?: true;
    poll_id?: true;
    parent_thread_id?: true;
    quoted_thread_id?: true;
    company_info_id?: true;
    parent_level?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    news_id?: true;
  };

  export type ThreadsMaxAggregateInputType = {
    id?: true;
    user_id?: true;
    content?: true;
    visibility?: true;
    start_thread_id?: true;
    poll_id?: true;
    parent_thread_id?: true;
    quoted_thread_id?: true;
    company_info_id?: true;
    parent_level?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    news_id?: true;
  };

  export type ThreadsCountAggregateInputType = {
    id?: true;
    user_id?: true;
    content?: true;
    visibility?: true;
    start_thread_id?: true;
    poll_id?: true;
    parent_thread_id?: true;
    quoted_thread_id?: true;
    company_info_id?: true;
    parent_level?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    news_id?: true;
    _all?: true;
  };

  export type ThreadsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Threads to aggregate.
     */
    where?: ThreadsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Threads to fetch.
     */
    orderBy?:
      | ThreadsOrderByWithRelationInput
      | ThreadsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ThreadsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Threads.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Threads
     **/
    _count?: true | ThreadsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ThreadsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ThreadsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ThreadsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ThreadsMaxAggregateInputType;
  };

  export type GetThreadsAggregateType<T extends ThreadsAggregateArgs> = {
    [P in keyof T & keyof AggregateThreads]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreads[P]>
      : GetScalarType<T[P], AggregateThreads[P]>;
  };

  export type ThreadsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ThreadsWhereInput;
    orderBy?:
      | ThreadsOrderByWithAggregationInput
      | ThreadsOrderByWithAggregationInput[];
    by: ThreadsScalarFieldEnum[] | ThreadsScalarFieldEnum;
    having?: ThreadsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ThreadsCountAggregateInputType | true;
    _avg?: ThreadsAvgAggregateInputType;
    _sum?: ThreadsSumAggregateInputType;
    _min?: ThreadsMinAggregateInputType;
    _max?: ThreadsMaxAggregateInputType;
  };

  export type ThreadsGroupByOutputType = {
    id: string;
    user_id: number;
    content: string | null;
    visibility: $Enums.visibility_enum | null;
    start_thread_id: string | null;
    poll_id: string | null;
    parent_thread_id: string | null;
    quoted_thread_id: string | null;
    company_info_id: string | null;
    parent_level: number;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    news_id: string | null;
    _count: ThreadsCountAggregateOutputType | null;
    _avg: ThreadsAvgAggregateOutputType | null;
    _sum: ThreadsSumAggregateOutputType | null;
    _min: ThreadsMinAggregateOutputType | null;
    _max: ThreadsMaxAggregateOutputType | null;
  };

  type GetThreadsGroupByPayload<T extends ThreadsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ThreadsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ThreadsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadsGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadsGroupByOutputType[P]>;
        }
      >
    >;

  export type ThreadsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      content?: boolean;
      visibility?: boolean;
      start_thread_id?: boolean;
      poll_id?: boolean;
      parent_thread_id?: boolean;
      quoted_thread_id?: boolean;
      company_info_id?: boolean;
      parent_level?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
      news_id?: boolean;
    },
    ExtArgs['result']['threads']
  >;

  export type ThreadsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      content?: boolean;
      visibility?: boolean;
      start_thread_id?: boolean;
      poll_id?: boolean;
      parent_thread_id?: boolean;
      quoted_thread_id?: boolean;
      company_info_id?: boolean;
      parent_level?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
      news_id?: boolean;
    },
    ExtArgs['result']['threads']
  >;

  export type ThreadsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      content?: boolean;
      visibility?: boolean;
      start_thread_id?: boolean;
      poll_id?: boolean;
      parent_thread_id?: boolean;
      quoted_thread_id?: boolean;
      company_info_id?: boolean;
      parent_level?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
      news_id?: boolean;
    },
    ExtArgs['result']['threads']
  >;

  export type ThreadsSelectScalar = {
    id?: boolean;
    user_id?: boolean;
    content?: boolean;
    visibility?: boolean;
    start_thread_id?: boolean;
    poll_id?: boolean;
    parent_thread_id?: boolean;
    quoted_thread_id?: boolean;
    company_info_id?: boolean;
    parent_level?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
    news_id?: boolean;
  };

  export type ThreadsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'user_id'
    | 'content'
    | 'visibility'
    | 'start_thread_id'
    | 'poll_id'
    | 'parent_thread_id'
    | 'quoted_thread_id'
    | 'company_info_id'
    | 'parent_level'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at'
    | 'news_id',
    ExtArgs['result']['threads']
  >;

  export type $ThreadsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Threads';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        user_id: number;
        content: string | null;
        visibility: $Enums.visibility_enum | null;
        start_thread_id: string | null;
        poll_id: string | null;
        parent_thread_id: string | null;
        quoted_thread_id: string | null;
        company_info_id: string | null;
        parent_level: number;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
        news_id: string | null;
      },
      ExtArgs['result']['threads']
    >;
    composites: {};
  };

  type ThreadsGetPayload<
    S extends boolean | null | undefined | ThreadsDefaultArgs
  > = $Result.GetResult<Prisma.$ThreadsPayload, S>;

  type ThreadsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<ThreadsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ThreadsCountAggregateInputType | true;
  };

  export interface ThreadsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Threads'];
      meta: { name: 'Threads' };
    };
    /**
     * Find zero or one Threads that matches the filter.
     * @param {ThreadsFindUniqueArgs} args - Arguments to find a Threads
     * @example
     * // Get one Threads
     * const threads = await prisma.threads.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadsFindUniqueArgs>(
      args: SelectSubset<T, ThreadsFindUniqueArgs<ExtArgs>>
    ): Prisma__ThreadsClient<
      $Result.GetResult<
        Prisma.$ThreadsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Threads that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadsFindUniqueOrThrowArgs} args - Arguments to find a Threads
     * @example
     * // Get one Threads
     * const threads = await prisma.threads.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ThreadsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadsClient<
      $Result.GetResult<
        Prisma.$ThreadsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Threads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadsFindFirstArgs} args - Arguments to find a Threads
     * @example
     * // Get one Threads
     * const threads = await prisma.threads.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadsFindFirstArgs>(
      args?: SelectSubset<T, ThreadsFindFirstArgs<ExtArgs>>
    ): Prisma__ThreadsClient<
      $Result.GetResult<
        Prisma.$ThreadsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Threads that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadsFindFirstOrThrowArgs} args - Arguments to find a Threads
     * @example
     * // Get one Threads
     * const threads = await prisma.threads.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadsClient<
      $Result.GetResult<
        Prisma.$ThreadsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Threads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Threads
     * const threads = await prisma.threads.findMany()
     *
     * // Get first 10 Threads
     * const threads = await prisma.threads.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const threadsWithIdOnly = await prisma.threads.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ThreadsFindManyArgs>(
      args?: SelectSubset<T, ThreadsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Threads.
     * @param {ThreadsCreateArgs} args - Arguments to create a Threads.
     * @example
     * // Create one Threads
     * const Threads = await prisma.threads.create({
     *   data: {
     *     // ... data to create a Threads
     *   }
     * })
     *
     */
    create<T extends ThreadsCreateArgs>(
      args: SelectSubset<T, ThreadsCreateArgs<ExtArgs>>
    ): Prisma__ThreadsClient<
      $Result.GetResult<
        Prisma.$ThreadsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Threads.
     * @param {ThreadsCreateManyArgs} args - Arguments to create many Threads.
     * @example
     * // Create many Threads
     * const threads = await prisma.threads.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ThreadsCreateManyArgs>(
      args?: SelectSubset<T, ThreadsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Threads and returns the data saved in the database.
     * @param {ThreadsCreateManyAndReturnArgs} args - Arguments to create many Threads.
     * @example
     * // Create many Threads
     * const threads = await prisma.threads.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Threads and only return the `id`
     * const threadsWithIdOnly = await prisma.threads.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ThreadsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ThreadsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Threads.
     * @param {ThreadsDeleteArgs} args - Arguments to delete one Threads.
     * @example
     * // Delete one Threads
     * const Threads = await prisma.threads.delete({
     *   where: {
     *     // ... filter to delete one Threads
     *   }
     * })
     *
     */
    delete<T extends ThreadsDeleteArgs>(
      args: SelectSubset<T, ThreadsDeleteArgs<ExtArgs>>
    ): Prisma__ThreadsClient<
      $Result.GetResult<
        Prisma.$ThreadsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Threads.
     * @param {ThreadsUpdateArgs} args - Arguments to update one Threads.
     * @example
     * // Update one Threads
     * const threads = await prisma.threads.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ThreadsUpdateArgs>(
      args: SelectSubset<T, ThreadsUpdateArgs<ExtArgs>>
    ): Prisma__ThreadsClient<
      $Result.GetResult<
        Prisma.$ThreadsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Threads.
     * @param {ThreadsDeleteManyArgs} args - Arguments to filter Threads to delete.
     * @example
     * // Delete a few Threads
     * const { count } = await prisma.threads.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ThreadsDeleteManyArgs>(
      args?: SelectSubset<T, ThreadsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Threads
     * const threads = await prisma.threads.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ThreadsUpdateManyArgs>(
      args: SelectSubset<T, ThreadsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Threads and returns the data updated in the database.
     * @param {ThreadsUpdateManyAndReturnArgs} args - Arguments to update many Threads.
     * @example
     * // Update many Threads
     * const threads = await prisma.threads.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Threads and only return the `id`
     * const threadsWithIdOnly = await prisma.threads.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ThreadsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ThreadsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ThreadsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Threads.
     * @param {ThreadsUpsertArgs} args - Arguments to update or create a Threads.
     * @example
     * // Update or create a Threads
     * const threads = await prisma.threads.upsert({
     *   create: {
     *     // ... data to create a Threads
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Threads we want to update
     *   }
     * })
     */
    upsert<T extends ThreadsUpsertArgs>(
      args: SelectSubset<T, ThreadsUpsertArgs<ExtArgs>>
    ): Prisma__ThreadsClient<
      $Result.GetResult<
        Prisma.$ThreadsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadsCountArgs} args - Arguments to filter Threads to count.
     * @example
     * // Count the number of Threads
     * const count = await prisma.threads.count({
     *   where: {
     *     // ... the filter for the Threads we want to count
     *   }
     * })
     **/
    count<T extends ThreadsCountArgs>(
      args?: Subset<T, ThreadsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ThreadsAggregateArgs>(
      args: Subset<T, ThreadsAggregateArgs>
    ): Prisma.PrismaPromise<GetThreadsAggregateType<T>>;

    /**
     * Group by Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ThreadsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadsGroupByArgs['orderBy'] }
        : { orderBy?: ThreadsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ThreadsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetThreadsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Threads model
     */
    readonly fields: ThreadsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Threads.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Threads model
   */
  interface ThreadsFieldRefs {
    readonly id: FieldRef<'Threads', 'String'>;
    readonly user_id: FieldRef<'Threads', 'Int'>;
    readonly content: FieldRef<'Threads', 'String'>;
    readonly visibility: FieldRef<'Threads', 'visibility_enum'>;
    readonly start_thread_id: FieldRef<'Threads', 'String'>;
    readonly poll_id: FieldRef<'Threads', 'String'>;
    readonly parent_thread_id: FieldRef<'Threads', 'String'>;
    readonly quoted_thread_id: FieldRef<'Threads', 'String'>;
    readonly company_info_id: FieldRef<'Threads', 'String'>;
    readonly parent_level: FieldRef<'Threads', 'Int'>;
    readonly created_at: FieldRef<'Threads', 'DateTime'>;
    readonly updated_at: FieldRef<'Threads', 'DateTime'>;
    readonly deleted_at: FieldRef<'Threads', 'DateTime'>;
    readonly news_id: FieldRef<'Threads', 'String'>;
  }

  // Custom InputTypes
  /**
   * Threads findUnique
   */
  export type ThreadsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Threads
     */
    select?: ThreadsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Threads
     */
    omit?: ThreadsOmit<ExtArgs> | null;
    /**
     * Filter, which Threads to fetch.
     */
    where: ThreadsWhereUniqueInput;
  };

  /**
   * Threads findUniqueOrThrow
   */
  export type ThreadsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Threads
     */
    select?: ThreadsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Threads
     */
    omit?: ThreadsOmit<ExtArgs> | null;
    /**
     * Filter, which Threads to fetch.
     */
    where: ThreadsWhereUniqueInput;
  };

  /**
   * Threads findFirst
   */
  export type ThreadsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Threads
     */
    select?: ThreadsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Threads
     */
    omit?: ThreadsOmit<ExtArgs> | null;
    /**
     * Filter, which Threads to fetch.
     */
    where?: ThreadsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Threads to fetch.
     */
    orderBy?:
      | ThreadsOrderByWithRelationInput
      | ThreadsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Threads.
     */
    cursor?: ThreadsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Threads.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Threads.
     */
    distinct?: ThreadsScalarFieldEnum | ThreadsScalarFieldEnum[];
  };

  /**
   * Threads findFirstOrThrow
   */
  export type ThreadsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Threads
     */
    select?: ThreadsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Threads
     */
    omit?: ThreadsOmit<ExtArgs> | null;
    /**
     * Filter, which Threads to fetch.
     */
    where?: ThreadsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Threads to fetch.
     */
    orderBy?:
      | ThreadsOrderByWithRelationInput
      | ThreadsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Threads.
     */
    cursor?: ThreadsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Threads.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Threads.
     */
    distinct?: ThreadsScalarFieldEnum | ThreadsScalarFieldEnum[];
  };

  /**
   * Threads findMany
   */
  export type ThreadsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Threads
     */
    select?: ThreadsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Threads
     */
    omit?: ThreadsOmit<ExtArgs> | null;
    /**
     * Filter, which Threads to fetch.
     */
    where?: ThreadsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Threads to fetch.
     */
    orderBy?:
      | ThreadsOrderByWithRelationInput
      | ThreadsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Threads.
     */
    cursor?: ThreadsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Threads.
     */
    skip?: number;
    distinct?: ThreadsScalarFieldEnum | ThreadsScalarFieldEnum[];
  };

  /**
   * Threads create
   */
  export type ThreadsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Threads
     */
    select?: ThreadsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Threads
     */
    omit?: ThreadsOmit<ExtArgs> | null;
    /**
     * The data needed to create a Threads.
     */
    data: XOR<ThreadsCreateInput, ThreadsUncheckedCreateInput>;
  };

  /**
   * Threads createMany
   */
  export type ThreadsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Threads.
     */
    data: ThreadsCreateManyInput | ThreadsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Threads createManyAndReturn
   */
  export type ThreadsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Threads
     */
    select?: ThreadsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Threads
     */
    omit?: ThreadsOmit<ExtArgs> | null;
    /**
     * The data used to create many Threads.
     */
    data: ThreadsCreateManyInput | ThreadsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Threads update
   */
  export type ThreadsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Threads
     */
    select?: ThreadsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Threads
     */
    omit?: ThreadsOmit<ExtArgs> | null;
    /**
     * The data needed to update a Threads.
     */
    data: XOR<ThreadsUpdateInput, ThreadsUncheckedUpdateInput>;
    /**
     * Choose, which Threads to update.
     */
    where: ThreadsWhereUniqueInput;
  };

  /**
   * Threads updateMany
   */
  export type ThreadsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Threads.
     */
    data: XOR<ThreadsUpdateManyMutationInput, ThreadsUncheckedUpdateManyInput>;
    /**
     * Filter which Threads to update
     */
    where?: ThreadsWhereInput;
    /**
     * Limit how many Threads to update.
     */
    limit?: number;
  };

  /**
   * Threads updateManyAndReturn
   */
  export type ThreadsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Threads
     */
    select?: ThreadsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Threads
     */
    omit?: ThreadsOmit<ExtArgs> | null;
    /**
     * The data used to update Threads.
     */
    data: XOR<ThreadsUpdateManyMutationInput, ThreadsUncheckedUpdateManyInput>;
    /**
     * Filter which Threads to update
     */
    where?: ThreadsWhereInput;
    /**
     * Limit how many Threads to update.
     */
    limit?: number;
  };

  /**
   * Threads upsert
   */
  export type ThreadsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Threads
     */
    select?: ThreadsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Threads
     */
    omit?: ThreadsOmit<ExtArgs> | null;
    /**
     * The filter to search for the Threads to update in case it exists.
     */
    where: ThreadsWhereUniqueInput;
    /**
     * In case the Threads found by the `where` argument doesn't exist, create a new Threads with this data.
     */
    create: XOR<ThreadsCreateInput, ThreadsUncheckedCreateInput>;
    /**
     * In case the Threads was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadsUpdateInput, ThreadsUncheckedUpdateInput>;
  };

  /**
   * Threads delete
   */
  export type ThreadsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Threads
     */
    select?: ThreadsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Threads
     */
    omit?: ThreadsOmit<ExtArgs> | null;
    /**
     * Filter which Threads to delete.
     */
    where: ThreadsWhereUniqueInput;
  };

  /**
   * Threads deleteMany
   */
  export type ThreadsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Threads to delete
     */
    where?: ThreadsWhereInput;
    /**
     * Limit how many Threads to delete.
     */
    limit?: number;
  };

  /**
   * Threads without action
   */
  export type ThreadsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Threads
     */
    select?: ThreadsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Threads
     */
    omit?: ThreadsOmit<ExtArgs> | null;
  };

  /**
   * Model UserBlocks
   */

  export type AggregateUserBlocks = {
    _count: UserBlocksCountAggregateOutputType | null;
    _avg: UserBlocksAvgAggregateOutputType | null;
    _sum: UserBlocksSumAggregateOutputType | null;
    _min: UserBlocksMinAggregateOutputType | null;
    _max: UserBlocksMaxAggregateOutputType | null;
  };

  export type UserBlocksAvgAggregateOutputType = {
    blocker_user_id: number | null;
    blocked_user_id: number | null;
  };

  export type UserBlocksSumAggregateOutputType = {
    blocker_user_id: number | null;
    blocked_user_id: number | null;
  };

  export type UserBlocksMinAggregateOutputType = {
    id: string | null;
    blocker_user_id: number | null;
    blocked_user_id: number | null;
    reason: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type UserBlocksMaxAggregateOutputType = {
    id: string | null;
    blocker_user_id: number | null;
    blocked_user_id: number | null;
    reason: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type UserBlocksCountAggregateOutputType = {
    id: number;
    blocker_user_id: number;
    blocked_user_id: number;
    reason: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type UserBlocksAvgAggregateInputType = {
    blocker_user_id?: true;
    blocked_user_id?: true;
  };

  export type UserBlocksSumAggregateInputType = {
    blocker_user_id?: true;
    blocked_user_id?: true;
  };

  export type UserBlocksMinAggregateInputType = {
    id?: true;
    blocker_user_id?: true;
    blocked_user_id?: true;
    reason?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type UserBlocksMaxAggregateInputType = {
    id?: true;
    blocker_user_id?: true;
    blocked_user_id?: true;
    reason?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type UserBlocksCountAggregateInputType = {
    id?: true;
    blocker_user_id?: true;
    blocked_user_id?: true;
    reason?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type UserBlocksAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which UserBlocks to aggregate.
     */
    where?: UserBlocksWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserBlocks to fetch.
     */
    orderBy?:
      | UserBlocksOrderByWithRelationInput
      | UserBlocksOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserBlocksWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserBlocks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserBlocks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserBlocks
     **/
    _count?: true | UserBlocksCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UserBlocksAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UserBlocksSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserBlocksMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserBlocksMaxAggregateInputType;
  };

  export type GetUserBlocksAggregateType<T extends UserBlocksAggregateArgs> = {
    [P in keyof T & keyof AggregateUserBlocks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBlocks[P]>
      : GetScalarType<T[P], AggregateUserBlocks[P]>;
  };

  export type UserBlocksGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UserBlocksWhereInput;
    orderBy?:
      | UserBlocksOrderByWithAggregationInput
      | UserBlocksOrderByWithAggregationInput[];
    by: UserBlocksScalarFieldEnum[] | UserBlocksScalarFieldEnum;
    having?: UserBlocksScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserBlocksCountAggregateInputType | true;
    _avg?: UserBlocksAvgAggregateInputType;
    _sum?: UserBlocksSumAggregateInputType;
    _min?: UserBlocksMinAggregateInputType;
    _max?: UserBlocksMaxAggregateInputType;
  };

  export type UserBlocksGroupByOutputType = {
    id: string;
    blocker_user_id: number;
    blocked_user_id: number;
    reason: string | null;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: UserBlocksCountAggregateOutputType | null;
    _avg: UserBlocksAvgAggregateOutputType | null;
    _sum: UserBlocksSumAggregateOutputType | null;
    _min: UserBlocksMinAggregateOutputType | null;
    _max: UserBlocksMaxAggregateOutputType | null;
  };

  type GetUserBlocksGroupByPayload<T extends UserBlocksGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UserBlocksGroupByOutputType, T['by']> & {
          [P in keyof T & keyof UserBlocksGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBlocksGroupByOutputType[P]>
            : GetScalarType<T[P], UserBlocksGroupByOutputType[P]>;
        }
      >
    >;

  export type UserBlocksSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      blocker_user_id?: boolean;
      blocked_user_id?: boolean;
      reason?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['userBlocks']
  >;

  export type UserBlocksSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      blocker_user_id?: boolean;
      blocked_user_id?: boolean;
      reason?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['userBlocks']
  >;

  export type UserBlocksSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      blocker_user_id?: boolean;
      blocked_user_id?: boolean;
      reason?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['userBlocks']
  >;

  export type UserBlocksSelectScalar = {
    id?: boolean;
    blocker_user_id?: boolean;
    blocked_user_id?: boolean;
    reason?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type UserBlocksOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'blocker_user_id'
    | 'blocked_user_id'
    | 'reason'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['userBlocks']
  >;

  export type $UserBlocksPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'UserBlocks';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        blocker_user_id: number;
        blocked_user_id: number;
        reason: string | null;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['userBlocks']
    >;
    composites: {};
  };

  type UserBlocksGetPayload<
    S extends boolean | null | undefined | UserBlocksDefaultArgs
  > = $Result.GetResult<Prisma.$UserBlocksPayload, S>;

  type UserBlocksCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    UserBlocksFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: UserBlocksCountAggregateInputType | true;
  };

  export interface UserBlocksDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['UserBlocks'];
      meta: { name: 'UserBlocks' };
    };
    /**
     * Find zero or one UserBlocks that matches the filter.
     * @param {UserBlocksFindUniqueArgs} args - Arguments to find a UserBlocks
     * @example
     * // Get one UserBlocks
     * const userBlocks = await prisma.userBlocks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBlocksFindUniqueArgs>(
      args: SelectSubset<T, UserBlocksFindUniqueArgs<ExtArgs>>
    ): Prisma__UserBlocksClient<
      $Result.GetResult<
        Prisma.$UserBlocksPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserBlocks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserBlocksFindUniqueOrThrowArgs} args - Arguments to find a UserBlocks
     * @example
     * // Get one UserBlocks
     * const userBlocks = await prisma.userBlocks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBlocksFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserBlocksFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserBlocksClient<
      $Result.GetResult<
        Prisma.$UserBlocksPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBlocksFindFirstArgs} args - Arguments to find a UserBlocks
     * @example
     * // Get one UserBlocks
     * const userBlocks = await prisma.userBlocks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBlocksFindFirstArgs>(
      args?: SelectSubset<T, UserBlocksFindFirstArgs<ExtArgs>>
    ): Prisma__UserBlocksClient<
      $Result.GetResult<
        Prisma.$UserBlocksPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserBlocks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBlocksFindFirstOrThrowArgs} args - Arguments to find a UserBlocks
     * @example
     * // Get one UserBlocks
     * const userBlocks = await prisma.userBlocks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBlocksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserBlocksFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserBlocksClient<
      $Result.GetResult<
        Prisma.$UserBlocksPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBlocksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBlocks
     * const userBlocks = await prisma.userBlocks.findMany()
     *
     * // Get first 10 UserBlocks
     * const userBlocks = await prisma.userBlocks.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userBlocksWithIdOnly = await prisma.userBlocks.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserBlocksFindManyArgs>(
      args?: SelectSubset<T, UserBlocksFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserBlocksPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a UserBlocks.
     * @param {UserBlocksCreateArgs} args - Arguments to create a UserBlocks.
     * @example
     * // Create one UserBlocks
     * const UserBlocks = await prisma.userBlocks.create({
     *   data: {
     *     // ... data to create a UserBlocks
     *   }
     * })
     *
     */
    create<T extends UserBlocksCreateArgs>(
      args: SelectSubset<T, UserBlocksCreateArgs<ExtArgs>>
    ): Prisma__UserBlocksClient<
      $Result.GetResult<
        Prisma.$UserBlocksPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserBlocks.
     * @param {UserBlocksCreateManyArgs} args - Arguments to create many UserBlocks.
     * @example
     * // Create many UserBlocks
     * const userBlocks = await prisma.userBlocks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserBlocksCreateManyArgs>(
      args?: SelectSubset<T, UserBlocksCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserBlocks and returns the data saved in the database.
     * @param {UserBlocksCreateManyAndReturnArgs} args - Arguments to create many UserBlocks.
     * @example
     * // Create many UserBlocks
     * const userBlocks = await prisma.userBlocks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserBlocks and only return the `id`
     * const userBlocksWithIdOnly = await prisma.userBlocks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserBlocksCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserBlocksCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserBlocksPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UserBlocks.
     * @param {UserBlocksDeleteArgs} args - Arguments to delete one UserBlocks.
     * @example
     * // Delete one UserBlocks
     * const UserBlocks = await prisma.userBlocks.delete({
     *   where: {
     *     // ... filter to delete one UserBlocks
     *   }
     * })
     *
     */
    delete<T extends UserBlocksDeleteArgs>(
      args: SelectSubset<T, UserBlocksDeleteArgs<ExtArgs>>
    ): Prisma__UserBlocksClient<
      $Result.GetResult<
        Prisma.$UserBlocksPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserBlocks.
     * @param {UserBlocksUpdateArgs} args - Arguments to update one UserBlocks.
     * @example
     * // Update one UserBlocks
     * const userBlocks = await prisma.userBlocks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserBlocksUpdateArgs>(
      args: SelectSubset<T, UserBlocksUpdateArgs<ExtArgs>>
    ): Prisma__UserBlocksClient<
      $Result.GetResult<
        Prisma.$UserBlocksPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserBlocks.
     * @param {UserBlocksDeleteManyArgs} args - Arguments to filter UserBlocks to delete.
     * @example
     * // Delete a few UserBlocks
     * const { count } = await prisma.userBlocks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserBlocksDeleteManyArgs>(
      args?: SelectSubset<T, UserBlocksDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBlocksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBlocks
     * const userBlocks = await prisma.userBlocks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserBlocksUpdateManyArgs>(
      args: SelectSubset<T, UserBlocksUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserBlocks and returns the data updated in the database.
     * @param {UserBlocksUpdateManyAndReturnArgs} args - Arguments to update many UserBlocks.
     * @example
     * // Update many UserBlocks
     * const userBlocks = await prisma.userBlocks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserBlocks and only return the `id`
     * const userBlocksWithIdOnly = await prisma.userBlocks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserBlocksUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserBlocksUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserBlocksPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UserBlocks.
     * @param {UserBlocksUpsertArgs} args - Arguments to update or create a UserBlocks.
     * @example
     * // Update or create a UserBlocks
     * const userBlocks = await prisma.userBlocks.upsert({
     *   create: {
     *     // ... data to create a UserBlocks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBlocks we want to update
     *   }
     * })
     */
    upsert<T extends UserBlocksUpsertArgs>(
      args: SelectSubset<T, UserBlocksUpsertArgs<ExtArgs>>
    ): Prisma__UserBlocksClient<
      $Result.GetResult<
        Prisma.$UserBlocksPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBlocksCountArgs} args - Arguments to filter UserBlocks to count.
     * @example
     * // Count the number of UserBlocks
     * const count = await prisma.userBlocks.count({
     *   where: {
     *     // ... the filter for the UserBlocks we want to count
     *   }
     * })
     **/
    count<T extends UserBlocksCountArgs>(
      args?: Subset<T, UserBlocksCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBlocksCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBlocksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserBlocksAggregateArgs>(
      args: Subset<T, UserBlocksAggregateArgs>
    ): Prisma.PrismaPromise<GetUserBlocksAggregateType<T>>;

    /**
     * Group by UserBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBlocksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserBlocksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBlocksGroupByArgs['orderBy'] }
        : { orderBy?: UserBlocksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, UserBlocksGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetUserBlocksGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserBlocks model
     */
    readonly fields: UserBlocksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBlocks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBlocksClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserBlocks model
   */
  interface UserBlocksFieldRefs {
    readonly id: FieldRef<'UserBlocks', 'String'>;
    readonly blocker_user_id: FieldRef<'UserBlocks', 'Int'>;
    readonly blocked_user_id: FieldRef<'UserBlocks', 'Int'>;
    readonly reason: FieldRef<'UserBlocks', 'String'>;
    readonly created_at: FieldRef<'UserBlocks', 'DateTime'>;
    readonly updated_at: FieldRef<'UserBlocks', 'DateTime'>;
    readonly deleted_at: FieldRef<'UserBlocks', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * UserBlocks findUnique
   */
  export type UserBlocksFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserBlocks
     */
    select?: UserBlocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserBlocks
     */
    omit?: UserBlocksOmit<ExtArgs> | null;
    /**
     * Filter, which UserBlocks to fetch.
     */
    where: UserBlocksWhereUniqueInput;
  };

  /**
   * UserBlocks findUniqueOrThrow
   */
  export type UserBlocksFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserBlocks
     */
    select?: UserBlocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserBlocks
     */
    omit?: UserBlocksOmit<ExtArgs> | null;
    /**
     * Filter, which UserBlocks to fetch.
     */
    where: UserBlocksWhereUniqueInput;
  };

  /**
   * UserBlocks findFirst
   */
  export type UserBlocksFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserBlocks
     */
    select?: UserBlocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserBlocks
     */
    omit?: UserBlocksOmit<ExtArgs> | null;
    /**
     * Filter, which UserBlocks to fetch.
     */
    where?: UserBlocksWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserBlocks to fetch.
     */
    orderBy?:
      | UserBlocksOrderByWithRelationInput
      | UserBlocksOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserBlocks.
     */
    cursor?: UserBlocksWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserBlocks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserBlocks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserBlocks.
     */
    distinct?: UserBlocksScalarFieldEnum | UserBlocksScalarFieldEnum[];
  };

  /**
   * UserBlocks findFirstOrThrow
   */
  export type UserBlocksFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserBlocks
     */
    select?: UserBlocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserBlocks
     */
    omit?: UserBlocksOmit<ExtArgs> | null;
    /**
     * Filter, which UserBlocks to fetch.
     */
    where?: UserBlocksWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserBlocks to fetch.
     */
    orderBy?:
      | UserBlocksOrderByWithRelationInput
      | UserBlocksOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserBlocks.
     */
    cursor?: UserBlocksWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserBlocks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserBlocks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserBlocks.
     */
    distinct?: UserBlocksScalarFieldEnum | UserBlocksScalarFieldEnum[];
  };

  /**
   * UserBlocks findMany
   */
  export type UserBlocksFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserBlocks
     */
    select?: UserBlocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserBlocks
     */
    omit?: UserBlocksOmit<ExtArgs> | null;
    /**
     * Filter, which UserBlocks to fetch.
     */
    where?: UserBlocksWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserBlocks to fetch.
     */
    orderBy?:
      | UserBlocksOrderByWithRelationInput
      | UserBlocksOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserBlocks.
     */
    cursor?: UserBlocksWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserBlocks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserBlocks.
     */
    skip?: number;
    distinct?: UserBlocksScalarFieldEnum | UserBlocksScalarFieldEnum[];
  };

  /**
   * UserBlocks create
   */
  export type UserBlocksCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserBlocks
     */
    select?: UserBlocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserBlocks
     */
    omit?: UserBlocksOmit<ExtArgs> | null;
    /**
     * The data needed to create a UserBlocks.
     */
    data: XOR<UserBlocksCreateInput, UserBlocksUncheckedCreateInput>;
  };

  /**
   * UserBlocks createMany
   */
  export type UserBlocksCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many UserBlocks.
     */
    data: UserBlocksCreateManyInput | UserBlocksCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserBlocks createManyAndReturn
   */
  export type UserBlocksCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserBlocks
     */
    select?: UserBlocksSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserBlocks
     */
    omit?: UserBlocksOmit<ExtArgs> | null;
    /**
     * The data used to create many UserBlocks.
     */
    data: UserBlocksCreateManyInput | UserBlocksCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserBlocks update
   */
  export type UserBlocksUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserBlocks
     */
    select?: UserBlocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserBlocks
     */
    omit?: UserBlocksOmit<ExtArgs> | null;
    /**
     * The data needed to update a UserBlocks.
     */
    data: XOR<UserBlocksUpdateInput, UserBlocksUncheckedUpdateInput>;
    /**
     * Choose, which UserBlocks to update.
     */
    where: UserBlocksWhereUniqueInput;
  };

  /**
   * UserBlocks updateMany
   */
  export type UserBlocksUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update UserBlocks.
     */
    data: XOR<
      UserBlocksUpdateManyMutationInput,
      UserBlocksUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserBlocks to update
     */
    where?: UserBlocksWhereInput;
    /**
     * Limit how many UserBlocks to update.
     */
    limit?: number;
  };

  /**
   * UserBlocks updateManyAndReturn
   */
  export type UserBlocksUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserBlocks
     */
    select?: UserBlocksSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserBlocks
     */
    omit?: UserBlocksOmit<ExtArgs> | null;
    /**
     * The data used to update UserBlocks.
     */
    data: XOR<
      UserBlocksUpdateManyMutationInput,
      UserBlocksUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserBlocks to update
     */
    where?: UserBlocksWhereInput;
    /**
     * Limit how many UserBlocks to update.
     */
    limit?: number;
  };

  /**
   * UserBlocks upsert
   */
  export type UserBlocksUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserBlocks
     */
    select?: UserBlocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserBlocks
     */
    omit?: UserBlocksOmit<ExtArgs> | null;
    /**
     * The filter to search for the UserBlocks to update in case it exists.
     */
    where: UserBlocksWhereUniqueInput;
    /**
     * In case the UserBlocks found by the `where` argument doesn't exist, create a new UserBlocks with this data.
     */
    create: XOR<UserBlocksCreateInput, UserBlocksUncheckedCreateInput>;
    /**
     * In case the UserBlocks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBlocksUpdateInput, UserBlocksUncheckedUpdateInput>;
  };

  /**
   * UserBlocks delete
   */
  export type UserBlocksDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserBlocks
     */
    select?: UserBlocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserBlocks
     */
    omit?: UserBlocksOmit<ExtArgs> | null;
    /**
     * Filter which UserBlocks to delete.
     */
    where: UserBlocksWhereUniqueInput;
  };

  /**
   * UserBlocks deleteMany
   */
  export type UserBlocksDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which UserBlocks to delete
     */
    where?: UserBlocksWhereInput;
    /**
     * Limit how many UserBlocks to delete.
     */
    limit?: number;
  };

  /**
   * UserBlocks without action
   */
  export type UserBlocksDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserBlocks
     */
    select?: UserBlocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserBlocks
     */
    omit?: UserBlocksOmit<ExtArgs> | null;
  };

  /**
   * Model UserInterestLogs
   */

  export type AggregateUserInterestLogs = {
    _count: UserInterestLogsCountAggregateOutputType | null;
    _avg: UserInterestLogsAvgAggregateOutputType | null;
    _sum: UserInterestLogsSumAggregateOutputType | null;
    _min: UserInterestLogsMinAggregateOutputType | null;
    _max: UserInterestLogsMaxAggregateOutputType | null;
  };

  export type UserInterestLogsAvgAggregateOutputType = {
    user_id: number | null;
    weight: number | null;
  };

  export type UserInterestLogsSumAggregateOutputType = {
    user_id: number | null;
    weight: number | null;
  };

  export type UserInterestLogsMinAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    symbol_id: string | null;
    activity_type: string | null;
    weight: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type UserInterestLogsMaxAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    symbol_id: string | null;
    activity_type: string | null;
    weight: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type UserInterestLogsCountAggregateOutputType = {
    id: number;
    user_id: number;
    symbol_id: number;
    activity_type: number;
    weight: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type UserInterestLogsAvgAggregateInputType = {
    user_id?: true;
    weight?: true;
  };

  export type UserInterestLogsSumAggregateInputType = {
    user_id?: true;
    weight?: true;
  };

  export type UserInterestLogsMinAggregateInputType = {
    id?: true;
    user_id?: true;
    symbol_id?: true;
    activity_type?: true;
    weight?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type UserInterestLogsMaxAggregateInputType = {
    id?: true;
    user_id?: true;
    symbol_id?: true;
    activity_type?: true;
    weight?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type UserInterestLogsCountAggregateInputType = {
    id?: true;
    user_id?: true;
    symbol_id?: true;
    activity_type?: true;
    weight?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type UserInterestLogsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which UserInterestLogs to aggregate.
     */
    where?: UserInterestLogsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserInterestLogs to fetch.
     */
    orderBy?:
      | UserInterestLogsOrderByWithRelationInput
      | UserInterestLogsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserInterestLogsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserInterestLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserInterestLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserInterestLogs
     **/
    _count?: true | UserInterestLogsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UserInterestLogsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UserInterestLogsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserInterestLogsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserInterestLogsMaxAggregateInputType;
  };

  export type GetUserInterestLogsAggregateType<
    T extends UserInterestLogsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateUserInterestLogs]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInterestLogs[P]>
      : GetScalarType<T[P], AggregateUserInterestLogs[P]>;
  };

  export type UserInterestLogsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UserInterestLogsWhereInput;
    orderBy?:
      | UserInterestLogsOrderByWithAggregationInput
      | UserInterestLogsOrderByWithAggregationInput[];
    by: UserInterestLogsScalarFieldEnum[] | UserInterestLogsScalarFieldEnum;
    having?: UserInterestLogsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserInterestLogsCountAggregateInputType | true;
    _avg?: UserInterestLogsAvgAggregateInputType;
    _sum?: UserInterestLogsSumAggregateInputType;
    _min?: UserInterestLogsMinAggregateInputType;
    _max?: UserInterestLogsMaxAggregateInputType;
  };

  export type UserInterestLogsGroupByOutputType = {
    id: string;
    user_id: number;
    symbol_id: string;
    activity_type: string;
    weight: number | null;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: UserInterestLogsCountAggregateOutputType | null;
    _avg: UserInterestLogsAvgAggregateOutputType | null;
    _sum: UserInterestLogsSumAggregateOutputType | null;
    _min: UserInterestLogsMinAggregateOutputType | null;
    _max: UserInterestLogsMaxAggregateOutputType | null;
  };

  type GetUserInterestLogsGroupByPayload<
    T extends UserInterestLogsGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserInterestLogsGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof UserInterestLogsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserInterestLogsGroupByOutputType[P]>
          : GetScalarType<T[P], UserInterestLogsGroupByOutputType[P]>;
      }
    >
  >;

  export type UserInterestLogsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      symbol_id?: boolean;
      activity_type?: boolean;
      weight?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['userInterestLogs']
  >;

  export type UserInterestLogsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      symbol_id?: boolean;
      activity_type?: boolean;
      weight?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['userInterestLogs']
  >;

  export type UserInterestLogsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      symbol_id?: boolean;
      activity_type?: boolean;
      weight?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['userInterestLogs']
  >;

  export type UserInterestLogsSelectScalar = {
    id?: boolean;
    user_id?: boolean;
    symbol_id?: boolean;
    activity_type?: boolean;
    weight?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type UserInterestLogsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'user_id'
    | 'symbol_id'
    | 'activity_type'
    | 'weight'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['userInterestLogs']
  >;

  export type $UserInterestLogsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'UserInterestLogs';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        user_id: number;
        symbol_id: string;
        activity_type: string;
        weight: number | null;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['userInterestLogs']
    >;
    composites: {};
  };

  type UserInterestLogsGetPayload<
    S extends boolean | null | undefined | UserInterestLogsDefaultArgs
  > = $Result.GetResult<Prisma.$UserInterestLogsPayload, S>;

  type UserInterestLogsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    UserInterestLogsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: UserInterestLogsCountAggregateInputType | true;
  };

  export interface UserInterestLogsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['UserInterestLogs'];
      meta: { name: 'UserInterestLogs' };
    };
    /**
     * Find zero or one UserInterestLogs that matches the filter.
     * @param {UserInterestLogsFindUniqueArgs} args - Arguments to find a UserInterestLogs
     * @example
     * // Get one UserInterestLogs
     * const userInterestLogs = await prisma.userInterestLogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInterestLogsFindUniqueArgs>(
      args: SelectSubset<T, UserInterestLogsFindUniqueArgs<ExtArgs>>
    ): Prisma__UserInterestLogsClient<
      $Result.GetResult<
        Prisma.$UserInterestLogsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserInterestLogs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserInterestLogsFindUniqueOrThrowArgs} args - Arguments to find a UserInterestLogs
     * @example
     * // Get one UserInterestLogs
     * const userInterestLogs = await prisma.userInterestLogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInterestLogsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserInterestLogsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserInterestLogsClient<
      $Result.GetResult<
        Prisma.$UserInterestLogsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserInterestLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestLogsFindFirstArgs} args - Arguments to find a UserInterestLogs
     * @example
     * // Get one UserInterestLogs
     * const userInterestLogs = await prisma.userInterestLogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInterestLogsFindFirstArgs>(
      args?: SelectSubset<T, UserInterestLogsFindFirstArgs<ExtArgs>>
    ): Prisma__UserInterestLogsClient<
      $Result.GetResult<
        Prisma.$UserInterestLogsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserInterestLogs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestLogsFindFirstOrThrowArgs} args - Arguments to find a UserInterestLogs
     * @example
     * // Get one UserInterestLogs
     * const userInterestLogs = await prisma.userInterestLogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInterestLogsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserInterestLogsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserInterestLogsClient<
      $Result.GetResult<
        Prisma.$UserInterestLogsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserInterestLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestLogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInterestLogs
     * const userInterestLogs = await prisma.userInterestLogs.findMany()
     *
     * // Get first 10 UserInterestLogs
     * const userInterestLogs = await prisma.userInterestLogs.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userInterestLogsWithIdOnly = await prisma.userInterestLogs.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserInterestLogsFindManyArgs>(
      args?: SelectSubset<T, UserInterestLogsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserInterestLogsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a UserInterestLogs.
     * @param {UserInterestLogsCreateArgs} args - Arguments to create a UserInterestLogs.
     * @example
     * // Create one UserInterestLogs
     * const UserInterestLogs = await prisma.userInterestLogs.create({
     *   data: {
     *     // ... data to create a UserInterestLogs
     *   }
     * })
     *
     */
    create<T extends UserInterestLogsCreateArgs>(
      args: SelectSubset<T, UserInterestLogsCreateArgs<ExtArgs>>
    ): Prisma__UserInterestLogsClient<
      $Result.GetResult<
        Prisma.$UserInterestLogsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserInterestLogs.
     * @param {UserInterestLogsCreateManyArgs} args - Arguments to create many UserInterestLogs.
     * @example
     * // Create many UserInterestLogs
     * const userInterestLogs = await prisma.userInterestLogs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserInterestLogsCreateManyArgs>(
      args?: SelectSubset<T, UserInterestLogsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserInterestLogs and returns the data saved in the database.
     * @param {UserInterestLogsCreateManyAndReturnArgs} args - Arguments to create many UserInterestLogs.
     * @example
     * // Create many UserInterestLogs
     * const userInterestLogs = await prisma.userInterestLogs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserInterestLogs and only return the `id`
     * const userInterestLogsWithIdOnly = await prisma.userInterestLogs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserInterestLogsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserInterestLogsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserInterestLogsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UserInterestLogs.
     * @param {UserInterestLogsDeleteArgs} args - Arguments to delete one UserInterestLogs.
     * @example
     * // Delete one UserInterestLogs
     * const UserInterestLogs = await prisma.userInterestLogs.delete({
     *   where: {
     *     // ... filter to delete one UserInterestLogs
     *   }
     * })
     *
     */
    delete<T extends UserInterestLogsDeleteArgs>(
      args: SelectSubset<T, UserInterestLogsDeleteArgs<ExtArgs>>
    ): Prisma__UserInterestLogsClient<
      $Result.GetResult<
        Prisma.$UserInterestLogsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserInterestLogs.
     * @param {UserInterestLogsUpdateArgs} args - Arguments to update one UserInterestLogs.
     * @example
     * // Update one UserInterestLogs
     * const userInterestLogs = await prisma.userInterestLogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserInterestLogsUpdateArgs>(
      args: SelectSubset<T, UserInterestLogsUpdateArgs<ExtArgs>>
    ): Prisma__UserInterestLogsClient<
      $Result.GetResult<
        Prisma.$UserInterestLogsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserInterestLogs.
     * @param {UserInterestLogsDeleteManyArgs} args - Arguments to filter UserInterestLogs to delete.
     * @example
     * // Delete a few UserInterestLogs
     * const { count } = await prisma.userInterestLogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserInterestLogsDeleteManyArgs>(
      args?: SelectSubset<T, UserInterestLogsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserInterestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestLogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInterestLogs
     * const userInterestLogs = await prisma.userInterestLogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserInterestLogsUpdateManyArgs>(
      args: SelectSubset<T, UserInterestLogsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserInterestLogs and returns the data updated in the database.
     * @param {UserInterestLogsUpdateManyAndReturnArgs} args - Arguments to update many UserInterestLogs.
     * @example
     * // Update many UserInterestLogs
     * const userInterestLogs = await prisma.userInterestLogs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserInterestLogs and only return the `id`
     * const userInterestLogsWithIdOnly = await prisma.userInterestLogs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserInterestLogsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserInterestLogsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserInterestLogsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UserInterestLogs.
     * @param {UserInterestLogsUpsertArgs} args - Arguments to update or create a UserInterestLogs.
     * @example
     * // Update or create a UserInterestLogs
     * const userInterestLogs = await prisma.userInterestLogs.upsert({
     *   create: {
     *     // ... data to create a UserInterestLogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInterestLogs we want to update
     *   }
     * })
     */
    upsert<T extends UserInterestLogsUpsertArgs>(
      args: SelectSubset<T, UserInterestLogsUpsertArgs<ExtArgs>>
    ): Prisma__UserInterestLogsClient<
      $Result.GetResult<
        Prisma.$UserInterestLogsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserInterestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestLogsCountArgs} args - Arguments to filter UserInterestLogs to count.
     * @example
     * // Count the number of UserInterestLogs
     * const count = await prisma.userInterestLogs.count({
     *   where: {
     *     // ... the filter for the UserInterestLogs we want to count
     *   }
     * })
     **/
    count<T extends UserInterestLogsCountArgs>(
      args?: Subset<T, UserInterestLogsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInterestLogsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserInterestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestLogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserInterestLogsAggregateArgs>(
      args: Subset<T, UserInterestLogsAggregateArgs>
    ): Prisma.PrismaPromise<GetUserInterestLogsAggregateType<T>>;

    /**
     * Group by UserInterestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestLogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserInterestLogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInterestLogsGroupByArgs['orderBy'] }
        : { orderBy?: UserInterestLogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, UserInterestLogsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetUserInterestLogsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserInterestLogs model
     */
    readonly fields: UserInterestLogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInterestLogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInterestLogsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserInterestLogs model
   */
  interface UserInterestLogsFieldRefs {
    readonly id: FieldRef<'UserInterestLogs', 'String'>;
    readonly user_id: FieldRef<'UserInterestLogs', 'Int'>;
    readonly symbol_id: FieldRef<'UserInterestLogs', 'String'>;
    readonly activity_type: FieldRef<'UserInterestLogs', 'String'>;
    readonly weight: FieldRef<'UserInterestLogs', 'Float'>;
    readonly created_at: FieldRef<'UserInterestLogs', 'DateTime'>;
    readonly updated_at: FieldRef<'UserInterestLogs', 'DateTime'>;
    readonly deleted_at: FieldRef<'UserInterestLogs', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * UserInterestLogs findUnique
   */
  export type UserInterestLogsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterestLogs
     */
    select?: UserInterestLogsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterestLogs
     */
    omit?: UserInterestLogsOmit<ExtArgs> | null;
    /**
     * Filter, which UserInterestLogs to fetch.
     */
    where: UserInterestLogsWhereUniqueInput;
  };

  /**
   * UserInterestLogs findUniqueOrThrow
   */
  export type UserInterestLogsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterestLogs
     */
    select?: UserInterestLogsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterestLogs
     */
    omit?: UserInterestLogsOmit<ExtArgs> | null;
    /**
     * Filter, which UserInterestLogs to fetch.
     */
    where: UserInterestLogsWhereUniqueInput;
  };

  /**
   * UserInterestLogs findFirst
   */
  export type UserInterestLogsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterestLogs
     */
    select?: UserInterestLogsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterestLogs
     */
    omit?: UserInterestLogsOmit<ExtArgs> | null;
    /**
     * Filter, which UserInterestLogs to fetch.
     */
    where?: UserInterestLogsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserInterestLogs to fetch.
     */
    orderBy?:
      | UserInterestLogsOrderByWithRelationInput
      | UserInterestLogsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserInterestLogs.
     */
    cursor?: UserInterestLogsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserInterestLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserInterestLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserInterestLogs.
     */
    distinct?:
      | UserInterestLogsScalarFieldEnum
      | UserInterestLogsScalarFieldEnum[];
  };

  /**
   * UserInterestLogs findFirstOrThrow
   */
  export type UserInterestLogsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterestLogs
     */
    select?: UserInterestLogsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterestLogs
     */
    omit?: UserInterestLogsOmit<ExtArgs> | null;
    /**
     * Filter, which UserInterestLogs to fetch.
     */
    where?: UserInterestLogsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserInterestLogs to fetch.
     */
    orderBy?:
      | UserInterestLogsOrderByWithRelationInput
      | UserInterestLogsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserInterestLogs.
     */
    cursor?: UserInterestLogsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserInterestLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserInterestLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserInterestLogs.
     */
    distinct?:
      | UserInterestLogsScalarFieldEnum
      | UserInterestLogsScalarFieldEnum[];
  };

  /**
   * UserInterestLogs findMany
   */
  export type UserInterestLogsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterestLogs
     */
    select?: UserInterestLogsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterestLogs
     */
    omit?: UserInterestLogsOmit<ExtArgs> | null;
    /**
     * Filter, which UserInterestLogs to fetch.
     */
    where?: UserInterestLogsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserInterestLogs to fetch.
     */
    orderBy?:
      | UserInterestLogsOrderByWithRelationInput
      | UserInterestLogsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserInterestLogs.
     */
    cursor?: UserInterestLogsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserInterestLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserInterestLogs.
     */
    skip?: number;
    distinct?:
      | UserInterestLogsScalarFieldEnum
      | UserInterestLogsScalarFieldEnum[];
  };

  /**
   * UserInterestLogs create
   */
  export type UserInterestLogsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterestLogs
     */
    select?: UserInterestLogsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterestLogs
     */
    omit?: UserInterestLogsOmit<ExtArgs> | null;
    /**
     * The data needed to create a UserInterestLogs.
     */
    data: XOR<
      UserInterestLogsCreateInput,
      UserInterestLogsUncheckedCreateInput
    >;
  };

  /**
   * UserInterestLogs createMany
   */
  export type UserInterestLogsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many UserInterestLogs.
     */
    data: UserInterestLogsCreateManyInput | UserInterestLogsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserInterestLogs createManyAndReturn
   */
  export type UserInterestLogsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterestLogs
     */
    select?: UserInterestLogsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterestLogs
     */
    omit?: UserInterestLogsOmit<ExtArgs> | null;
    /**
     * The data used to create many UserInterestLogs.
     */
    data: UserInterestLogsCreateManyInput | UserInterestLogsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserInterestLogs update
   */
  export type UserInterestLogsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterestLogs
     */
    select?: UserInterestLogsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterestLogs
     */
    omit?: UserInterestLogsOmit<ExtArgs> | null;
    /**
     * The data needed to update a UserInterestLogs.
     */
    data: XOR<
      UserInterestLogsUpdateInput,
      UserInterestLogsUncheckedUpdateInput
    >;
    /**
     * Choose, which UserInterestLogs to update.
     */
    where: UserInterestLogsWhereUniqueInput;
  };

  /**
   * UserInterestLogs updateMany
   */
  export type UserInterestLogsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update UserInterestLogs.
     */
    data: XOR<
      UserInterestLogsUpdateManyMutationInput,
      UserInterestLogsUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserInterestLogs to update
     */
    where?: UserInterestLogsWhereInput;
    /**
     * Limit how many UserInterestLogs to update.
     */
    limit?: number;
  };

  /**
   * UserInterestLogs updateManyAndReturn
   */
  export type UserInterestLogsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterestLogs
     */
    select?: UserInterestLogsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterestLogs
     */
    omit?: UserInterestLogsOmit<ExtArgs> | null;
    /**
     * The data used to update UserInterestLogs.
     */
    data: XOR<
      UserInterestLogsUpdateManyMutationInput,
      UserInterestLogsUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserInterestLogs to update
     */
    where?: UserInterestLogsWhereInput;
    /**
     * Limit how many UserInterestLogs to update.
     */
    limit?: number;
  };

  /**
   * UserInterestLogs upsert
   */
  export type UserInterestLogsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterestLogs
     */
    select?: UserInterestLogsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterestLogs
     */
    omit?: UserInterestLogsOmit<ExtArgs> | null;
    /**
     * The filter to search for the UserInterestLogs to update in case it exists.
     */
    where: UserInterestLogsWhereUniqueInput;
    /**
     * In case the UserInterestLogs found by the `where` argument doesn't exist, create a new UserInterestLogs with this data.
     */
    create: XOR<
      UserInterestLogsCreateInput,
      UserInterestLogsUncheckedCreateInput
    >;
    /**
     * In case the UserInterestLogs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      UserInterestLogsUpdateInput,
      UserInterestLogsUncheckedUpdateInput
    >;
  };

  /**
   * UserInterestLogs delete
   */
  export type UserInterestLogsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterestLogs
     */
    select?: UserInterestLogsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterestLogs
     */
    omit?: UserInterestLogsOmit<ExtArgs> | null;
    /**
     * Filter which UserInterestLogs to delete.
     */
    where: UserInterestLogsWhereUniqueInput;
  };

  /**
   * UserInterestLogs deleteMany
   */
  export type UserInterestLogsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which UserInterestLogs to delete
     */
    where?: UserInterestLogsWhereInput;
    /**
     * Limit how many UserInterestLogs to delete.
     */
    limit?: number;
  };

  /**
   * UserInterestLogs without action
   */
  export type UserInterestLogsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterestLogs
     */
    select?: UserInterestLogsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterestLogs
     */
    omit?: UserInterestLogsOmit<ExtArgs> | null;
  };

  /**
   * Model UserInterests
   */

  export type AggregateUserInterests = {
    _count: UserInterestsCountAggregateOutputType | null;
    _avg: UserInterestsAvgAggregateOutputType | null;
    _sum: UserInterestsSumAggregateOutputType | null;
    _min: UserInterestsMinAggregateOutputType | null;
    _max: UserInterestsMaxAggregateOutputType | null;
  };

  export type UserInterestsAvgAggregateOutputType = {
    user_id: number | null;
    weight: number | null;
  };

  export type UserInterestsSumAggregateOutputType = {
    user_id: number | null;
    weight: number | null;
  };

  export type UserInterestsMinAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    symbol_id: string | null;
    weight: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type UserInterestsMaxAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    symbol_id: string | null;
    weight: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type UserInterestsCountAggregateOutputType = {
    id: number;
    user_id: number;
    symbol_id: number;
    weight: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type UserInterestsAvgAggregateInputType = {
    user_id?: true;
    weight?: true;
  };

  export type UserInterestsSumAggregateInputType = {
    user_id?: true;
    weight?: true;
  };

  export type UserInterestsMinAggregateInputType = {
    id?: true;
    user_id?: true;
    symbol_id?: true;
    weight?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type UserInterestsMaxAggregateInputType = {
    id?: true;
    user_id?: true;
    symbol_id?: true;
    weight?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type UserInterestsCountAggregateInputType = {
    id?: true;
    user_id?: true;
    symbol_id?: true;
    weight?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type UserInterestsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which UserInterests to aggregate.
     */
    where?: UserInterestsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserInterests to fetch.
     */
    orderBy?:
      | UserInterestsOrderByWithRelationInput
      | UserInterestsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserInterestsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserInterests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserInterests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserInterests
     **/
    _count?: true | UserInterestsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UserInterestsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UserInterestsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserInterestsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserInterestsMaxAggregateInputType;
  };

  export type GetUserInterestsAggregateType<
    T extends UserInterestsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateUserInterests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInterests[P]>
      : GetScalarType<T[P], AggregateUserInterests[P]>;
  };

  export type UserInterestsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UserInterestsWhereInput;
    orderBy?:
      | UserInterestsOrderByWithAggregationInput
      | UserInterestsOrderByWithAggregationInput[];
    by: UserInterestsScalarFieldEnum[] | UserInterestsScalarFieldEnum;
    having?: UserInterestsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserInterestsCountAggregateInputType | true;
    _avg?: UserInterestsAvgAggregateInputType;
    _sum?: UserInterestsSumAggregateInputType;
    _min?: UserInterestsMinAggregateInputType;
    _max?: UserInterestsMaxAggregateInputType;
  };

  export type UserInterestsGroupByOutputType = {
    id: string;
    user_id: number;
    symbol_id: string;
    weight: number | null;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: UserInterestsCountAggregateOutputType | null;
    _avg: UserInterestsAvgAggregateOutputType | null;
    _sum: UserInterestsSumAggregateOutputType | null;
    _min: UserInterestsMinAggregateOutputType | null;
    _max: UserInterestsMaxAggregateOutputType | null;
  };

  type GetUserInterestsGroupByPayload<T extends UserInterestsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UserInterestsGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof UserInterestsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserInterestsGroupByOutputType[P]>
            : GetScalarType<T[P], UserInterestsGroupByOutputType[P]>;
        }
      >
    >;

  export type UserInterestsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      symbol_id?: boolean;
      weight?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['userInterests']
  >;

  export type UserInterestsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      symbol_id?: boolean;
      weight?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['userInterests']
  >;

  export type UserInterestsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      symbol_id?: boolean;
      weight?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['userInterests']
  >;

  export type UserInterestsSelectScalar = {
    id?: boolean;
    user_id?: boolean;
    symbol_id?: boolean;
    weight?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type UserInterestsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'user_id'
    | 'symbol_id'
    | 'weight'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['userInterests']
  >;

  export type $UserInterestsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'UserInterests';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        user_id: number;
        symbol_id: string;
        weight: number | null;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['userInterests']
    >;
    composites: {};
  };

  type UserInterestsGetPayload<
    S extends boolean | null | undefined | UserInterestsDefaultArgs
  > = $Result.GetResult<Prisma.$UserInterestsPayload, S>;

  type UserInterestsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    UserInterestsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: UserInterestsCountAggregateInputType | true;
  };

  export interface UserInterestsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['UserInterests'];
      meta: { name: 'UserInterests' };
    };
    /**
     * Find zero or one UserInterests that matches the filter.
     * @param {UserInterestsFindUniqueArgs} args - Arguments to find a UserInterests
     * @example
     * // Get one UserInterests
     * const userInterests = await prisma.userInterests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInterestsFindUniqueArgs>(
      args: SelectSubset<T, UserInterestsFindUniqueArgs<ExtArgs>>
    ): Prisma__UserInterestsClient<
      $Result.GetResult<
        Prisma.$UserInterestsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserInterests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserInterestsFindUniqueOrThrowArgs} args - Arguments to find a UserInterests
     * @example
     * // Get one UserInterests
     * const userInterests = await prisma.userInterests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInterestsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserInterestsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserInterestsClient<
      $Result.GetResult<
        Prisma.$UserInterestsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestsFindFirstArgs} args - Arguments to find a UserInterests
     * @example
     * // Get one UserInterests
     * const userInterests = await prisma.userInterests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInterestsFindFirstArgs>(
      args?: SelectSubset<T, UserInterestsFindFirstArgs<ExtArgs>>
    ): Prisma__UserInterestsClient<
      $Result.GetResult<
        Prisma.$UserInterestsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserInterests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestsFindFirstOrThrowArgs} args - Arguments to find a UserInterests
     * @example
     * // Get one UserInterests
     * const userInterests = await prisma.userInterests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInterestsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserInterestsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserInterestsClient<
      $Result.GetResult<
        Prisma.$UserInterestsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInterests
     * const userInterests = await prisma.userInterests.findMany()
     *
     * // Get first 10 UserInterests
     * const userInterests = await prisma.userInterests.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userInterestsWithIdOnly = await prisma.userInterests.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserInterestsFindManyArgs>(
      args?: SelectSubset<T, UserInterestsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserInterestsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a UserInterests.
     * @param {UserInterestsCreateArgs} args - Arguments to create a UserInterests.
     * @example
     * // Create one UserInterests
     * const UserInterests = await prisma.userInterests.create({
     *   data: {
     *     // ... data to create a UserInterests
     *   }
     * })
     *
     */
    create<T extends UserInterestsCreateArgs>(
      args: SelectSubset<T, UserInterestsCreateArgs<ExtArgs>>
    ): Prisma__UserInterestsClient<
      $Result.GetResult<
        Prisma.$UserInterestsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserInterests.
     * @param {UserInterestsCreateManyArgs} args - Arguments to create many UserInterests.
     * @example
     * // Create many UserInterests
     * const userInterests = await prisma.userInterests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserInterestsCreateManyArgs>(
      args?: SelectSubset<T, UserInterestsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserInterests and returns the data saved in the database.
     * @param {UserInterestsCreateManyAndReturnArgs} args - Arguments to create many UserInterests.
     * @example
     * // Create many UserInterests
     * const userInterests = await prisma.userInterests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserInterests and only return the `id`
     * const userInterestsWithIdOnly = await prisma.userInterests.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserInterestsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserInterestsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserInterestsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UserInterests.
     * @param {UserInterestsDeleteArgs} args - Arguments to delete one UserInterests.
     * @example
     * // Delete one UserInterests
     * const UserInterests = await prisma.userInterests.delete({
     *   where: {
     *     // ... filter to delete one UserInterests
     *   }
     * })
     *
     */
    delete<T extends UserInterestsDeleteArgs>(
      args: SelectSubset<T, UserInterestsDeleteArgs<ExtArgs>>
    ): Prisma__UserInterestsClient<
      $Result.GetResult<
        Prisma.$UserInterestsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserInterests.
     * @param {UserInterestsUpdateArgs} args - Arguments to update one UserInterests.
     * @example
     * // Update one UserInterests
     * const userInterests = await prisma.userInterests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserInterestsUpdateArgs>(
      args: SelectSubset<T, UserInterestsUpdateArgs<ExtArgs>>
    ): Prisma__UserInterestsClient<
      $Result.GetResult<
        Prisma.$UserInterestsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserInterests.
     * @param {UserInterestsDeleteManyArgs} args - Arguments to filter UserInterests to delete.
     * @example
     * // Delete a few UserInterests
     * const { count } = await prisma.userInterests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserInterestsDeleteManyArgs>(
      args?: SelectSubset<T, UserInterestsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInterests
     * const userInterests = await prisma.userInterests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserInterestsUpdateManyArgs>(
      args: SelectSubset<T, UserInterestsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserInterests and returns the data updated in the database.
     * @param {UserInterestsUpdateManyAndReturnArgs} args - Arguments to update many UserInterests.
     * @example
     * // Update many UserInterests
     * const userInterests = await prisma.userInterests.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserInterests and only return the `id`
     * const userInterestsWithIdOnly = await prisma.userInterests.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserInterestsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserInterestsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserInterestsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UserInterests.
     * @param {UserInterestsUpsertArgs} args - Arguments to update or create a UserInterests.
     * @example
     * // Update or create a UserInterests
     * const userInterests = await prisma.userInterests.upsert({
     *   create: {
     *     // ... data to create a UserInterests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInterests we want to update
     *   }
     * })
     */
    upsert<T extends UserInterestsUpsertArgs>(
      args: SelectSubset<T, UserInterestsUpsertArgs<ExtArgs>>
    ): Prisma__UserInterestsClient<
      $Result.GetResult<
        Prisma.$UserInterestsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestsCountArgs} args - Arguments to filter UserInterests to count.
     * @example
     * // Count the number of UserInterests
     * const count = await prisma.userInterests.count({
     *   where: {
     *     // ... the filter for the UserInterests we want to count
     *   }
     * })
     **/
    count<T extends UserInterestsCountArgs>(
      args?: Subset<T, UserInterestsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInterestsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserInterestsAggregateArgs>(
      args: Subset<T, UserInterestsAggregateArgs>
    ): Prisma.PrismaPromise<GetUserInterestsAggregateType<T>>;

    /**
     * Group by UserInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserInterestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInterestsGroupByArgs['orderBy'] }
        : { orderBy?: UserInterestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, UserInterestsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetUserInterestsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserInterests model
     */
    readonly fields: UserInterestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInterests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInterestsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserInterests model
   */
  interface UserInterestsFieldRefs {
    readonly id: FieldRef<'UserInterests', 'String'>;
    readonly user_id: FieldRef<'UserInterests', 'Int'>;
    readonly symbol_id: FieldRef<'UserInterests', 'String'>;
    readonly weight: FieldRef<'UserInterests', 'Float'>;
    readonly created_at: FieldRef<'UserInterests', 'DateTime'>;
    readonly updated_at: FieldRef<'UserInterests', 'DateTime'>;
    readonly deleted_at: FieldRef<'UserInterests', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * UserInterests findUnique
   */
  export type UserInterestsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterests
     */
    select?: UserInterestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterests
     */
    omit?: UserInterestsOmit<ExtArgs> | null;
    /**
     * Filter, which UserInterests to fetch.
     */
    where: UserInterestsWhereUniqueInput;
  };

  /**
   * UserInterests findUniqueOrThrow
   */
  export type UserInterestsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterests
     */
    select?: UserInterestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterests
     */
    omit?: UserInterestsOmit<ExtArgs> | null;
    /**
     * Filter, which UserInterests to fetch.
     */
    where: UserInterestsWhereUniqueInput;
  };

  /**
   * UserInterests findFirst
   */
  export type UserInterestsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterests
     */
    select?: UserInterestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterests
     */
    omit?: UserInterestsOmit<ExtArgs> | null;
    /**
     * Filter, which UserInterests to fetch.
     */
    where?: UserInterestsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserInterests to fetch.
     */
    orderBy?:
      | UserInterestsOrderByWithRelationInput
      | UserInterestsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserInterests.
     */
    cursor?: UserInterestsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserInterests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserInterests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserInterests.
     */
    distinct?: UserInterestsScalarFieldEnum | UserInterestsScalarFieldEnum[];
  };

  /**
   * UserInterests findFirstOrThrow
   */
  export type UserInterestsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterests
     */
    select?: UserInterestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterests
     */
    omit?: UserInterestsOmit<ExtArgs> | null;
    /**
     * Filter, which UserInterests to fetch.
     */
    where?: UserInterestsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserInterests to fetch.
     */
    orderBy?:
      | UserInterestsOrderByWithRelationInput
      | UserInterestsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserInterests.
     */
    cursor?: UserInterestsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserInterests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserInterests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserInterests.
     */
    distinct?: UserInterestsScalarFieldEnum | UserInterestsScalarFieldEnum[];
  };

  /**
   * UserInterests findMany
   */
  export type UserInterestsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterests
     */
    select?: UserInterestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterests
     */
    omit?: UserInterestsOmit<ExtArgs> | null;
    /**
     * Filter, which UserInterests to fetch.
     */
    where?: UserInterestsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserInterests to fetch.
     */
    orderBy?:
      | UserInterestsOrderByWithRelationInput
      | UserInterestsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserInterests.
     */
    cursor?: UserInterestsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserInterests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserInterests.
     */
    skip?: number;
    distinct?: UserInterestsScalarFieldEnum | UserInterestsScalarFieldEnum[];
  };

  /**
   * UserInterests create
   */
  export type UserInterestsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterests
     */
    select?: UserInterestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterests
     */
    omit?: UserInterestsOmit<ExtArgs> | null;
    /**
     * The data needed to create a UserInterests.
     */
    data: XOR<UserInterestsCreateInput, UserInterestsUncheckedCreateInput>;
  };

  /**
   * UserInterests createMany
   */
  export type UserInterestsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many UserInterests.
     */
    data: UserInterestsCreateManyInput | UserInterestsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserInterests createManyAndReturn
   */
  export type UserInterestsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterests
     */
    select?: UserInterestsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterests
     */
    omit?: UserInterestsOmit<ExtArgs> | null;
    /**
     * The data used to create many UserInterests.
     */
    data: UserInterestsCreateManyInput | UserInterestsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserInterests update
   */
  export type UserInterestsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterests
     */
    select?: UserInterestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterests
     */
    omit?: UserInterestsOmit<ExtArgs> | null;
    /**
     * The data needed to update a UserInterests.
     */
    data: XOR<UserInterestsUpdateInput, UserInterestsUncheckedUpdateInput>;
    /**
     * Choose, which UserInterests to update.
     */
    where: UserInterestsWhereUniqueInput;
  };

  /**
   * UserInterests updateMany
   */
  export type UserInterestsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update UserInterests.
     */
    data: XOR<
      UserInterestsUpdateManyMutationInput,
      UserInterestsUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserInterests to update
     */
    where?: UserInterestsWhereInput;
    /**
     * Limit how many UserInterests to update.
     */
    limit?: number;
  };

  /**
   * UserInterests updateManyAndReturn
   */
  export type UserInterestsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterests
     */
    select?: UserInterestsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterests
     */
    omit?: UserInterestsOmit<ExtArgs> | null;
    /**
     * The data used to update UserInterests.
     */
    data: XOR<
      UserInterestsUpdateManyMutationInput,
      UserInterestsUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserInterests to update
     */
    where?: UserInterestsWhereInput;
    /**
     * Limit how many UserInterests to update.
     */
    limit?: number;
  };

  /**
   * UserInterests upsert
   */
  export type UserInterestsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterests
     */
    select?: UserInterestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterests
     */
    omit?: UserInterestsOmit<ExtArgs> | null;
    /**
     * The filter to search for the UserInterests to update in case it exists.
     */
    where: UserInterestsWhereUniqueInput;
    /**
     * In case the UserInterests found by the `where` argument doesn't exist, create a new UserInterests with this data.
     */
    create: XOR<UserInterestsCreateInput, UserInterestsUncheckedCreateInput>;
    /**
     * In case the UserInterests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserInterestsUpdateInput, UserInterestsUncheckedUpdateInput>;
  };

  /**
   * UserInterests delete
   */
  export type UserInterestsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterests
     */
    select?: UserInterestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterests
     */
    omit?: UserInterestsOmit<ExtArgs> | null;
    /**
     * Filter which UserInterests to delete.
     */
    where: UserInterestsWhereUniqueInput;
  };

  /**
   * UserInterests deleteMany
   */
  export type UserInterestsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which UserInterests to delete
     */
    where?: UserInterestsWhereInput;
    /**
     * Limit how many UserInterests to delete.
     */
    limit?: number;
  };

  /**
   * UserInterests without action
   */
  export type UserInterestsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserInterests
     */
    select?: UserInterestsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserInterests
     */
    omit?: UserInterestsOmit<ExtArgs> | null;
  };

  /**
   * Model UserNotificationSettings
   */

  export type AggregateUserNotificationSettings = {
    _count: UserNotificationSettingsCountAggregateOutputType | null;
    _avg: UserNotificationSettingsAvgAggregateOutputType | null;
    _sum: UserNotificationSettingsSumAggregateOutputType | null;
    _min: UserNotificationSettingsMinAggregateOutputType | null;
    _max: UserNotificationSettingsMaxAggregateOutputType | null;
  };

  export type UserNotificationSettingsAvgAggregateOutputType = {
    user_id: number | null;
  };

  export type UserNotificationSettingsSumAggregateOutputType = {
    user_id: number | null;
  };

  export type UserNotificationSettingsMinAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    push_enabled: boolean | null;
    email_enabled: boolean | null;
    notify_followed_threads: boolean | null;
    notify_followed_replies: boolean | null;
    notify_mentions: boolean | null;
    notify_when_followed: boolean | null;
    notify_reposts: boolean | null;
    notify_likes: boolean | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type UserNotificationSettingsMaxAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    push_enabled: boolean | null;
    email_enabled: boolean | null;
    notify_followed_threads: boolean | null;
    notify_followed_replies: boolean | null;
    notify_mentions: boolean | null;
    notify_when_followed: boolean | null;
    notify_reposts: boolean | null;
    notify_likes: boolean | null;
    created_at: Date | null;
    updated_at: Date | null;
    deleted_at: Date | null;
  };

  export type UserNotificationSettingsCountAggregateOutputType = {
    id: number;
    user_id: number;
    push_enabled: number;
    email_enabled: number;
    notify_followed_threads: number;
    notify_followed_replies: number;
    notify_mentions: number;
    notify_when_followed: number;
    notify_reposts: number;
    notify_likes: number;
    created_at: number;
    updated_at: number;
    deleted_at: number;
    _all: number;
  };

  export type UserNotificationSettingsAvgAggregateInputType = {
    user_id?: true;
  };

  export type UserNotificationSettingsSumAggregateInputType = {
    user_id?: true;
  };

  export type UserNotificationSettingsMinAggregateInputType = {
    id?: true;
    user_id?: true;
    push_enabled?: true;
    email_enabled?: true;
    notify_followed_threads?: true;
    notify_followed_replies?: true;
    notify_mentions?: true;
    notify_when_followed?: true;
    notify_reposts?: true;
    notify_likes?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type UserNotificationSettingsMaxAggregateInputType = {
    id?: true;
    user_id?: true;
    push_enabled?: true;
    email_enabled?: true;
    notify_followed_threads?: true;
    notify_followed_replies?: true;
    notify_mentions?: true;
    notify_when_followed?: true;
    notify_reposts?: true;
    notify_likes?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
  };

  export type UserNotificationSettingsCountAggregateInputType = {
    id?: true;
    user_id?: true;
    push_enabled?: true;
    email_enabled?: true;
    notify_followed_threads?: true;
    notify_followed_replies?: true;
    notify_mentions?: true;
    notify_when_followed?: true;
    notify_reposts?: true;
    notify_likes?: true;
    created_at?: true;
    updated_at?: true;
    deleted_at?: true;
    _all?: true;
  };

  export type UserNotificationSettingsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which UserNotificationSettings to aggregate.
     */
    where?: UserNotificationSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserNotificationSettings to fetch.
     */
    orderBy?:
      | UserNotificationSettingsOrderByWithRelationInput
      | UserNotificationSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserNotificationSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserNotificationSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserNotificationSettings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserNotificationSettings
     **/
    _count?: true | UserNotificationSettingsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UserNotificationSettingsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UserNotificationSettingsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserNotificationSettingsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserNotificationSettingsMaxAggregateInputType;
  };

  export type GetUserNotificationSettingsAggregateType<
    T extends UserNotificationSettingsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateUserNotificationSettings]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserNotificationSettings[P]>
      : GetScalarType<T[P], AggregateUserNotificationSettings[P]>;
  };

  export type UserNotificationSettingsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UserNotificationSettingsWhereInput;
    orderBy?:
      | UserNotificationSettingsOrderByWithAggregationInput
      | UserNotificationSettingsOrderByWithAggregationInput[];
    by:
      | UserNotificationSettingsScalarFieldEnum[]
      | UserNotificationSettingsScalarFieldEnum;
    having?: UserNotificationSettingsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserNotificationSettingsCountAggregateInputType | true;
    _avg?: UserNotificationSettingsAvgAggregateInputType;
    _sum?: UserNotificationSettingsSumAggregateInputType;
    _min?: UserNotificationSettingsMinAggregateInputType;
    _max?: UserNotificationSettingsMaxAggregateInputType;
  };

  export type UserNotificationSettingsGroupByOutputType = {
    id: string;
    user_id: number;
    push_enabled: boolean;
    email_enabled: boolean;
    notify_followed_threads: boolean;
    notify_followed_replies: boolean;
    notify_mentions: boolean;
    notify_when_followed: boolean;
    notify_reposts: boolean;
    notify_likes: boolean;
    created_at: Date;
    updated_at: Date;
    deleted_at: Date | null;
    _count: UserNotificationSettingsCountAggregateOutputType | null;
    _avg: UserNotificationSettingsAvgAggregateOutputType | null;
    _sum: UserNotificationSettingsSumAggregateOutputType | null;
    _min: UserNotificationSettingsMinAggregateOutputType | null;
    _max: UserNotificationSettingsMaxAggregateOutputType | null;
  };

  type GetUserNotificationSettingsGroupByPayload<
    T extends UserNotificationSettingsGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserNotificationSettingsGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof UserNotificationSettingsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserNotificationSettingsGroupByOutputType[P]>
          : GetScalarType<T[P], UserNotificationSettingsGroupByOutputType[P]>;
      }
    >
  >;

  export type UserNotificationSettingsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      push_enabled?: boolean;
      email_enabled?: boolean;
      notify_followed_threads?: boolean;
      notify_followed_replies?: boolean;
      notify_mentions?: boolean;
      notify_when_followed?: boolean;
      notify_reposts?: boolean;
      notify_likes?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['userNotificationSettings']
  >;

  export type UserNotificationSettingsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      push_enabled?: boolean;
      email_enabled?: boolean;
      notify_followed_threads?: boolean;
      notify_followed_replies?: boolean;
      notify_mentions?: boolean;
      notify_when_followed?: boolean;
      notify_reposts?: boolean;
      notify_likes?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['userNotificationSettings']
  >;

  export type UserNotificationSettingsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      push_enabled?: boolean;
      email_enabled?: boolean;
      notify_followed_threads?: boolean;
      notify_followed_replies?: boolean;
      notify_mentions?: boolean;
      notify_when_followed?: boolean;
      notify_reposts?: boolean;
      notify_likes?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      deleted_at?: boolean;
    },
    ExtArgs['result']['userNotificationSettings']
  >;

  export type UserNotificationSettingsSelectScalar = {
    id?: boolean;
    user_id?: boolean;
    push_enabled?: boolean;
    email_enabled?: boolean;
    notify_followed_threads?: boolean;
    notify_followed_replies?: boolean;
    notify_mentions?: boolean;
    notify_when_followed?: boolean;
    notify_reposts?: boolean;
    notify_likes?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    deleted_at?: boolean;
  };

  export type UserNotificationSettingsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'user_id'
    | 'push_enabled'
    | 'email_enabled'
    | 'notify_followed_threads'
    | 'notify_followed_replies'
    | 'notify_mentions'
    | 'notify_when_followed'
    | 'notify_reposts'
    | 'notify_likes'
    | 'created_at'
    | 'updated_at'
    | 'deleted_at',
    ExtArgs['result']['userNotificationSettings']
  >;

  export type $UserNotificationSettingsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'UserNotificationSettings';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        user_id: number;
        push_enabled: boolean;
        email_enabled: boolean;
        notify_followed_threads: boolean;
        notify_followed_replies: boolean;
        notify_mentions: boolean;
        notify_when_followed: boolean;
        notify_reposts: boolean;
        notify_likes: boolean;
        created_at: Date;
        updated_at: Date;
        deleted_at: Date | null;
      },
      ExtArgs['result']['userNotificationSettings']
    >;
    composites: {};
  };

  type UserNotificationSettingsGetPayload<
    S extends boolean | null | undefined | UserNotificationSettingsDefaultArgs
  > = $Result.GetResult<Prisma.$UserNotificationSettingsPayload, S>;

  type UserNotificationSettingsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    UserNotificationSettingsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: UserNotificationSettingsCountAggregateInputType | true;
  };

  export interface UserNotificationSettingsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['UserNotificationSettings'];
      meta: { name: 'UserNotificationSettings' };
    };
    /**
     * Find zero or one UserNotificationSettings that matches the filter.
     * @param {UserNotificationSettingsFindUniqueArgs} args - Arguments to find a UserNotificationSettings
     * @example
     * // Get one UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserNotificationSettingsFindUniqueArgs>(
      args: SelectSubset<T, UserNotificationSettingsFindUniqueArgs<ExtArgs>>
    ): Prisma__UserNotificationSettingsClient<
      $Result.GetResult<
        Prisma.$UserNotificationSettingsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserNotificationSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserNotificationSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserNotificationSettings
     * @example
     * // Get one UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserNotificationSettingsFindUniqueOrThrowArgs>(
      args: SelectSubset<
        T,
        UserNotificationSettingsFindUniqueOrThrowArgs<ExtArgs>
      >
    ): Prisma__UserNotificationSettingsClient<
      $Result.GetResult<
        Prisma.$UserNotificationSettingsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserNotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingsFindFirstArgs} args - Arguments to find a UserNotificationSettings
     * @example
     * // Get one UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserNotificationSettingsFindFirstArgs>(
      args?: SelectSubset<T, UserNotificationSettingsFindFirstArgs<ExtArgs>>
    ): Prisma__UserNotificationSettingsClient<
      $Result.GetResult<
        Prisma.$UserNotificationSettingsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserNotificationSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingsFindFirstOrThrowArgs} args - Arguments to find a UserNotificationSettings
     * @example
     * // Get one UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserNotificationSettingsFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        UserNotificationSettingsFindFirstOrThrowArgs<ExtArgs>
      >
    ): Prisma__UserNotificationSettingsClient<
      $Result.GetResult<
        Prisma.$UserNotificationSettingsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserNotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.findMany()
     *
     * // Get first 10 UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userNotificationSettingsWithIdOnly = await prisma.userNotificationSettings.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserNotificationSettingsFindManyArgs>(
      args?: SelectSubset<T, UserNotificationSettingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserNotificationSettingsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a UserNotificationSettings.
     * @param {UserNotificationSettingsCreateArgs} args - Arguments to create a UserNotificationSettings.
     * @example
     * // Create one UserNotificationSettings
     * const UserNotificationSettings = await prisma.userNotificationSettings.create({
     *   data: {
     *     // ... data to create a UserNotificationSettings
     *   }
     * })
     *
     */
    create<T extends UserNotificationSettingsCreateArgs>(
      args: SelectSubset<T, UserNotificationSettingsCreateArgs<ExtArgs>>
    ): Prisma__UserNotificationSettingsClient<
      $Result.GetResult<
        Prisma.$UserNotificationSettingsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserNotificationSettings.
     * @param {UserNotificationSettingsCreateManyArgs} args - Arguments to create many UserNotificationSettings.
     * @example
     * // Create many UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserNotificationSettingsCreateManyArgs>(
      args?: SelectSubset<T, UserNotificationSettingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserNotificationSettings and returns the data saved in the database.
     * @param {UserNotificationSettingsCreateManyAndReturnArgs} args - Arguments to create many UserNotificationSettings.
     * @example
     * // Create many UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserNotificationSettings and only return the `id`
     * const userNotificationSettingsWithIdOnly = await prisma.userNotificationSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends UserNotificationSettingsCreateManyAndReturnArgs
    >(
      args?: SelectSubset<
        T,
        UserNotificationSettingsCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserNotificationSettingsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UserNotificationSettings.
     * @param {UserNotificationSettingsDeleteArgs} args - Arguments to delete one UserNotificationSettings.
     * @example
     * // Delete one UserNotificationSettings
     * const UserNotificationSettings = await prisma.userNotificationSettings.delete({
     *   where: {
     *     // ... filter to delete one UserNotificationSettings
     *   }
     * })
     *
     */
    delete<T extends UserNotificationSettingsDeleteArgs>(
      args: SelectSubset<T, UserNotificationSettingsDeleteArgs<ExtArgs>>
    ): Prisma__UserNotificationSettingsClient<
      $Result.GetResult<
        Prisma.$UserNotificationSettingsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserNotificationSettings.
     * @param {UserNotificationSettingsUpdateArgs} args - Arguments to update one UserNotificationSettings.
     * @example
     * // Update one UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserNotificationSettingsUpdateArgs>(
      args: SelectSubset<T, UserNotificationSettingsUpdateArgs<ExtArgs>>
    ): Prisma__UserNotificationSettingsClient<
      $Result.GetResult<
        Prisma.$UserNotificationSettingsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserNotificationSettings.
     * @param {UserNotificationSettingsDeleteManyArgs} args - Arguments to filter UserNotificationSettings to delete.
     * @example
     * // Delete a few UserNotificationSettings
     * const { count } = await prisma.userNotificationSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserNotificationSettingsDeleteManyArgs>(
      args?: SelectSubset<T, UserNotificationSettingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserNotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserNotificationSettingsUpdateManyArgs>(
      args: SelectSubset<T, UserNotificationSettingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserNotificationSettings and returns the data updated in the database.
     * @param {UserNotificationSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserNotificationSettings.
     * @example
     * // Update many UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserNotificationSettings and only return the `id`
     * const userNotificationSettingsWithIdOnly = await prisma.userNotificationSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends UserNotificationSettingsUpdateManyAndReturnArgs
    >(
      args: SelectSubset<
        T,
        UserNotificationSettingsUpdateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserNotificationSettingsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UserNotificationSettings.
     * @param {UserNotificationSettingsUpsertArgs} args - Arguments to update or create a UserNotificationSettings.
     * @example
     * // Update or create a UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.upsert({
     *   create: {
     *     // ... data to create a UserNotificationSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserNotificationSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserNotificationSettingsUpsertArgs>(
      args: SelectSubset<T, UserNotificationSettingsUpsertArgs<ExtArgs>>
    ): Prisma__UserNotificationSettingsClient<
      $Result.GetResult<
        Prisma.$UserNotificationSettingsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserNotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingsCountArgs} args - Arguments to filter UserNotificationSettings to count.
     * @example
     * // Count the number of UserNotificationSettings
     * const count = await prisma.userNotificationSettings.count({
     *   where: {
     *     // ... the filter for the UserNotificationSettings we want to count
     *   }
     * })
     **/
    count<T extends UserNotificationSettingsCountArgs>(
      args?: Subset<T, UserNotificationSettingsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              UserNotificationSettingsCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserNotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserNotificationSettingsAggregateArgs>(
      args: Subset<T, UserNotificationSettingsAggregateArgs>
    ): Prisma.PrismaPromise<GetUserNotificationSettingsAggregateType<T>>;

    /**
     * Group by UserNotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserNotificationSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserNotificationSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserNotificationSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<
        T,
        UserNotificationSettingsGroupByArgs,
        OrderByArg
      > &
        InputErrors
    ): {} extends InputErrors
      ? GetUserNotificationSettingsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserNotificationSettings model
     */
    readonly fields: UserNotificationSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserNotificationSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserNotificationSettingsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserNotificationSettings model
   */
  interface UserNotificationSettingsFieldRefs {
    readonly id: FieldRef<'UserNotificationSettings', 'String'>;
    readonly user_id: FieldRef<'UserNotificationSettings', 'Int'>;
    readonly push_enabled: FieldRef<'UserNotificationSettings', 'Boolean'>;
    readonly email_enabled: FieldRef<'UserNotificationSettings', 'Boolean'>;
    readonly notify_followed_threads: FieldRef<
      'UserNotificationSettings',
      'Boolean'
    >;
    readonly notify_followed_replies: FieldRef<
      'UserNotificationSettings',
      'Boolean'
    >;
    readonly notify_mentions: FieldRef<'UserNotificationSettings', 'Boolean'>;
    readonly notify_when_followed: FieldRef<
      'UserNotificationSettings',
      'Boolean'
    >;
    readonly notify_reposts: FieldRef<'UserNotificationSettings', 'Boolean'>;
    readonly notify_likes: FieldRef<'UserNotificationSettings', 'Boolean'>;
    readonly created_at: FieldRef<'UserNotificationSettings', 'DateTime'>;
    readonly updated_at: FieldRef<'UserNotificationSettings', 'DateTime'>;
    readonly deleted_at: FieldRef<'UserNotificationSettings', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * UserNotificationSettings findUnique
   */
  export type UserNotificationSettingsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null;
    /**
     * Filter, which UserNotificationSettings to fetch.
     */
    where: UserNotificationSettingsWhereUniqueInput;
  };

  /**
   * UserNotificationSettings findUniqueOrThrow
   */
  export type UserNotificationSettingsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null;
    /**
     * Filter, which UserNotificationSettings to fetch.
     */
    where: UserNotificationSettingsWhereUniqueInput;
  };

  /**
   * UserNotificationSettings findFirst
   */
  export type UserNotificationSettingsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null;
    /**
     * Filter, which UserNotificationSettings to fetch.
     */
    where?: UserNotificationSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserNotificationSettings to fetch.
     */
    orderBy?:
      | UserNotificationSettingsOrderByWithRelationInput
      | UserNotificationSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserNotificationSettings.
     */
    cursor?: UserNotificationSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserNotificationSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserNotificationSettings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserNotificationSettings.
     */
    distinct?:
      | UserNotificationSettingsScalarFieldEnum
      | UserNotificationSettingsScalarFieldEnum[];
  };

  /**
   * UserNotificationSettings findFirstOrThrow
   */
  export type UserNotificationSettingsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null;
    /**
     * Filter, which UserNotificationSettings to fetch.
     */
    where?: UserNotificationSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserNotificationSettings to fetch.
     */
    orderBy?:
      | UserNotificationSettingsOrderByWithRelationInput
      | UserNotificationSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserNotificationSettings.
     */
    cursor?: UserNotificationSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserNotificationSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserNotificationSettings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserNotificationSettings.
     */
    distinct?:
      | UserNotificationSettingsScalarFieldEnum
      | UserNotificationSettingsScalarFieldEnum[];
  };

  /**
   * UserNotificationSettings findMany
   */
  export type UserNotificationSettingsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null;
    /**
     * Filter, which UserNotificationSettings to fetch.
     */
    where?: UserNotificationSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserNotificationSettings to fetch.
     */
    orderBy?:
      | UserNotificationSettingsOrderByWithRelationInput
      | UserNotificationSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserNotificationSettings.
     */
    cursor?: UserNotificationSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserNotificationSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserNotificationSettings.
     */
    skip?: number;
    distinct?:
      | UserNotificationSettingsScalarFieldEnum
      | UserNotificationSettingsScalarFieldEnum[];
  };

  /**
   * UserNotificationSettings create
   */
  export type UserNotificationSettingsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null;
    /**
     * The data needed to create a UserNotificationSettings.
     */
    data: XOR<
      UserNotificationSettingsCreateInput,
      UserNotificationSettingsUncheckedCreateInput
    >;
  };

  /**
   * UserNotificationSettings createMany
   */
  export type UserNotificationSettingsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many UserNotificationSettings.
     */
    data:
      | UserNotificationSettingsCreateManyInput
      | UserNotificationSettingsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserNotificationSettings createManyAndReturn
   */
  export type UserNotificationSettingsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null;
    /**
     * The data used to create many UserNotificationSettings.
     */
    data:
      | UserNotificationSettingsCreateManyInput
      | UserNotificationSettingsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserNotificationSettings update
   */
  export type UserNotificationSettingsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null;
    /**
     * The data needed to update a UserNotificationSettings.
     */
    data: XOR<
      UserNotificationSettingsUpdateInput,
      UserNotificationSettingsUncheckedUpdateInput
    >;
    /**
     * Choose, which UserNotificationSettings to update.
     */
    where: UserNotificationSettingsWhereUniqueInput;
  };

  /**
   * UserNotificationSettings updateMany
   */
  export type UserNotificationSettingsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update UserNotificationSettings.
     */
    data: XOR<
      UserNotificationSettingsUpdateManyMutationInput,
      UserNotificationSettingsUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserNotificationSettings to update
     */
    where?: UserNotificationSettingsWhereInput;
    /**
     * Limit how many UserNotificationSettings to update.
     */
    limit?: number;
  };

  /**
   * UserNotificationSettings updateManyAndReturn
   */
  export type UserNotificationSettingsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null;
    /**
     * The data used to update UserNotificationSettings.
     */
    data: XOR<
      UserNotificationSettingsUpdateManyMutationInput,
      UserNotificationSettingsUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserNotificationSettings to update
     */
    where?: UserNotificationSettingsWhereInput;
    /**
     * Limit how many UserNotificationSettings to update.
     */
    limit?: number;
  };

  /**
   * UserNotificationSettings upsert
   */
  export type UserNotificationSettingsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null;
    /**
     * The filter to search for the UserNotificationSettings to update in case it exists.
     */
    where: UserNotificationSettingsWhereUniqueInput;
    /**
     * In case the UserNotificationSettings found by the `where` argument doesn't exist, create a new UserNotificationSettings with this data.
     */
    create: XOR<
      UserNotificationSettingsCreateInput,
      UserNotificationSettingsUncheckedCreateInput
    >;
    /**
     * In case the UserNotificationSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      UserNotificationSettingsUpdateInput,
      UserNotificationSettingsUncheckedUpdateInput
    >;
  };

  /**
   * UserNotificationSettings delete
   */
  export type UserNotificationSettingsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null;
    /**
     * Filter which UserNotificationSettings to delete.
     */
    where: UserNotificationSettingsWhereUniqueInput;
  };

  /**
   * UserNotificationSettings deleteMany
   */
  export type UserNotificationSettingsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which UserNotificationSettings to delete
     */
    where?: UserNotificationSettingsWhereInput;
    /**
     * Limit how many UserNotificationSettings to delete.
     */
    limit?: number;
  };

  /**
   * UserNotificationSettings without action
   */
  export type UserNotificationSettingsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const CompaniesInfoScalarFieldEnum: {
    id: 'id';
    threads_id: 'threads_id';
    symbol: 'symbol';
    name: 'name';
    market_state: 'market_state';
    regular_market_price: 'regular_market_price';
    regular_market_change: 'regular_market_change';
    regular_market_change_percent: 'regular_market_change_percent';
    sector: 'sector';
    industry: 'industry';
    date_at_shares: 'date_at_shares';
    assets_type: 'assets_type';
    exchange_name: 'exchange_name';
    pre_market_price: 'pre_market_price';
    pre_market_change: 'pre_market_change';
    pre_market_change_percent: 'pre_market_change_percent';
    post_market_price: 'post_market_price';
    post_market_change: 'post_market_change';
    post_market_change_percent: 'post_market_change_percent';
    overnight_market_price: 'overnight_market_price';
    overnight_market_change: 'overnight_market_change';
    overnight_market_change_percent: 'overnight_market_change_percent';
    market_cap: 'market_cap';
    regular_market_time: 'regular_market_time';
    pre_market_time: 'pre_market_time';
    post_market_time: 'post_market_time';
    overnight_market_time: 'overnight_market_time';
    currency: 'currency';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type CompaniesInfoScalarFieldEnum =
    (typeof CompaniesInfoScalarFieldEnum)[keyof typeof CompaniesInfoScalarFieldEnum];

  export const FollowNotificationOverridesScalarFieldEnum: {
    id: 'id';
    follower_id: 'follower_id';
    following_id: 'following_id';
    mute_all: 'mute_all';
    notify_threads: 'notify_threads';
    notify_replies: 'notify_replies';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type FollowNotificationOverridesScalarFieldEnum =
    (typeof FollowNotificationOverridesScalarFieldEnum)[keyof typeof FollowNotificationOverridesScalarFieldEnum];

  export const FollowRequestsScalarFieldEnum: {
    id: 'id';
    requester_id: 'requester_id';
    target_id: 'target_id';
    status: 'status';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type FollowRequestsScalarFieldEnum =
    (typeof FollowRequestsScalarFieldEnum)[keyof typeof FollowRequestsScalarFieldEnum];

  export const FollowsScalarFieldEnum: {
    id: 'id';
    follower_id: 'follower_id';
    following_id: 'following_id';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type FollowsScalarFieldEnum =
    (typeof FollowsScalarFieldEnum)[keyof typeof FollowsScalarFieldEnum];

  export const FollowsCountScalarFieldEnum: {
    id: 'id';
    user_id: 'user_id';
    followers_count: 'followers_count';
    following_count: 'following_count';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type FollowsCountScalarFieldEnum =
    (typeof FollowsCountScalarFieldEnum)[keyof typeof FollowsCountScalarFieldEnum];

  export const NotificationsScalarFieldEnum: {
    id: 'id';
    user_id: 'user_id';
    sender_id: 'sender_id';
    message_th: 'message_th';
    message_en: 'message_en';
    metadata: 'metadata';
    is_read: 'is_read';
    type: 'type';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type NotificationsScalarFieldEnum =
    (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum];

  export const SymbolsScalarFieldEnum: {
    id: 'id';
    symbol_code: 'symbol_code';
    name: 'name';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type SymbolsScalarFieldEnum =
    (typeof SymbolsScalarFieldEnum)[keyof typeof SymbolsScalarFieldEnum];

  export const ThreadEngagementMetricsScalarFieldEnum: {
    id: 'id';
    threads_id: 'threads_id';
    viewed_count: 'viewed_count';
    replied_count: 'replied_count';
    reposted_count: 'reposted_count';
    quoted_count: 'quoted_count';
    liked_count: 'liked_count';
    reported_count: 'reported_count';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type ThreadEngagementMetricsScalarFieldEnum =
    (typeof ThreadEngagementMetricsScalarFieldEnum)[keyof typeof ThreadEngagementMetricsScalarFieldEnum];

  export const ThreadHashtagsScalarFieldEnum: {
    id: 'id';
    threads_id: 'threads_id';
    tag: 'tag';
    type: 'type';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type ThreadHashtagsScalarFieldEnum =
    (typeof ThreadHashtagsScalarFieldEnum)[keyof typeof ThreadHashtagsScalarFieldEnum];

  export const ThreadLikesScalarFieldEnum: {
    id: 'id';
    threads_id: 'threads_id';
    user_id: 'user_id';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type ThreadLikesScalarFieldEnum =
    (typeof ThreadLikesScalarFieldEnum)[keyof typeof ThreadLikesScalarFieldEnum];

  export const ThreadMediaScalarFieldEnum: {
    id: 'id';
    threads_id: 'threads_id';
    media_type: 'media_type';
    media_url: 'media_url';
    thumbnail_url: 'thumbnail_url';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
    width: 'width';
    height: 'height';
    size: 'size';
    duration: 'duration';
    object_key: 'object_key';
  };

  export type ThreadMediaScalarFieldEnum =
    (typeof ThreadMediaScalarFieldEnum)[keyof typeof ThreadMediaScalarFieldEnum];

  export const ThreadMentionsScalarFieldEnum: {
    id: 'id';
    threads_id: 'threads_id';
    mentioned_user_id: 'mentioned_user_id';
    position: 'position';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type ThreadMentionsScalarFieldEnum =
    (typeof ThreadMentionsScalarFieldEnum)[keyof typeof ThreadMentionsScalarFieldEnum];

  export const ThreadPinsScalarFieldEnum: {
    id: 'id';
    user_id: 'user_id';
    threads_id: 'threads_id';
    pinned_at: 'pinned_at';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type ThreadPinsScalarFieldEnum =
    (typeof ThreadPinsScalarFieldEnum)[keyof typeof ThreadPinsScalarFieldEnum];

  export const ThreadPollOptionsScalarFieldEnum: {
    id: 'id';
    poll_id: 'poll_id';
    option_text: 'option_text';
    voted_count: 'voted_count';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type ThreadPollOptionsScalarFieldEnum =
    (typeof ThreadPollOptionsScalarFieldEnum)[keyof typeof ThreadPollOptionsScalarFieldEnum];

  export const ThreadPollVotesScalarFieldEnum: {
    id: 'id';
    option_id: 'option_id';
    user_id: 'user_id';
    voted_at: 'voted_at';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type ThreadPollVotesScalarFieldEnum =
    (typeof ThreadPollVotesScalarFieldEnum)[keyof typeof ThreadPollVotesScalarFieldEnum];

  export const ThreadPollsScalarFieldEnum: {
    id: 'id';
    threads_id: 'threads_id';
    question: 'question';
    total_voted: 'total_voted';
    expires_at: 'expires_at';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type ThreadPollsScalarFieldEnum =
    (typeof ThreadPollsScalarFieldEnum)[keyof typeof ThreadPollsScalarFieldEnum];

  export const ThreadReportReasonsScalarFieldEnum: {
    id: 'id';
    parent_id: 'parent_id';
    code: 'code';
    level: 'level';
    is_leaf: 'is_leaf';
    translations: 'translations';
    is_active: 'is_active';
    sort_order: 'sort_order';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type ThreadReportReasonsScalarFieldEnum =
    (typeof ThreadReportReasonsScalarFieldEnum)[keyof typeof ThreadReportReasonsScalarFieldEnum];

  export const ThreadReportsScalarFieldEnum: {
    id: 'id';
    threads_id: 'threads_id';
    reported_by: 'reported_by';
    reason: 'reason';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type ThreadReportsScalarFieldEnum =
    (typeof ThreadReportsScalarFieldEnum)[keyof typeof ThreadReportsScalarFieldEnum];

  export const ThreadRepostsScalarFieldEnum: {
    id: 'id';
    threads_id: 'threads_id';
    user_id: 'user_id';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type ThreadRepostsScalarFieldEnum =
    (typeof ThreadRepostsScalarFieldEnum)[keyof typeof ThreadRepostsScalarFieldEnum];

  export const ThreadsScalarFieldEnum: {
    id: 'id';
    user_id: 'user_id';
    content: 'content';
    visibility: 'visibility';
    start_thread_id: 'start_thread_id';
    poll_id: 'poll_id';
    parent_thread_id: 'parent_thread_id';
    quoted_thread_id: 'quoted_thread_id';
    company_info_id: 'company_info_id';
    parent_level: 'parent_level';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
    news_id: 'news_id';
  };

  export type ThreadsScalarFieldEnum =
    (typeof ThreadsScalarFieldEnum)[keyof typeof ThreadsScalarFieldEnum];

  export const UserBlocksScalarFieldEnum: {
    id: 'id';
    blocker_user_id: 'blocker_user_id';
    blocked_user_id: 'blocked_user_id';
    reason: 'reason';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type UserBlocksScalarFieldEnum =
    (typeof UserBlocksScalarFieldEnum)[keyof typeof UserBlocksScalarFieldEnum];

  export const UserInterestLogsScalarFieldEnum: {
    id: 'id';
    user_id: 'user_id';
    symbol_id: 'symbol_id';
    activity_type: 'activity_type';
    weight: 'weight';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type UserInterestLogsScalarFieldEnum =
    (typeof UserInterestLogsScalarFieldEnum)[keyof typeof UserInterestLogsScalarFieldEnum];

  export const UserInterestsScalarFieldEnum: {
    id: 'id';
    user_id: 'user_id';
    symbol_id: 'symbol_id';
    weight: 'weight';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type UserInterestsScalarFieldEnum =
    (typeof UserInterestsScalarFieldEnum)[keyof typeof UserInterestsScalarFieldEnum];

  export const UserNotificationSettingsScalarFieldEnum: {
    id: 'id';
    user_id: 'user_id';
    push_enabled: 'push_enabled';
    email_enabled: 'email_enabled';
    notify_followed_threads: 'notify_followed_threads';
    notify_followed_replies: 'notify_followed_replies';
    notify_mentions: 'notify_mentions';
    notify_when_followed: 'notify_when_followed';
    notify_reposts: 'notify_reposts';
    notify_likes: 'notify_likes';
    created_at: 'created_at';
    updated_at: 'updated_at';
    deleted_at: 'deleted_at';
  };

  export type UserNotificationSettingsScalarFieldEnum =
    (typeof UserNotificationSettingsScalarFieldEnum)[keyof typeof UserNotificationSettingsScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull;
  };

  export type JsonNullValueInput =
    (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter =
    (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String'
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String[]'
  >;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float'
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float[]'
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime'
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >;

  /**
   * Reference to a field of type 'assets_type_enum'
   */
  export type Enumassets_type_enumFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'assets_type_enum'>;

  /**
   * Reference to a field of type 'assets_type_enum[]'
   */
  export type ListEnumassets_type_enumFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'assets_type_enum[]'>;

  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'BigInt'
  >;

  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'BigInt[]'
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int'
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int[]'
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Boolean'
  >;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Json'
  >;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'QueryMode'
  >;

  /**
   * Reference to a field of type 'notification_type_enum'
   */
  export type Enumnotification_type_enumFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'notification_type_enum'>;

  /**
   * Reference to a field of type 'notification_type_enum[]'
   */
  export type ListEnumnotification_type_enumFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'notification_type_enum[]'>;

  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Decimal'
  >;

  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Decimal[]'
  >;

  /**
   * Reference to a field of type 'tag_type_enum'
   */
  export type Enumtag_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'tag_type_enum'
  >;

  /**
   * Reference to a field of type 'tag_type_enum[]'
   */
  export type ListEnumtag_type_enumFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'tag_type_enum[]'>;

  /**
   * Reference to a field of type 'media_type_enum'
   */
  export type Enummedia_type_enumFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'media_type_enum'>;

  /**
   * Reference to a field of type 'media_type_enum[]'
   */
  export type ListEnummedia_type_enumFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'media_type_enum[]'>;

  /**
   * Reference to a field of type 'visibility_enum'
   */
  export type Enumvisibility_enumFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'visibility_enum'>;

  /**
   * Reference to a field of type 'visibility_enum[]'
   */
  export type ListEnumvisibility_enumFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'visibility_enum[]'>;

  /**
   * Deep Input Types
   */

  export type CompaniesInfoWhereInput = {
    AND?: CompaniesInfoWhereInput | CompaniesInfoWhereInput[];
    OR?: CompaniesInfoWhereInput[];
    NOT?: CompaniesInfoWhereInput | CompaniesInfoWhereInput[];
    id?: UuidFilter<'CompaniesInfo'> | string;
    threads_id?: UuidFilter<'CompaniesInfo'> | string;
    symbol?: StringFilter<'CompaniesInfo'> | string;
    name?: StringFilter<'CompaniesInfo'> | string;
    market_state?: StringFilter<'CompaniesInfo'> | string;
    regular_market_price?: FloatFilter<'CompaniesInfo'> | number;
    regular_market_change?: FloatFilter<'CompaniesInfo'> | number;
    regular_market_change_percent?: FloatFilter<'CompaniesInfo'> | number;
    sector?: StringFilter<'CompaniesInfo'> | string;
    industry?: StringFilter<'CompaniesInfo'> | string;
    date_at_shares?: DateTimeFilter<'CompaniesInfo'> | Date | string;
    assets_type?:
      | Enumassets_type_enumFilter<'CompaniesInfo'>
      | $Enums.assets_type_enum;
    exchange_name?: StringNullableFilter<'CompaniesInfo'> | string | null;
    pre_market_price?: FloatNullableFilter<'CompaniesInfo'> | number | null;
    pre_market_change?: FloatNullableFilter<'CompaniesInfo'> | number | null;
    pre_market_change_percent?:
      | FloatNullableFilter<'CompaniesInfo'>
      | number
      | null;
    post_market_price?: FloatNullableFilter<'CompaniesInfo'> | number | null;
    post_market_change?: FloatNullableFilter<'CompaniesInfo'> | number | null;
    post_market_change_percent?:
      | FloatNullableFilter<'CompaniesInfo'>
      | number
      | null;
    overnight_market_price?:
      | FloatNullableFilter<'CompaniesInfo'>
      | number
      | null;
    overnight_market_change?:
      | FloatNullableFilter<'CompaniesInfo'>
      | number
      | null;
    overnight_market_change_percent?:
      | FloatNullableFilter<'CompaniesInfo'>
      | number
      | null;
    market_cap?: BigIntNullableFilter<'CompaniesInfo'> | bigint | number | null;
    regular_market_time?: BigIntFilter<'CompaniesInfo'> | bigint | number;
    pre_market_time?:
      | BigIntNullableFilter<'CompaniesInfo'>
      | bigint
      | number
      | null;
    post_market_time?:
      | BigIntNullableFilter<'CompaniesInfo'>
      | bigint
      | number
      | null;
    overnight_market_time?:
      | BigIntNullableFilter<'CompaniesInfo'>
      | bigint
      | number
      | null;
    currency?: StringFilter<'CompaniesInfo'> | string;
    created_at?: DateTimeFilter<'CompaniesInfo'> | Date | string;
    updated_at?: DateTimeFilter<'CompaniesInfo'> | Date | string;
    deleted_at?: DateTimeNullableFilter<'CompaniesInfo'> | Date | string | null;
  };

  export type CompaniesInfoOrderByWithRelationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    symbol?: SortOrder;
    name?: SortOrder;
    market_state?: SortOrder;
    regular_market_price?: SortOrder;
    regular_market_change?: SortOrder;
    regular_market_change_percent?: SortOrder;
    sector?: SortOrder;
    industry?: SortOrder;
    date_at_shares?: SortOrder;
    assets_type?: SortOrder;
    exchange_name?: SortOrderInput | SortOrder;
    pre_market_price?: SortOrderInput | SortOrder;
    pre_market_change?: SortOrderInput | SortOrder;
    pre_market_change_percent?: SortOrderInput | SortOrder;
    post_market_price?: SortOrderInput | SortOrder;
    post_market_change?: SortOrderInput | SortOrder;
    post_market_change_percent?: SortOrderInput | SortOrder;
    overnight_market_price?: SortOrderInput | SortOrder;
    overnight_market_change?: SortOrderInput | SortOrder;
    overnight_market_change_percent?: SortOrderInput | SortOrder;
    market_cap?: SortOrderInput | SortOrder;
    regular_market_time?: SortOrder;
    pre_market_time?: SortOrderInput | SortOrder;
    post_market_time?: SortOrderInput | SortOrder;
    overnight_market_time?: SortOrderInput | SortOrder;
    currency?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type CompaniesInfoWhereUniqueInput = Prisma.AtLeast<
    {
      id_created_at?: CompaniesInfoIdCreated_atCompoundUniqueInput;
      AND?: CompaniesInfoWhereInput | CompaniesInfoWhereInput[];
      OR?: CompaniesInfoWhereInput[];
      NOT?: CompaniesInfoWhereInput | CompaniesInfoWhereInput[];
      id?: UuidFilter<'CompaniesInfo'> | string;
      threads_id?: UuidFilter<'CompaniesInfo'> | string;
      symbol?: StringFilter<'CompaniesInfo'> | string;
      name?: StringFilter<'CompaniesInfo'> | string;
      market_state?: StringFilter<'CompaniesInfo'> | string;
      regular_market_price?: FloatFilter<'CompaniesInfo'> | number;
      regular_market_change?: FloatFilter<'CompaniesInfo'> | number;
      regular_market_change_percent?: FloatFilter<'CompaniesInfo'> | number;
      sector?: StringFilter<'CompaniesInfo'> | string;
      industry?: StringFilter<'CompaniesInfo'> | string;
      date_at_shares?: DateTimeFilter<'CompaniesInfo'> | Date | string;
      assets_type?:
        | Enumassets_type_enumFilter<'CompaniesInfo'>
        | $Enums.assets_type_enum;
      exchange_name?: StringNullableFilter<'CompaniesInfo'> | string | null;
      pre_market_price?: FloatNullableFilter<'CompaniesInfo'> | number | null;
      pre_market_change?: FloatNullableFilter<'CompaniesInfo'> | number | null;
      pre_market_change_percent?:
        | FloatNullableFilter<'CompaniesInfo'>
        | number
        | null;
      post_market_price?: FloatNullableFilter<'CompaniesInfo'> | number | null;
      post_market_change?: FloatNullableFilter<'CompaniesInfo'> | number | null;
      post_market_change_percent?:
        | FloatNullableFilter<'CompaniesInfo'>
        | number
        | null;
      overnight_market_price?:
        | FloatNullableFilter<'CompaniesInfo'>
        | number
        | null;
      overnight_market_change?:
        | FloatNullableFilter<'CompaniesInfo'>
        | number
        | null;
      overnight_market_change_percent?:
        | FloatNullableFilter<'CompaniesInfo'>
        | number
        | null;
      market_cap?:
        | BigIntNullableFilter<'CompaniesInfo'>
        | bigint
        | number
        | null;
      regular_market_time?: BigIntFilter<'CompaniesInfo'> | bigint | number;
      pre_market_time?:
        | BigIntNullableFilter<'CompaniesInfo'>
        | bigint
        | number
        | null;
      post_market_time?:
        | BigIntNullableFilter<'CompaniesInfo'>
        | bigint
        | number
        | null;
      overnight_market_time?:
        | BigIntNullableFilter<'CompaniesInfo'>
        | bigint
        | number
        | null;
      currency?: StringFilter<'CompaniesInfo'> | string;
      created_at?: DateTimeFilter<'CompaniesInfo'> | Date | string;
      updated_at?: DateTimeFilter<'CompaniesInfo'> | Date | string;
      deleted_at?:
        | DateTimeNullableFilter<'CompaniesInfo'>
        | Date
        | string
        | null;
    },
    'id_created_at'
  >;

  export type CompaniesInfoOrderByWithAggregationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    symbol?: SortOrder;
    name?: SortOrder;
    market_state?: SortOrder;
    regular_market_price?: SortOrder;
    regular_market_change?: SortOrder;
    regular_market_change_percent?: SortOrder;
    sector?: SortOrder;
    industry?: SortOrder;
    date_at_shares?: SortOrder;
    assets_type?: SortOrder;
    exchange_name?: SortOrderInput | SortOrder;
    pre_market_price?: SortOrderInput | SortOrder;
    pre_market_change?: SortOrderInput | SortOrder;
    pre_market_change_percent?: SortOrderInput | SortOrder;
    post_market_price?: SortOrderInput | SortOrder;
    post_market_change?: SortOrderInput | SortOrder;
    post_market_change_percent?: SortOrderInput | SortOrder;
    overnight_market_price?: SortOrderInput | SortOrder;
    overnight_market_change?: SortOrderInput | SortOrder;
    overnight_market_change_percent?: SortOrderInput | SortOrder;
    market_cap?: SortOrderInput | SortOrder;
    regular_market_time?: SortOrder;
    pre_market_time?: SortOrderInput | SortOrder;
    post_market_time?: SortOrderInput | SortOrder;
    overnight_market_time?: SortOrderInput | SortOrder;
    currency?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: CompaniesInfoCountOrderByAggregateInput;
    _avg?: CompaniesInfoAvgOrderByAggregateInput;
    _max?: CompaniesInfoMaxOrderByAggregateInput;
    _min?: CompaniesInfoMinOrderByAggregateInput;
    _sum?: CompaniesInfoSumOrderByAggregateInput;
  };

  export type CompaniesInfoScalarWhereWithAggregatesInput = {
    AND?:
      | CompaniesInfoScalarWhereWithAggregatesInput
      | CompaniesInfoScalarWhereWithAggregatesInput[];
    OR?: CompaniesInfoScalarWhereWithAggregatesInput[];
    NOT?:
      | CompaniesInfoScalarWhereWithAggregatesInput
      | CompaniesInfoScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'CompaniesInfo'> | string;
    threads_id?: UuidWithAggregatesFilter<'CompaniesInfo'> | string;
    symbol?: StringWithAggregatesFilter<'CompaniesInfo'> | string;
    name?: StringWithAggregatesFilter<'CompaniesInfo'> | string;
    market_state?: StringWithAggregatesFilter<'CompaniesInfo'> | string;
    regular_market_price?: FloatWithAggregatesFilter<'CompaniesInfo'> | number;
    regular_market_change?: FloatWithAggregatesFilter<'CompaniesInfo'> | number;
    regular_market_change_percent?:
      | FloatWithAggregatesFilter<'CompaniesInfo'>
      | number;
    sector?: StringWithAggregatesFilter<'CompaniesInfo'> | string;
    industry?: StringWithAggregatesFilter<'CompaniesInfo'> | string;
    date_at_shares?:
      | DateTimeWithAggregatesFilter<'CompaniesInfo'>
      | Date
      | string;
    assets_type?:
      | Enumassets_type_enumWithAggregatesFilter<'CompaniesInfo'>
      | $Enums.assets_type_enum;
    exchange_name?:
      | StringNullableWithAggregatesFilter<'CompaniesInfo'>
      | string
      | null;
    pre_market_price?:
      | FloatNullableWithAggregatesFilter<'CompaniesInfo'>
      | number
      | null;
    pre_market_change?:
      | FloatNullableWithAggregatesFilter<'CompaniesInfo'>
      | number
      | null;
    pre_market_change_percent?:
      | FloatNullableWithAggregatesFilter<'CompaniesInfo'>
      | number
      | null;
    post_market_price?:
      | FloatNullableWithAggregatesFilter<'CompaniesInfo'>
      | number
      | null;
    post_market_change?:
      | FloatNullableWithAggregatesFilter<'CompaniesInfo'>
      | number
      | null;
    post_market_change_percent?:
      | FloatNullableWithAggregatesFilter<'CompaniesInfo'>
      | number
      | null;
    overnight_market_price?:
      | FloatNullableWithAggregatesFilter<'CompaniesInfo'>
      | number
      | null;
    overnight_market_change?:
      | FloatNullableWithAggregatesFilter<'CompaniesInfo'>
      | number
      | null;
    overnight_market_change_percent?:
      | FloatNullableWithAggregatesFilter<'CompaniesInfo'>
      | number
      | null;
    market_cap?:
      | BigIntNullableWithAggregatesFilter<'CompaniesInfo'>
      | bigint
      | number
      | null;
    regular_market_time?:
      | BigIntWithAggregatesFilter<'CompaniesInfo'>
      | bigint
      | number;
    pre_market_time?:
      | BigIntNullableWithAggregatesFilter<'CompaniesInfo'>
      | bigint
      | number
      | null;
    post_market_time?:
      | BigIntNullableWithAggregatesFilter<'CompaniesInfo'>
      | bigint
      | number
      | null;
    overnight_market_time?:
      | BigIntNullableWithAggregatesFilter<'CompaniesInfo'>
      | bigint
      | number
      | null;
    currency?: StringWithAggregatesFilter<'CompaniesInfo'> | string;
    created_at?: DateTimeWithAggregatesFilter<'CompaniesInfo'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'CompaniesInfo'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'CompaniesInfo'>
      | Date
      | string
      | null;
  };

  export type FollowNotificationOverridesWhereInput = {
    AND?:
      | FollowNotificationOverridesWhereInput
      | FollowNotificationOverridesWhereInput[];
    OR?: FollowNotificationOverridesWhereInput[];
    NOT?:
      | FollowNotificationOverridesWhereInput
      | FollowNotificationOverridesWhereInput[];
    id?: UuidFilter<'FollowNotificationOverrides'> | string;
    follower_id?: IntFilter<'FollowNotificationOverrides'> | number;
    following_id?: IntFilter<'FollowNotificationOverrides'> | number;
    mute_all?: BoolFilter<'FollowNotificationOverrides'> | boolean;
    notify_threads?: BoolFilter<'FollowNotificationOverrides'> | boolean;
    notify_replies?: BoolFilter<'FollowNotificationOverrides'> | boolean;
    created_at?: DateTimeFilter<'FollowNotificationOverrides'> | Date | string;
    updated_at?: DateTimeFilter<'FollowNotificationOverrides'> | Date | string;
    deleted_at?:
      | DateTimeNullableFilter<'FollowNotificationOverrides'>
      | Date
      | string
      | null;
  };

  export type FollowNotificationOverridesOrderByWithRelationInput = {
    id?: SortOrder;
    follower_id?: SortOrder;
    following_id?: SortOrder;
    mute_all?: SortOrder;
    notify_threads?: SortOrder;
    notify_replies?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type FollowNotificationOverridesWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?:
        | FollowNotificationOverridesWhereInput
        | FollowNotificationOverridesWhereInput[];
      OR?: FollowNotificationOverridesWhereInput[];
      NOT?:
        | FollowNotificationOverridesWhereInput
        | FollowNotificationOverridesWhereInput[];
      follower_id?: IntFilter<'FollowNotificationOverrides'> | number;
      following_id?: IntFilter<'FollowNotificationOverrides'> | number;
      mute_all?: BoolFilter<'FollowNotificationOverrides'> | boolean;
      notify_threads?: BoolFilter<'FollowNotificationOverrides'> | boolean;
      notify_replies?: BoolFilter<'FollowNotificationOverrides'> | boolean;
      created_at?:
        | DateTimeFilter<'FollowNotificationOverrides'>
        | Date
        | string;
      updated_at?:
        | DateTimeFilter<'FollowNotificationOverrides'>
        | Date
        | string;
      deleted_at?:
        | DateTimeNullableFilter<'FollowNotificationOverrides'>
        | Date
        | string
        | null;
    },
    'id'
  >;

  export type FollowNotificationOverridesOrderByWithAggregationInput = {
    id?: SortOrder;
    follower_id?: SortOrder;
    following_id?: SortOrder;
    mute_all?: SortOrder;
    notify_threads?: SortOrder;
    notify_replies?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: FollowNotificationOverridesCountOrderByAggregateInput;
    _avg?: FollowNotificationOverridesAvgOrderByAggregateInput;
    _max?: FollowNotificationOverridesMaxOrderByAggregateInput;
    _min?: FollowNotificationOverridesMinOrderByAggregateInput;
    _sum?: FollowNotificationOverridesSumOrderByAggregateInput;
  };

  export type FollowNotificationOverridesScalarWhereWithAggregatesInput = {
    AND?:
      | FollowNotificationOverridesScalarWhereWithAggregatesInput
      | FollowNotificationOverridesScalarWhereWithAggregatesInput[];
    OR?: FollowNotificationOverridesScalarWhereWithAggregatesInput[];
    NOT?:
      | FollowNotificationOverridesScalarWhereWithAggregatesInput
      | FollowNotificationOverridesScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'FollowNotificationOverrides'> | string;
    follower_id?:
      | IntWithAggregatesFilter<'FollowNotificationOverrides'>
      | number;
    following_id?:
      | IntWithAggregatesFilter<'FollowNotificationOverrides'>
      | number;
    mute_all?:
      | BoolWithAggregatesFilter<'FollowNotificationOverrides'>
      | boolean;
    notify_threads?:
      | BoolWithAggregatesFilter<'FollowNotificationOverrides'>
      | boolean;
    notify_replies?:
      | BoolWithAggregatesFilter<'FollowNotificationOverrides'>
      | boolean;
    created_at?:
      | DateTimeWithAggregatesFilter<'FollowNotificationOverrides'>
      | Date
      | string;
    updated_at?:
      | DateTimeWithAggregatesFilter<'FollowNotificationOverrides'>
      | Date
      | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'FollowNotificationOverrides'>
      | Date
      | string
      | null;
  };

  export type FollowRequestsWhereInput = {
    AND?: FollowRequestsWhereInput | FollowRequestsWhereInput[];
    OR?: FollowRequestsWhereInput[];
    NOT?: FollowRequestsWhereInput | FollowRequestsWhereInput[];
    id?: UuidFilter<'FollowRequests'> | string;
    requester_id?: IntFilter<'FollowRequests'> | number;
    target_id?: IntFilter<'FollowRequests'> | number;
    status?: StringFilter<'FollowRequests'> | string;
    created_at?: DateTimeFilter<'FollowRequests'> | Date | string;
    updated_at?: DateTimeFilter<'FollowRequests'> | Date | string;
    deleted_at?:
      | DateTimeNullableFilter<'FollowRequests'>
      | Date
      | string
      | null;
  };

  export type FollowRequestsOrderByWithRelationInput = {
    id?: SortOrder;
    requester_id?: SortOrder;
    target_id?: SortOrder;
    status?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type FollowRequestsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: FollowRequestsWhereInput | FollowRequestsWhereInput[];
      OR?: FollowRequestsWhereInput[];
      NOT?: FollowRequestsWhereInput | FollowRequestsWhereInput[];
      requester_id?: IntFilter<'FollowRequests'> | number;
      target_id?: IntFilter<'FollowRequests'> | number;
      status?: StringFilter<'FollowRequests'> | string;
      created_at?: DateTimeFilter<'FollowRequests'> | Date | string;
      updated_at?: DateTimeFilter<'FollowRequests'> | Date | string;
      deleted_at?:
        | DateTimeNullableFilter<'FollowRequests'>
        | Date
        | string
        | null;
    },
    'id'
  >;

  export type FollowRequestsOrderByWithAggregationInput = {
    id?: SortOrder;
    requester_id?: SortOrder;
    target_id?: SortOrder;
    status?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: FollowRequestsCountOrderByAggregateInput;
    _avg?: FollowRequestsAvgOrderByAggregateInput;
    _max?: FollowRequestsMaxOrderByAggregateInput;
    _min?: FollowRequestsMinOrderByAggregateInput;
    _sum?: FollowRequestsSumOrderByAggregateInput;
  };

  export type FollowRequestsScalarWhereWithAggregatesInput = {
    AND?:
      | FollowRequestsScalarWhereWithAggregatesInput
      | FollowRequestsScalarWhereWithAggregatesInput[];
    OR?: FollowRequestsScalarWhereWithAggregatesInput[];
    NOT?:
      | FollowRequestsScalarWhereWithAggregatesInput
      | FollowRequestsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'FollowRequests'> | string;
    requester_id?: IntWithAggregatesFilter<'FollowRequests'> | number;
    target_id?: IntWithAggregatesFilter<'FollowRequests'> | number;
    status?: StringWithAggregatesFilter<'FollowRequests'> | string;
    created_at?: DateTimeWithAggregatesFilter<'FollowRequests'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'FollowRequests'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'FollowRequests'>
      | Date
      | string
      | null;
  };

  export type FollowsWhereInput = {
    AND?: FollowsWhereInput | FollowsWhereInput[];
    OR?: FollowsWhereInput[];
    NOT?: FollowsWhereInput | FollowsWhereInput[];
    id?: UuidFilter<'Follows'> | string;
    follower_id?: IntFilter<'Follows'> | number;
    following_id?: IntFilter<'Follows'> | number;
    created_at?: DateTimeFilter<'Follows'> | Date | string;
    updated_at?: DateTimeFilter<'Follows'> | Date | string;
    deleted_at?: DateTimeNullableFilter<'Follows'> | Date | string | null;
  };

  export type FollowsOrderByWithRelationInput = {
    id?: SortOrder;
    follower_id?: SortOrder;
    following_id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type FollowsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: FollowsWhereInput | FollowsWhereInput[];
      OR?: FollowsWhereInput[];
      NOT?: FollowsWhereInput | FollowsWhereInput[];
      follower_id?: IntFilter<'Follows'> | number;
      following_id?: IntFilter<'Follows'> | number;
      created_at?: DateTimeFilter<'Follows'> | Date | string;
      updated_at?: DateTimeFilter<'Follows'> | Date | string;
      deleted_at?: DateTimeNullableFilter<'Follows'> | Date | string | null;
    },
    'id'
  >;

  export type FollowsOrderByWithAggregationInput = {
    id?: SortOrder;
    follower_id?: SortOrder;
    following_id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: FollowsCountOrderByAggregateInput;
    _avg?: FollowsAvgOrderByAggregateInput;
    _max?: FollowsMaxOrderByAggregateInput;
    _min?: FollowsMinOrderByAggregateInput;
    _sum?: FollowsSumOrderByAggregateInput;
  };

  export type FollowsScalarWhereWithAggregatesInput = {
    AND?:
      | FollowsScalarWhereWithAggregatesInput
      | FollowsScalarWhereWithAggregatesInput[];
    OR?: FollowsScalarWhereWithAggregatesInput[];
    NOT?:
      | FollowsScalarWhereWithAggregatesInput
      | FollowsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'Follows'> | string;
    follower_id?: IntWithAggregatesFilter<'Follows'> | number;
    following_id?: IntWithAggregatesFilter<'Follows'> | number;
    created_at?: DateTimeWithAggregatesFilter<'Follows'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'Follows'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'Follows'>
      | Date
      | string
      | null;
  };

  export type FollowsCountWhereInput = {
    AND?: FollowsCountWhereInput | FollowsCountWhereInput[];
    OR?: FollowsCountWhereInput[];
    NOT?: FollowsCountWhereInput | FollowsCountWhereInput[];
    id?: UuidFilter<'FollowsCount'> | string;
    user_id?: IntFilter<'FollowsCount'> | number;
    followers_count?: IntFilter<'FollowsCount'> | number;
    following_count?: IntFilter<'FollowsCount'> | number;
    created_at?: DateTimeFilter<'FollowsCount'> | Date | string;
    updated_at?: DateTimeFilter<'FollowsCount'> | Date | string;
    deleted_at?: DateTimeNullableFilter<'FollowsCount'> | Date | string | null;
  };

  export type FollowsCountOrderByWithRelationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    followers_count?: SortOrder;
    following_count?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type FollowsCountWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      user_id?: number;
      AND?: FollowsCountWhereInput | FollowsCountWhereInput[];
      OR?: FollowsCountWhereInput[];
      NOT?: FollowsCountWhereInput | FollowsCountWhereInput[];
      followers_count?: IntFilter<'FollowsCount'> | number;
      following_count?: IntFilter<'FollowsCount'> | number;
      created_at?: DateTimeFilter<'FollowsCount'> | Date | string;
      updated_at?: DateTimeFilter<'FollowsCount'> | Date | string;
      deleted_at?:
        | DateTimeNullableFilter<'FollowsCount'>
        | Date
        | string
        | null;
    },
    'id' | 'id' | 'user_id'
  >;

  export type FollowsCountOrderByWithAggregationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    followers_count?: SortOrder;
    following_count?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: FollowsCountCountOrderByAggregateInput;
    _avg?: FollowsCountAvgOrderByAggregateInput;
    _max?: FollowsCountMaxOrderByAggregateInput;
    _min?: FollowsCountMinOrderByAggregateInput;
    _sum?: FollowsCountSumOrderByAggregateInput;
  };

  export type FollowsCountScalarWhereWithAggregatesInput = {
    AND?:
      | FollowsCountScalarWhereWithAggregatesInput
      | FollowsCountScalarWhereWithAggregatesInput[];
    OR?: FollowsCountScalarWhereWithAggregatesInput[];
    NOT?:
      | FollowsCountScalarWhereWithAggregatesInput
      | FollowsCountScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'FollowsCount'> | string;
    user_id?: IntWithAggregatesFilter<'FollowsCount'> | number;
    followers_count?: IntWithAggregatesFilter<'FollowsCount'> | number;
    following_count?: IntWithAggregatesFilter<'FollowsCount'> | number;
    created_at?: DateTimeWithAggregatesFilter<'FollowsCount'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'FollowsCount'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'FollowsCount'>
      | Date
      | string
      | null;
  };

  export type NotificationsWhereInput = {
    AND?: NotificationsWhereInput | NotificationsWhereInput[];
    OR?: NotificationsWhereInput[];
    NOT?: NotificationsWhereInput | NotificationsWhereInput[];
    id?: UuidFilter<'Notifications'> | string;
    user_id?: IntNullableFilter<'Notifications'> | number | null;
    sender_id?: IntNullableFilter<'Notifications'> | number | null;
    message_th?: StringNullableFilter<'Notifications'> | string | null;
    message_en?: StringNullableFilter<'Notifications'> | string | null;
    metadata?: JsonNullableFilter<'Notifications'>;
    is_read?: BoolNullableFilter<'Notifications'> | boolean | null;
    type?:
      | Enumnotification_type_enumNullableFilter<'Notifications'>
      | $Enums.notification_type_enum
      | null;
    created_at?: DateTimeFilter<'Notifications'> | Date | string;
    updated_at?: DateTimeFilter<'Notifications'> | Date | string;
    deleted_at?: DateTimeNullableFilter<'Notifications'> | Date | string | null;
  };

  export type NotificationsOrderByWithRelationInput = {
    id?: SortOrder;
    user_id?: SortOrderInput | SortOrder;
    sender_id?: SortOrderInput | SortOrder;
    message_th?: SortOrderInput | SortOrder;
    message_en?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    is_read?: SortOrderInput | SortOrder;
    type?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type NotificationsWhereUniqueInput = Prisma.AtLeast<
    {
      id_created_at?: NotificationsIdCreated_atCompoundUniqueInput;
      AND?: NotificationsWhereInput | NotificationsWhereInput[];
      OR?: NotificationsWhereInput[];
      NOT?: NotificationsWhereInput | NotificationsWhereInput[];
      id?: UuidFilter<'Notifications'> | string;
      user_id?: IntNullableFilter<'Notifications'> | number | null;
      sender_id?: IntNullableFilter<'Notifications'> | number | null;
      message_th?: StringNullableFilter<'Notifications'> | string | null;
      message_en?: StringNullableFilter<'Notifications'> | string | null;
      metadata?: JsonNullableFilter<'Notifications'>;
      is_read?: BoolNullableFilter<'Notifications'> | boolean | null;
      type?:
        | Enumnotification_type_enumNullableFilter<'Notifications'>
        | $Enums.notification_type_enum
        | null;
      created_at?: DateTimeFilter<'Notifications'> | Date | string;
      updated_at?: DateTimeFilter<'Notifications'> | Date | string;
      deleted_at?:
        | DateTimeNullableFilter<'Notifications'>
        | Date
        | string
        | null;
    },
    'id_created_at'
  >;

  export type NotificationsOrderByWithAggregationInput = {
    id?: SortOrder;
    user_id?: SortOrderInput | SortOrder;
    sender_id?: SortOrderInput | SortOrder;
    message_th?: SortOrderInput | SortOrder;
    message_en?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    is_read?: SortOrderInput | SortOrder;
    type?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: NotificationsCountOrderByAggregateInput;
    _avg?: NotificationsAvgOrderByAggregateInput;
    _max?: NotificationsMaxOrderByAggregateInput;
    _min?: NotificationsMinOrderByAggregateInput;
    _sum?: NotificationsSumOrderByAggregateInput;
  };

  export type NotificationsScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationsScalarWhereWithAggregatesInput
      | NotificationsScalarWhereWithAggregatesInput[];
    OR?: NotificationsScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationsScalarWhereWithAggregatesInput
      | NotificationsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'Notifications'> | string;
    user_id?: IntNullableWithAggregatesFilter<'Notifications'> | number | null;
    sender_id?:
      | IntNullableWithAggregatesFilter<'Notifications'>
      | number
      | null;
    message_th?:
      | StringNullableWithAggregatesFilter<'Notifications'>
      | string
      | null;
    message_en?:
      | StringNullableWithAggregatesFilter<'Notifications'>
      | string
      | null;
    metadata?: JsonNullableWithAggregatesFilter<'Notifications'>;
    is_read?:
      | BoolNullableWithAggregatesFilter<'Notifications'>
      | boolean
      | null;
    type?:
      | Enumnotification_type_enumNullableWithAggregatesFilter<'Notifications'>
      | $Enums.notification_type_enum
      | null;
    created_at?: DateTimeWithAggregatesFilter<'Notifications'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'Notifications'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'Notifications'>
      | Date
      | string
      | null;
  };

  export type SymbolsWhereInput = {
    AND?: SymbolsWhereInput | SymbolsWhereInput[];
    OR?: SymbolsWhereInput[];
    NOT?: SymbolsWhereInput | SymbolsWhereInput[];
    id?: UuidFilter<'Symbols'> | string;
    symbol_code?: StringFilter<'Symbols'> | string;
    name?: StringNullableFilter<'Symbols'> | string | null;
    created_at?: DateTimeFilter<'Symbols'> | Date | string;
    updated_at?: DateTimeFilter<'Symbols'> | Date | string;
    deleted_at?: DateTimeNullableFilter<'Symbols'> | Date | string | null;
  };

  export type SymbolsOrderByWithRelationInput = {
    id?: SortOrder;
    symbol_code?: SortOrder;
    name?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type SymbolsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      symbol_code?: string;
      AND?: SymbolsWhereInput | SymbolsWhereInput[];
      OR?: SymbolsWhereInput[];
      NOT?: SymbolsWhereInput | SymbolsWhereInput[];
      name?: StringNullableFilter<'Symbols'> | string | null;
      created_at?: DateTimeFilter<'Symbols'> | Date | string;
      updated_at?: DateTimeFilter<'Symbols'> | Date | string;
      deleted_at?: DateTimeNullableFilter<'Symbols'> | Date | string | null;
    },
    'id' | 'symbol_code'
  >;

  export type SymbolsOrderByWithAggregationInput = {
    id?: SortOrder;
    symbol_code?: SortOrder;
    name?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: SymbolsCountOrderByAggregateInput;
    _max?: SymbolsMaxOrderByAggregateInput;
    _min?: SymbolsMinOrderByAggregateInput;
  };

  export type SymbolsScalarWhereWithAggregatesInput = {
    AND?:
      | SymbolsScalarWhereWithAggregatesInput
      | SymbolsScalarWhereWithAggregatesInput[];
    OR?: SymbolsScalarWhereWithAggregatesInput[];
    NOT?:
      | SymbolsScalarWhereWithAggregatesInput
      | SymbolsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'Symbols'> | string;
    symbol_code?: StringWithAggregatesFilter<'Symbols'> | string;
    name?: StringNullableWithAggregatesFilter<'Symbols'> | string | null;
    created_at?: DateTimeWithAggregatesFilter<'Symbols'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'Symbols'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'Symbols'>
      | Date
      | string
      | null;
  };

  export type ThreadEngagementMetricsWhereInput = {
    AND?:
      | ThreadEngagementMetricsWhereInput
      | ThreadEngagementMetricsWhereInput[];
    OR?: ThreadEngagementMetricsWhereInput[];
    NOT?:
      | ThreadEngagementMetricsWhereInput
      | ThreadEngagementMetricsWhereInput[];
    id?: UuidFilter<'ThreadEngagementMetrics'> | string;
    threads_id?: UuidFilter<'ThreadEngagementMetrics'> | string;
    viewed_count?:
      | DecimalFilter<'ThreadEngagementMetrics'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    replied_count?: IntFilter<'ThreadEngagementMetrics'> | number;
    reposted_count?: IntFilter<'ThreadEngagementMetrics'> | number;
    quoted_count?: IntFilter<'ThreadEngagementMetrics'> | number;
    liked_count?: IntFilter<'ThreadEngagementMetrics'> | number;
    reported_count?: IntFilter<'ThreadEngagementMetrics'> | number;
    created_at?: DateTimeFilter<'ThreadEngagementMetrics'> | Date | string;
    updated_at?: DateTimeFilter<'ThreadEngagementMetrics'> | Date | string;
    deleted_at?:
      | DateTimeNullableFilter<'ThreadEngagementMetrics'>
      | Date
      | string
      | null;
  };

  export type ThreadEngagementMetricsOrderByWithRelationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    viewed_count?: SortOrder;
    replied_count?: SortOrder;
    reposted_count?: SortOrder;
    quoted_count?: SortOrder;
    liked_count?: SortOrder;
    reported_count?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type ThreadEngagementMetricsWhereUniqueInput = Prisma.AtLeast<
    {
      threads_id_created_at?: ThreadEngagementMetricsThreads_idCreated_atCompoundUniqueInput;
      id_created_at?: ThreadEngagementMetricsIdCreated_atCompoundUniqueInput;
      AND?:
        | ThreadEngagementMetricsWhereInput
        | ThreadEngagementMetricsWhereInput[];
      OR?: ThreadEngagementMetricsWhereInput[];
      NOT?:
        | ThreadEngagementMetricsWhereInput
        | ThreadEngagementMetricsWhereInput[];
      id?: UuidFilter<'ThreadEngagementMetrics'> | string;
      threads_id?: UuidFilter<'ThreadEngagementMetrics'> | string;
      viewed_count?:
        | DecimalFilter<'ThreadEngagementMetrics'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      replied_count?: IntFilter<'ThreadEngagementMetrics'> | number;
      reposted_count?: IntFilter<'ThreadEngagementMetrics'> | number;
      quoted_count?: IntFilter<'ThreadEngagementMetrics'> | number;
      liked_count?: IntFilter<'ThreadEngagementMetrics'> | number;
      reported_count?: IntFilter<'ThreadEngagementMetrics'> | number;
      created_at?: DateTimeFilter<'ThreadEngagementMetrics'> | Date | string;
      updated_at?: DateTimeFilter<'ThreadEngagementMetrics'> | Date | string;
      deleted_at?:
        | DateTimeNullableFilter<'ThreadEngagementMetrics'>
        | Date
        | string
        | null;
    },
    'id_created_at' | 'threads_id_created_at'
  >;

  export type ThreadEngagementMetricsOrderByWithAggregationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    viewed_count?: SortOrder;
    replied_count?: SortOrder;
    reposted_count?: SortOrder;
    quoted_count?: SortOrder;
    liked_count?: SortOrder;
    reported_count?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: ThreadEngagementMetricsCountOrderByAggregateInput;
    _avg?: ThreadEngagementMetricsAvgOrderByAggregateInput;
    _max?: ThreadEngagementMetricsMaxOrderByAggregateInput;
    _min?: ThreadEngagementMetricsMinOrderByAggregateInput;
    _sum?: ThreadEngagementMetricsSumOrderByAggregateInput;
  };

  export type ThreadEngagementMetricsScalarWhereWithAggregatesInput = {
    AND?:
      | ThreadEngagementMetricsScalarWhereWithAggregatesInput
      | ThreadEngagementMetricsScalarWhereWithAggregatesInput[];
    OR?: ThreadEngagementMetricsScalarWhereWithAggregatesInput[];
    NOT?:
      | ThreadEngagementMetricsScalarWhereWithAggregatesInput
      | ThreadEngagementMetricsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'ThreadEngagementMetrics'> | string;
    threads_id?: UuidWithAggregatesFilter<'ThreadEngagementMetrics'> | string;
    viewed_count?:
      | DecimalWithAggregatesFilter<'ThreadEngagementMetrics'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    replied_count?: IntWithAggregatesFilter<'ThreadEngagementMetrics'> | number;
    reposted_count?:
      | IntWithAggregatesFilter<'ThreadEngagementMetrics'>
      | number;
    quoted_count?: IntWithAggregatesFilter<'ThreadEngagementMetrics'> | number;
    liked_count?: IntWithAggregatesFilter<'ThreadEngagementMetrics'> | number;
    reported_count?:
      | IntWithAggregatesFilter<'ThreadEngagementMetrics'>
      | number;
    created_at?:
      | DateTimeWithAggregatesFilter<'ThreadEngagementMetrics'>
      | Date
      | string;
    updated_at?:
      | DateTimeWithAggregatesFilter<'ThreadEngagementMetrics'>
      | Date
      | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'ThreadEngagementMetrics'>
      | Date
      | string
      | null;
  };

  export type ThreadHashtagsWhereInput = {
    AND?: ThreadHashtagsWhereInput | ThreadHashtagsWhereInput[];
    OR?: ThreadHashtagsWhereInput[];
    NOT?: ThreadHashtagsWhereInput | ThreadHashtagsWhereInput[];
    id?: UuidFilter<'ThreadHashtags'> | string;
    threads_id?: UuidFilter<'ThreadHashtags'> | string;
    tag?: StringFilter<'ThreadHashtags'> | string;
    type?: Enumtag_type_enumFilter<'ThreadHashtags'> | $Enums.tag_type_enum;
    created_at?: DateTimeFilter<'ThreadHashtags'> | Date | string;
    updated_at?: DateTimeFilter<'ThreadHashtags'> | Date | string;
    deleted_at?:
      | DateTimeNullableFilter<'ThreadHashtags'>
      | Date
      | string
      | null;
  };

  export type ThreadHashtagsOrderByWithRelationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    tag?: SortOrder;
    type?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type ThreadHashtagsWhereUniqueInput = Prisma.AtLeast<
    {
      id_created_at?: ThreadHashtagsIdCreated_atCompoundUniqueInput;
      AND?: ThreadHashtagsWhereInput | ThreadHashtagsWhereInput[];
      OR?: ThreadHashtagsWhereInput[];
      NOT?: ThreadHashtagsWhereInput | ThreadHashtagsWhereInput[];
      id?: UuidFilter<'ThreadHashtags'> | string;
      threads_id?: UuidFilter<'ThreadHashtags'> | string;
      tag?: StringFilter<'ThreadHashtags'> | string;
      type?: Enumtag_type_enumFilter<'ThreadHashtags'> | $Enums.tag_type_enum;
      created_at?: DateTimeFilter<'ThreadHashtags'> | Date | string;
      updated_at?: DateTimeFilter<'ThreadHashtags'> | Date | string;
      deleted_at?:
        | DateTimeNullableFilter<'ThreadHashtags'>
        | Date
        | string
        | null;
    },
    'id_created_at'
  >;

  export type ThreadHashtagsOrderByWithAggregationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    tag?: SortOrder;
    type?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: ThreadHashtagsCountOrderByAggregateInput;
    _max?: ThreadHashtagsMaxOrderByAggregateInput;
    _min?: ThreadHashtagsMinOrderByAggregateInput;
  };

  export type ThreadHashtagsScalarWhereWithAggregatesInput = {
    AND?:
      | ThreadHashtagsScalarWhereWithAggregatesInput
      | ThreadHashtagsScalarWhereWithAggregatesInput[];
    OR?: ThreadHashtagsScalarWhereWithAggregatesInput[];
    NOT?:
      | ThreadHashtagsScalarWhereWithAggregatesInput
      | ThreadHashtagsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'ThreadHashtags'> | string;
    threads_id?: UuidWithAggregatesFilter<'ThreadHashtags'> | string;
    tag?: StringWithAggregatesFilter<'ThreadHashtags'> | string;
    type?:
      | Enumtag_type_enumWithAggregatesFilter<'ThreadHashtags'>
      | $Enums.tag_type_enum;
    created_at?: DateTimeWithAggregatesFilter<'ThreadHashtags'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'ThreadHashtags'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'ThreadHashtags'>
      | Date
      | string
      | null;
  };

  export type ThreadLikesWhereInput = {
    AND?: ThreadLikesWhereInput | ThreadLikesWhereInput[];
    OR?: ThreadLikesWhereInput[];
    NOT?: ThreadLikesWhereInput | ThreadLikesWhereInput[];
    id?: UuidFilter<'ThreadLikes'> | string;
    threads_id?: UuidFilter<'ThreadLikes'> | string;
    user_id?: IntFilter<'ThreadLikes'> | number;
    created_at?: DateTimeFilter<'ThreadLikes'> | Date | string;
    updated_at?: DateTimeFilter<'ThreadLikes'> | Date | string;
    deleted_at?: DateTimeNullableFilter<'ThreadLikes'> | Date | string | null;
  };

  export type ThreadLikesOrderByWithRelationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    user_id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type ThreadLikesWhereUniqueInput = Prisma.AtLeast<
    {
      id_created_at?: ThreadLikesIdCreated_atCompoundUniqueInput;
      AND?: ThreadLikesWhereInput | ThreadLikesWhereInput[];
      OR?: ThreadLikesWhereInput[];
      NOT?: ThreadLikesWhereInput | ThreadLikesWhereInput[];
      id?: UuidFilter<'ThreadLikes'> | string;
      threads_id?: UuidFilter<'ThreadLikes'> | string;
      user_id?: IntFilter<'ThreadLikes'> | number;
      created_at?: DateTimeFilter<'ThreadLikes'> | Date | string;
      updated_at?: DateTimeFilter<'ThreadLikes'> | Date | string;
      deleted_at?: DateTimeNullableFilter<'ThreadLikes'> | Date | string | null;
    },
    'id_created_at'
  >;

  export type ThreadLikesOrderByWithAggregationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    user_id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: ThreadLikesCountOrderByAggregateInput;
    _avg?: ThreadLikesAvgOrderByAggregateInput;
    _max?: ThreadLikesMaxOrderByAggregateInput;
    _min?: ThreadLikesMinOrderByAggregateInput;
    _sum?: ThreadLikesSumOrderByAggregateInput;
  };

  export type ThreadLikesScalarWhereWithAggregatesInput = {
    AND?:
      | ThreadLikesScalarWhereWithAggregatesInput
      | ThreadLikesScalarWhereWithAggregatesInput[];
    OR?: ThreadLikesScalarWhereWithAggregatesInput[];
    NOT?:
      | ThreadLikesScalarWhereWithAggregatesInput
      | ThreadLikesScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'ThreadLikes'> | string;
    threads_id?: UuidWithAggregatesFilter<'ThreadLikes'> | string;
    user_id?: IntWithAggregatesFilter<'ThreadLikes'> | number;
    created_at?: DateTimeWithAggregatesFilter<'ThreadLikes'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'ThreadLikes'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'ThreadLikes'>
      | Date
      | string
      | null;
  };

  export type ThreadMediaWhereInput = {
    AND?: ThreadMediaWhereInput | ThreadMediaWhereInput[];
    OR?: ThreadMediaWhereInput[];
    NOT?: ThreadMediaWhereInput | ThreadMediaWhereInput[];
    id?: UuidFilter<'ThreadMedia'> | string;
    threads_id?: UuidFilter<'ThreadMedia'> | string;
    media_type?:
      | Enummedia_type_enumNullableFilter<'ThreadMedia'>
      | $Enums.media_type_enum
      | null;
    media_url?: StringNullableFilter<'ThreadMedia'> | string | null;
    thumbnail_url?: StringNullableFilter<'ThreadMedia'> | string | null;
    created_at?: DateTimeFilter<'ThreadMedia'> | Date | string;
    updated_at?: DateTimeFilter<'ThreadMedia'> | Date | string;
    deleted_at?: DateTimeNullableFilter<'ThreadMedia'> | Date | string | null;
    width?: IntNullableFilter<'ThreadMedia'> | number | null;
    height?: IntNullableFilter<'ThreadMedia'> | number | null;
    size?: IntNullableFilter<'ThreadMedia'> | number | null;
    duration?: IntNullableFilter<'ThreadMedia'> | number | null;
    object_key?: StringNullableFilter<'ThreadMedia'> | string | null;
  };

  export type ThreadMediaOrderByWithRelationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    media_type?: SortOrderInput | SortOrder;
    media_url?: SortOrderInput | SortOrder;
    thumbnail_url?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    width?: SortOrderInput | SortOrder;
    height?: SortOrderInput | SortOrder;
    size?: SortOrderInput | SortOrder;
    duration?: SortOrderInput | SortOrder;
    object_key?: SortOrderInput | SortOrder;
  };

  export type ThreadMediaWhereUniqueInput = Prisma.AtLeast<
    {
      id_created_at?: ThreadMediaIdCreated_atCompoundUniqueInput;
      AND?: ThreadMediaWhereInput | ThreadMediaWhereInput[];
      OR?: ThreadMediaWhereInput[];
      NOT?: ThreadMediaWhereInput | ThreadMediaWhereInput[];
      id?: UuidFilter<'ThreadMedia'> | string;
      threads_id?: UuidFilter<'ThreadMedia'> | string;
      media_type?:
        | Enummedia_type_enumNullableFilter<'ThreadMedia'>
        | $Enums.media_type_enum
        | null;
      media_url?: StringNullableFilter<'ThreadMedia'> | string | null;
      thumbnail_url?: StringNullableFilter<'ThreadMedia'> | string | null;
      created_at?: DateTimeFilter<'ThreadMedia'> | Date | string;
      updated_at?: DateTimeFilter<'ThreadMedia'> | Date | string;
      deleted_at?: DateTimeNullableFilter<'ThreadMedia'> | Date | string | null;
      width?: IntNullableFilter<'ThreadMedia'> | number | null;
      height?: IntNullableFilter<'ThreadMedia'> | number | null;
      size?: IntNullableFilter<'ThreadMedia'> | number | null;
      duration?: IntNullableFilter<'ThreadMedia'> | number | null;
      object_key?: StringNullableFilter<'ThreadMedia'> | string | null;
    },
    'id_created_at'
  >;

  export type ThreadMediaOrderByWithAggregationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    media_type?: SortOrderInput | SortOrder;
    media_url?: SortOrderInput | SortOrder;
    thumbnail_url?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    width?: SortOrderInput | SortOrder;
    height?: SortOrderInput | SortOrder;
    size?: SortOrderInput | SortOrder;
    duration?: SortOrderInput | SortOrder;
    object_key?: SortOrderInput | SortOrder;
    _count?: ThreadMediaCountOrderByAggregateInput;
    _avg?: ThreadMediaAvgOrderByAggregateInput;
    _max?: ThreadMediaMaxOrderByAggregateInput;
    _min?: ThreadMediaMinOrderByAggregateInput;
    _sum?: ThreadMediaSumOrderByAggregateInput;
  };

  export type ThreadMediaScalarWhereWithAggregatesInput = {
    AND?:
      | ThreadMediaScalarWhereWithAggregatesInput
      | ThreadMediaScalarWhereWithAggregatesInput[];
    OR?: ThreadMediaScalarWhereWithAggregatesInput[];
    NOT?:
      | ThreadMediaScalarWhereWithAggregatesInput
      | ThreadMediaScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'ThreadMedia'> | string;
    threads_id?: UuidWithAggregatesFilter<'ThreadMedia'> | string;
    media_type?:
      | Enummedia_type_enumNullableWithAggregatesFilter<'ThreadMedia'>
      | $Enums.media_type_enum
      | null;
    media_url?:
      | StringNullableWithAggregatesFilter<'ThreadMedia'>
      | string
      | null;
    thumbnail_url?:
      | StringNullableWithAggregatesFilter<'ThreadMedia'>
      | string
      | null;
    created_at?: DateTimeWithAggregatesFilter<'ThreadMedia'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'ThreadMedia'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'ThreadMedia'>
      | Date
      | string
      | null;
    width?: IntNullableWithAggregatesFilter<'ThreadMedia'> | number | null;
    height?: IntNullableWithAggregatesFilter<'ThreadMedia'> | number | null;
    size?: IntNullableWithAggregatesFilter<'ThreadMedia'> | number | null;
    duration?: IntNullableWithAggregatesFilter<'ThreadMedia'> | number | null;
    object_key?:
      | StringNullableWithAggregatesFilter<'ThreadMedia'>
      | string
      | null;
  };

  export type ThreadMentionsWhereInput = {
    AND?: ThreadMentionsWhereInput | ThreadMentionsWhereInput[];
    OR?: ThreadMentionsWhereInput[];
    NOT?: ThreadMentionsWhereInput | ThreadMentionsWhereInput[];
    id?: UuidFilter<'ThreadMentions'> | string;
    threads_id?: UuidFilter<'ThreadMentions'> | string;
    mentioned_user_id?: IntFilter<'ThreadMentions'> | number;
    position?: IntFilter<'ThreadMentions'> | number;
    created_at?: DateTimeFilter<'ThreadMentions'> | Date | string;
    updated_at?: DateTimeFilter<'ThreadMentions'> | Date | string;
    deleted_at?:
      | DateTimeNullableFilter<'ThreadMentions'>
      | Date
      | string
      | null;
  };

  export type ThreadMentionsOrderByWithRelationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    mentioned_user_id?: SortOrder;
    position?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type ThreadMentionsWhereUniqueInput = Prisma.AtLeast<
    {
      id_created_at?: ThreadMentionsIdCreated_atCompoundUniqueInput;
      AND?: ThreadMentionsWhereInput | ThreadMentionsWhereInput[];
      OR?: ThreadMentionsWhereInput[];
      NOT?: ThreadMentionsWhereInput | ThreadMentionsWhereInput[];
      id?: UuidFilter<'ThreadMentions'> | string;
      threads_id?: UuidFilter<'ThreadMentions'> | string;
      mentioned_user_id?: IntFilter<'ThreadMentions'> | number;
      position?: IntFilter<'ThreadMentions'> | number;
      created_at?: DateTimeFilter<'ThreadMentions'> | Date | string;
      updated_at?: DateTimeFilter<'ThreadMentions'> | Date | string;
      deleted_at?:
        | DateTimeNullableFilter<'ThreadMentions'>
        | Date
        | string
        | null;
    },
    'id_created_at'
  >;

  export type ThreadMentionsOrderByWithAggregationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    mentioned_user_id?: SortOrder;
    position?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: ThreadMentionsCountOrderByAggregateInput;
    _avg?: ThreadMentionsAvgOrderByAggregateInput;
    _max?: ThreadMentionsMaxOrderByAggregateInput;
    _min?: ThreadMentionsMinOrderByAggregateInput;
    _sum?: ThreadMentionsSumOrderByAggregateInput;
  };

  export type ThreadMentionsScalarWhereWithAggregatesInput = {
    AND?:
      | ThreadMentionsScalarWhereWithAggregatesInput
      | ThreadMentionsScalarWhereWithAggregatesInput[];
    OR?: ThreadMentionsScalarWhereWithAggregatesInput[];
    NOT?:
      | ThreadMentionsScalarWhereWithAggregatesInput
      | ThreadMentionsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'ThreadMentions'> | string;
    threads_id?: UuidWithAggregatesFilter<'ThreadMentions'> | string;
    mentioned_user_id?: IntWithAggregatesFilter<'ThreadMentions'> | number;
    position?: IntWithAggregatesFilter<'ThreadMentions'> | number;
    created_at?: DateTimeWithAggregatesFilter<'ThreadMentions'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'ThreadMentions'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'ThreadMentions'>
      | Date
      | string
      | null;
  };

  export type ThreadPinsWhereInput = {
    AND?: ThreadPinsWhereInput | ThreadPinsWhereInput[];
    OR?: ThreadPinsWhereInput[];
    NOT?: ThreadPinsWhereInput | ThreadPinsWhereInput[];
    id?: UuidFilter<'ThreadPins'> | string;
    user_id?: IntFilter<'ThreadPins'> | number;
    threads_id?: UuidFilter<'ThreadPins'> | string;
    pinned_at?: DateTimeFilter<'ThreadPins'> | Date | string;
    created_at?: DateTimeFilter<'ThreadPins'> | Date | string;
    updated_at?: DateTimeFilter<'ThreadPins'> | Date | string;
    deleted_at?: DateTimeNullableFilter<'ThreadPins'> | Date | string | null;
  };

  export type ThreadPinsOrderByWithRelationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    threads_id?: SortOrder;
    pinned_at?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type ThreadPinsWhereUniqueInput = Prisma.AtLeast<
    {
      id_created_at?: ThreadPinsIdCreated_atCompoundUniqueInput;
      AND?: ThreadPinsWhereInput | ThreadPinsWhereInput[];
      OR?: ThreadPinsWhereInput[];
      NOT?: ThreadPinsWhereInput | ThreadPinsWhereInput[];
      id?: UuidFilter<'ThreadPins'> | string;
      user_id?: IntFilter<'ThreadPins'> | number;
      threads_id?: UuidFilter<'ThreadPins'> | string;
      pinned_at?: DateTimeFilter<'ThreadPins'> | Date | string;
      created_at?: DateTimeFilter<'ThreadPins'> | Date | string;
      updated_at?: DateTimeFilter<'ThreadPins'> | Date | string;
      deleted_at?: DateTimeNullableFilter<'ThreadPins'> | Date | string | null;
    },
    'id_created_at'
  >;

  export type ThreadPinsOrderByWithAggregationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    threads_id?: SortOrder;
    pinned_at?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: ThreadPinsCountOrderByAggregateInput;
    _avg?: ThreadPinsAvgOrderByAggregateInput;
    _max?: ThreadPinsMaxOrderByAggregateInput;
    _min?: ThreadPinsMinOrderByAggregateInput;
    _sum?: ThreadPinsSumOrderByAggregateInput;
  };

  export type ThreadPinsScalarWhereWithAggregatesInput = {
    AND?:
      | ThreadPinsScalarWhereWithAggregatesInput
      | ThreadPinsScalarWhereWithAggregatesInput[];
    OR?: ThreadPinsScalarWhereWithAggregatesInput[];
    NOT?:
      | ThreadPinsScalarWhereWithAggregatesInput
      | ThreadPinsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'ThreadPins'> | string;
    user_id?: IntWithAggregatesFilter<'ThreadPins'> | number;
    threads_id?: UuidWithAggregatesFilter<'ThreadPins'> | string;
    pinned_at?: DateTimeWithAggregatesFilter<'ThreadPins'> | Date | string;
    created_at?: DateTimeWithAggregatesFilter<'ThreadPins'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'ThreadPins'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'ThreadPins'>
      | Date
      | string
      | null;
  };

  export type ThreadPollOptionsWhereInput = {
    AND?: ThreadPollOptionsWhereInput | ThreadPollOptionsWhereInput[];
    OR?: ThreadPollOptionsWhereInput[];
    NOT?: ThreadPollOptionsWhereInput | ThreadPollOptionsWhereInput[];
    id?: UuidFilter<'ThreadPollOptions'> | string;
    poll_id?: UuidFilter<'ThreadPollOptions'> | string;
    option_text?: StringFilter<'ThreadPollOptions'> | string;
    voted_count?: IntFilter<'ThreadPollOptions'> | number;
    created_at?: DateTimeFilter<'ThreadPollOptions'> | Date | string;
    updated_at?: DateTimeFilter<'ThreadPollOptions'> | Date | string;
    deleted_at?:
      | DateTimeNullableFilter<'ThreadPollOptions'>
      | Date
      | string
      | null;
  };

  export type ThreadPollOptionsOrderByWithRelationInput = {
    id?: SortOrder;
    poll_id?: SortOrder;
    option_text?: SortOrder;
    voted_count?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type ThreadPollOptionsWhereUniqueInput = Prisma.AtLeast<
    {
      id_created_at?: ThreadPollOptionsIdCreated_atCompoundUniqueInput;
      AND?: ThreadPollOptionsWhereInput | ThreadPollOptionsWhereInput[];
      OR?: ThreadPollOptionsWhereInput[];
      NOT?: ThreadPollOptionsWhereInput | ThreadPollOptionsWhereInput[];
      id?: UuidFilter<'ThreadPollOptions'> | string;
      poll_id?: UuidFilter<'ThreadPollOptions'> | string;
      option_text?: StringFilter<'ThreadPollOptions'> | string;
      voted_count?: IntFilter<'ThreadPollOptions'> | number;
      created_at?: DateTimeFilter<'ThreadPollOptions'> | Date | string;
      updated_at?: DateTimeFilter<'ThreadPollOptions'> | Date | string;
      deleted_at?:
        | DateTimeNullableFilter<'ThreadPollOptions'>
        | Date
        | string
        | null;
    },
    'id_created_at'
  >;

  export type ThreadPollOptionsOrderByWithAggregationInput = {
    id?: SortOrder;
    poll_id?: SortOrder;
    option_text?: SortOrder;
    voted_count?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: ThreadPollOptionsCountOrderByAggregateInput;
    _avg?: ThreadPollOptionsAvgOrderByAggregateInput;
    _max?: ThreadPollOptionsMaxOrderByAggregateInput;
    _min?: ThreadPollOptionsMinOrderByAggregateInput;
    _sum?: ThreadPollOptionsSumOrderByAggregateInput;
  };

  export type ThreadPollOptionsScalarWhereWithAggregatesInput = {
    AND?:
      | ThreadPollOptionsScalarWhereWithAggregatesInput
      | ThreadPollOptionsScalarWhereWithAggregatesInput[];
    OR?: ThreadPollOptionsScalarWhereWithAggregatesInput[];
    NOT?:
      | ThreadPollOptionsScalarWhereWithAggregatesInput
      | ThreadPollOptionsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'ThreadPollOptions'> | string;
    poll_id?: UuidWithAggregatesFilter<'ThreadPollOptions'> | string;
    option_text?: StringWithAggregatesFilter<'ThreadPollOptions'> | string;
    voted_count?: IntWithAggregatesFilter<'ThreadPollOptions'> | number;
    created_at?:
      | DateTimeWithAggregatesFilter<'ThreadPollOptions'>
      | Date
      | string;
    updated_at?:
      | DateTimeWithAggregatesFilter<'ThreadPollOptions'>
      | Date
      | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'ThreadPollOptions'>
      | Date
      | string
      | null;
  };

  export type ThreadPollVotesWhereInput = {
    AND?: ThreadPollVotesWhereInput | ThreadPollVotesWhereInput[];
    OR?: ThreadPollVotesWhereInput[];
    NOT?: ThreadPollVotesWhereInput | ThreadPollVotesWhereInput[];
    id?: UuidFilter<'ThreadPollVotes'> | string;
    option_id?: UuidFilter<'ThreadPollVotes'> | string;
    user_id?: IntFilter<'ThreadPollVotes'> | number;
    voted_at?: DateTimeFilter<'ThreadPollVotes'> | Date | string;
    created_at?: DateTimeFilter<'ThreadPollVotes'> | Date | string;
    updated_at?: DateTimeFilter<'ThreadPollVotes'> | Date | string;
    deleted_at?:
      | DateTimeNullableFilter<'ThreadPollVotes'>
      | Date
      | string
      | null;
  };

  export type ThreadPollVotesOrderByWithRelationInput = {
    id?: SortOrder;
    option_id?: SortOrder;
    user_id?: SortOrder;
    voted_at?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type ThreadPollVotesWhereUniqueInput = Prisma.AtLeast<
    {
      id_created_at?: ThreadPollVotesIdCreated_atCompoundUniqueInput;
      AND?: ThreadPollVotesWhereInput | ThreadPollVotesWhereInput[];
      OR?: ThreadPollVotesWhereInput[];
      NOT?: ThreadPollVotesWhereInput | ThreadPollVotesWhereInput[];
      id?: UuidFilter<'ThreadPollVotes'> | string;
      option_id?: UuidFilter<'ThreadPollVotes'> | string;
      user_id?: IntFilter<'ThreadPollVotes'> | number;
      voted_at?: DateTimeFilter<'ThreadPollVotes'> | Date | string;
      created_at?: DateTimeFilter<'ThreadPollVotes'> | Date | string;
      updated_at?: DateTimeFilter<'ThreadPollVotes'> | Date | string;
      deleted_at?:
        | DateTimeNullableFilter<'ThreadPollVotes'>
        | Date
        | string
        | null;
    },
    'id_created_at'
  >;

  export type ThreadPollVotesOrderByWithAggregationInput = {
    id?: SortOrder;
    option_id?: SortOrder;
    user_id?: SortOrder;
    voted_at?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: ThreadPollVotesCountOrderByAggregateInput;
    _avg?: ThreadPollVotesAvgOrderByAggregateInput;
    _max?: ThreadPollVotesMaxOrderByAggregateInput;
    _min?: ThreadPollVotesMinOrderByAggregateInput;
    _sum?: ThreadPollVotesSumOrderByAggregateInput;
  };

  export type ThreadPollVotesScalarWhereWithAggregatesInput = {
    AND?:
      | ThreadPollVotesScalarWhereWithAggregatesInput
      | ThreadPollVotesScalarWhereWithAggregatesInput[];
    OR?: ThreadPollVotesScalarWhereWithAggregatesInput[];
    NOT?:
      | ThreadPollVotesScalarWhereWithAggregatesInput
      | ThreadPollVotesScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'ThreadPollVotes'> | string;
    option_id?: UuidWithAggregatesFilter<'ThreadPollVotes'> | string;
    user_id?: IntWithAggregatesFilter<'ThreadPollVotes'> | number;
    voted_at?: DateTimeWithAggregatesFilter<'ThreadPollVotes'> | Date | string;
    created_at?:
      | DateTimeWithAggregatesFilter<'ThreadPollVotes'>
      | Date
      | string;
    updated_at?:
      | DateTimeWithAggregatesFilter<'ThreadPollVotes'>
      | Date
      | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'ThreadPollVotes'>
      | Date
      | string
      | null;
  };

  export type ThreadPollsWhereInput = {
    AND?: ThreadPollsWhereInput | ThreadPollsWhereInput[];
    OR?: ThreadPollsWhereInput[];
    NOT?: ThreadPollsWhereInput | ThreadPollsWhereInput[];
    id?: UuidFilter<'ThreadPolls'> | string;
    threads_id?: UuidFilter<'ThreadPolls'> | string;
    question?: StringFilter<'ThreadPolls'> | string;
    total_voted?: IntFilter<'ThreadPolls'> | number;
    expires_at?: DateTimeFilter<'ThreadPolls'> | Date | string;
    created_at?: DateTimeFilter<'ThreadPolls'> | Date | string;
    updated_at?: DateTimeFilter<'ThreadPolls'> | Date | string;
    deleted_at?: DateTimeNullableFilter<'ThreadPolls'> | Date | string | null;
  };

  export type ThreadPollsOrderByWithRelationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    question?: SortOrder;
    total_voted?: SortOrder;
    expires_at?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type ThreadPollsWhereUniqueInput = Prisma.AtLeast<
    {
      id_created_at?: ThreadPollsIdCreated_atCompoundUniqueInput;
      AND?: ThreadPollsWhereInput | ThreadPollsWhereInput[];
      OR?: ThreadPollsWhereInput[];
      NOT?: ThreadPollsWhereInput | ThreadPollsWhereInput[];
      id?: UuidFilter<'ThreadPolls'> | string;
      threads_id?: UuidFilter<'ThreadPolls'> | string;
      question?: StringFilter<'ThreadPolls'> | string;
      total_voted?: IntFilter<'ThreadPolls'> | number;
      expires_at?: DateTimeFilter<'ThreadPolls'> | Date | string;
      created_at?: DateTimeFilter<'ThreadPolls'> | Date | string;
      updated_at?: DateTimeFilter<'ThreadPolls'> | Date | string;
      deleted_at?: DateTimeNullableFilter<'ThreadPolls'> | Date | string | null;
    },
    'id_created_at'
  >;

  export type ThreadPollsOrderByWithAggregationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    question?: SortOrder;
    total_voted?: SortOrder;
    expires_at?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: ThreadPollsCountOrderByAggregateInput;
    _avg?: ThreadPollsAvgOrderByAggregateInput;
    _max?: ThreadPollsMaxOrderByAggregateInput;
    _min?: ThreadPollsMinOrderByAggregateInput;
    _sum?: ThreadPollsSumOrderByAggregateInput;
  };

  export type ThreadPollsScalarWhereWithAggregatesInput = {
    AND?:
      | ThreadPollsScalarWhereWithAggregatesInput
      | ThreadPollsScalarWhereWithAggregatesInput[];
    OR?: ThreadPollsScalarWhereWithAggregatesInput[];
    NOT?:
      | ThreadPollsScalarWhereWithAggregatesInput
      | ThreadPollsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'ThreadPolls'> | string;
    threads_id?: UuidWithAggregatesFilter<'ThreadPolls'> | string;
    question?: StringWithAggregatesFilter<'ThreadPolls'> | string;
    total_voted?: IntWithAggregatesFilter<'ThreadPolls'> | number;
    expires_at?: DateTimeWithAggregatesFilter<'ThreadPolls'> | Date | string;
    created_at?: DateTimeWithAggregatesFilter<'ThreadPolls'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'ThreadPolls'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'ThreadPolls'>
      | Date
      | string
      | null;
  };

  export type ThreadReportReasonsWhereInput = {
    AND?: ThreadReportReasonsWhereInput | ThreadReportReasonsWhereInput[];
    OR?: ThreadReportReasonsWhereInput[];
    NOT?: ThreadReportReasonsWhereInput | ThreadReportReasonsWhereInput[];
    id?: UuidFilter<'ThreadReportReasons'> | string;
    parent_id?: UuidNullableFilter<'ThreadReportReasons'> | string | null;
    code?: StringFilter<'ThreadReportReasons'> | string;
    level?: IntFilter<'ThreadReportReasons'> | number;
    is_leaf?: BoolFilter<'ThreadReportReasons'> | boolean;
    translations?: JsonFilter<'ThreadReportReasons'>;
    is_active?: BoolFilter<'ThreadReportReasons'> | boolean;
    sort_order?: IntFilter<'ThreadReportReasons'> | number;
    created_at?: DateTimeFilter<'ThreadReportReasons'> | Date | string;
    updated_at?: DateTimeFilter<'ThreadReportReasons'> | Date | string;
    deleted_at?:
      | DateTimeNullableFilter<'ThreadReportReasons'>
      | Date
      | string
      | null;
    ThreadReportReasons?: XOR<
      ThreadReportReasonsNullableScalarRelationFilter,
      ThreadReportReasonsWhereInput
    > | null;
    other_ThreadReportReasons?: ThreadReportReasonsListRelationFilter;
  };

  export type ThreadReportReasonsOrderByWithRelationInput = {
    id?: SortOrder;
    parent_id?: SortOrderInput | SortOrder;
    code?: SortOrder;
    level?: SortOrder;
    is_leaf?: SortOrder;
    translations?: SortOrder;
    is_active?: SortOrder;
    sort_order?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    ThreadReportReasons?: ThreadReportReasonsOrderByWithRelationInput;
    other_ThreadReportReasons?: ThreadReportReasonsOrderByRelationAggregateInput;
  };

  export type ThreadReportReasonsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      code?: string;
      AND?: ThreadReportReasonsWhereInput | ThreadReportReasonsWhereInput[];
      OR?: ThreadReportReasonsWhereInput[];
      NOT?: ThreadReportReasonsWhereInput | ThreadReportReasonsWhereInput[];
      parent_id?: UuidNullableFilter<'ThreadReportReasons'> | string | null;
      level?: IntFilter<'ThreadReportReasons'> | number;
      is_leaf?: BoolFilter<'ThreadReportReasons'> | boolean;
      translations?: JsonFilter<'ThreadReportReasons'>;
      is_active?: BoolFilter<'ThreadReportReasons'> | boolean;
      sort_order?: IntFilter<'ThreadReportReasons'> | number;
      created_at?: DateTimeFilter<'ThreadReportReasons'> | Date | string;
      updated_at?: DateTimeFilter<'ThreadReportReasons'> | Date | string;
      deleted_at?:
        | DateTimeNullableFilter<'ThreadReportReasons'>
        | Date
        | string
        | null;
      ThreadReportReasons?: XOR<
        ThreadReportReasonsNullableScalarRelationFilter,
        ThreadReportReasonsWhereInput
      > | null;
      other_ThreadReportReasons?: ThreadReportReasonsListRelationFilter;
    },
    'id' | 'code'
  >;

  export type ThreadReportReasonsOrderByWithAggregationInput = {
    id?: SortOrder;
    parent_id?: SortOrderInput | SortOrder;
    code?: SortOrder;
    level?: SortOrder;
    is_leaf?: SortOrder;
    translations?: SortOrder;
    is_active?: SortOrder;
    sort_order?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: ThreadReportReasonsCountOrderByAggregateInput;
    _avg?: ThreadReportReasonsAvgOrderByAggregateInput;
    _max?: ThreadReportReasonsMaxOrderByAggregateInput;
    _min?: ThreadReportReasonsMinOrderByAggregateInput;
    _sum?: ThreadReportReasonsSumOrderByAggregateInput;
  };

  export type ThreadReportReasonsScalarWhereWithAggregatesInput = {
    AND?:
      | ThreadReportReasonsScalarWhereWithAggregatesInput
      | ThreadReportReasonsScalarWhereWithAggregatesInput[];
    OR?: ThreadReportReasonsScalarWhereWithAggregatesInput[];
    NOT?:
      | ThreadReportReasonsScalarWhereWithAggregatesInput
      | ThreadReportReasonsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'ThreadReportReasons'> | string;
    parent_id?:
      | UuidNullableWithAggregatesFilter<'ThreadReportReasons'>
      | string
      | null;
    code?: StringWithAggregatesFilter<'ThreadReportReasons'> | string;
    level?: IntWithAggregatesFilter<'ThreadReportReasons'> | number;
    is_leaf?: BoolWithAggregatesFilter<'ThreadReportReasons'> | boolean;
    translations?: JsonWithAggregatesFilter<'ThreadReportReasons'>;
    is_active?: BoolWithAggregatesFilter<'ThreadReportReasons'> | boolean;
    sort_order?: IntWithAggregatesFilter<'ThreadReportReasons'> | number;
    created_at?:
      | DateTimeWithAggregatesFilter<'ThreadReportReasons'>
      | Date
      | string;
    updated_at?:
      | DateTimeWithAggregatesFilter<'ThreadReportReasons'>
      | Date
      | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'ThreadReportReasons'>
      | Date
      | string
      | null;
  };

  export type ThreadReportsWhereInput = {
    AND?: ThreadReportsWhereInput | ThreadReportsWhereInput[];
    OR?: ThreadReportsWhereInput[];
    NOT?: ThreadReportsWhereInput | ThreadReportsWhereInput[];
    id?: UuidFilter<'ThreadReports'> | string;
    threads_id?: UuidFilter<'ThreadReports'> | string;
    reported_by?: IntNullableFilter<'ThreadReports'> | number | null;
    reason?: StringNullableFilter<'ThreadReports'> | string | null;
    created_at?: DateTimeFilter<'ThreadReports'> | Date | string;
    updated_at?: DateTimeFilter<'ThreadReports'> | Date | string;
    deleted_at?: DateTimeNullableFilter<'ThreadReports'> | Date | string | null;
  };

  export type ThreadReportsOrderByWithRelationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    reported_by?: SortOrderInput | SortOrder;
    reason?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type ThreadReportsWhereUniqueInput = Prisma.AtLeast<
    {
      id_created_at?: ThreadReportsIdCreated_atCompoundUniqueInput;
      AND?: ThreadReportsWhereInput | ThreadReportsWhereInput[];
      OR?: ThreadReportsWhereInput[];
      NOT?: ThreadReportsWhereInput | ThreadReportsWhereInput[];
      id?: UuidFilter<'ThreadReports'> | string;
      threads_id?: UuidFilter<'ThreadReports'> | string;
      reported_by?: IntNullableFilter<'ThreadReports'> | number | null;
      reason?: StringNullableFilter<'ThreadReports'> | string | null;
      created_at?: DateTimeFilter<'ThreadReports'> | Date | string;
      updated_at?: DateTimeFilter<'ThreadReports'> | Date | string;
      deleted_at?:
        | DateTimeNullableFilter<'ThreadReports'>
        | Date
        | string
        | null;
    },
    'id_created_at'
  >;

  export type ThreadReportsOrderByWithAggregationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    reported_by?: SortOrderInput | SortOrder;
    reason?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: ThreadReportsCountOrderByAggregateInput;
    _avg?: ThreadReportsAvgOrderByAggregateInput;
    _max?: ThreadReportsMaxOrderByAggregateInput;
    _min?: ThreadReportsMinOrderByAggregateInput;
    _sum?: ThreadReportsSumOrderByAggregateInput;
  };

  export type ThreadReportsScalarWhereWithAggregatesInput = {
    AND?:
      | ThreadReportsScalarWhereWithAggregatesInput
      | ThreadReportsScalarWhereWithAggregatesInput[];
    OR?: ThreadReportsScalarWhereWithAggregatesInput[];
    NOT?:
      | ThreadReportsScalarWhereWithAggregatesInput
      | ThreadReportsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'ThreadReports'> | string;
    threads_id?: UuidWithAggregatesFilter<'ThreadReports'> | string;
    reported_by?:
      | IntNullableWithAggregatesFilter<'ThreadReports'>
      | number
      | null;
    reason?:
      | StringNullableWithAggregatesFilter<'ThreadReports'>
      | string
      | null;
    created_at?: DateTimeWithAggregatesFilter<'ThreadReports'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'ThreadReports'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'ThreadReports'>
      | Date
      | string
      | null;
  };

  export type ThreadRepostsWhereInput = {
    AND?: ThreadRepostsWhereInput | ThreadRepostsWhereInput[];
    OR?: ThreadRepostsWhereInput[];
    NOT?: ThreadRepostsWhereInput | ThreadRepostsWhereInput[];
    id?: UuidFilter<'ThreadReposts'> | string;
    threads_id?: UuidFilter<'ThreadReposts'> | string;
    user_id?: IntFilter<'ThreadReposts'> | number;
    created_at?: DateTimeFilter<'ThreadReposts'> | Date | string;
    updated_at?: DateTimeFilter<'ThreadReposts'> | Date | string;
    deleted_at?: DateTimeNullableFilter<'ThreadReposts'> | Date | string | null;
  };

  export type ThreadRepostsOrderByWithRelationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    user_id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type ThreadRepostsWhereUniqueInput = Prisma.AtLeast<
    {
      id_created_at?: ThreadRepostsIdCreated_atCompoundUniqueInput;
      AND?: ThreadRepostsWhereInput | ThreadRepostsWhereInput[];
      OR?: ThreadRepostsWhereInput[];
      NOT?: ThreadRepostsWhereInput | ThreadRepostsWhereInput[];
      id?: UuidFilter<'ThreadReposts'> | string;
      threads_id?: UuidFilter<'ThreadReposts'> | string;
      user_id?: IntFilter<'ThreadReposts'> | number;
      created_at?: DateTimeFilter<'ThreadReposts'> | Date | string;
      updated_at?: DateTimeFilter<'ThreadReposts'> | Date | string;
      deleted_at?:
        | DateTimeNullableFilter<'ThreadReposts'>
        | Date
        | string
        | null;
    },
    'id_created_at'
  >;

  export type ThreadRepostsOrderByWithAggregationInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    user_id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: ThreadRepostsCountOrderByAggregateInput;
    _avg?: ThreadRepostsAvgOrderByAggregateInput;
    _max?: ThreadRepostsMaxOrderByAggregateInput;
    _min?: ThreadRepostsMinOrderByAggregateInput;
    _sum?: ThreadRepostsSumOrderByAggregateInput;
  };

  export type ThreadRepostsScalarWhereWithAggregatesInput = {
    AND?:
      | ThreadRepostsScalarWhereWithAggregatesInput
      | ThreadRepostsScalarWhereWithAggregatesInput[];
    OR?: ThreadRepostsScalarWhereWithAggregatesInput[];
    NOT?:
      | ThreadRepostsScalarWhereWithAggregatesInput
      | ThreadRepostsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'ThreadReposts'> | string;
    threads_id?: UuidWithAggregatesFilter<'ThreadReposts'> | string;
    user_id?: IntWithAggregatesFilter<'ThreadReposts'> | number;
    created_at?: DateTimeWithAggregatesFilter<'ThreadReposts'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'ThreadReposts'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'ThreadReposts'>
      | Date
      | string
      | null;
  };

  export type ThreadsWhereInput = {
    AND?: ThreadsWhereInput | ThreadsWhereInput[];
    OR?: ThreadsWhereInput[];
    NOT?: ThreadsWhereInput | ThreadsWhereInput[];
    id?: UuidFilter<'Threads'> | string;
    user_id?: IntFilter<'Threads'> | number;
    content?: StringNullableFilter<'Threads'> | string | null;
    visibility?:
      | Enumvisibility_enumNullableFilter<'Threads'>
      | $Enums.visibility_enum
      | null;
    start_thread_id?: UuidNullableFilter<'Threads'> | string | null;
    poll_id?: UuidNullableFilter<'Threads'> | string | null;
    parent_thread_id?: UuidNullableFilter<'Threads'> | string | null;
    quoted_thread_id?: UuidNullableFilter<'Threads'> | string | null;
    company_info_id?: UuidNullableFilter<'Threads'> | string | null;
    parent_level?: IntFilter<'Threads'> | number;
    created_at?: DateTimeFilter<'Threads'> | Date | string;
    updated_at?: DateTimeFilter<'Threads'> | Date | string;
    deleted_at?: DateTimeNullableFilter<'Threads'> | Date | string | null;
    news_id?: UuidNullableFilter<'Threads'> | string | null;
  };

  export type ThreadsOrderByWithRelationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    content?: SortOrderInput | SortOrder;
    visibility?: SortOrderInput | SortOrder;
    start_thread_id?: SortOrderInput | SortOrder;
    poll_id?: SortOrderInput | SortOrder;
    parent_thread_id?: SortOrderInput | SortOrder;
    quoted_thread_id?: SortOrderInput | SortOrder;
    company_info_id?: SortOrderInput | SortOrder;
    parent_level?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    news_id?: SortOrderInput | SortOrder;
  };

  export type ThreadsWhereUniqueInput = Prisma.AtLeast<
    {
      id_created_at?: ThreadsIdCreated_atCompoundUniqueInput;
      AND?: ThreadsWhereInput | ThreadsWhereInput[];
      OR?: ThreadsWhereInput[];
      NOT?: ThreadsWhereInput | ThreadsWhereInput[];
      id?: UuidFilter<'Threads'> | string;
      user_id?: IntFilter<'Threads'> | number;
      content?: StringNullableFilter<'Threads'> | string | null;
      visibility?:
        | Enumvisibility_enumNullableFilter<'Threads'>
        | $Enums.visibility_enum
        | null;
      start_thread_id?: UuidNullableFilter<'Threads'> | string | null;
      poll_id?: UuidNullableFilter<'Threads'> | string | null;
      parent_thread_id?: UuidNullableFilter<'Threads'> | string | null;
      quoted_thread_id?: UuidNullableFilter<'Threads'> | string | null;
      company_info_id?: UuidNullableFilter<'Threads'> | string | null;
      parent_level?: IntFilter<'Threads'> | number;
      created_at?: DateTimeFilter<'Threads'> | Date | string;
      updated_at?: DateTimeFilter<'Threads'> | Date | string;
      deleted_at?: DateTimeNullableFilter<'Threads'> | Date | string | null;
      news_id?: UuidNullableFilter<'Threads'> | string | null;
    },
    'id_created_at'
  >;

  export type ThreadsOrderByWithAggregationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    content?: SortOrderInput | SortOrder;
    visibility?: SortOrderInput | SortOrder;
    start_thread_id?: SortOrderInput | SortOrder;
    poll_id?: SortOrderInput | SortOrder;
    parent_thread_id?: SortOrderInput | SortOrder;
    quoted_thread_id?: SortOrderInput | SortOrder;
    company_info_id?: SortOrderInput | SortOrder;
    parent_level?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    news_id?: SortOrderInput | SortOrder;
    _count?: ThreadsCountOrderByAggregateInput;
    _avg?: ThreadsAvgOrderByAggregateInput;
    _max?: ThreadsMaxOrderByAggregateInput;
    _min?: ThreadsMinOrderByAggregateInput;
    _sum?: ThreadsSumOrderByAggregateInput;
  };

  export type ThreadsScalarWhereWithAggregatesInput = {
    AND?:
      | ThreadsScalarWhereWithAggregatesInput
      | ThreadsScalarWhereWithAggregatesInput[];
    OR?: ThreadsScalarWhereWithAggregatesInput[];
    NOT?:
      | ThreadsScalarWhereWithAggregatesInput
      | ThreadsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'Threads'> | string;
    user_id?: IntWithAggregatesFilter<'Threads'> | number;
    content?: StringNullableWithAggregatesFilter<'Threads'> | string | null;
    visibility?:
      | Enumvisibility_enumNullableWithAggregatesFilter<'Threads'>
      | $Enums.visibility_enum
      | null;
    start_thread_id?:
      | UuidNullableWithAggregatesFilter<'Threads'>
      | string
      | null;
    poll_id?: UuidNullableWithAggregatesFilter<'Threads'> | string | null;
    parent_thread_id?:
      | UuidNullableWithAggregatesFilter<'Threads'>
      | string
      | null;
    quoted_thread_id?:
      | UuidNullableWithAggregatesFilter<'Threads'>
      | string
      | null;
    company_info_id?:
      | UuidNullableWithAggregatesFilter<'Threads'>
      | string
      | null;
    parent_level?: IntWithAggregatesFilter<'Threads'> | number;
    created_at?: DateTimeWithAggregatesFilter<'Threads'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'Threads'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'Threads'>
      | Date
      | string
      | null;
    news_id?: UuidNullableWithAggregatesFilter<'Threads'> | string | null;
  };

  export type UserBlocksWhereInput = {
    AND?: UserBlocksWhereInput | UserBlocksWhereInput[];
    OR?: UserBlocksWhereInput[];
    NOT?: UserBlocksWhereInput | UserBlocksWhereInput[];
    id?: UuidFilter<'UserBlocks'> | string;
    blocker_user_id?: IntFilter<'UserBlocks'> | number;
    blocked_user_id?: IntFilter<'UserBlocks'> | number;
    reason?: StringNullableFilter<'UserBlocks'> | string | null;
    created_at?: DateTimeFilter<'UserBlocks'> | Date | string;
    updated_at?: DateTimeFilter<'UserBlocks'> | Date | string;
    deleted_at?: DateTimeNullableFilter<'UserBlocks'> | Date | string | null;
  };

  export type UserBlocksOrderByWithRelationInput = {
    id?: SortOrder;
    blocker_user_id?: SortOrder;
    blocked_user_id?: SortOrder;
    reason?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type UserBlocksWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: UserBlocksWhereInput | UserBlocksWhereInput[];
      OR?: UserBlocksWhereInput[];
      NOT?: UserBlocksWhereInput | UserBlocksWhereInput[];
      blocker_user_id?: IntFilter<'UserBlocks'> | number;
      blocked_user_id?: IntFilter<'UserBlocks'> | number;
      reason?: StringNullableFilter<'UserBlocks'> | string | null;
      created_at?: DateTimeFilter<'UserBlocks'> | Date | string;
      updated_at?: DateTimeFilter<'UserBlocks'> | Date | string;
      deleted_at?: DateTimeNullableFilter<'UserBlocks'> | Date | string | null;
    },
    'id'
  >;

  export type UserBlocksOrderByWithAggregationInput = {
    id?: SortOrder;
    blocker_user_id?: SortOrder;
    blocked_user_id?: SortOrder;
    reason?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: UserBlocksCountOrderByAggregateInput;
    _avg?: UserBlocksAvgOrderByAggregateInput;
    _max?: UserBlocksMaxOrderByAggregateInput;
    _min?: UserBlocksMinOrderByAggregateInput;
    _sum?: UserBlocksSumOrderByAggregateInput;
  };

  export type UserBlocksScalarWhereWithAggregatesInput = {
    AND?:
      | UserBlocksScalarWhereWithAggregatesInput
      | UserBlocksScalarWhereWithAggregatesInput[];
    OR?: UserBlocksScalarWhereWithAggregatesInput[];
    NOT?:
      | UserBlocksScalarWhereWithAggregatesInput
      | UserBlocksScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'UserBlocks'> | string;
    blocker_user_id?: IntWithAggregatesFilter<'UserBlocks'> | number;
    blocked_user_id?: IntWithAggregatesFilter<'UserBlocks'> | number;
    reason?: StringNullableWithAggregatesFilter<'UserBlocks'> | string | null;
    created_at?: DateTimeWithAggregatesFilter<'UserBlocks'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'UserBlocks'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'UserBlocks'>
      | Date
      | string
      | null;
  };

  export type UserInterestLogsWhereInput = {
    AND?: UserInterestLogsWhereInput | UserInterestLogsWhereInput[];
    OR?: UserInterestLogsWhereInput[];
    NOT?: UserInterestLogsWhereInput | UserInterestLogsWhereInput[];
    id?: UuidFilter<'UserInterestLogs'> | string;
    user_id?: IntFilter<'UserInterestLogs'> | number;
    symbol_id?: UuidFilter<'UserInterestLogs'> | string;
    activity_type?: StringFilter<'UserInterestLogs'> | string;
    weight?: FloatNullableFilter<'UserInterestLogs'> | number | null;
    created_at?: DateTimeFilter<'UserInterestLogs'> | Date | string;
    updated_at?: DateTimeFilter<'UserInterestLogs'> | Date | string;
    deleted_at?:
      | DateTimeNullableFilter<'UserInterestLogs'>
      | Date
      | string
      | null;
  };

  export type UserInterestLogsOrderByWithRelationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    symbol_id?: SortOrder;
    activity_type?: SortOrder;
    weight?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type UserInterestLogsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: UserInterestLogsWhereInput | UserInterestLogsWhereInput[];
      OR?: UserInterestLogsWhereInput[];
      NOT?: UserInterestLogsWhereInput | UserInterestLogsWhereInput[];
      user_id?: IntFilter<'UserInterestLogs'> | number;
      symbol_id?: UuidFilter<'UserInterestLogs'> | string;
      activity_type?: StringFilter<'UserInterestLogs'> | string;
      weight?: FloatNullableFilter<'UserInterestLogs'> | number | null;
      created_at?: DateTimeFilter<'UserInterestLogs'> | Date | string;
      updated_at?: DateTimeFilter<'UserInterestLogs'> | Date | string;
      deleted_at?:
        | DateTimeNullableFilter<'UserInterestLogs'>
        | Date
        | string
        | null;
    },
    'id'
  >;

  export type UserInterestLogsOrderByWithAggregationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    symbol_id?: SortOrder;
    activity_type?: SortOrder;
    weight?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: UserInterestLogsCountOrderByAggregateInput;
    _avg?: UserInterestLogsAvgOrderByAggregateInput;
    _max?: UserInterestLogsMaxOrderByAggregateInput;
    _min?: UserInterestLogsMinOrderByAggregateInput;
    _sum?: UserInterestLogsSumOrderByAggregateInput;
  };

  export type UserInterestLogsScalarWhereWithAggregatesInput = {
    AND?:
      | UserInterestLogsScalarWhereWithAggregatesInput
      | UserInterestLogsScalarWhereWithAggregatesInput[];
    OR?: UserInterestLogsScalarWhereWithAggregatesInput[];
    NOT?:
      | UserInterestLogsScalarWhereWithAggregatesInput
      | UserInterestLogsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'UserInterestLogs'> | string;
    user_id?: IntWithAggregatesFilter<'UserInterestLogs'> | number;
    symbol_id?: UuidWithAggregatesFilter<'UserInterestLogs'> | string;
    activity_type?: StringWithAggregatesFilter<'UserInterestLogs'> | string;
    weight?:
      | FloatNullableWithAggregatesFilter<'UserInterestLogs'>
      | number
      | null;
    created_at?:
      | DateTimeWithAggregatesFilter<'UserInterestLogs'>
      | Date
      | string;
    updated_at?:
      | DateTimeWithAggregatesFilter<'UserInterestLogs'>
      | Date
      | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'UserInterestLogs'>
      | Date
      | string
      | null;
  };

  export type UserInterestsWhereInput = {
    AND?: UserInterestsWhereInput | UserInterestsWhereInput[];
    OR?: UserInterestsWhereInput[];
    NOT?: UserInterestsWhereInput | UserInterestsWhereInput[];
    id?: UuidFilter<'UserInterests'> | string;
    user_id?: IntFilter<'UserInterests'> | number;
    symbol_id?: UuidFilter<'UserInterests'> | string;
    weight?: FloatNullableFilter<'UserInterests'> | number | null;
    created_at?: DateTimeFilter<'UserInterests'> | Date | string;
    updated_at?: DateTimeFilter<'UserInterests'> | Date | string;
    deleted_at?: DateTimeNullableFilter<'UserInterests'> | Date | string | null;
  };

  export type UserInterestsOrderByWithRelationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    symbol_id?: SortOrder;
    weight?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type UserInterestsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      user_id_symbol_id?: UserInterestsUser_idSymbol_idCompoundUniqueInput;
      AND?: UserInterestsWhereInput | UserInterestsWhereInput[];
      OR?: UserInterestsWhereInput[];
      NOT?: UserInterestsWhereInput | UserInterestsWhereInput[];
      user_id?: IntFilter<'UserInterests'> | number;
      symbol_id?: UuidFilter<'UserInterests'> | string;
      weight?: FloatNullableFilter<'UserInterests'> | number | null;
      created_at?: DateTimeFilter<'UserInterests'> | Date | string;
      updated_at?: DateTimeFilter<'UserInterests'> | Date | string;
      deleted_at?:
        | DateTimeNullableFilter<'UserInterests'>
        | Date
        | string
        | null;
    },
    'id' | 'user_id_symbol_id'
  >;

  export type UserInterestsOrderByWithAggregationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    symbol_id?: SortOrder;
    weight?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: UserInterestsCountOrderByAggregateInput;
    _avg?: UserInterestsAvgOrderByAggregateInput;
    _max?: UserInterestsMaxOrderByAggregateInput;
    _min?: UserInterestsMinOrderByAggregateInput;
    _sum?: UserInterestsSumOrderByAggregateInput;
  };

  export type UserInterestsScalarWhereWithAggregatesInput = {
    AND?:
      | UserInterestsScalarWhereWithAggregatesInput
      | UserInterestsScalarWhereWithAggregatesInput[];
    OR?: UserInterestsScalarWhereWithAggregatesInput[];
    NOT?:
      | UserInterestsScalarWhereWithAggregatesInput
      | UserInterestsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'UserInterests'> | string;
    user_id?: IntWithAggregatesFilter<'UserInterests'> | number;
    symbol_id?: UuidWithAggregatesFilter<'UserInterests'> | string;
    weight?: FloatNullableWithAggregatesFilter<'UserInterests'> | number | null;
    created_at?: DateTimeWithAggregatesFilter<'UserInterests'> | Date | string;
    updated_at?: DateTimeWithAggregatesFilter<'UserInterests'> | Date | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'UserInterests'>
      | Date
      | string
      | null;
  };

  export type UserNotificationSettingsWhereInput = {
    AND?:
      | UserNotificationSettingsWhereInput
      | UserNotificationSettingsWhereInput[];
    OR?: UserNotificationSettingsWhereInput[];
    NOT?:
      | UserNotificationSettingsWhereInput
      | UserNotificationSettingsWhereInput[];
    id?: UuidFilter<'UserNotificationSettings'> | string;
    user_id?: IntFilter<'UserNotificationSettings'> | number;
    push_enabled?: BoolFilter<'UserNotificationSettings'> | boolean;
    email_enabled?: BoolFilter<'UserNotificationSettings'> | boolean;
    notify_followed_threads?: BoolFilter<'UserNotificationSettings'> | boolean;
    notify_followed_replies?: BoolFilter<'UserNotificationSettings'> | boolean;
    notify_mentions?: BoolFilter<'UserNotificationSettings'> | boolean;
    notify_when_followed?: BoolFilter<'UserNotificationSettings'> | boolean;
    notify_reposts?: BoolFilter<'UserNotificationSettings'> | boolean;
    notify_likes?: BoolFilter<'UserNotificationSettings'> | boolean;
    created_at?: DateTimeFilter<'UserNotificationSettings'> | Date | string;
    updated_at?: DateTimeFilter<'UserNotificationSettings'> | Date | string;
    deleted_at?:
      | DateTimeNullableFilter<'UserNotificationSettings'>
      | Date
      | string
      | null;
  };

  export type UserNotificationSettingsOrderByWithRelationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    push_enabled?: SortOrder;
    email_enabled?: SortOrder;
    notify_followed_threads?: SortOrder;
    notify_followed_replies?: SortOrder;
    notify_mentions?: SortOrder;
    notify_when_followed?: SortOrder;
    notify_reposts?: SortOrder;
    notify_likes?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
  };

  export type UserNotificationSettingsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?:
        | UserNotificationSettingsWhereInput
        | UserNotificationSettingsWhereInput[];
      OR?: UserNotificationSettingsWhereInput[];
      NOT?:
        | UserNotificationSettingsWhereInput
        | UserNotificationSettingsWhereInput[];
      user_id?: IntFilter<'UserNotificationSettings'> | number;
      push_enabled?: BoolFilter<'UserNotificationSettings'> | boolean;
      email_enabled?: BoolFilter<'UserNotificationSettings'> | boolean;
      notify_followed_threads?:
        | BoolFilter<'UserNotificationSettings'>
        | boolean;
      notify_followed_replies?:
        | BoolFilter<'UserNotificationSettings'>
        | boolean;
      notify_mentions?: BoolFilter<'UserNotificationSettings'> | boolean;
      notify_when_followed?: BoolFilter<'UserNotificationSettings'> | boolean;
      notify_reposts?: BoolFilter<'UserNotificationSettings'> | boolean;
      notify_likes?: BoolFilter<'UserNotificationSettings'> | boolean;
      created_at?: DateTimeFilter<'UserNotificationSettings'> | Date | string;
      updated_at?: DateTimeFilter<'UserNotificationSettings'> | Date | string;
      deleted_at?:
        | DateTimeNullableFilter<'UserNotificationSettings'>
        | Date
        | string
        | null;
    },
    'id'
  >;

  export type UserNotificationSettingsOrderByWithAggregationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    push_enabled?: SortOrder;
    email_enabled?: SortOrder;
    notify_followed_threads?: SortOrder;
    notify_followed_replies?: SortOrder;
    notify_mentions?: SortOrder;
    notify_when_followed?: SortOrder;
    notify_reposts?: SortOrder;
    notify_likes?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrderInput | SortOrder;
    _count?: UserNotificationSettingsCountOrderByAggregateInput;
    _avg?: UserNotificationSettingsAvgOrderByAggregateInput;
    _max?: UserNotificationSettingsMaxOrderByAggregateInput;
    _min?: UserNotificationSettingsMinOrderByAggregateInput;
    _sum?: UserNotificationSettingsSumOrderByAggregateInput;
  };

  export type UserNotificationSettingsScalarWhereWithAggregatesInput = {
    AND?:
      | UserNotificationSettingsScalarWhereWithAggregatesInput
      | UserNotificationSettingsScalarWhereWithAggregatesInput[];
    OR?: UserNotificationSettingsScalarWhereWithAggregatesInput[];
    NOT?:
      | UserNotificationSettingsScalarWhereWithAggregatesInput
      | UserNotificationSettingsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'UserNotificationSettings'> | string;
    user_id?: IntWithAggregatesFilter<'UserNotificationSettings'> | number;
    push_enabled?:
      | BoolWithAggregatesFilter<'UserNotificationSettings'>
      | boolean;
    email_enabled?:
      | BoolWithAggregatesFilter<'UserNotificationSettings'>
      | boolean;
    notify_followed_threads?:
      | BoolWithAggregatesFilter<'UserNotificationSettings'>
      | boolean;
    notify_followed_replies?:
      | BoolWithAggregatesFilter<'UserNotificationSettings'>
      | boolean;
    notify_mentions?:
      | BoolWithAggregatesFilter<'UserNotificationSettings'>
      | boolean;
    notify_when_followed?:
      | BoolWithAggregatesFilter<'UserNotificationSettings'>
      | boolean;
    notify_reposts?:
      | BoolWithAggregatesFilter<'UserNotificationSettings'>
      | boolean;
    notify_likes?:
      | BoolWithAggregatesFilter<'UserNotificationSettings'>
      | boolean;
    created_at?:
      | DateTimeWithAggregatesFilter<'UserNotificationSettings'>
      | Date
      | string;
    updated_at?:
      | DateTimeWithAggregatesFilter<'UserNotificationSettings'>
      | Date
      | string;
    deleted_at?:
      | DateTimeNullableWithAggregatesFilter<'UserNotificationSettings'>
      | Date
      | string
      | null;
  };

  export type CompaniesInfoCreateInput = {
    id?: string;
    threads_id: string;
    symbol: string;
    name: string;
    market_state: string;
    regular_market_price: number;
    regular_market_change: number;
    regular_market_change_percent: number;
    sector: string;
    industry: string;
    date_at_shares: Date | string;
    assets_type: $Enums.assets_type_enum;
    exchange_name?: string | null;
    pre_market_price?: number | null;
    pre_market_change?: number | null;
    pre_market_change_percent?: number | null;
    post_market_price?: number | null;
    post_market_change?: number | null;
    post_market_change_percent?: number | null;
    overnight_market_price?: number | null;
    overnight_market_change?: number | null;
    overnight_market_change_percent?: number | null;
    market_cap?: bigint | number | null;
    regular_market_time: bigint | number;
    pre_market_time?: bigint | number | null;
    post_market_time?: bigint | number | null;
    overnight_market_time?: bigint | number | null;
    currency: string;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type CompaniesInfoUncheckedCreateInput = {
    id?: string;
    threads_id: string;
    symbol: string;
    name: string;
    market_state: string;
    regular_market_price: number;
    regular_market_change: number;
    regular_market_change_percent: number;
    sector: string;
    industry: string;
    date_at_shares: Date | string;
    assets_type: $Enums.assets_type_enum;
    exchange_name?: string | null;
    pre_market_price?: number | null;
    pre_market_change?: number | null;
    pre_market_change_percent?: number | null;
    post_market_price?: number | null;
    post_market_change?: number | null;
    post_market_change_percent?: number | null;
    overnight_market_price?: number | null;
    overnight_market_change?: number | null;
    overnight_market_change_percent?: number | null;
    market_cap?: bigint | number | null;
    regular_market_time: bigint | number;
    pre_market_time?: bigint | number | null;
    post_market_time?: bigint | number | null;
    overnight_market_time?: bigint | number | null;
    currency: string;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type CompaniesInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    market_state?: StringFieldUpdateOperationsInput | string;
    regular_market_price?: FloatFieldUpdateOperationsInput | number;
    regular_market_change?: FloatFieldUpdateOperationsInput | number;
    regular_market_change_percent?: FloatFieldUpdateOperationsInput | number;
    sector?: StringFieldUpdateOperationsInput | string;
    industry?: StringFieldUpdateOperationsInput | string;
    date_at_shares?: DateTimeFieldUpdateOperationsInput | Date | string;
    assets_type?:
      | Enumassets_type_enumFieldUpdateOperationsInput
      | $Enums.assets_type_enum;
    exchange_name?: NullableStringFieldUpdateOperationsInput | string | null;
    pre_market_price?: NullableFloatFieldUpdateOperationsInput | number | null;
    pre_market_change?: NullableFloatFieldUpdateOperationsInput | number | null;
    pre_market_change_percent?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    post_market_price?: NullableFloatFieldUpdateOperationsInput | number | null;
    post_market_change?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    post_market_change_percent?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    overnight_market_price?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    overnight_market_change?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    overnight_market_change_percent?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    market_cap?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    regular_market_time?: BigIntFieldUpdateOperationsInput | bigint | number;
    pre_market_time?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    post_market_time?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    overnight_market_time?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type CompaniesInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    market_state?: StringFieldUpdateOperationsInput | string;
    regular_market_price?: FloatFieldUpdateOperationsInput | number;
    regular_market_change?: FloatFieldUpdateOperationsInput | number;
    regular_market_change_percent?: FloatFieldUpdateOperationsInput | number;
    sector?: StringFieldUpdateOperationsInput | string;
    industry?: StringFieldUpdateOperationsInput | string;
    date_at_shares?: DateTimeFieldUpdateOperationsInput | Date | string;
    assets_type?:
      | Enumassets_type_enumFieldUpdateOperationsInput
      | $Enums.assets_type_enum;
    exchange_name?: NullableStringFieldUpdateOperationsInput | string | null;
    pre_market_price?: NullableFloatFieldUpdateOperationsInput | number | null;
    pre_market_change?: NullableFloatFieldUpdateOperationsInput | number | null;
    pre_market_change_percent?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    post_market_price?: NullableFloatFieldUpdateOperationsInput | number | null;
    post_market_change?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    post_market_change_percent?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    overnight_market_price?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    overnight_market_change?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    overnight_market_change_percent?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    market_cap?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    regular_market_time?: BigIntFieldUpdateOperationsInput | bigint | number;
    pre_market_time?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    post_market_time?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    overnight_market_time?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type CompaniesInfoCreateManyInput = {
    id?: string;
    threads_id: string;
    symbol: string;
    name: string;
    market_state: string;
    regular_market_price: number;
    regular_market_change: number;
    regular_market_change_percent: number;
    sector: string;
    industry: string;
    date_at_shares: Date | string;
    assets_type: $Enums.assets_type_enum;
    exchange_name?: string | null;
    pre_market_price?: number | null;
    pre_market_change?: number | null;
    pre_market_change_percent?: number | null;
    post_market_price?: number | null;
    post_market_change?: number | null;
    post_market_change_percent?: number | null;
    overnight_market_price?: number | null;
    overnight_market_change?: number | null;
    overnight_market_change_percent?: number | null;
    market_cap?: bigint | number | null;
    regular_market_time: bigint | number;
    pre_market_time?: bigint | number | null;
    post_market_time?: bigint | number | null;
    overnight_market_time?: bigint | number | null;
    currency: string;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type CompaniesInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    market_state?: StringFieldUpdateOperationsInput | string;
    regular_market_price?: FloatFieldUpdateOperationsInput | number;
    regular_market_change?: FloatFieldUpdateOperationsInput | number;
    regular_market_change_percent?: FloatFieldUpdateOperationsInput | number;
    sector?: StringFieldUpdateOperationsInput | string;
    industry?: StringFieldUpdateOperationsInput | string;
    date_at_shares?: DateTimeFieldUpdateOperationsInput | Date | string;
    assets_type?:
      | Enumassets_type_enumFieldUpdateOperationsInput
      | $Enums.assets_type_enum;
    exchange_name?: NullableStringFieldUpdateOperationsInput | string | null;
    pre_market_price?: NullableFloatFieldUpdateOperationsInput | number | null;
    pre_market_change?: NullableFloatFieldUpdateOperationsInput | number | null;
    pre_market_change_percent?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    post_market_price?: NullableFloatFieldUpdateOperationsInput | number | null;
    post_market_change?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    post_market_change_percent?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    overnight_market_price?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    overnight_market_change?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    overnight_market_change_percent?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    market_cap?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    regular_market_time?: BigIntFieldUpdateOperationsInput | bigint | number;
    pre_market_time?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    post_market_time?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    overnight_market_time?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type CompaniesInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    market_state?: StringFieldUpdateOperationsInput | string;
    regular_market_price?: FloatFieldUpdateOperationsInput | number;
    regular_market_change?: FloatFieldUpdateOperationsInput | number;
    regular_market_change_percent?: FloatFieldUpdateOperationsInput | number;
    sector?: StringFieldUpdateOperationsInput | string;
    industry?: StringFieldUpdateOperationsInput | string;
    date_at_shares?: DateTimeFieldUpdateOperationsInput | Date | string;
    assets_type?:
      | Enumassets_type_enumFieldUpdateOperationsInput
      | $Enums.assets_type_enum;
    exchange_name?: NullableStringFieldUpdateOperationsInput | string | null;
    pre_market_price?: NullableFloatFieldUpdateOperationsInput | number | null;
    pre_market_change?: NullableFloatFieldUpdateOperationsInput | number | null;
    pre_market_change_percent?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    post_market_price?: NullableFloatFieldUpdateOperationsInput | number | null;
    post_market_change?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    post_market_change_percent?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    overnight_market_price?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    overnight_market_change?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    overnight_market_change_percent?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    market_cap?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    regular_market_time?: BigIntFieldUpdateOperationsInput | bigint | number;
    pre_market_time?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    post_market_time?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    overnight_market_time?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null;
    currency?: StringFieldUpdateOperationsInput | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowNotificationOverridesCreateInput = {
    id?: string;
    follower_id: number;
    following_id: number;
    mute_all?: boolean;
    notify_threads?: boolean;
    notify_replies?: boolean;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type FollowNotificationOverridesUncheckedCreateInput = {
    id?: string;
    follower_id: number;
    following_id: number;
    mute_all?: boolean;
    notify_threads?: boolean;
    notify_replies?: boolean;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type FollowNotificationOverridesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    follower_id?: IntFieldUpdateOperationsInput | number;
    following_id?: IntFieldUpdateOperationsInput | number;
    mute_all?: BoolFieldUpdateOperationsInput | boolean;
    notify_threads?: BoolFieldUpdateOperationsInput | boolean;
    notify_replies?: BoolFieldUpdateOperationsInput | boolean;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowNotificationOverridesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    follower_id?: IntFieldUpdateOperationsInput | number;
    following_id?: IntFieldUpdateOperationsInput | number;
    mute_all?: BoolFieldUpdateOperationsInput | boolean;
    notify_threads?: BoolFieldUpdateOperationsInput | boolean;
    notify_replies?: BoolFieldUpdateOperationsInput | boolean;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowNotificationOverridesCreateManyInput = {
    id?: string;
    follower_id: number;
    following_id: number;
    mute_all?: boolean;
    notify_threads?: boolean;
    notify_replies?: boolean;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type FollowNotificationOverridesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    follower_id?: IntFieldUpdateOperationsInput | number;
    following_id?: IntFieldUpdateOperationsInput | number;
    mute_all?: BoolFieldUpdateOperationsInput | boolean;
    notify_threads?: BoolFieldUpdateOperationsInput | boolean;
    notify_replies?: BoolFieldUpdateOperationsInput | boolean;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowNotificationOverridesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    follower_id?: IntFieldUpdateOperationsInput | number;
    following_id?: IntFieldUpdateOperationsInput | number;
    mute_all?: BoolFieldUpdateOperationsInput | boolean;
    notify_threads?: BoolFieldUpdateOperationsInput | boolean;
    notify_replies?: BoolFieldUpdateOperationsInput | boolean;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowRequestsCreateInput = {
    id?: string;
    requester_id: number;
    target_id: number;
    status?: string;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type FollowRequestsUncheckedCreateInput = {
    id?: string;
    requester_id: number;
    target_id: number;
    status?: string;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type FollowRequestsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requester_id?: IntFieldUpdateOperationsInput | number;
    target_id?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowRequestsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requester_id?: IntFieldUpdateOperationsInput | number;
    target_id?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowRequestsCreateManyInput = {
    id?: string;
    requester_id: number;
    target_id: number;
    status?: string;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type FollowRequestsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requester_id?: IntFieldUpdateOperationsInput | number;
    target_id?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowRequestsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requester_id?: IntFieldUpdateOperationsInput | number;
    target_id?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowsCreateInput = {
    id?: string;
    follower_id: number;
    following_id: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type FollowsUncheckedCreateInput = {
    id?: string;
    follower_id: number;
    following_id: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type FollowsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    follower_id?: IntFieldUpdateOperationsInput | number;
    following_id?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    follower_id?: IntFieldUpdateOperationsInput | number;
    following_id?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowsCreateManyInput = {
    id?: string;
    follower_id: number;
    following_id: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type FollowsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    follower_id?: IntFieldUpdateOperationsInput | number;
    following_id?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    follower_id?: IntFieldUpdateOperationsInput | number;
    following_id?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowsCountCreateInput = {
    id?: string;
    user_id: number;
    followers_count?: number;
    following_count?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type FollowsCountUncheckedCreateInput = {
    id?: string;
    user_id: number;
    followers_count?: number;
    following_count?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type FollowsCountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    followers_count?: IntFieldUpdateOperationsInput | number;
    following_count?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowsCountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    followers_count?: IntFieldUpdateOperationsInput | number;
    following_count?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowsCountCreateManyInput = {
    id?: string;
    user_id: number;
    followers_count?: number;
    following_count?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type FollowsCountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    followers_count?: IntFieldUpdateOperationsInput | number;
    following_count?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type FollowsCountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    followers_count?: IntFieldUpdateOperationsInput | number;
    following_count?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type NotificationsCreateInput = {
    id?: string;
    user_id?: number | null;
    sender_id?: number | null;
    message_th?: string | null;
    message_en?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    is_read?: boolean | null;
    type?: $Enums.notification_type_enum | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type NotificationsUncheckedCreateInput = {
    id?: string;
    user_id?: number | null;
    sender_id?: number | null;
    message_th?: string | null;
    message_en?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    is_read?: boolean | null;
    type?: $Enums.notification_type_enum | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type NotificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: NullableIntFieldUpdateOperationsInput | number | null;
    sender_id?: NullableIntFieldUpdateOperationsInput | number | null;
    message_th?: NullableStringFieldUpdateOperationsInput | string | null;
    message_en?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    type?:
      | NullableEnumnotification_type_enumFieldUpdateOperationsInput
      | $Enums.notification_type_enum
      | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type NotificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: NullableIntFieldUpdateOperationsInput | number | null;
    sender_id?: NullableIntFieldUpdateOperationsInput | number | null;
    message_th?: NullableStringFieldUpdateOperationsInput | string | null;
    message_en?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    type?:
      | NullableEnumnotification_type_enumFieldUpdateOperationsInput
      | $Enums.notification_type_enum
      | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type NotificationsCreateManyInput = {
    id?: string;
    user_id?: number | null;
    sender_id?: number | null;
    message_th?: string | null;
    message_en?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    is_read?: boolean | null;
    type?: $Enums.notification_type_enum | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type NotificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: NullableIntFieldUpdateOperationsInput | number | null;
    sender_id?: NullableIntFieldUpdateOperationsInput | number | null;
    message_th?: NullableStringFieldUpdateOperationsInput | string | null;
    message_en?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    type?:
      | NullableEnumnotification_type_enumFieldUpdateOperationsInput
      | $Enums.notification_type_enum
      | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type NotificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: NullableIntFieldUpdateOperationsInput | number | null;
    sender_id?: NullableIntFieldUpdateOperationsInput | number | null;
    message_th?: NullableStringFieldUpdateOperationsInput | string | null;
    message_en?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    type?:
      | NullableEnumnotification_type_enumFieldUpdateOperationsInput
      | $Enums.notification_type_enum
      | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type SymbolsCreateInput = {
    id?: string;
    symbol_code: string;
    name?: string | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type SymbolsUncheckedCreateInput = {
    id?: string;
    symbol_code: string;
    name?: string | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type SymbolsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol_code?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type SymbolsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol_code?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type SymbolsCreateManyInput = {
    id?: string;
    symbol_code: string;
    name?: string | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type SymbolsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol_code?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type SymbolsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol_code?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadEngagementMetricsCreateInput = {
    id?: string;
    threads_id: string;
    viewed_count?: Decimal | DecimalJsLike | number | string;
    replied_count?: number;
    reposted_count?: number;
    quoted_count?: number;
    liked_count?: number;
    reported_count?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadEngagementMetricsUncheckedCreateInput = {
    id?: string;
    threads_id: string;
    viewed_count?: Decimal | DecimalJsLike | number | string;
    replied_count?: number;
    reposted_count?: number;
    quoted_count?: number;
    liked_count?: number;
    reported_count?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadEngagementMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    viewed_count?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    replied_count?: IntFieldUpdateOperationsInput | number;
    reposted_count?: IntFieldUpdateOperationsInput | number;
    quoted_count?: IntFieldUpdateOperationsInput | number;
    liked_count?: IntFieldUpdateOperationsInput | number;
    reported_count?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadEngagementMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    viewed_count?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    replied_count?: IntFieldUpdateOperationsInput | number;
    reposted_count?: IntFieldUpdateOperationsInput | number;
    quoted_count?: IntFieldUpdateOperationsInput | number;
    liked_count?: IntFieldUpdateOperationsInput | number;
    reported_count?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadEngagementMetricsCreateManyInput = {
    id?: string;
    threads_id: string;
    viewed_count?: Decimal | DecimalJsLike | number | string;
    replied_count?: number;
    reposted_count?: number;
    quoted_count?: number;
    liked_count?: number;
    reported_count?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadEngagementMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    viewed_count?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    replied_count?: IntFieldUpdateOperationsInput | number;
    reposted_count?: IntFieldUpdateOperationsInput | number;
    quoted_count?: IntFieldUpdateOperationsInput | number;
    liked_count?: IntFieldUpdateOperationsInput | number;
    reported_count?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadEngagementMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    viewed_count?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    replied_count?: IntFieldUpdateOperationsInput | number;
    reposted_count?: IntFieldUpdateOperationsInput | number;
    quoted_count?: IntFieldUpdateOperationsInput | number;
    liked_count?: IntFieldUpdateOperationsInput | number;
    reported_count?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadHashtagsCreateInput = {
    id?: string;
    threads_id: string;
    tag: string;
    type?: $Enums.tag_type_enum;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadHashtagsUncheckedCreateInput = {
    id?: string;
    threads_id: string;
    tag: string;
    type?: $Enums.tag_type_enum;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadHashtagsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    type?: Enumtag_type_enumFieldUpdateOperationsInput | $Enums.tag_type_enum;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadHashtagsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    type?: Enumtag_type_enumFieldUpdateOperationsInput | $Enums.tag_type_enum;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadHashtagsCreateManyInput = {
    id?: string;
    threads_id: string;
    tag: string;
    type?: $Enums.tag_type_enum;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadHashtagsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    type?: Enumtag_type_enumFieldUpdateOperationsInput | $Enums.tag_type_enum;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadHashtagsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    type?: Enumtag_type_enumFieldUpdateOperationsInput | $Enums.tag_type_enum;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadLikesCreateInput = {
    id?: string;
    threads_id: string;
    user_id: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadLikesUncheckedCreateInput = {
    id?: string;
    threads_id: string;
    user_id: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadLikesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadLikesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadLikesCreateManyInput = {
    id?: string;
    threads_id: string;
    user_id: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadLikesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadLikesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadMediaCreateInput = {
    id?: string;
    threads_id: string;
    media_type?: $Enums.media_type_enum | null;
    media_url?: string | null;
    thumbnail_url?: string | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
    width?: number | null;
    height?: number | null;
    size?: number | null;
    duration?: number | null;
    object_key?: string | null;
  };

  export type ThreadMediaUncheckedCreateInput = {
    id?: string;
    threads_id: string;
    media_type?: $Enums.media_type_enum | null;
    media_url?: string | null;
    thumbnail_url?: string | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
    width?: number | null;
    height?: number | null;
    size?: number | null;
    duration?: number | null;
    object_key?: string | null;
  };

  export type ThreadMediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    media_type?:
      | NullableEnummedia_type_enumFieldUpdateOperationsInput
      | $Enums.media_type_enum
      | null;
    media_url?: NullableStringFieldUpdateOperationsInput | string | null;
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    width?: NullableIntFieldUpdateOperationsInput | number | null;
    height?: NullableIntFieldUpdateOperationsInput | number | null;
    size?: NullableIntFieldUpdateOperationsInput | number | null;
    duration?: NullableIntFieldUpdateOperationsInput | number | null;
    object_key?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ThreadMediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    media_type?:
      | NullableEnummedia_type_enumFieldUpdateOperationsInput
      | $Enums.media_type_enum
      | null;
    media_url?: NullableStringFieldUpdateOperationsInput | string | null;
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    width?: NullableIntFieldUpdateOperationsInput | number | null;
    height?: NullableIntFieldUpdateOperationsInput | number | null;
    size?: NullableIntFieldUpdateOperationsInput | number | null;
    duration?: NullableIntFieldUpdateOperationsInput | number | null;
    object_key?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ThreadMediaCreateManyInput = {
    id?: string;
    threads_id: string;
    media_type?: $Enums.media_type_enum | null;
    media_url?: string | null;
    thumbnail_url?: string | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
    width?: number | null;
    height?: number | null;
    size?: number | null;
    duration?: number | null;
    object_key?: string | null;
  };

  export type ThreadMediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    media_type?:
      | NullableEnummedia_type_enumFieldUpdateOperationsInput
      | $Enums.media_type_enum
      | null;
    media_url?: NullableStringFieldUpdateOperationsInput | string | null;
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    width?: NullableIntFieldUpdateOperationsInput | number | null;
    height?: NullableIntFieldUpdateOperationsInput | number | null;
    size?: NullableIntFieldUpdateOperationsInput | number | null;
    duration?: NullableIntFieldUpdateOperationsInput | number | null;
    object_key?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ThreadMediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    media_type?:
      | NullableEnummedia_type_enumFieldUpdateOperationsInput
      | $Enums.media_type_enum
      | null;
    media_url?: NullableStringFieldUpdateOperationsInput | string | null;
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    width?: NullableIntFieldUpdateOperationsInput | number | null;
    height?: NullableIntFieldUpdateOperationsInput | number | null;
    size?: NullableIntFieldUpdateOperationsInput | number | null;
    duration?: NullableIntFieldUpdateOperationsInput | number | null;
    object_key?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ThreadMentionsCreateInput = {
    id?: string;
    threads_id: string;
    mentioned_user_id: number;
    position?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadMentionsUncheckedCreateInput = {
    id?: string;
    threads_id: string;
    mentioned_user_id: number;
    position?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadMentionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    mentioned_user_id?: IntFieldUpdateOperationsInput | number;
    position?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadMentionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    mentioned_user_id?: IntFieldUpdateOperationsInput | number;
    position?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadMentionsCreateManyInput = {
    id?: string;
    threads_id: string;
    mentioned_user_id: number;
    position?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadMentionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    mentioned_user_id?: IntFieldUpdateOperationsInput | number;
    position?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadMentionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    mentioned_user_id?: IntFieldUpdateOperationsInput | number;
    position?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPinsCreateInput = {
    id?: string;
    user_id: number;
    threads_id: string;
    pinned_at?: Date | string;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadPinsUncheckedCreateInput = {
    id?: string;
    user_id: number;
    threads_id: string;
    pinned_at?: Date | string;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadPinsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    threads_id?: StringFieldUpdateOperationsInput | string;
    pinned_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPinsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    threads_id?: StringFieldUpdateOperationsInput | string;
    pinned_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPinsCreateManyInput = {
    id?: string;
    user_id: number;
    threads_id: string;
    pinned_at?: Date | string;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadPinsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    threads_id?: StringFieldUpdateOperationsInput | string;
    pinned_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPinsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    threads_id?: StringFieldUpdateOperationsInput | string;
    pinned_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPollOptionsCreateInput = {
    id?: string;
    poll_id: string;
    option_text: string;
    voted_count?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadPollOptionsUncheckedCreateInput = {
    id?: string;
    poll_id: string;
    option_text: string;
    voted_count?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadPollOptionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    poll_id?: StringFieldUpdateOperationsInput | string;
    option_text?: StringFieldUpdateOperationsInput | string;
    voted_count?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPollOptionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    poll_id?: StringFieldUpdateOperationsInput | string;
    option_text?: StringFieldUpdateOperationsInput | string;
    voted_count?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPollOptionsCreateManyInput = {
    id?: string;
    poll_id: string;
    option_text: string;
    voted_count?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadPollOptionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    poll_id?: StringFieldUpdateOperationsInput | string;
    option_text?: StringFieldUpdateOperationsInput | string;
    voted_count?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPollOptionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    poll_id?: StringFieldUpdateOperationsInput | string;
    option_text?: StringFieldUpdateOperationsInput | string;
    voted_count?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPollVotesCreateInput = {
    id?: string;
    option_id: string;
    user_id: number;
    voted_at?: Date | string;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadPollVotesUncheckedCreateInput = {
    id?: string;
    option_id: string;
    user_id: number;
    voted_at?: Date | string;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadPollVotesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    option_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    voted_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPollVotesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    option_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    voted_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPollVotesCreateManyInput = {
    id?: string;
    option_id: string;
    user_id: number;
    voted_at?: Date | string;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadPollVotesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    option_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    voted_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPollVotesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    option_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    voted_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPollsCreateInput = {
    id?: string;
    threads_id: string;
    question: string;
    total_voted?: number;
    expires_at?: Date | string;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadPollsUncheckedCreateInput = {
    id?: string;
    threads_id: string;
    question: string;
    total_voted?: number;
    expires_at?: Date | string;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadPollsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    question?: StringFieldUpdateOperationsInput | string;
    total_voted?: IntFieldUpdateOperationsInput | number;
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPollsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    question?: StringFieldUpdateOperationsInput | string;
    total_voted?: IntFieldUpdateOperationsInput | number;
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPollsCreateManyInput = {
    id?: string;
    threads_id: string;
    question: string;
    total_voted?: number;
    expires_at?: Date | string;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadPollsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    question?: StringFieldUpdateOperationsInput | string;
    total_voted?: IntFieldUpdateOperationsInput | number;
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadPollsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    question?: StringFieldUpdateOperationsInput | string;
    total_voted?: IntFieldUpdateOperationsInput | number;
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadReportReasonsCreateInput = {
    id?: string;
    code: string;
    level: number;
    is_leaf?: boolean;
    translations?: JsonNullValueInput | InputJsonValue;
    is_active?: boolean;
    sort_order?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
    ThreadReportReasons?: ThreadReportReasonsCreateNestedOneWithoutOther_ThreadReportReasonsInput;
    other_ThreadReportReasons?: ThreadReportReasonsCreateNestedManyWithoutThreadReportReasonsInput;
  };

  export type ThreadReportReasonsUncheckedCreateInput = {
    id?: string;
    parent_id?: string | null;
    code: string;
    level: number;
    is_leaf?: boolean;
    translations?: JsonNullValueInput | InputJsonValue;
    is_active?: boolean;
    sort_order?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
    other_ThreadReportReasons?: ThreadReportReasonsUncheckedCreateNestedManyWithoutThreadReportReasonsInput;
  };

  export type ThreadReportReasonsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    is_leaf?: BoolFieldUpdateOperationsInput | boolean;
    translations?: JsonNullValueInput | InputJsonValue;
    is_active?: BoolFieldUpdateOperationsInput | boolean;
    sort_order?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    ThreadReportReasons?: ThreadReportReasonsUpdateOneWithoutOther_ThreadReportReasonsNestedInput;
    other_ThreadReportReasons?: ThreadReportReasonsUpdateManyWithoutThreadReportReasonsNestedInput;
  };

  export type ThreadReportReasonsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null;
    code?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    is_leaf?: BoolFieldUpdateOperationsInput | boolean;
    translations?: JsonNullValueInput | InputJsonValue;
    is_active?: BoolFieldUpdateOperationsInput | boolean;
    sort_order?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    other_ThreadReportReasons?: ThreadReportReasonsUncheckedUpdateManyWithoutThreadReportReasonsNestedInput;
  };

  export type ThreadReportReasonsCreateManyInput = {
    id?: string;
    parent_id?: string | null;
    code: string;
    level: number;
    is_leaf?: boolean;
    translations?: JsonNullValueInput | InputJsonValue;
    is_active?: boolean;
    sort_order?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadReportReasonsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    is_leaf?: BoolFieldUpdateOperationsInput | boolean;
    translations?: JsonNullValueInput | InputJsonValue;
    is_active?: BoolFieldUpdateOperationsInput | boolean;
    sort_order?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadReportReasonsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null;
    code?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    is_leaf?: BoolFieldUpdateOperationsInput | boolean;
    translations?: JsonNullValueInput | InputJsonValue;
    is_active?: BoolFieldUpdateOperationsInput | boolean;
    sort_order?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadReportsCreateInput = {
    id?: string;
    threads_id: string;
    reported_by?: number | null;
    reason?: string | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadReportsUncheckedCreateInput = {
    id?: string;
    threads_id: string;
    reported_by?: number | null;
    reason?: string | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadReportsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    reported_by?: NullableIntFieldUpdateOperationsInput | number | null;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadReportsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    reported_by?: NullableIntFieldUpdateOperationsInput | number | null;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadReportsCreateManyInput = {
    id?: string;
    threads_id: string;
    reported_by?: number | null;
    reason?: string | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadReportsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    reported_by?: NullableIntFieldUpdateOperationsInput | number | null;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadReportsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    reported_by?: NullableIntFieldUpdateOperationsInput | number | null;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadRepostsCreateInput = {
    id?: string;
    threads_id: string;
    user_id: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadRepostsUncheckedCreateInput = {
    id?: string;
    threads_id: string;
    user_id: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadRepostsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadRepostsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadRepostsCreateManyInput = {
    id?: string;
    threads_id: string;
    user_id: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadRepostsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadRepostsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threads_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ThreadsCreateInput = {
    id?: string;
    user_id: number;
    content?: string | null;
    visibility?: $Enums.visibility_enum | null;
    start_thread_id?: string | null;
    poll_id?: string | null;
    parent_thread_id?: string | null;
    quoted_thread_id?: string | null;
    company_info_id?: string | null;
    parent_level: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
    news_id?: string | null;
  };

  export type ThreadsUncheckedCreateInput = {
    id?: string;
    user_id: number;
    content?: string | null;
    visibility?: $Enums.visibility_enum | null;
    start_thread_id?: string | null;
    poll_id?: string | null;
    parent_thread_id?: string | null;
    quoted_thread_id?: string | null;
    company_info_id?: string | null;
    parent_level: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
    news_id?: string | null;
  };

  export type ThreadsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    visibility?:
      | NullableEnumvisibility_enumFieldUpdateOperationsInput
      | $Enums.visibility_enum
      | null;
    start_thread_id?: NullableStringFieldUpdateOperationsInput | string | null;
    poll_id?: NullableStringFieldUpdateOperationsInput | string | null;
    parent_thread_id?: NullableStringFieldUpdateOperationsInput | string | null;
    quoted_thread_id?: NullableStringFieldUpdateOperationsInput | string | null;
    company_info_id?: NullableStringFieldUpdateOperationsInput | string | null;
    parent_level?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    news_id?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ThreadsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    visibility?:
      | NullableEnumvisibility_enumFieldUpdateOperationsInput
      | $Enums.visibility_enum
      | null;
    start_thread_id?: NullableStringFieldUpdateOperationsInput | string | null;
    poll_id?: NullableStringFieldUpdateOperationsInput | string | null;
    parent_thread_id?: NullableStringFieldUpdateOperationsInput | string | null;
    quoted_thread_id?: NullableStringFieldUpdateOperationsInput | string | null;
    company_info_id?: NullableStringFieldUpdateOperationsInput | string | null;
    parent_level?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    news_id?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ThreadsCreateManyInput = {
    id?: string;
    user_id: number;
    content?: string | null;
    visibility?: $Enums.visibility_enum | null;
    start_thread_id?: string | null;
    poll_id?: string | null;
    parent_thread_id?: string | null;
    quoted_thread_id?: string | null;
    company_info_id?: string | null;
    parent_level: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
    news_id?: string | null;
  };

  export type ThreadsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    visibility?:
      | NullableEnumvisibility_enumFieldUpdateOperationsInput
      | $Enums.visibility_enum
      | null;
    start_thread_id?: NullableStringFieldUpdateOperationsInput | string | null;
    poll_id?: NullableStringFieldUpdateOperationsInput | string | null;
    parent_thread_id?: NullableStringFieldUpdateOperationsInput | string | null;
    quoted_thread_id?: NullableStringFieldUpdateOperationsInput | string | null;
    company_info_id?: NullableStringFieldUpdateOperationsInput | string | null;
    parent_level?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    news_id?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ThreadsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    visibility?:
      | NullableEnumvisibility_enumFieldUpdateOperationsInput
      | $Enums.visibility_enum
      | null;
    start_thread_id?: NullableStringFieldUpdateOperationsInput | string | null;
    poll_id?: NullableStringFieldUpdateOperationsInput | string | null;
    parent_thread_id?: NullableStringFieldUpdateOperationsInput | string | null;
    quoted_thread_id?: NullableStringFieldUpdateOperationsInput | string | null;
    company_info_id?: NullableStringFieldUpdateOperationsInput | string | null;
    parent_level?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    news_id?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserBlocksCreateInput = {
    id?: string;
    blocker_user_id: number;
    blocked_user_id: number;
    reason?: string | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type UserBlocksUncheckedCreateInput = {
    id?: string;
    blocker_user_id: number;
    blocked_user_id: number;
    reason?: string | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type UserBlocksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    blocker_user_id?: IntFieldUpdateOperationsInput | number;
    blocked_user_id?: IntFieldUpdateOperationsInput | number;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserBlocksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    blocker_user_id?: IntFieldUpdateOperationsInput | number;
    blocked_user_id?: IntFieldUpdateOperationsInput | number;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserBlocksCreateManyInput = {
    id?: string;
    blocker_user_id: number;
    blocked_user_id: number;
    reason?: string | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type UserBlocksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    blocker_user_id?: IntFieldUpdateOperationsInput | number;
    blocked_user_id?: IntFieldUpdateOperationsInput | number;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserBlocksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    blocker_user_id?: IntFieldUpdateOperationsInput | number;
    blocked_user_id?: IntFieldUpdateOperationsInput | number;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserInterestLogsCreateInput = {
    id?: string;
    user_id: number;
    symbol_id: string;
    activity_type: string;
    weight?: number | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type UserInterestLogsUncheckedCreateInput = {
    id?: string;
    user_id: number;
    symbol_id: string;
    activity_type: string;
    weight?: number | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type UserInterestLogsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    symbol_id?: StringFieldUpdateOperationsInput | string;
    activity_type?: StringFieldUpdateOperationsInput | string;
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserInterestLogsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    symbol_id?: StringFieldUpdateOperationsInput | string;
    activity_type?: StringFieldUpdateOperationsInput | string;
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserInterestLogsCreateManyInput = {
    id?: string;
    user_id: number;
    symbol_id: string;
    activity_type: string;
    weight?: number | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type UserInterestLogsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    symbol_id?: StringFieldUpdateOperationsInput | string;
    activity_type?: StringFieldUpdateOperationsInput | string;
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserInterestLogsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    symbol_id?: StringFieldUpdateOperationsInput | string;
    activity_type?: StringFieldUpdateOperationsInput | string;
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserInterestsCreateInput = {
    id?: string;
    user_id: number;
    symbol_id: string;
    weight?: number | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type UserInterestsUncheckedCreateInput = {
    id?: string;
    user_id: number;
    symbol_id: string;
    weight?: number | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type UserInterestsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    symbol_id?: StringFieldUpdateOperationsInput | string;
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserInterestsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    symbol_id?: StringFieldUpdateOperationsInput | string;
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserInterestsCreateManyInput = {
    id?: string;
    user_id: number;
    symbol_id: string;
    weight?: number | null;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type UserInterestsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    symbol_id?: StringFieldUpdateOperationsInput | string;
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserInterestsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    symbol_id?: StringFieldUpdateOperationsInput | string;
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserNotificationSettingsCreateInput = {
    id?: string;
    user_id: number;
    push_enabled?: boolean;
    email_enabled?: boolean;
    notify_followed_threads?: boolean;
    notify_followed_replies?: boolean;
    notify_mentions?: boolean;
    notify_when_followed?: boolean;
    notify_reposts?: boolean;
    notify_likes?: boolean;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type UserNotificationSettingsUncheckedCreateInput = {
    id?: string;
    user_id: number;
    push_enabled?: boolean;
    email_enabled?: boolean;
    notify_followed_threads?: boolean;
    notify_followed_replies?: boolean;
    notify_mentions?: boolean;
    notify_when_followed?: boolean;
    notify_reposts?: boolean;
    notify_likes?: boolean;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type UserNotificationSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    push_enabled?: BoolFieldUpdateOperationsInput | boolean;
    email_enabled?: BoolFieldUpdateOperationsInput | boolean;
    notify_followed_threads?: BoolFieldUpdateOperationsInput | boolean;
    notify_followed_replies?: BoolFieldUpdateOperationsInput | boolean;
    notify_mentions?: BoolFieldUpdateOperationsInput | boolean;
    notify_when_followed?: BoolFieldUpdateOperationsInput | boolean;
    notify_reposts?: BoolFieldUpdateOperationsInput | boolean;
    notify_likes?: BoolFieldUpdateOperationsInput | boolean;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserNotificationSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    push_enabled?: BoolFieldUpdateOperationsInput | boolean;
    email_enabled?: BoolFieldUpdateOperationsInput | boolean;
    notify_followed_threads?: BoolFieldUpdateOperationsInput | boolean;
    notify_followed_replies?: BoolFieldUpdateOperationsInput | boolean;
    notify_mentions?: BoolFieldUpdateOperationsInput | boolean;
    notify_when_followed?: BoolFieldUpdateOperationsInput | boolean;
    notify_reposts?: BoolFieldUpdateOperationsInput | boolean;
    notify_likes?: BoolFieldUpdateOperationsInput | boolean;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserNotificationSettingsCreateManyInput = {
    id?: string;
    user_id: number;
    push_enabled?: boolean;
    email_enabled?: boolean;
    notify_followed_threads?: boolean;
    notify_followed_replies?: boolean;
    notify_mentions?: boolean;
    notify_when_followed?: boolean;
    notify_reposts?: boolean;
    notify_likes?: boolean;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type UserNotificationSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    push_enabled?: BoolFieldUpdateOperationsInput | boolean;
    email_enabled?: BoolFieldUpdateOperationsInput | boolean;
    notify_followed_threads?: BoolFieldUpdateOperationsInput | boolean;
    notify_followed_replies?: BoolFieldUpdateOperationsInput | boolean;
    notify_mentions?: BoolFieldUpdateOperationsInput | boolean;
    notify_when_followed?: BoolFieldUpdateOperationsInput | boolean;
    notify_reposts?: BoolFieldUpdateOperationsInput | boolean;
    notify_likes?: BoolFieldUpdateOperationsInput | boolean;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserNotificationSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    push_enabled?: BoolFieldUpdateOperationsInput | boolean;
    email_enabled?: BoolFieldUpdateOperationsInput | boolean;
    notify_followed_threads?: BoolFieldUpdateOperationsInput | boolean;
    notify_followed_replies?: BoolFieldUpdateOperationsInput | boolean;
    notify_mentions?: BoolFieldUpdateOperationsInput | boolean;
    notify_when_followed?: BoolFieldUpdateOperationsInput | boolean;
    notify_reposts?: BoolFieldUpdateOperationsInput | boolean;
    notify_likes?: BoolFieldUpdateOperationsInput | boolean;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedUuidFilter<$PrismaModel> | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type Enumassets_type_enumFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.assets_type_enum
      | Enumassets_type_enumFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.assets_type_enum[]
      | ListEnumassets_type_enumFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.assets_type_enum[]
      | ListEnumassets_type_enumFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumassets_type_enumFilter<$PrismaModel>
      | $Enums.assets_type_enum;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null;
  };

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type CompaniesInfoIdCreated_atCompoundUniqueInput = {
    id: string;
    created_at: Date | string;
  };

  export type CompaniesInfoCountOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    symbol?: SortOrder;
    name?: SortOrder;
    market_state?: SortOrder;
    regular_market_price?: SortOrder;
    regular_market_change?: SortOrder;
    regular_market_change_percent?: SortOrder;
    sector?: SortOrder;
    industry?: SortOrder;
    date_at_shares?: SortOrder;
    assets_type?: SortOrder;
    exchange_name?: SortOrder;
    pre_market_price?: SortOrder;
    pre_market_change?: SortOrder;
    pre_market_change_percent?: SortOrder;
    post_market_price?: SortOrder;
    post_market_change?: SortOrder;
    post_market_change_percent?: SortOrder;
    overnight_market_price?: SortOrder;
    overnight_market_change?: SortOrder;
    overnight_market_change_percent?: SortOrder;
    market_cap?: SortOrder;
    regular_market_time?: SortOrder;
    pre_market_time?: SortOrder;
    post_market_time?: SortOrder;
    overnight_market_time?: SortOrder;
    currency?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type CompaniesInfoAvgOrderByAggregateInput = {
    regular_market_price?: SortOrder;
    regular_market_change?: SortOrder;
    regular_market_change_percent?: SortOrder;
    pre_market_price?: SortOrder;
    pre_market_change?: SortOrder;
    pre_market_change_percent?: SortOrder;
    post_market_price?: SortOrder;
    post_market_change?: SortOrder;
    post_market_change_percent?: SortOrder;
    overnight_market_price?: SortOrder;
    overnight_market_change?: SortOrder;
    overnight_market_change_percent?: SortOrder;
    market_cap?: SortOrder;
    regular_market_time?: SortOrder;
    pre_market_time?: SortOrder;
    post_market_time?: SortOrder;
    overnight_market_time?: SortOrder;
  };

  export type CompaniesInfoMaxOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    symbol?: SortOrder;
    name?: SortOrder;
    market_state?: SortOrder;
    regular_market_price?: SortOrder;
    regular_market_change?: SortOrder;
    regular_market_change_percent?: SortOrder;
    sector?: SortOrder;
    industry?: SortOrder;
    date_at_shares?: SortOrder;
    assets_type?: SortOrder;
    exchange_name?: SortOrder;
    pre_market_price?: SortOrder;
    pre_market_change?: SortOrder;
    pre_market_change_percent?: SortOrder;
    post_market_price?: SortOrder;
    post_market_change?: SortOrder;
    post_market_change_percent?: SortOrder;
    overnight_market_price?: SortOrder;
    overnight_market_change?: SortOrder;
    overnight_market_change_percent?: SortOrder;
    market_cap?: SortOrder;
    regular_market_time?: SortOrder;
    pre_market_time?: SortOrder;
    post_market_time?: SortOrder;
    overnight_market_time?: SortOrder;
    currency?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type CompaniesInfoMinOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    symbol?: SortOrder;
    name?: SortOrder;
    market_state?: SortOrder;
    regular_market_price?: SortOrder;
    regular_market_change?: SortOrder;
    regular_market_change_percent?: SortOrder;
    sector?: SortOrder;
    industry?: SortOrder;
    date_at_shares?: SortOrder;
    assets_type?: SortOrder;
    exchange_name?: SortOrder;
    pre_market_price?: SortOrder;
    pre_market_change?: SortOrder;
    pre_market_change_percent?: SortOrder;
    post_market_price?: SortOrder;
    post_market_change?: SortOrder;
    post_market_change_percent?: SortOrder;
    overnight_market_price?: SortOrder;
    overnight_market_change?: SortOrder;
    overnight_market_change_percent?: SortOrder;
    market_cap?: SortOrder;
    regular_market_time?: SortOrder;
    pre_market_time?: SortOrder;
    post_market_time?: SortOrder;
    overnight_market_time?: SortOrder;
    currency?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type CompaniesInfoSumOrderByAggregateInput = {
    regular_market_price?: SortOrder;
    regular_market_change?: SortOrder;
    regular_market_change_percent?: SortOrder;
    pre_market_price?: SortOrder;
    pre_market_change?: SortOrder;
    pre_market_change_percent?: SortOrder;
    post_market_price?: SortOrder;
    post_market_change?: SortOrder;
    post_market_change_percent?: SortOrder;
    overnight_market_price?: SortOrder;
    overnight_market_change?: SortOrder;
    overnight_market_change_percent?: SortOrder;
    market_cap?: SortOrder;
    regular_market_time?: SortOrder;
    pre_market_time?: SortOrder;
    post_market_time?: SortOrder;
    overnight_market_time?: SortOrder;
  };

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type Enumassets_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.assets_type_enum
      | Enumassets_type_enumFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.assets_type_enum[]
      | ListEnumassets_type_enumFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.assets_type_enum[]
      | ListEnumassets_type_enumFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumassets_type_enumWithAggregatesFilter<$PrismaModel>
      | $Enums.assets_type_enum;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumassets_type_enumFilter<$PrismaModel>;
    _max?: NestedEnumassets_type_enumFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?:
      | NestedBigIntNullableWithAggregatesFilter<$PrismaModel>
      | bigint
      | number
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedBigIntNullableFilter<$PrismaModel>;
    _min?: NestedBigIntNullableFilter<$PrismaModel>;
    _max?: NestedBigIntNullableFilter<$PrismaModel>;
  };

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedBigIntFilter<$PrismaModel>;
    _min?: NestedBigIntFilter<$PrismaModel>;
    _max?: NestedBigIntFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type FollowNotificationOverridesCountOrderByAggregateInput = {
    id?: SortOrder;
    follower_id?: SortOrder;
    following_id?: SortOrder;
    mute_all?: SortOrder;
    notify_threads?: SortOrder;
    notify_replies?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type FollowNotificationOverridesAvgOrderByAggregateInput = {
    follower_id?: SortOrder;
    following_id?: SortOrder;
  };

  export type FollowNotificationOverridesMaxOrderByAggregateInput = {
    id?: SortOrder;
    follower_id?: SortOrder;
    following_id?: SortOrder;
    mute_all?: SortOrder;
    notify_threads?: SortOrder;
    notify_replies?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type FollowNotificationOverridesMinOrderByAggregateInput = {
    id?: SortOrder;
    follower_id?: SortOrder;
    following_id?: SortOrder;
    mute_all?: SortOrder;
    notify_threads?: SortOrder;
    notify_replies?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type FollowNotificationOverridesSumOrderByAggregateInput = {
    follower_id?: SortOrder;
    following_id?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type FollowRequestsCountOrderByAggregateInput = {
    id?: SortOrder;
    requester_id?: SortOrder;
    target_id?: SortOrder;
    status?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type FollowRequestsAvgOrderByAggregateInput = {
    requester_id?: SortOrder;
    target_id?: SortOrder;
  };

  export type FollowRequestsMaxOrderByAggregateInput = {
    id?: SortOrder;
    requester_id?: SortOrder;
    target_id?: SortOrder;
    status?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type FollowRequestsMinOrderByAggregateInput = {
    id?: SortOrder;
    requester_id?: SortOrder;
    target_id?: SortOrder;
    status?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type FollowRequestsSumOrderByAggregateInput = {
    requester_id?: SortOrder;
    target_id?: SortOrder;
  };

  export type FollowsCountOrderByAggregateInput = {
    id?: SortOrder;
    follower_id?: SortOrder;
    following_id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type FollowsAvgOrderByAggregateInput = {
    follower_id?: SortOrder;
    following_id?: SortOrder;
  };

  export type FollowsMaxOrderByAggregateInput = {
    id?: SortOrder;
    follower_id?: SortOrder;
    following_id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type FollowsMinOrderByAggregateInput = {
    id?: SortOrder;
    follower_id?: SortOrder;
    following_id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type FollowsSumOrderByAggregateInput = {
    follower_id?: SortOrder;
    following_id?: SortOrder;
  };

  export type FollowsCountCountOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    followers_count?: SortOrder;
    following_count?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type FollowsCountAvgOrderByAggregateInput = {
    user_id?: SortOrder;
    followers_count?: SortOrder;
    following_count?: SortOrder;
  };

  export type FollowsCountMaxOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    followers_count?: SortOrder;
    following_count?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type FollowsCountMinOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    followers_count?: SortOrder;
    following_count?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type FollowsCountSumOrderByAggregateInput = {
    user_id?: SortOrder;
    followers_count?: SortOrder;
    following_count?: SortOrder;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
      >;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null;
  };

  export type Enumnotification_type_enumNullableFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.notification_type_enum
      | Enumnotification_type_enumFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.notification_type_enum[]
      | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.notification_type_enum[]
      | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumnotification_type_enumNullableFilter<$PrismaModel>
      | $Enums.notification_type_enum
      | null;
  };

  export type NotificationsIdCreated_atCompoundUniqueInput = {
    id: string;
    created_at: Date | string;
  };

  export type NotificationsCountOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    sender_id?: SortOrder;
    message_th?: SortOrder;
    message_en?: SortOrder;
    metadata?: SortOrder;
    is_read?: SortOrder;
    type?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type NotificationsAvgOrderByAggregateInput = {
    user_id?: SortOrder;
    sender_id?: SortOrder;
  };

  export type NotificationsMaxOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    sender_id?: SortOrder;
    message_th?: SortOrder;
    message_en?: SortOrder;
    is_read?: SortOrder;
    type?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type NotificationsMinOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    sender_id?: SortOrder;
    message_th?: SortOrder;
    message_en?: SortOrder;
    is_read?: SortOrder;
    type?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type NotificationsSumOrderByAggregateInput = {
    user_id?: SortOrder;
    sender_id?: SortOrder;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          'path'
        >
      >;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedBoolNullableFilter<$PrismaModel>;
    _max?: NestedBoolNullableFilter<$PrismaModel>;
  };

  export type Enumnotification_type_enumNullableWithAggregatesFilter<
    $PrismaModel = never
  > = {
    equals?:
      | $Enums.notification_type_enum
      | Enumnotification_type_enumFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.notification_type_enum[]
      | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.notification_type_enum[]
      | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumnotification_type_enumNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.notification_type_enum
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumnotification_type_enumNullableFilter<$PrismaModel>;
    _max?: NestedEnumnotification_type_enumNullableFilter<$PrismaModel>;
  };

  export type SymbolsCountOrderByAggregateInput = {
    id?: SortOrder;
    symbol_code?: SortOrder;
    name?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type SymbolsMaxOrderByAggregateInput = {
    id?: SortOrder;
    symbol_code?: SortOrder;
    name?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type SymbolsMinOrderByAggregateInput = {
    id?: SortOrder;
    symbol_code?: SortOrder;
    name?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type DecimalFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type ThreadEngagementMetricsThreads_idCreated_atCompoundUniqueInput = {
    threads_id: string;
    created_at: Date | string;
  };

  export type ThreadEngagementMetricsIdCreated_atCompoundUniqueInput = {
    id: string;
    created_at: Date | string;
  };

  export type ThreadEngagementMetricsCountOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    viewed_count?: SortOrder;
    replied_count?: SortOrder;
    reposted_count?: SortOrder;
    quoted_count?: SortOrder;
    liked_count?: SortOrder;
    reported_count?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadEngagementMetricsAvgOrderByAggregateInput = {
    viewed_count?: SortOrder;
    replied_count?: SortOrder;
    reposted_count?: SortOrder;
    quoted_count?: SortOrder;
    liked_count?: SortOrder;
    reported_count?: SortOrder;
  };

  export type ThreadEngagementMetricsMaxOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    viewed_count?: SortOrder;
    replied_count?: SortOrder;
    reposted_count?: SortOrder;
    quoted_count?: SortOrder;
    liked_count?: SortOrder;
    reported_count?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadEngagementMetricsMinOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    viewed_count?: SortOrder;
    replied_count?: SortOrder;
    reposted_count?: SortOrder;
    quoted_count?: SortOrder;
    liked_count?: SortOrder;
    reported_count?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadEngagementMetricsSumOrderByAggregateInput = {
    viewed_count?: SortOrder;
    replied_count?: SortOrder;
    reposted_count?: SortOrder;
    quoted_count?: SortOrder;
    liked_count?: SortOrder;
    reported_count?: SortOrder;
  };

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type Enumtag_type_enumFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.tag_type_enum
      | Enumtag_type_enumFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.tag_type_enum[]
      | ListEnumtag_type_enumFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.tag_type_enum[]
      | ListEnumtag_type_enumFieldRefInput<$PrismaModel>;
    not?: NestedEnumtag_type_enumFilter<$PrismaModel> | $Enums.tag_type_enum;
  };

  export type ThreadHashtagsIdCreated_atCompoundUniqueInput = {
    id: string;
    created_at: Date | string;
  };

  export type ThreadHashtagsCountOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    tag?: SortOrder;
    type?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadHashtagsMaxOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    tag?: SortOrder;
    type?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadHashtagsMinOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    tag?: SortOrder;
    type?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type Enumtag_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.tag_type_enum
      | Enumtag_type_enumFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.tag_type_enum[]
      | ListEnumtag_type_enumFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.tag_type_enum[]
      | ListEnumtag_type_enumFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumtag_type_enumWithAggregatesFilter<$PrismaModel>
      | $Enums.tag_type_enum;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumtag_type_enumFilter<$PrismaModel>;
    _max?: NestedEnumtag_type_enumFilter<$PrismaModel>;
  };

  export type ThreadLikesIdCreated_atCompoundUniqueInput = {
    id: string;
    created_at: Date | string;
  };

  export type ThreadLikesCountOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    user_id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadLikesAvgOrderByAggregateInput = {
    user_id?: SortOrder;
  };

  export type ThreadLikesMaxOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    user_id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadLikesMinOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    user_id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadLikesSumOrderByAggregateInput = {
    user_id?: SortOrder;
  };

  export type Enummedia_type_enumNullableFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.media_type_enum
      | Enummedia_type_enumFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.media_type_enum[]
      | ListEnummedia_type_enumFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.media_type_enum[]
      | ListEnummedia_type_enumFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnummedia_type_enumNullableFilter<$PrismaModel>
      | $Enums.media_type_enum
      | null;
  };

  export type ThreadMediaIdCreated_atCompoundUniqueInput = {
    id: string;
    created_at: Date | string;
  };

  export type ThreadMediaCountOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    media_type?: SortOrder;
    media_url?: SortOrder;
    thumbnail_url?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
    width?: SortOrder;
    height?: SortOrder;
    size?: SortOrder;
    duration?: SortOrder;
    object_key?: SortOrder;
  };

  export type ThreadMediaAvgOrderByAggregateInput = {
    width?: SortOrder;
    height?: SortOrder;
    size?: SortOrder;
    duration?: SortOrder;
  };

  export type ThreadMediaMaxOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    media_type?: SortOrder;
    media_url?: SortOrder;
    thumbnail_url?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
    width?: SortOrder;
    height?: SortOrder;
    size?: SortOrder;
    duration?: SortOrder;
    object_key?: SortOrder;
  };

  export type ThreadMediaMinOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    media_type?: SortOrder;
    media_url?: SortOrder;
    thumbnail_url?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
    width?: SortOrder;
    height?: SortOrder;
    size?: SortOrder;
    duration?: SortOrder;
    object_key?: SortOrder;
  };

  export type ThreadMediaSumOrderByAggregateInput = {
    width?: SortOrder;
    height?: SortOrder;
    size?: SortOrder;
    duration?: SortOrder;
  };

  export type Enummedia_type_enumNullableWithAggregatesFilter<
    $PrismaModel = never
  > = {
    equals?:
      | $Enums.media_type_enum
      | Enummedia_type_enumFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.media_type_enum[]
      | ListEnummedia_type_enumFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.media_type_enum[]
      | ListEnummedia_type_enumFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnummedia_type_enumNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.media_type_enum
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnummedia_type_enumNullableFilter<$PrismaModel>;
    _max?: NestedEnummedia_type_enumNullableFilter<$PrismaModel>;
  };

  export type ThreadMentionsIdCreated_atCompoundUniqueInput = {
    id: string;
    created_at: Date | string;
  };

  export type ThreadMentionsCountOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    mentioned_user_id?: SortOrder;
    position?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadMentionsAvgOrderByAggregateInput = {
    mentioned_user_id?: SortOrder;
    position?: SortOrder;
  };

  export type ThreadMentionsMaxOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    mentioned_user_id?: SortOrder;
    position?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadMentionsMinOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    mentioned_user_id?: SortOrder;
    position?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadMentionsSumOrderByAggregateInput = {
    mentioned_user_id?: SortOrder;
    position?: SortOrder;
  };

  export type ThreadPinsIdCreated_atCompoundUniqueInput = {
    id: string;
    created_at: Date | string;
  };

  export type ThreadPinsCountOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    threads_id?: SortOrder;
    pinned_at?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadPinsAvgOrderByAggregateInput = {
    user_id?: SortOrder;
  };

  export type ThreadPinsMaxOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    threads_id?: SortOrder;
    pinned_at?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadPinsMinOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    threads_id?: SortOrder;
    pinned_at?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadPinsSumOrderByAggregateInput = {
    user_id?: SortOrder;
  };

  export type ThreadPollOptionsIdCreated_atCompoundUniqueInput = {
    id: string;
    created_at: Date | string;
  };

  export type ThreadPollOptionsCountOrderByAggregateInput = {
    id?: SortOrder;
    poll_id?: SortOrder;
    option_text?: SortOrder;
    voted_count?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadPollOptionsAvgOrderByAggregateInput = {
    voted_count?: SortOrder;
  };

  export type ThreadPollOptionsMaxOrderByAggregateInput = {
    id?: SortOrder;
    poll_id?: SortOrder;
    option_text?: SortOrder;
    voted_count?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadPollOptionsMinOrderByAggregateInput = {
    id?: SortOrder;
    poll_id?: SortOrder;
    option_text?: SortOrder;
    voted_count?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadPollOptionsSumOrderByAggregateInput = {
    voted_count?: SortOrder;
  };

  export type ThreadPollVotesIdCreated_atCompoundUniqueInput = {
    id: string;
    created_at: Date | string;
  };

  export type ThreadPollVotesCountOrderByAggregateInput = {
    id?: SortOrder;
    option_id?: SortOrder;
    user_id?: SortOrder;
    voted_at?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadPollVotesAvgOrderByAggregateInput = {
    user_id?: SortOrder;
  };

  export type ThreadPollVotesMaxOrderByAggregateInput = {
    id?: SortOrder;
    option_id?: SortOrder;
    user_id?: SortOrder;
    voted_at?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadPollVotesMinOrderByAggregateInput = {
    id?: SortOrder;
    option_id?: SortOrder;
    user_id?: SortOrder;
    voted_at?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadPollVotesSumOrderByAggregateInput = {
    user_id?: SortOrder;
  };

  export type ThreadPollsIdCreated_atCompoundUniqueInput = {
    id: string;
    created_at: Date | string;
  };

  export type ThreadPollsCountOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    question?: SortOrder;
    total_voted?: SortOrder;
    expires_at?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadPollsAvgOrderByAggregateInput = {
    total_voted?: SortOrder;
  };

  export type ThreadPollsMaxOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    question?: SortOrder;
    total_voted?: SortOrder;
    expires_at?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadPollsMinOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    question?: SortOrder;
    total_voted?: SortOrder;
    expires_at?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadPollsSumOrderByAggregateInput = {
    total_voted?: SortOrder;
  };

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null;
  };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type ThreadReportReasonsNullableScalarRelationFilter = {
    is?: ThreadReportReasonsWhereInput | null;
    isNot?: ThreadReportReasonsWhereInput | null;
  };

  export type ThreadReportReasonsListRelationFilter = {
    every?: ThreadReportReasonsWhereInput;
    some?: ThreadReportReasonsWhereInput;
    none?: ThreadReportReasonsWhereInput;
  };

  export type ThreadReportReasonsOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ThreadReportReasonsCountOrderByAggregateInput = {
    id?: SortOrder;
    parent_id?: SortOrder;
    code?: SortOrder;
    level?: SortOrder;
    is_leaf?: SortOrder;
    translations?: SortOrder;
    is_active?: SortOrder;
    sort_order?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadReportReasonsAvgOrderByAggregateInput = {
    level?: SortOrder;
    sort_order?: SortOrder;
  };

  export type ThreadReportReasonsMaxOrderByAggregateInput = {
    id?: SortOrder;
    parent_id?: SortOrder;
    code?: SortOrder;
    level?: SortOrder;
    is_leaf?: SortOrder;
    is_active?: SortOrder;
    sort_order?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadReportReasonsMinOrderByAggregateInput = {
    id?: SortOrder;
    parent_id?: SortOrder;
    code?: SortOrder;
    level?: SortOrder;
    is_leaf?: SortOrder;
    is_active?: SortOrder;
    sort_order?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadReportReasonsSumOrderByAggregateInput = {
    level?: SortOrder;
    sort_order?: SortOrder;
  };

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>
      >;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type ThreadReportsIdCreated_atCompoundUniqueInput = {
    id: string;
    created_at: Date | string;
  };

  export type ThreadReportsCountOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    reported_by?: SortOrder;
    reason?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadReportsAvgOrderByAggregateInput = {
    reported_by?: SortOrder;
  };

  export type ThreadReportsMaxOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    reported_by?: SortOrder;
    reason?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadReportsMinOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    reported_by?: SortOrder;
    reason?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadReportsSumOrderByAggregateInput = {
    reported_by?: SortOrder;
  };

  export type ThreadRepostsIdCreated_atCompoundUniqueInput = {
    id: string;
    created_at: Date | string;
  };

  export type ThreadRepostsCountOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    user_id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadRepostsAvgOrderByAggregateInput = {
    user_id?: SortOrder;
  };

  export type ThreadRepostsMaxOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    user_id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadRepostsMinOrderByAggregateInput = {
    id?: SortOrder;
    threads_id?: SortOrder;
    user_id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type ThreadRepostsSumOrderByAggregateInput = {
    user_id?: SortOrder;
  };

  export type Enumvisibility_enumNullableFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.visibility_enum
      | Enumvisibility_enumFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.visibility_enum[]
      | ListEnumvisibility_enumFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.visibility_enum[]
      | ListEnumvisibility_enumFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumvisibility_enumNullableFilter<$PrismaModel>
      | $Enums.visibility_enum
      | null;
  };

  export type ThreadsIdCreated_atCompoundUniqueInput = {
    id: string;
    created_at: Date | string;
  };

  export type ThreadsCountOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    content?: SortOrder;
    visibility?: SortOrder;
    start_thread_id?: SortOrder;
    poll_id?: SortOrder;
    parent_thread_id?: SortOrder;
    quoted_thread_id?: SortOrder;
    company_info_id?: SortOrder;
    parent_level?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
    news_id?: SortOrder;
  };

  export type ThreadsAvgOrderByAggregateInput = {
    user_id?: SortOrder;
    parent_level?: SortOrder;
  };

  export type ThreadsMaxOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    content?: SortOrder;
    visibility?: SortOrder;
    start_thread_id?: SortOrder;
    poll_id?: SortOrder;
    parent_thread_id?: SortOrder;
    quoted_thread_id?: SortOrder;
    company_info_id?: SortOrder;
    parent_level?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
    news_id?: SortOrder;
  };

  export type ThreadsMinOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    content?: SortOrder;
    visibility?: SortOrder;
    start_thread_id?: SortOrder;
    poll_id?: SortOrder;
    parent_thread_id?: SortOrder;
    quoted_thread_id?: SortOrder;
    company_info_id?: SortOrder;
    parent_level?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
    news_id?: SortOrder;
  };

  export type ThreadsSumOrderByAggregateInput = {
    user_id?: SortOrder;
    parent_level?: SortOrder;
  };

  export type Enumvisibility_enumNullableWithAggregatesFilter<
    $PrismaModel = never
  > = {
    equals?:
      | $Enums.visibility_enum
      | Enumvisibility_enumFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.visibility_enum[]
      | ListEnumvisibility_enumFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.visibility_enum[]
      | ListEnumvisibility_enumFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumvisibility_enumNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.visibility_enum
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumvisibility_enumNullableFilter<$PrismaModel>;
    _max?: NestedEnumvisibility_enumNullableFilter<$PrismaModel>;
  };

  export type UserBlocksCountOrderByAggregateInput = {
    id?: SortOrder;
    blocker_user_id?: SortOrder;
    blocked_user_id?: SortOrder;
    reason?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type UserBlocksAvgOrderByAggregateInput = {
    blocker_user_id?: SortOrder;
    blocked_user_id?: SortOrder;
  };

  export type UserBlocksMaxOrderByAggregateInput = {
    id?: SortOrder;
    blocker_user_id?: SortOrder;
    blocked_user_id?: SortOrder;
    reason?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type UserBlocksMinOrderByAggregateInput = {
    id?: SortOrder;
    blocker_user_id?: SortOrder;
    blocked_user_id?: SortOrder;
    reason?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type UserBlocksSumOrderByAggregateInput = {
    blocker_user_id?: SortOrder;
    blocked_user_id?: SortOrder;
  };

  export type UserInterestLogsCountOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    symbol_id?: SortOrder;
    activity_type?: SortOrder;
    weight?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type UserInterestLogsAvgOrderByAggregateInput = {
    user_id?: SortOrder;
    weight?: SortOrder;
  };

  export type UserInterestLogsMaxOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    symbol_id?: SortOrder;
    activity_type?: SortOrder;
    weight?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type UserInterestLogsMinOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    symbol_id?: SortOrder;
    activity_type?: SortOrder;
    weight?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type UserInterestLogsSumOrderByAggregateInput = {
    user_id?: SortOrder;
    weight?: SortOrder;
  };

  export type UserInterestsUser_idSymbol_idCompoundUniqueInput = {
    user_id: number;
    symbol_id: string;
  };

  export type UserInterestsCountOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    symbol_id?: SortOrder;
    weight?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type UserInterestsAvgOrderByAggregateInput = {
    user_id?: SortOrder;
    weight?: SortOrder;
  };

  export type UserInterestsMaxOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    symbol_id?: SortOrder;
    weight?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type UserInterestsMinOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    symbol_id?: SortOrder;
    weight?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type UserInterestsSumOrderByAggregateInput = {
    user_id?: SortOrder;
    weight?: SortOrder;
  };

  export type UserNotificationSettingsCountOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    push_enabled?: SortOrder;
    email_enabled?: SortOrder;
    notify_followed_threads?: SortOrder;
    notify_followed_replies?: SortOrder;
    notify_mentions?: SortOrder;
    notify_when_followed?: SortOrder;
    notify_reposts?: SortOrder;
    notify_likes?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type UserNotificationSettingsAvgOrderByAggregateInput = {
    user_id?: SortOrder;
  };

  export type UserNotificationSettingsMaxOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    push_enabled?: SortOrder;
    email_enabled?: SortOrder;
    notify_followed_threads?: SortOrder;
    notify_followed_replies?: SortOrder;
    notify_mentions?: SortOrder;
    notify_when_followed?: SortOrder;
    notify_reposts?: SortOrder;
    notify_likes?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type UserNotificationSettingsMinOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    push_enabled?: SortOrder;
    email_enabled?: SortOrder;
    notify_followed_threads?: SortOrder;
    notify_followed_replies?: SortOrder;
    notify_mentions?: SortOrder;
    notify_when_followed?: SortOrder;
    notify_reposts?: SortOrder;
    notify_likes?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    deleted_at?: SortOrder;
  };

  export type UserNotificationSettingsSumOrderByAggregateInput = {
    user_id?: SortOrder;
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type Enumassets_type_enumFieldUpdateOperationsInput = {
    set?: $Enums.assets_type_enum;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null;
    increment?: bigint | number;
    decrement?: bigint | number;
    multiply?: bigint | number;
    divide?: bigint | number;
  };

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number;
    increment?: bigint | number;
    decrement?: bigint | number;
    multiply?: bigint | number;
    divide?: bigint | number;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null;
  };

  export type NullableEnumnotification_type_enumFieldUpdateOperationsInput = {
    set?: $Enums.notification_type_enum | null;
  };

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type Enumtag_type_enumFieldUpdateOperationsInput = {
    set?: $Enums.tag_type_enum;
  };

  export type NullableEnummedia_type_enumFieldUpdateOperationsInput = {
    set?: $Enums.media_type_enum | null;
  };

  export type ThreadReportReasonsCreateNestedOneWithoutOther_ThreadReportReasonsInput =
    {
      create?: XOR<
        ThreadReportReasonsCreateWithoutOther_ThreadReportReasonsInput,
        ThreadReportReasonsUncheckedCreateWithoutOther_ThreadReportReasonsInput
      >;
      connectOrCreate?: ThreadReportReasonsCreateOrConnectWithoutOther_ThreadReportReasonsInput;
      connect?: ThreadReportReasonsWhereUniqueInput;
    };

  export type ThreadReportReasonsCreateNestedManyWithoutThreadReportReasonsInput =
    {
      create?:
        | XOR<
            ThreadReportReasonsCreateWithoutThreadReportReasonsInput,
            ThreadReportReasonsUncheckedCreateWithoutThreadReportReasonsInput
          >
        | ThreadReportReasonsCreateWithoutThreadReportReasonsInput[]
        | ThreadReportReasonsUncheckedCreateWithoutThreadReportReasonsInput[];
      connectOrCreate?:
        | ThreadReportReasonsCreateOrConnectWithoutThreadReportReasonsInput
        | ThreadReportReasonsCreateOrConnectWithoutThreadReportReasonsInput[];
      createMany?: ThreadReportReasonsCreateManyThreadReportReasonsInputEnvelope;
      connect?:
        | ThreadReportReasonsWhereUniqueInput
        | ThreadReportReasonsWhereUniqueInput[];
    };

  export type ThreadReportReasonsUncheckedCreateNestedManyWithoutThreadReportReasonsInput =
    {
      create?:
        | XOR<
            ThreadReportReasonsCreateWithoutThreadReportReasonsInput,
            ThreadReportReasonsUncheckedCreateWithoutThreadReportReasonsInput
          >
        | ThreadReportReasonsCreateWithoutThreadReportReasonsInput[]
        | ThreadReportReasonsUncheckedCreateWithoutThreadReportReasonsInput[];
      connectOrCreate?:
        | ThreadReportReasonsCreateOrConnectWithoutThreadReportReasonsInput
        | ThreadReportReasonsCreateOrConnectWithoutThreadReportReasonsInput[];
      createMany?: ThreadReportReasonsCreateManyThreadReportReasonsInputEnvelope;
      connect?:
        | ThreadReportReasonsWhereUniqueInput
        | ThreadReportReasonsWhereUniqueInput[];
    };

  export type ThreadReportReasonsUpdateOneWithoutOther_ThreadReportReasonsNestedInput =
    {
      create?: XOR<
        ThreadReportReasonsCreateWithoutOther_ThreadReportReasonsInput,
        ThreadReportReasonsUncheckedCreateWithoutOther_ThreadReportReasonsInput
      >;
      connectOrCreate?: ThreadReportReasonsCreateOrConnectWithoutOther_ThreadReportReasonsInput;
      upsert?: ThreadReportReasonsUpsertWithoutOther_ThreadReportReasonsInput;
      disconnect?: ThreadReportReasonsWhereInput | boolean;
      delete?: ThreadReportReasonsWhereInput | boolean;
      connect?: ThreadReportReasonsWhereUniqueInput;
      update?: XOR<
        XOR<
          ThreadReportReasonsUpdateToOneWithWhereWithoutOther_ThreadReportReasonsInput,
          ThreadReportReasonsUpdateWithoutOther_ThreadReportReasonsInput
        >,
        ThreadReportReasonsUncheckedUpdateWithoutOther_ThreadReportReasonsInput
      >;
    };

  export type ThreadReportReasonsUpdateManyWithoutThreadReportReasonsNestedInput =
    {
      create?:
        | XOR<
            ThreadReportReasonsCreateWithoutThreadReportReasonsInput,
            ThreadReportReasonsUncheckedCreateWithoutThreadReportReasonsInput
          >
        | ThreadReportReasonsCreateWithoutThreadReportReasonsInput[]
        | ThreadReportReasonsUncheckedCreateWithoutThreadReportReasonsInput[];
      connectOrCreate?:
        | ThreadReportReasonsCreateOrConnectWithoutThreadReportReasonsInput
        | ThreadReportReasonsCreateOrConnectWithoutThreadReportReasonsInput[];
      upsert?:
        | ThreadReportReasonsUpsertWithWhereUniqueWithoutThreadReportReasonsInput
        | ThreadReportReasonsUpsertWithWhereUniqueWithoutThreadReportReasonsInput[];
      createMany?: ThreadReportReasonsCreateManyThreadReportReasonsInputEnvelope;
      set?:
        | ThreadReportReasonsWhereUniqueInput
        | ThreadReportReasonsWhereUniqueInput[];
      disconnect?:
        | ThreadReportReasonsWhereUniqueInput
        | ThreadReportReasonsWhereUniqueInput[];
      delete?:
        | ThreadReportReasonsWhereUniqueInput
        | ThreadReportReasonsWhereUniqueInput[];
      connect?:
        | ThreadReportReasonsWhereUniqueInput
        | ThreadReportReasonsWhereUniqueInput[];
      update?:
        | ThreadReportReasonsUpdateWithWhereUniqueWithoutThreadReportReasonsInput
        | ThreadReportReasonsUpdateWithWhereUniqueWithoutThreadReportReasonsInput[];
      updateMany?:
        | ThreadReportReasonsUpdateManyWithWhereWithoutThreadReportReasonsInput
        | ThreadReportReasonsUpdateManyWithWhereWithoutThreadReportReasonsInput[];
      deleteMany?:
        | ThreadReportReasonsScalarWhereInput
        | ThreadReportReasonsScalarWhereInput[];
    };

  export type ThreadReportReasonsUncheckedUpdateManyWithoutThreadReportReasonsNestedInput =
    {
      create?:
        | XOR<
            ThreadReportReasonsCreateWithoutThreadReportReasonsInput,
            ThreadReportReasonsUncheckedCreateWithoutThreadReportReasonsInput
          >
        | ThreadReportReasonsCreateWithoutThreadReportReasonsInput[]
        | ThreadReportReasonsUncheckedCreateWithoutThreadReportReasonsInput[];
      connectOrCreate?:
        | ThreadReportReasonsCreateOrConnectWithoutThreadReportReasonsInput
        | ThreadReportReasonsCreateOrConnectWithoutThreadReportReasonsInput[];
      upsert?:
        | ThreadReportReasonsUpsertWithWhereUniqueWithoutThreadReportReasonsInput
        | ThreadReportReasonsUpsertWithWhereUniqueWithoutThreadReportReasonsInput[];
      createMany?: ThreadReportReasonsCreateManyThreadReportReasonsInputEnvelope;
      set?:
        | ThreadReportReasonsWhereUniqueInput
        | ThreadReportReasonsWhereUniqueInput[];
      disconnect?:
        | ThreadReportReasonsWhereUniqueInput
        | ThreadReportReasonsWhereUniqueInput[];
      delete?:
        | ThreadReportReasonsWhereUniqueInput
        | ThreadReportReasonsWhereUniqueInput[];
      connect?:
        | ThreadReportReasonsWhereUniqueInput
        | ThreadReportReasonsWhereUniqueInput[];
      update?:
        | ThreadReportReasonsUpdateWithWhereUniqueWithoutThreadReportReasonsInput
        | ThreadReportReasonsUpdateWithWhereUniqueWithoutThreadReportReasonsInput[];
      updateMany?:
        | ThreadReportReasonsUpdateManyWithWhereWithoutThreadReportReasonsInput
        | ThreadReportReasonsUpdateManyWithWhereWithoutThreadReportReasonsInput[];
      deleteMany?:
        | ThreadReportReasonsScalarWhereInput
        | ThreadReportReasonsScalarWhereInput[];
    };

  export type NullableEnumvisibility_enumFieldUpdateOperationsInput = {
    set?: $Enums.visibility_enum | null;
  };

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedUuidFilter<$PrismaModel> | string;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedEnumassets_type_enumFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.assets_type_enum
      | Enumassets_type_enumFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.assets_type_enum[]
      | ListEnumassets_type_enumFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.assets_type_enum[]
      | ListEnumassets_type_enumFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumassets_type_enumFilter<$PrismaModel>
      | $Enums.assets_type_enum;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null;
  };

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedEnumassets_type_enumWithAggregatesFilter<
    $PrismaModel = never
  > = {
    equals?:
      | $Enums.assets_type_enum
      | Enumassets_type_enumFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.assets_type_enum[]
      | ListEnumassets_type_enumFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.assets_type_enum[]
      | ListEnumassets_type_enumFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumassets_type_enumWithAggregatesFilter<$PrismaModel>
      | $Enums.assets_type_enum;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumassets_type_enumFilter<$PrismaModel>;
    _max?: NestedEnumassets_type_enumFilter<$PrismaModel>;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?:
      | NestedBigIntNullableWithAggregatesFilter<$PrismaModel>
      | bigint
      | number
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedBigIntNullableFilter<$PrismaModel>;
    _min?: NestedBigIntNullableFilter<$PrismaModel>;
    _max?: NestedBigIntNullableFilter<$PrismaModel>;
  };

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedBigIntFilter<$PrismaModel>;
    _min?: NestedBigIntFilter<$PrismaModel>;
    _max?: NestedBigIntFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null;
  };

  export type NestedEnumnotification_type_enumNullableFilter<
    $PrismaModel = never
  > = {
    equals?:
      | $Enums.notification_type_enum
      | Enumnotification_type_enumFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.notification_type_enum[]
      | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.notification_type_enum[]
      | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumnotification_type_enumNullableFilter<$PrismaModel>
      | $Enums.notification_type_enum
      | null;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>
      >;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedBoolNullableFilter<$PrismaModel>;
    _max?: NestedBoolNullableFilter<$PrismaModel>;
  };

  export type NestedEnumnotification_type_enumNullableWithAggregatesFilter<
    $PrismaModel = never
  > = {
    equals?:
      | $Enums.notification_type_enum
      | Enumnotification_type_enumFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.notification_type_enum[]
      | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.notification_type_enum[]
      | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumnotification_type_enumNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.notification_type_enum
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumnotification_type_enumNullableFilter<$PrismaModel>;
    _max?: NestedEnumnotification_type_enumNullableFilter<$PrismaModel>;
  };

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type NestedEnumtag_type_enumFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.tag_type_enum
      | Enumtag_type_enumFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.tag_type_enum[]
      | ListEnumtag_type_enumFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.tag_type_enum[]
      | ListEnumtag_type_enumFieldRefInput<$PrismaModel>;
    not?: NestedEnumtag_type_enumFilter<$PrismaModel> | $Enums.tag_type_enum;
  };

  export type NestedEnumtag_type_enumWithAggregatesFilter<
    $PrismaModel = never
  > = {
    equals?:
      | $Enums.tag_type_enum
      | Enumtag_type_enumFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.tag_type_enum[]
      | ListEnumtag_type_enumFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.tag_type_enum[]
      | ListEnumtag_type_enumFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumtag_type_enumWithAggregatesFilter<$PrismaModel>
      | $Enums.tag_type_enum;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumtag_type_enumFilter<$PrismaModel>;
    _max?: NestedEnumtag_type_enumFilter<$PrismaModel>;
  };

  export type NestedEnummedia_type_enumNullableFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.media_type_enum
      | Enummedia_type_enumFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.media_type_enum[]
      | ListEnummedia_type_enumFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.media_type_enum[]
      | ListEnummedia_type_enumFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnummedia_type_enumNullableFilter<$PrismaModel>
      | $Enums.media_type_enum
      | null;
  };

  export type NestedEnummedia_type_enumNullableWithAggregatesFilter<
    $PrismaModel = never
  > = {
    equals?:
      | $Enums.media_type_enum
      | Enummedia_type_enumFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.media_type_enum[]
      | ListEnummedia_type_enumFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.media_type_enum[]
      | ListEnummedia_type_enumFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnummedia_type_enumNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.media_type_enum
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnummedia_type_enumNullableFilter<$PrismaModel>;
    _max?: NestedEnummedia_type_enumNullableFilter<$PrismaModel>;
  };

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type NestedEnumvisibility_enumNullableFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.visibility_enum
      | Enumvisibility_enumFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.visibility_enum[]
      | ListEnumvisibility_enumFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.visibility_enum[]
      | ListEnumvisibility_enumFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumvisibility_enumNullableFilter<$PrismaModel>
      | $Enums.visibility_enum
      | null;
  };

  export type NestedEnumvisibility_enumNullableWithAggregatesFilter<
    $PrismaModel = never
  > = {
    equals?:
      | $Enums.visibility_enum
      | Enumvisibility_enumFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.visibility_enum[]
      | ListEnumvisibility_enumFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.visibility_enum[]
      | ListEnumvisibility_enumFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumvisibility_enumNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.visibility_enum
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumvisibility_enumNullableFilter<$PrismaModel>;
    _max?: NestedEnumvisibility_enumNullableFilter<$PrismaModel>;
  };

  export type ThreadReportReasonsCreateWithoutOther_ThreadReportReasonsInput = {
    id?: string;
    code: string;
    level: number;
    is_leaf?: boolean;
    translations?: JsonNullValueInput | InputJsonValue;
    is_active?: boolean;
    sort_order?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
    ThreadReportReasons?: ThreadReportReasonsCreateNestedOneWithoutOther_ThreadReportReasonsInput;
  };

  export type ThreadReportReasonsUncheckedCreateWithoutOther_ThreadReportReasonsInput =
    {
      id?: string;
      parent_id?: string | null;
      code: string;
      level: number;
      is_leaf?: boolean;
      translations?: JsonNullValueInput | InputJsonValue;
      is_active?: boolean;
      sort_order?: number;
      created_at?: Date | string;
      updated_at?: Date | string;
      deleted_at?: Date | string | null;
    };

  export type ThreadReportReasonsCreateOrConnectWithoutOther_ThreadReportReasonsInput =
    {
      where: ThreadReportReasonsWhereUniqueInput;
      create: XOR<
        ThreadReportReasonsCreateWithoutOther_ThreadReportReasonsInput,
        ThreadReportReasonsUncheckedCreateWithoutOther_ThreadReportReasonsInput
      >;
    };

  export type ThreadReportReasonsCreateWithoutThreadReportReasonsInput = {
    id?: string;
    code: string;
    level: number;
    is_leaf?: boolean;
    translations?: JsonNullValueInput | InputJsonValue;
    is_active?: boolean;
    sort_order?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
    other_ThreadReportReasons?: ThreadReportReasonsCreateNestedManyWithoutThreadReportReasonsInput;
  };

  export type ThreadReportReasonsUncheckedCreateWithoutThreadReportReasonsInput =
    {
      id?: string;
      code: string;
      level: number;
      is_leaf?: boolean;
      translations?: JsonNullValueInput | InputJsonValue;
      is_active?: boolean;
      sort_order?: number;
      created_at?: Date | string;
      updated_at?: Date | string;
      deleted_at?: Date | string | null;
      other_ThreadReportReasons?: ThreadReportReasonsUncheckedCreateNestedManyWithoutThreadReportReasonsInput;
    };

  export type ThreadReportReasonsCreateOrConnectWithoutThreadReportReasonsInput =
    {
      where: ThreadReportReasonsWhereUniqueInput;
      create: XOR<
        ThreadReportReasonsCreateWithoutThreadReportReasonsInput,
        ThreadReportReasonsUncheckedCreateWithoutThreadReportReasonsInput
      >;
    };

  export type ThreadReportReasonsCreateManyThreadReportReasonsInputEnvelope = {
    data:
      | ThreadReportReasonsCreateManyThreadReportReasonsInput
      | ThreadReportReasonsCreateManyThreadReportReasonsInput[];
    skipDuplicates?: boolean;
  };

  export type ThreadReportReasonsUpsertWithoutOther_ThreadReportReasonsInput = {
    update: XOR<
      ThreadReportReasonsUpdateWithoutOther_ThreadReportReasonsInput,
      ThreadReportReasonsUncheckedUpdateWithoutOther_ThreadReportReasonsInput
    >;
    create: XOR<
      ThreadReportReasonsCreateWithoutOther_ThreadReportReasonsInput,
      ThreadReportReasonsUncheckedCreateWithoutOther_ThreadReportReasonsInput
    >;
    where?: ThreadReportReasonsWhereInput;
  };

  export type ThreadReportReasonsUpdateToOneWithWhereWithoutOther_ThreadReportReasonsInput =
    {
      where?: ThreadReportReasonsWhereInput;
      data: XOR<
        ThreadReportReasonsUpdateWithoutOther_ThreadReportReasonsInput,
        ThreadReportReasonsUncheckedUpdateWithoutOther_ThreadReportReasonsInput
      >;
    };

  export type ThreadReportReasonsUpdateWithoutOther_ThreadReportReasonsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    is_leaf?: BoolFieldUpdateOperationsInput | boolean;
    translations?: JsonNullValueInput | InputJsonValue;
    is_active?: BoolFieldUpdateOperationsInput | boolean;
    sort_order?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    ThreadReportReasons?: ThreadReportReasonsUpdateOneWithoutOther_ThreadReportReasonsNestedInput;
  };

  export type ThreadReportReasonsUncheckedUpdateWithoutOther_ThreadReportReasonsInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      parent_id?: NullableStringFieldUpdateOperationsInput | string | null;
      code?: StringFieldUpdateOperationsInput | string;
      level?: IntFieldUpdateOperationsInput | number;
      is_leaf?: BoolFieldUpdateOperationsInput | boolean;
      translations?: JsonNullValueInput | InputJsonValue;
      is_active?: BoolFieldUpdateOperationsInput | boolean;
      sort_order?: IntFieldUpdateOperationsInput | number;
      created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
      updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
      deleted_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    };

  export type ThreadReportReasonsUpsertWithWhereUniqueWithoutThreadReportReasonsInput =
    {
      where: ThreadReportReasonsWhereUniqueInput;
      update: XOR<
        ThreadReportReasonsUpdateWithoutThreadReportReasonsInput,
        ThreadReportReasonsUncheckedUpdateWithoutThreadReportReasonsInput
      >;
      create: XOR<
        ThreadReportReasonsCreateWithoutThreadReportReasonsInput,
        ThreadReportReasonsUncheckedCreateWithoutThreadReportReasonsInput
      >;
    };

  export type ThreadReportReasonsUpdateWithWhereUniqueWithoutThreadReportReasonsInput =
    {
      where: ThreadReportReasonsWhereUniqueInput;
      data: XOR<
        ThreadReportReasonsUpdateWithoutThreadReportReasonsInput,
        ThreadReportReasonsUncheckedUpdateWithoutThreadReportReasonsInput
      >;
    };

  export type ThreadReportReasonsUpdateManyWithWhereWithoutThreadReportReasonsInput =
    {
      where: ThreadReportReasonsScalarWhereInput;
      data: XOR<
        ThreadReportReasonsUpdateManyMutationInput,
        ThreadReportReasonsUncheckedUpdateManyWithoutThreadReportReasonsInput
      >;
    };

  export type ThreadReportReasonsScalarWhereInput = {
    AND?:
      | ThreadReportReasonsScalarWhereInput
      | ThreadReportReasonsScalarWhereInput[];
    OR?: ThreadReportReasonsScalarWhereInput[];
    NOT?:
      | ThreadReportReasonsScalarWhereInput
      | ThreadReportReasonsScalarWhereInput[];
    id?: UuidFilter<'ThreadReportReasons'> | string;
    parent_id?: UuidNullableFilter<'ThreadReportReasons'> | string | null;
    code?: StringFilter<'ThreadReportReasons'> | string;
    level?: IntFilter<'ThreadReportReasons'> | number;
    is_leaf?: BoolFilter<'ThreadReportReasons'> | boolean;
    translations?: JsonFilter<'ThreadReportReasons'>;
    is_active?: BoolFilter<'ThreadReportReasons'> | boolean;
    sort_order?: IntFilter<'ThreadReportReasons'> | number;
    created_at?: DateTimeFilter<'ThreadReportReasons'> | Date | string;
    updated_at?: DateTimeFilter<'ThreadReportReasons'> | Date | string;
    deleted_at?:
      | DateTimeNullableFilter<'ThreadReportReasons'>
      | Date
      | string
      | null;
  };

  export type ThreadReportReasonsCreateManyThreadReportReasonsInput = {
    id?: string;
    code: string;
    level: number;
    is_leaf?: boolean;
    translations?: JsonNullValueInput | InputJsonValue;
    is_active?: boolean;
    sort_order?: number;
    created_at?: Date | string;
    updated_at?: Date | string;
    deleted_at?: Date | string | null;
  };

  export type ThreadReportReasonsUpdateWithoutThreadReportReasonsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    is_leaf?: BoolFieldUpdateOperationsInput | boolean;
    translations?: JsonNullValueInput | InputJsonValue;
    is_active?: BoolFieldUpdateOperationsInput | boolean;
    sort_order?: IntFieldUpdateOperationsInput | number;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    deleted_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    other_ThreadReportReasons?: ThreadReportReasonsUpdateManyWithoutThreadReportReasonsNestedInput;
  };

  export type ThreadReportReasonsUncheckedUpdateWithoutThreadReportReasonsInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      code?: StringFieldUpdateOperationsInput | string;
      level?: IntFieldUpdateOperationsInput | number;
      is_leaf?: BoolFieldUpdateOperationsInput | boolean;
      translations?: JsonNullValueInput | InputJsonValue;
      is_active?: BoolFieldUpdateOperationsInput | boolean;
      sort_order?: IntFieldUpdateOperationsInput | number;
      created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
      updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
      deleted_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      other_ThreadReportReasons?: ThreadReportReasonsUncheckedUpdateManyWithoutThreadReportReasonsNestedInput;
    };

  export type ThreadReportReasonsUncheckedUpdateManyWithoutThreadReportReasonsInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      code?: StringFieldUpdateOperationsInput | string;
      level?: IntFieldUpdateOperationsInput | number;
      is_leaf?: BoolFieldUpdateOperationsInput | boolean;
      translations?: JsonNullValueInput | InputJsonValue;
      is_active?: BoolFieldUpdateOperationsInput | boolean;
      sort_order?: IntFieldUpdateOperationsInput | number;
      created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
      updated_at?: DateTimeFieldUpdateOperationsInput | Date | string;
      deleted_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
