/**
 * Client
 **/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model app_problem_report
 *
 */
export type app_problem_report =
  $Result.DefaultSelection<Prisma.$app_problem_reportPayload>;
/**
 * Model app_version_support
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type app_version_support =
  $Result.DefaultSelection<Prisma.$app_version_supportPayload>;
/**
 * Model comments
 *
 */
export type comments = $Result.DefaultSelection<Prisma.$commentsPayload>;
/**
 * Model in_app_announcements
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type in_app_announcements =
  $Result.DefaultSelection<Prisma.$in_app_announcementsPayload>;
/**
 * Model investment_insights
 *
 */
export type investment_insights =
  $Result.DefaultSelection<Prisma.$investment_insightsPayload>;
/**
 * Model market_recap
 *
 */
export type market_recap =
  $Result.DefaultSelection<Prisma.$market_recapPayload>;
/**
 * Model news_comments
 *
 */
export type news_comments =
  $Result.DefaultSelection<Prisma.$news_commentsPayload>;
/**
 * Model news_config
 *
 */
export type news_config = $Result.DefaultSelection<Prisma.$news_configPayload>;
/**
 * Model payment_history
 *
 */
export type payment_history =
  $Result.DefaultSelection<Prisma.$payment_historyPayload>;
/**
 * Model permissions
 *
 */
export type permissions = $Result.DefaultSelection<Prisma.$permissionsPayload>;
/**
 * Model portfolio
 *
 */
export type portfolio = $Result.DefaultSelection<Prisma.$portfolioPayload>;
/**
 * Model portfolio_holdings
 *
 */
export type portfolio_holdings =
  $Result.DefaultSelection<Prisma.$portfolio_holdingsPayload>;
/**
 * Model portfolio_stocks
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type portfolio_stocks =
  $Result.DefaultSelection<Prisma.$portfolio_stocksPayload>;
/**
 * Model price_alerts
 *
 */
export type price_alerts =
  $Result.DefaultSelection<Prisma.$price_alertsPayload>;
/**
 * Model promotion_articles
 *
 */
export type promotion_articles =
  $Result.DefaultSelection<Prisma.$promotion_articlesPayload>;
/**
 * Model stock_news
 *
 */
export type stock_news = $Result.DefaultSelection<Prisma.$stock_newsPayload>;
/**
 * Model stock_news_read_history
 *
 */
export type stock_news_read_history =
  $Result.DefaultSelection<Prisma.$stock_news_read_historyPayload>;
/**
 * Model stock_news_related_symbols
 *
 */
export type stock_news_related_symbols =
  $Result.DefaultSelection<Prisma.$stock_news_related_symbolsPayload>;
/**
 * Model stock_news_translation
 *
 */
export type stock_news_translation =
  $Result.DefaultSelection<Prisma.$stock_news_translationPayload>;
/**
 * Model subscriptions
 *
 */
export type subscriptions =
  $Result.DefaultSelection<Prisma.$subscriptionsPayload>;
/**
 * Model superinvestor_holdings
 *
 */
export type superinvestor_holdings =
  $Result.DefaultSelection<Prisma.$superinvestor_holdingsPayload>;
/**
 * Model superinvestor_holdings_list
 *
 */
export type superinvestor_holdings_list =
  $Result.DefaultSelection<Prisma.$superinvestor_holdings_listPayload>;
/**
 * Model superinvestor_sector_analysis
 *
 */
export type superinvestor_sector_analysis =
  $Result.DefaultSelection<Prisma.$superinvestor_sector_analysisPayload>;
/**
 * Model symbol
 *
 */
export type symbol = $Result.DefaultSelection<Prisma.$symbolPayload>;
/**
 * Model user_devices
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type user_devices =
  $Result.DefaultSelection<Prisma.$user_devicesPayload>;
/**
 * Model user_subscriptions
 *
 */
export type user_subscriptions =
  $Result.DefaultSelection<Prisma.$user_subscriptionsPayload>;
/**
 * Model users
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>;
/**
 * Model watchlist_items
 *
 */
export type watchlist_items =
  $Result.DefaultSelection<Prisma.$watchlist_itemsPayload>;
/**
 * Model watchlists
 *
 */
export type watchlists = $Result.DefaultSelection<Prisma.$watchlistsPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const alert_status: {
    ACTIVE: 'ACTIVE';
    TRIGGERED: 'TRIGGERED';
    EXPIRED: 'EXPIRED';
    CANCELLED: 'CANCELLED';
  };

  export type alert_status = (typeof alert_status)[keyof typeof alert_status];

  export const alert_type: {
    ABOVE: 'ABOVE';
    BELOW: 'BELOW';
  };

  export type alert_type = (typeof alert_type)[keyof typeof alert_type];

  export const asset_type: {
    STOCK: 'STOCK';
    CRYPTO: 'CRYPTO';
    INDEX: 'INDEX';
  };

  export type asset_type = (typeof asset_type)[keyof typeof asset_type];

  export const comment_status: {
    active: 'active';
    deleted: 'deleted';
    hidden: 'hidden';
  };

  export type comment_status =
    (typeof comment_status)[keyof typeof comment_status];
}

export type alert_status = $Enums.alert_status;

export const alert_status: typeof $Enums.alert_status;

export type alert_type = $Enums.alert_type;

export const alert_type: typeof $Enums.alert_type;

export type asset_type = $Enums.asset_type;

export const asset_type: typeof $Enums.asset_type;

export type comment_status = $Enums.comment_status;

export const comment_status: typeof $Enums.comment_status;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more App_problem_reports
 * const app_problem_reports = await prisma.app_problem_report.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more App_problem_reports
   * const app_problem_reports = await prisma.app_problem_report.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent
    ) => void
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.app_problem_report`: Exposes CRUD operations for the **app_problem_report** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more App_problem_reports
   * const app_problem_reports = await prisma.app_problem_report.findMany()
   * ```
   */
  get app_problem_report(): Prisma.app_problem_reportDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.app_version_support`: Exposes CRUD operations for the **app_version_support** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more App_version_supports
   * const app_version_supports = await prisma.app_version_support.findMany()
   * ```
   */
  get app_version_support(): Prisma.app_version_supportDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.comments`: Exposes CRUD operations for the **comments** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Comments
   * const comments = await prisma.comments.findMany()
   * ```
   */
  get comments(): Prisma.commentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.in_app_announcements`: Exposes CRUD operations for the **in_app_announcements** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more In_app_announcements
   * const in_app_announcements = await prisma.in_app_announcements.findMany()
   * ```
   */
  get in_app_announcements(): Prisma.in_app_announcementsDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.investment_insights`: Exposes CRUD operations for the **investment_insights** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Investment_insights
   * const investment_insights = await prisma.investment_insights.findMany()
   * ```
   */
  get investment_insights(): Prisma.investment_insightsDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.market_recap`: Exposes CRUD operations for the **market_recap** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Market_recaps
   * const market_recaps = await prisma.market_recap.findMany()
   * ```
   */
  get market_recap(): Prisma.market_recapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.news_comments`: Exposes CRUD operations for the **news_comments** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more News_comments
   * const news_comments = await prisma.news_comments.findMany()
   * ```
   */
  get news_comments(): Prisma.news_commentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.news_config`: Exposes CRUD operations for the **news_config** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more News_configs
   * const news_configs = await prisma.news_config.findMany()
   * ```
   */
  get news_config(): Prisma.news_configDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_history`: Exposes CRUD operations for the **payment_history** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Payment_histories
   * const payment_histories = await prisma.payment_history.findMany()
   * ```
   */
  get payment_history(): Prisma.payment_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permissions`: Exposes CRUD operations for the **permissions** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Permissions
   * const permissions = await prisma.permissions.findMany()
   * ```
   */
  get permissions(): Prisma.permissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portfolio`: Exposes CRUD operations for the **portfolio** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Portfolios
   * const portfolios = await prisma.portfolio.findMany()
   * ```
   */
  get portfolio(): Prisma.portfolioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portfolio_holdings`: Exposes CRUD operations for the **portfolio_holdings** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Portfolio_holdings
   * const portfolio_holdings = await prisma.portfolio_holdings.findMany()
   * ```
   */
  get portfolio_holdings(): Prisma.portfolio_holdingsDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.portfolio_stocks`: Exposes CRUD operations for the **portfolio_stocks** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Portfolio_stocks
   * const portfolio_stocks = await prisma.portfolio_stocks.findMany()
   * ```
   */
  get portfolio_stocks(): Prisma.portfolio_stocksDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.price_alerts`: Exposes CRUD operations for the **price_alerts** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Price_alerts
   * const price_alerts = await prisma.price_alerts.findMany()
   * ```
   */
  get price_alerts(): Prisma.price_alertsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotion_articles`: Exposes CRUD operations for the **promotion_articles** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Promotion_articles
   * const promotion_articles = await prisma.promotion_articles.findMany()
   * ```
   */
  get promotion_articles(): Prisma.promotion_articlesDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.stock_news`: Exposes CRUD operations for the **stock_news** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Stock_news
   * const stock_news = await prisma.stock_news.findMany()
   * ```
   */
  get stock_news(): Prisma.stock_newsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stock_news_read_history`: Exposes CRUD operations for the **stock_news_read_history** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Stock_news_read_histories
   * const stock_news_read_histories = await prisma.stock_news_read_history.findMany()
   * ```
   */
  get stock_news_read_history(): Prisma.stock_news_read_historyDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.stock_news_related_symbols`: Exposes CRUD operations for the **stock_news_related_symbols** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Stock_news_related_symbols
   * const stock_news_related_symbols = await prisma.stock_news_related_symbols.findMany()
   * ```
   */
  get stock_news_related_symbols(): Prisma.stock_news_related_symbolsDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.stock_news_translation`: Exposes CRUD operations for the **stock_news_translation** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Stock_news_translations
   * const stock_news_translations = await prisma.stock_news_translation.findMany()
   * ```
   */
  get stock_news_translation(): Prisma.stock_news_translationDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.subscriptions`: Exposes CRUD operations for the **subscriptions** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Subscriptions
   * const subscriptions = await prisma.subscriptions.findMany()
   * ```
   */
  get subscriptions(): Prisma.subscriptionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.superinvestor_holdings`: Exposes CRUD operations for the **superinvestor_holdings** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Superinvestor_holdings
   * const superinvestor_holdings = await prisma.superinvestor_holdings.findMany()
   * ```
   */
  get superinvestor_holdings(): Prisma.superinvestor_holdingsDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.superinvestor_holdings_list`: Exposes CRUD operations for the **superinvestor_holdings_list** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Superinvestor_holdings_lists
   * const superinvestor_holdings_lists = await prisma.superinvestor_holdings_list.findMany()
   * ```
   */
  get superinvestor_holdings_list(): Prisma.superinvestor_holdings_listDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.superinvestor_sector_analysis`: Exposes CRUD operations for the **superinvestor_sector_analysis** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Superinvestor_sector_analyses
   * const superinvestor_sector_analyses = await prisma.superinvestor_sector_analysis.findMany()
   * ```
   */
  get superinvestor_sector_analysis(): Prisma.superinvestor_sector_analysisDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.symbol`: Exposes CRUD operations for the **symbol** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Symbols
   * const symbols = await prisma.symbol.findMany()
   * ```
   */
  get symbol(): Prisma.symbolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_devices`: Exposes CRUD operations for the **user_devices** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more User_devices
   * const user_devices = await prisma.user_devices.findMany()
   * ```
   */
  get user_devices(): Prisma.user_devicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_subscriptions`: Exposes CRUD operations for the **user_subscriptions** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more User_subscriptions
   * const user_subscriptions = await prisma.user_subscriptions.findMany()
   * ```
   */
  get user_subscriptions(): Prisma.user_subscriptionsDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.watchlist_items`: Exposes CRUD operations for the **watchlist_items** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Watchlist_items
   * const watchlist_items = await prisma.watchlist_items.findMany()
   * ```
   */
  get watchlist_items(): Prisma.watchlist_itemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.watchlists`: Exposes CRUD operations for the **watchlists** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Watchlists
   * const watchlists = await prisma.watchlists.findMany()
   * ```
   */
  get watchlists(): Prisma.watchlistsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 7.4.0
   * Query Engine version: ab56fe763f921d033a6c195e7ddeb3e255bdbb57
   */
  export type PrismaVersion = {
    client: string;
    engine: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import Bytes = runtime.Bytes;
  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    app_problem_report: 'app_problem_report';
    app_version_support: 'app_version_support';
    comments: 'comments';
    in_app_announcements: 'in_app_announcements';
    investment_insights: 'investment_insights';
    market_recap: 'market_recap';
    news_comments: 'news_comments';
    news_config: 'news_config';
    payment_history: 'payment_history';
    permissions: 'permissions';
    portfolio: 'portfolio';
    portfolio_holdings: 'portfolio_holdings';
    portfolio_stocks: 'portfolio_stocks';
    price_alerts: 'price_alerts';
    promotion_articles: 'promotion_articles';
    stock_news: 'stock_news';
    stock_news_read_history: 'stock_news_read_history';
    stock_news_related_symbols: 'stock_news_related_symbols';
    stock_news_translation: 'stock_news_translation';
    subscriptions: 'subscriptions';
    superinvestor_holdings: 'superinvestor_holdings';
    superinvestor_holdings_list: 'superinvestor_holdings_list';
    superinvestor_sector_analysis: 'superinvestor_sector_analysis';
    symbol: 'symbol';
    user_devices: 'user_devices';
    user_subscriptions: 'user_subscriptions';
    users: 'users';
    watchlist_items: 'watchlist_items';
    watchlists: 'watchlists';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | 'app_problem_report'
        | 'app_version_support'
        | 'comments'
        | 'in_app_announcements'
        | 'investment_insights'
        | 'market_recap'
        | 'news_comments'
        | 'news_config'
        | 'payment_history'
        | 'permissions'
        | 'portfolio'
        | 'portfolio_holdings'
        | 'portfolio_stocks'
        | 'price_alerts'
        | 'promotion_articles'
        | 'stock_news'
        | 'stock_news_read_history'
        | 'stock_news_related_symbols'
        | 'stock_news_translation'
        | 'subscriptions'
        | 'superinvestor_holdings'
        | 'superinvestor_holdings_list'
        | 'superinvestor_sector_analysis'
        | 'symbol'
        | 'user_devices'
        | 'user_subscriptions'
        | 'users'
        | 'watchlist_items'
        | 'watchlists';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      app_problem_report: {
        payload: Prisma.$app_problem_reportPayload<ExtArgs>;
        fields: Prisma.app_problem_reportFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.app_problem_reportFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_problem_reportPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.app_problem_reportFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_problem_reportPayload>;
          };
          findFirst: {
            args: Prisma.app_problem_reportFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_problem_reportPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.app_problem_reportFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_problem_reportPayload>;
          };
          findMany: {
            args: Prisma.app_problem_reportFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_problem_reportPayload>[];
          };
          create: {
            args: Prisma.app_problem_reportCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_problem_reportPayload>;
          };
          createMany: {
            args: Prisma.app_problem_reportCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.app_problem_reportCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_problem_reportPayload>[];
          };
          delete: {
            args: Prisma.app_problem_reportDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_problem_reportPayload>;
          };
          update: {
            args: Prisma.app_problem_reportUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_problem_reportPayload>;
          };
          deleteMany: {
            args: Prisma.app_problem_reportDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.app_problem_reportUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.app_problem_reportUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_problem_reportPayload>[];
          };
          upsert: {
            args: Prisma.app_problem_reportUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_problem_reportPayload>;
          };
          aggregate: {
            args: Prisma.App_problem_reportAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateApp_problem_report>;
          };
          groupBy: {
            args: Prisma.app_problem_reportGroupByArgs<ExtArgs>;
            result: $Utils.Optional<App_problem_reportGroupByOutputType>[];
          };
          count: {
            args: Prisma.app_problem_reportCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<App_problem_reportCountAggregateOutputType>
              | number;
          };
        };
      };
      app_version_support: {
        payload: Prisma.$app_version_supportPayload<ExtArgs>;
        fields: Prisma.app_version_supportFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.app_version_supportFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_version_supportPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.app_version_supportFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_version_supportPayload>;
          };
          findFirst: {
            args: Prisma.app_version_supportFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_version_supportPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.app_version_supportFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_version_supportPayload>;
          };
          findMany: {
            args: Prisma.app_version_supportFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_version_supportPayload>[];
          };
          create: {
            args: Prisma.app_version_supportCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_version_supportPayload>;
          };
          createMany: {
            args: Prisma.app_version_supportCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.app_version_supportCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_version_supportPayload>[];
          };
          delete: {
            args: Prisma.app_version_supportDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_version_supportPayload>;
          };
          update: {
            args: Prisma.app_version_supportUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_version_supportPayload>;
          };
          deleteMany: {
            args: Prisma.app_version_supportDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.app_version_supportUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.app_version_supportUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_version_supportPayload>[];
          };
          upsert: {
            args: Prisma.app_version_supportUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$app_version_supportPayload>;
          };
          aggregate: {
            args: Prisma.App_version_supportAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateApp_version_support>;
          };
          groupBy: {
            args: Prisma.app_version_supportGroupByArgs<ExtArgs>;
            result: $Utils.Optional<App_version_supportGroupByOutputType>[];
          };
          count: {
            args: Prisma.app_version_supportCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<App_version_supportCountAggregateOutputType>
              | number;
          };
        };
      };
      comments: {
        payload: Prisma.$commentsPayload<ExtArgs>;
        fields: Prisma.commentsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.commentsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.commentsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>;
          };
          findFirst: {
            args: Prisma.commentsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.commentsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>;
          };
          findMany: {
            args: Prisma.commentsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[];
          };
          create: {
            args: Prisma.commentsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>;
          };
          createMany: {
            args: Prisma.commentsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.commentsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[];
          };
          delete: {
            args: Prisma.commentsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>;
          };
          update: {
            args: Prisma.commentsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>;
          };
          deleteMany: {
            args: Prisma.commentsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.commentsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.commentsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[];
          };
          upsert: {
            args: Prisma.commentsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>;
          };
          aggregate: {
            args: Prisma.CommentsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateComments>;
          };
          groupBy: {
            args: Prisma.commentsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CommentsGroupByOutputType>[];
          };
          count: {
            args: Prisma.commentsCountArgs<ExtArgs>;
            result: $Utils.Optional<CommentsCountAggregateOutputType> | number;
          };
        };
      };
      in_app_announcements: {
        payload: Prisma.$in_app_announcementsPayload<ExtArgs>;
        fields: Prisma.in_app_announcementsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.in_app_announcementsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$in_app_announcementsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.in_app_announcementsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$in_app_announcementsPayload>;
          };
          findFirst: {
            args: Prisma.in_app_announcementsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$in_app_announcementsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.in_app_announcementsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$in_app_announcementsPayload>;
          };
          findMany: {
            args: Prisma.in_app_announcementsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$in_app_announcementsPayload>[];
          };
          create: {
            args: Prisma.in_app_announcementsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$in_app_announcementsPayload>;
          };
          createMany: {
            args: Prisma.in_app_announcementsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.in_app_announcementsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$in_app_announcementsPayload>[];
          };
          delete: {
            args: Prisma.in_app_announcementsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$in_app_announcementsPayload>;
          };
          update: {
            args: Prisma.in_app_announcementsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$in_app_announcementsPayload>;
          };
          deleteMany: {
            args: Prisma.in_app_announcementsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.in_app_announcementsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.in_app_announcementsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$in_app_announcementsPayload>[];
          };
          upsert: {
            args: Prisma.in_app_announcementsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$in_app_announcementsPayload>;
          };
          aggregate: {
            args: Prisma.In_app_announcementsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateIn_app_announcements>;
          };
          groupBy: {
            args: Prisma.in_app_announcementsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<In_app_announcementsGroupByOutputType>[];
          };
          count: {
            args: Prisma.in_app_announcementsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<In_app_announcementsCountAggregateOutputType>
              | number;
          };
        };
      };
      investment_insights: {
        payload: Prisma.$investment_insightsPayload<ExtArgs>;
        fields: Prisma.investment_insightsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.investment_insightsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$investment_insightsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.investment_insightsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$investment_insightsPayload>;
          };
          findFirst: {
            args: Prisma.investment_insightsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$investment_insightsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.investment_insightsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$investment_insightsPayload>;
          };
          findMany: {
            args: Prisma.investment_insightsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$investment_insightsPayload>[];
          };
          create: {
            args: Prisma.investment_insightsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$investment_insightsPayload>;
          };
          createMany: {
            args: Prisma.investment_insightsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.investment_insightsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$investment_insightsPayload>[];
          };
          delete: {
            args: Prisma.investment_insightsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$investment_insightsPayload>;
          };
          update: {
            args: Prisma.investment_insightsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$investment_insightsPayload>;
          };
          deleteMany: {
            args: Prisma.investment_insightsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.investment_insightsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.investment_insightsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$investment_insightsPayload>[];
          };
          upsert: {
            args: Prisma.investment_insightsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$investment_insightsPayload>;
          };
          aggregate: {
            args: Prisma.Investment_insightsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateInvestment_insights>;
          };
          groupBy: {
            args: Prisma.investment_insightsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Investment_insightsGroupByOutputType>[];
          };
          count: {
            args: Prisma.investment_insightsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Investment_insightsCountAggregateOutputType>
              | number;
          };
        };
      };
      market_recap: {
        payload: Prisma.$market_recapPayload<ExtArgs>;
        fields: Prisma.market_recapFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.market_recapFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$market_recapPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.market_recapFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$market_recapPayload>;
          };
          findFirst: {
            args: Prisma.market_recapFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$market_recapPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.market_recapFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$market_recapPayload>;
          };
          findMany: {
            args: Prisma.market_recapFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$market_recapPayload>[];
          };
          create: {
            args: Prisma.market_recapCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$market_recapPayload>;
          };
          createMany: {
            args: Prisma.market_recapCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.market_recapCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$market_recapPayload>[];
          };
          delete: {
            args: Prisma.market_recapDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$market_recapPayload>;
          };
          update: {
            args: Prisma.market_recapUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$market_recapPayload>;
          };
          deleteMany: {
            args: Prisma.market_recapDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.market_recapUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.market_recapUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$market_recapPayload>[];
          };
          upsert: {
            args: Prisma.market_recapUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$market_recapPayload>;
          };
          aggregate: {
            args: Prisma.Market_recapAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMarket_recap>;
          };
          groupBy: {
            args: Prisma.market_recapGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Market_recapGroupByOutputType>[];
          };
          count: {
            args: Prisma.market_recapCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Market_recapCountAggregateOutputType>
              | number;
          };
        };
      };
      news_comments: {
        payload: Prisma.$news_commentsPayload<ExtArgs>;
        fields: Prisma.news_commentsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.news_commentsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_commentsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.news_commentsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_commentsPayload>;
          };
          findFirst: {
            args: Prisma.news_commentsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_commentsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.news_commentsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_commentsPayload>;
          };
          findMany: {
            args: Prisma.news_commentsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_commentsPayload>[];
          };
          create: {
            args: Prisma.news_commentsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_commentsPayload>;
          };
          createMany: {
            args: Prisma.news_commentsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.news_commentsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_commentsPayload>[];
          };
          delete: {
            args: Prisma.news_commentsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_commentsPayload>;
          };
          update: {
            args: Prisma.news_commentsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_commentsPayload>;
          };
          deleteMany: {
            args: Prisma.news_commentsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.news_commentsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.news_commentsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_commentsPayload>[];
          };
          upsert: {
            args: Prisma.news_commentsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_commentsPayload>;
          };
          aggregate: {
            args: Prisma.News_commentsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNews_comments>;
          };
          groupBy: {
            args: Prisma.news_commentsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<News_commentsGroupByOutputType>[];
          };
          count: {
            args: Prisma.news_commentsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<News_commentsCountAggregateOutputType>
              | number;
          };
        };
      };
      news_config: {
        payload: Prisma.$news_configPayload<ExtArgs>;
        fields: Prisma.news_configFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.news_configFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_configPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.news_configFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_configPayload>;
          };
          findFirst: {
            args: Prisma.news_configFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_configPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.news_configFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_configPayload>;
          };
          findMany: {
            args: Prisma.news_configFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_configPayload>[];
          };
          create: {
            args: Prisma.news_configCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_configPayload>;
          };
          createMany: {
            args: Prisma.news_configCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.news_configCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_configPayload>[];
          };
          delete: {
            args: Prisma.news_configDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_configPayload>;
          };
          update: {
            args: Prisma.news_configUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_configPayload>;
          };
          deleteMany: {
            args: Prisma.news_configDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.news_configUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.news_configUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_configPayload>[];
          };
          upsert: {
            args: Prisma.news_configUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$news_configPayload>;
          };
          aggregate: {
            args: Prisma.News_configAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNews_config>;
          };
          groupBy: {
            args: Prisma.news_configGroupByArgs<ExtArgs>;
            result: $Utils.Optional<News_configGroupByOutputType>[];
          };
          count: {
            args: Prisma.news_configCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<News_configCountAggregateOutputType>
              | number;
          };
        };
      };
      payment_history: {
        payload: Prisma.$payment_historyPayload<ExtArgs>;
        fields: Prisma.payment_historyFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.payment_historyFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_historyPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.payment_historyFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_historyPayload>;
          };
          findFirst: {
            args: Prisma.payment_historyFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_historyPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.payment_historyFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_historyPayload>;
          };
          findMany: {
            args: Prisma.payment_historyFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_historyPayload>[];
          };
          create: {
            args: Prisma.payment_historyCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_historyPayload>;
          };
          createMany: {
            args: Prisma.payment_historyCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.payment_historyCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_historyPayload>[];
          };
          delete: {
            args: Prisma.payment_historyDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_historyPayload>;
          };
          update: {
            args: Prisma.payment_historyUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_historyPayload>;
          };
          deleteMany: {
            args: Prisma.payment_historyDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.payment_historyUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.payment_historyUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_historyPayload>[];
          };
          upsert: {
            args: Prisma.payment_historyUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_historyPayload>;
          };
          aggregate: {
            args: Prisma.Payment_historyAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePayment_history>;
          };
          groupBy: {
            args: Prisma.payment_historyGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Payment_historyGroupByOutputType>[];
          };
          count: {
            args: Prisma.payment_historyCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Payment_historyCountAggregateOutputType>
              | number;
          };
        };
      };
      permissions: {
        payload: Prisma.$permissionsPayload<ExtArgs>;
        fields: Prisma.permissionsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.permissionsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.permissionsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>;
          };
          findFirst: {
            args: Prisma.permissionsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.permissionsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>;
          };
          findMany: {
            args: Prisma.permissionsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>[];
          };
          create: {
            args: Prisma.permissionsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>;
          };
          createMany: {
            args: Prisma.permissionsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.permissionsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>[];
          };
          delete: {
            args: Prisma.permissionsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>;
          };
          update: {
            args: Prisma.permissionsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>;
          };
          deleteMany: {
            args: Prisma.permissionsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.permissionsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.permissionsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>[];
          };
          upsert: {
            args: Prisma.permissionsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>;
          };
          aggregate: {
            args: Prisma.PermissionsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePermissions>;
          };
          groupBy: {
            args: Prisma.permissionsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PermissionsGroupByOutputType>[];
          };
          count: {
            args: Prisma.permissionsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<PermissionsCountAggregateOutputType>
              | number;
          };
        };
      };
      portfolio: {
        payload: Prisma.$portfolioPayload<ExtArgs>;
        fields: Prisma.portfolioFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.portfolioFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolioPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.portfolioFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolioPayload>;
          };
          findFirst: {
            args: Prisma.portfolioFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolioPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.portfolioFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolioPayload>;
          };
          findMany: {
            args: Prisma.portfolioFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolioPayload>[];
          };
          create: {
            args: Prisma.portfolioCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolioPayload>;
          };
          createMany: {
            args: Prisma.portfolioCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.portfolioCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolioPayload>[];
          };
          delete: {
            args: Prisma.portfolioDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolioPayload>;
          };
          update: {
            args: Prisma.portfolioUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolioPayload>;
          };
          deleteMany: {
            args: Prisma.portfolioDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.portfolioUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.portfolioUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolioPayload>[];
          };
          upsert: {
            args: Prisma.portfolioUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolioPayload>;
          };
          aggregate: {
            args: Prisma.PortfolioAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePortfolio>;
          };
          groupBy: {
            args: Prisma.portfolioGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PortfolioGroupByOutputType>[];
          };
          count: {
            args: Prisma.portfolioCountArgs<ExtArgs>;
            result: $Utils.Optional<PortfolioCountAggregateOutputType> | number;
          };
        };
      };
      portfolio_holdings: {
        payload: Prisma.$portfolio_holdingsPayload<ExtArgs>;
        fields: Prisma.portfolio_holdingsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.portfolio_holdingsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_holdingsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.portfolio_holdingsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_holdingsPayload>;
          };
          findFirst: {
            args: Prisma.portfolio_holdingsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_holdingsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.portfolio_holdingsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_holdingsPayload>;
          };
          findMany: {
            args: Prisma.portfolio_holdingsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_holdingsPayload>[];
          };
          create: {
            args: Prisma.portfolio_holdingsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_holdingsPayload>;
          };
          createMany: {
            args: Prisma.portfolio_holdingsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.portfolio_holdingsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_holdingsPayload>[];
          };
          delete: {
            args: Prisma.portfolio_holdingsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_holdingsPayload>;
          };
          update: {
            args: Prisma.portfolio_holdingsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_holdingsPayload>;
          };
          deleteMany: {
            args: Prisma.portfolio_holdingsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.portfolio_holdingsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.portfolio_holdingsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_holdingsPayload>[];
          };
          upsert: {
            args: Prisma.portfolio_holdingsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_holdingsPayload>;
          };
          aggregate: {
            args: Prisma.Portfolio_holdingsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePortfolio_holdings>;
          };
          groupBy: {
            args: Prisma.portfolio_holdingsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Portfolio_holdingsGroupByOutputType>[];
          };
          count: {
            args: Prisma.portfolio_holdingsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Portfolio_holdingsCountAggregateOutputType>
              | number;
          };
        };
      };
      portfolio_stocks: {
        payload: Prisma.$portfolio_stocksPayload<ExtArgs>;
        fields: Prisma.portfolio_stocksFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.portfolio_stocksFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_stocksPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.portfolio_stocksFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_stocksPayload>;
          };
          findFirst: {
            args: Prisma.portfolio_stocksFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_stocksPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.portfolio_stocksFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_stocksPayload>;
          };
          findMany: {
            args: Prisma.portfolio_stocksFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_stocksPayload>[];
          };
          create: {
            args: Prisma.portfolio_stocksCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_stocksPayload>;
          };
          createMany: {
            args: Prisma.portfolio_stocksCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.portfolio_stocksCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_stocksPayload>[];
          };
          delete: {
            args: Prisma.portfolio_stocksDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_stocksPayload>;
          };
          update: {
            args: Prisma.portfolio_stocksUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_stocksPayload>;
          };
          deleteMany: {
            args: Prisma.portfolio_stocksDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.portfolio_stocksUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.portfolio_stocksUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_stocksPayload>[];
          };
          upsert: {
            args: Prisma.portfolio_stocksUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$portfolio_stocksPayload>;
          };
          aggregate: {
            args: Prisma.Portfolio_stocksAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePortfolio_stocks>;
          };
          groupBy: {
            args: Prisma.portfolio_stocksGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Portfolio_stocksGroupByOutputType>[];
          };
          count: {
            args: Prisma.portfolio_stocksCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Portfolio_stocksCountAggregateOutputType>
              | number;
          };
        };
      };
      price_alerts: {
        payload: Prisma.$price_alertsPayload<ExtArgs>;
        fields: Prisma.price_alertsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.price_alertsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$price_alertsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.price_alertsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$price_alertsPayload>;
          };
          findFirst: {
            args: Prisma.price_alertsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$price_alertsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.price_alertsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$price_alertsPayload>;
          };
          findMany: {
            args: Prisma.price_alertsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$price_alertsPayload>[];
          };
          create: {
            args: Prisma.price_alertsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$price_alertsPayload>;
          };
          createMany: {
            args: Prisma.price_alertsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.price_alertsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$price_alertsPayload>[];
          };
          delete: {
            args: Prisma.price_alertsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$price_alertsPayload>;
          };
          update: {
            args: Prisma.price_alertsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$price_alertsPayload>;
          };
          deleteMany: {
            args: Prisma.price_alertsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.price_alertsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.price_alertsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$price_alertsPayload>[];
          };
          upsert: {
            args: Prisma.price_alertsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$price_alertsPayload>;
          };
          aggregate: {
            args: Prisma.Price_alertsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePrice_alerts>;
          };
          groupBy: {
            args: Prisma.price_alertsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Price_alertsGroupByOutputType>[];
          };
          count: {
            args: Prisma.price_alertsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Price_alertsCountAggregateOutputType>
              | number;
          };
        };
      };
      promotion_articles: {
        payload: Prisma.$promotion_articlesPayload<ExtArgs>;
        fields: Prisma.promotion_articlesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.promotion_articlesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$promotion_articlesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.promotion_articlesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$promotion_articlesPayload>;
          };
          findFirst: {
            args: Prisma.promotion_articlesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$promotion_articlesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.promotion_articlesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$promotion_articlesPayload>;
          };
          findMany: {
            args: Prisma.promotion_articlesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$promotion_articlesPayload>[];
          };
          create: {
            args: Prisma.promotion_articlesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$promotion_articlesPayload>;
          };
          createMany: {
            args: Prisma.promotion_articlesCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.promotion_articlesCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$promotion_articlesPayload>[];
          };
          delete: {
            args: Prisma.promotion_articlesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$promotion_articlesPayload>;
          };
          update: {
            args: Prisma.promotion_articlesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$promotion_articlesPayload>;
          };
          deleteMany: {
            args: Prisma.promotion_articlesDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.promotion_articlesUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.promotion_articlesUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$promotion_articlesPayload>[];
          };
          upsert: {
            args: Prisma.promotion_articlesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$promotion_articlesPayload>;
          };
          aggregate: {
            args: Prisma.Promotion_articlesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePromotion_articles>;
          };
          groupBy: {
            args: Prisma.promotion_articlesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Promotion_articlesGroupByOutputType>[];
          };
          count: {
            args: Prisma.promotion_articlesCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Promotion_articlesCountAggregateOutputType>
              | number;
          };
        };
      };
      stock_news: {
        payload: Prisma.$stock_newsPayload<ExtArgs>;
        fields: Prisma.stock_newsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.stock_newsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_newsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.stock_newsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_newsPayload>;
          };
          findFirst: {
            args: Prisma.stock_newsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_newsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.stock_newsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_newsPayload>;
          };
          findMany: {
            args: Prisma.stock_newsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_newsPayload>[];
          };
          create: {
            args: Prisma.stock_newsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_newsPayload>;
          };
          createMany: {
            args: Prisma.stock_newsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.stock_newsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_newsPayload>[];
          };
          delete: {
            args: Prisma.stock_newsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_newsPayload>;
          };
          update: {
            args: Prisma.stock_newsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_newsPayload>;
          };
          deleteMany: {
            args: Prisma.stock_newsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.stock_newsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.stock_newsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_newsPayload>[];
          };
          upsert: {
            args: Prisma.stock_newsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_newsPayload>;
          };
          aggregate: {
            args: Prisma.Stock_newsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateStock_news>;
          };
          groupBy: {
            args: Prisma.stock_newsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Stock_newsGroupByOutputType>[];
          };
          count: {
            args: Prisma.stock_newsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Stock_newsCountAggregateOutputType>
              | number;
          };
        };
      };
      stock_news_read_history: {
        payload: Prisma.$stock_news_read_historyPayload<ExtArgs>;
        fields: Prisma.stock_news_read_historyFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.stock_news_read_historyFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_read_historyPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.stock_news_read_historyFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_read_historyPayload>;
          };
          findFirst: {
            args: Prisma.stock_news_read_historyFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_read_historyPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.stock_news_read_historyFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_read_historyPayload>;
          };
          findMany: {
            args: Prisma.stock_news_read_historyFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_read_historyPayload>[];
          };
          create: {
            args: Prisma.stock_news_read_historyCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_read_historyPayload>;
          };
          createMany: {
            args: Prisma.stock_news_read_historyCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.stock_news_read_historyCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_read_historyPayload>[];
          };
          delete: {
            args: Prisma.stock_news_read_historyDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_read_historyPayload>;
          };
          update: {
            args: Prisma.stock_news_read_historyUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_read_historyPayload>;
          };
          deleteMany: {
            args: Prisma.stock_news_read_historyDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.stock_news_read_historyUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.stock_news_read_historyUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_read_historyPayload>[];
          };
          upsert: {
            args: Prisma.stock_news_read_historyUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_read_historyPayload>;
          };
          aggregate: {
            args: Prisma.Stock_news_read_historyAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateStock_news_read_history>;
          };
          groupBy: {
            args: Prisma.stock_news_read_historyGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Stock_news_read_historyGroupByOutputType>[];
          };
          count: {
            args: Prisma.stock_news_read_historyCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Stock_news_read_historyCountAggregateOutputType>
              | number;
          };
        };
      };
      stock_news_related_symbols: {
        payload: Prisma.$stock_news_related_symbolsPayload<ExtArgs>;
        fields: Prisma.stock_news_related_symbolsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.stock_news_related_symbolsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_related_symbolsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.stock_news_related_symbolsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_related_symbolsPayload>;
          };
          findFirst: {
            args: Prisma.stock_news_related_symbolsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_related_symbolsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.stock_news_related_symbolsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_related_symbolsPayload>;
          };
          findMany: {
            args: Prisma.stock_news_related_symbolsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_related_symbolsPayload>[];
          };
          create: {
            args: Prisma.stock_news_related_symbolsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_related_symbolsPayload>;
          };
          createMany: {
            args: Prisma.stock_news_related_symbolsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.stock_news_related_symbolsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_related_symbolsPayload>[];
          };
          delete: {
            args: Prisma.stock_news_related_symbolsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_related_symbolsPayload>;
          };
          update: {
            args: Prisma.stock_news_related_symbolsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_related_symbolsPayload>;
          };
          deleteMany: {
            args: Prisma.stock_news_related_symbolsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.stock_news_related_symbolsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.stock_news_related_symbolsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_related_symbolsPayload>[];
          };
          upsert: {
            args: Prisma.stock_news_related_symbolsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_related_symbolsPayload>;
          };
          aggregate: {
            args: Prisma.Stock_news_related_symbolsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateStock_news_related_symbols>;
          };
          groupBy: {
            args: Prisma.stock_news_related_symbolsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Stock_news_related_symbolsGroupByOutputType>[];
          };
          count: {
            args: Prisma.stock_news_related_symbolsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Stock_news_related_symbolsCountAggregateOutputType>
              | number;
          };
        };
      };
      stock_news_translation: {
        payload: Prisma.$stock_news_translationPayload<ExtArgs>;
        fields: Prisma.stock_news_translationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.stock_news_translationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_translationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.stock_news_translationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_translationPayload>;
          };
          findFirst: {
            args: Prisma.stock_news_translationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_translationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.stock_news_translationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_translationPayload>;
          };
          findMany: {
            args: Prisma.stock_news_translationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_translationPayload>[];
          };
          create: {
            args: Prisma.stock_news_translationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_translationPayload>;
          };
          createMany: {
            args: Prisma.stock_news_translationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.stock_news_translationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_translationPayload>[];
          };
          delete: {
            args: Prisma.stock_news_translationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_translationPayload>;
          };
          update: {
            args: Prisma.stock_news_translationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_translationPayload>;
          };
          deleteMany: {
            args: Prisma.stock_news_translationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.stock_news_translationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.stock_news_translationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_translationPayload>[];
          };
          upsert: {
            args: Prisma.stock_news_translationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$stock_news_translationPayload>;
          };
          aggregate: {
            args: Prisma.Stock_news_translationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateStock_news_translation>;
          };
          groupBy: {
            args: Prisma.stock_news_translationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Stock_news_translationGroupByOutputType>[];
          };
          count: {
            args: Prisma.stock_news_translationCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Stock_news_translationCountAggregateOutputType>
              | number;
          };
        };
      };
      subscriptions: {
        payload: Prisma.$subscriptionsPayload<ExtArgs>;
        fields: Prisma.subscriptionsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.subscriptionsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.subscriptionsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>;
          };
          findFirst: {
            args: Prisma.subscriptionsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.subscriptionsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>;
          };
          findMany: {
            args: Prisma.subscriptionsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[];
          };
          create: {
            args: Prisma.subscriptionsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>;
          };
          createMany: {
            args: Prisma.subscriptionsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.subscriptionsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[];
          };
          delete: {
            args: Prisma.subscriptionsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>;
          };
          update: {
            args: Prisma.subscriptionsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>;
          };
          deleteMany: {
            args: Prisma.subscriptionsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.subscriptionsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.subscriptionsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[];
          };
          upsert: {
            args: Prisma.subscriptionsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>;
          };
          aggregate: {
            args: Prisma.SubscriptionsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSubscriptions>;
          };
          groupBy: {
            args: Prisma.subscriptionsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SubscriptionsGroupByOutputType>[];
          };
          count: {
            args: Prisma.subscriptionsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<SubscriptionsCountAggregateOutputType>
              | number;
          };
        };
      };
      superinvestor_holdings: {
        payload: Prisma.$superinvestor_holdingsPayload<ExtArgs>;
        fields: Prisma.superinvestor_holdingsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.superinvestor_holdingsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdingsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.superinvestor_holdingsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdingsPayload>;
          };
          findFirst: {
            args: Prisma.superinvestor_holdingsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdingsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.superinvestor_holdingsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdingsPayload>;
          };
          findMany: {
            args: Prisma.superinvestor_holdingsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdingsPayload>[];
          };
          create: {
            args: Prisma.superinvestor_holdingsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdingsPayload>;
          };
          createMany: {
            args: Prisma.superinvestor_holdingsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.superinvestor_holdingsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdingsPayload>[];
          };
          delete: {
            args: Prisma.superinvestor_holdingsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdingsPayload>;
          };
          update: {
            args: Prisma.superinvestor_holdingsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdingsPayload>;
          };
          deleteMany: {
            args: Prisma.superinvestor_holdingsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.superinvestor_holdingsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.superinvestor_holdingsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdingsPayload>[];
          };
          upsert: {
            args: Prisma.superinvestor_holdingsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdingsPayload>;
          };
          aggregate: {
            args: Prisma.Superinvestor_holdingsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSuperinvestor_holdings>;
          };
          groupBy: {
            args: Prisma.superinvestor_holdingsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Superinvestor_holdingsGroupByOutputType>[];
          };
          count: {
            args: Prisma.superinvestor_holdingsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Superinvestor_holdingsCountAggregateOutputType>
              | number;
          };
        };
      };
      superinvestor_holdings_list: {
        payload: Prisma.$superinvestor_holdings_listPayload<ExtArgs>;
        fields: Prisma.superinvestor_holdings_listFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.superinvestor_holdings_listFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdings_listPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.superinvestor_holdings_listFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdings_listPayload>;
          };
          findFirst: {
            args: Prisma.superinvestor_holdings_listFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdings_listPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.superinvestor_holdings_listFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdings_listPayload>;
          };
          findMany: {
            args: Prisma.superinvestor_holdings_listFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdings_listPayload>[];
          };
          create: {
            args: Prisma.superinvestor_holdings_listCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdings_listPayload>;
          };
          createMany: {
            args: Prisma.superinvestor_holdings_listCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.superinvestor_holdings_listCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdings_listPayload>[];
          };
          delete: {
            args: Prisma.superinvestor_holdings_listDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdings_listPayload>;
          };
          update: {
            args: Prisma.superinvestor_holdings_listUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdings_listPayload>;
          };
          deleteMany: {
            args: Prisma.superinvestor_holdings_listDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.superinvestor_holdings_listUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.superinvestor_holdings_listUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdings_listPayload>[];
          };
          upsert: {
            args: Prisma.superinvestor_holdings_listUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_holdings_listPayload>;
          };
          aggregate: {
            args: Prisma.Superinvestor_holdings_listAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSuperinvestor_holdings_list>;
          };
          groupBy: {
            args: Prisma.superinvestor_holdings_listGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Superinvestor_holdings_listGroupByOutputType>[];
          };
          count: {
            args: Prisma.superinvestor_holdings_listCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Superinvestor_holdings_listCountAggregateOutputType>
              | number;
          };
        };
      };
      superinvestor_sector_analysis: {
        payload: Prisma.$superinvestor_sector_analysisPayload<ExtArgs>;
        fields: Prisma.superinvestor_sector_analysisFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.superinvestor_sector_analysisFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_sector_analysisPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.superinvestor_sector_analysisFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_sector_analysisPayload>;
          };
          findFirst: {
            args: Prisma.superinvestor_sector_analysisFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_sector_analysisPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.superinvestor_sector_analysisFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_sector_analysisPayload>;
          };
          findMany: {
            args: Prisma.superinvestor_sector_analysisFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_sector_analysisPayload>[];
          };
          create: {
            args: Prisma.superinvestor_sector_analysisCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_sector_analysisPayload>;
          };
          createMany: {
            args: Prisma.superinvestor_sector_analysisCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.superinvestor_sector_analysisCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_sector_analysisPayload>[];
          };
          delete: {
            args: Prisma.superinvestor_sector_analysisDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_sector_analysisPayload>;
          };
          update: {
            args: Prisma.superinvestor_sector_analysisUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_sector_analysisPayload>;
          };
          deleteMany: {
            args: Prisma.superinvestor_sector_analysisDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.superinvestor_sector_analysisUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.superinvestor_sector_analysisUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_sector_analysisPayload>[];
          };
          upsert: {
            args: Prisma.superinvestor_sector_analysisUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$superinvestor_sector_analysisPayload>;
          };
          aggregate: {
            args: Prisma.Superinvestor_sector_analysisAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSuperinvestor_sector_analysis>;
          };
          groupBy: {
            args: Prisma.superinvestor_sector_analysisGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Superinvestor_sector_analysisGroupByOutputType>[];
          };
          count: {
            args: Prisma.superinvestor_sector_analysisCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Superinvestor_sector_analysisCountAggregateOutputType>
              | number;
          };
        };
      };
      symbol: {
        payload: Prisma.$symbolPayload<ExtArgs>;
        fields: Prisma.symbolFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.symbolFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$symbolPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.symbolFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$symbolPayload>;
          };
          findFirst: {
            args: Prisma.symbolFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$symbolPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.symbolFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$symbolPayload>;
          };
          findMany: {
            args: Prisma.symbolFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$symbolPayload>[];
          };
          create: {
            args: Prisma.symbolCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$symbolPayload>;
          };
          createMany: {
            args: Prisma.symbolCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.symbolCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$symbolPayload>[];
          };
          delete: {
            args: Prisma.symbolDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$symbolPayload>;
          };
          update: {
            args: Prisma.symbolUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$symbolPayload>;
          };
          deleteMany: {
            args: Prisma.symbolDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.symbolUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.symbolUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$symbolPayload>[];
          };
          upsert: {
            args: Prisma.symbolUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$symbolPayload>;
          };
          aggregate: {
            args: Prisma.SymbolAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSymbol>;
          };
          groupBy: {
            args: Prisma.symbolGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SymbolGroupByOutputType>[];
          };
          count: {
            args: Prisma.symbolCountArgs<ExtArgs>;
            result: $Utils.Optional<SymbolCountAggregateOutputType> | number;
          };
        };
      };
      user_devices: {
        payload: Prisma.$user_devicesPayload<ExtArgs>;
        fields: Prisma.user_devicesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.user_devicesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.user_devicesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>;
          };
          findFirst: {
            args: Prisma.user_devicesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.user_devicesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>;
          };
          findMany: {
            args: Prisma.user_devicesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>[];
          };
          create: {
            args: Prisma.user_devicesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>;
          };
          createMany: {
            args: Prisma.user_devicesCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.user_devicesCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>[];
          };
          delete: {
            args: Prisma.user_devicesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>;
          };
          update: {
            args: Prisma.user_devicesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>;
          };
          deleteMany: {
            args: Prisma.user_devicesDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.user_devicesUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.user_devicesUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>[];
          };
          upsert: {
            args: Prisma.user_devicesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>;
          };
          aggregate: {
            args: Prisma.User_devicesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser_devices>;
          };
          groupBy: {
            args: Prisma.user_devicesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<User_devicesGroupByOutputType>[];
          };
          count: {
            args: Prisma.user_devicesCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<User_devicesCountAggregateOutputType>
              | number;
          };
        };
      };
      user_subscriptions: {
        payload: Prisma.$user_subscriptionsPayload<ExtArgs>;
        fields: Prisma.user_subscriptionsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.user_subscriptionsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_subscriptionsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.user_subscriptionsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_subscriptionsPayload>;
          };
          findFirst: {
            args: Prisma.user_subscriptionsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_subscriptionsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.user_subscriptionsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_subscriptionsPayload>;
          };
          findMany: {
            args: Prisma.user_subscriptionsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_subscriptionsPayload>[];
          };
          create: {
            args: Prisma.user_subscriptionsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_subscriptionsPayload>;
          };
          createMany: {
            args: Prisma.user_subscriptionsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.user_subscriptionsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_subscriptionsPayload>[];
          };
          delete: {
            args: Prisma.user_subscriptionsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_subscriptionsPayload>;
          };
          update: {
            args: Prisma.user_subscriptionsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_subscriptionsPayload>;
          };
          deleteMany: {
            args: Prisma.user_subscriptionsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.user_subscriptionsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.user_subscriptionsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_subscriptionsPayload>[];
          };
          upsert: {
            args: Prisma.user_subscriptionsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$user_subscriptionsPayload>;
          };
          aggregate: {
            args: Prisma.User_subscriptionsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser_subscriptions>;
          };
          groupBy: {
            args: Prisma.user_subscriptionsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<User_subscriptionsGroupByOutputType>[];
          };
          count: {
            args: Prisma.user_subscriptionsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<User_subscriptionsCountAggregateOutputType>
              | number;
          };
        };
      };
      users: {
        payload: Prisma.$usersPayload<ExtArgs>;
        fields: Prisma.usersFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>;
          };
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>;
          };
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[];
          };
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>;
          };
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[];
          };
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>;
          };
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>;
          };
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[];
          };
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>;
          };
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUsers>;
          };
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UsersGroupByOutputType>[];
          };
          count: {
            args: Prisma.usersCountArgs<ExtArgs>;
            result: $Utils.Optional<UsersCountAggregateOutputType> | number;
          };
        };
      };
      watchlist_items: {
        payload: Prisma.$watchlist_itemsPayload<ExtArgs>;
        fields: Prisma.watchlist_itemsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.watchlist_itemsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlist_itemsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.watchlist_itemsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlist_itemsPayload>;
          };
          findFirst: {
            args: Prisma.watchlist_itemsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlist_itemsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.watchlist_itemsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlist_itemsPayload>;
          };
          findMany: {
            args: Prisma.watchlist_itemsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlist_itemsPayload>[];
          };
          create: {
            args: Prisma.watchlist_itemsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlist_itemsPayload>;
          };
          createMany: {
            args: Prisma.watchlist_itemsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.watchlist_itemsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlist_itemsPayload>[];
          };
          delete: {
            args: Prisma.watchlist_itemsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlist_itemsPayload>;
          };
          update: {
            args: Prisma.watchlist_itemsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlist_itemsPayload>;
          };
          deleteMany: {
            args: Prisma.watchlist_itemsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.watchlist_itemsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.watchlist_itemsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlist_itemsPayload>[];
          };
          upsert: {
            args: Prisma.watchlist_itemsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlist_itemsPayload>;
          };
          aggregate: {
            args: Prisma.Watchlist_itemsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateWatchlist_items>;
          };
          groupBy: {
            args: Prisma.watchlist_itemsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Watchlist_itemsGroupByOutputType>[];
          };
          count: {
            args: Prisma.watchlist_itemsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Watchlist_itemsCountAggregateOutputType>
              | number;
          };
        };
      };
      watchlists: {
        payload: Prisma.$watchlistsPayload<ExtArgs>;
        fields: Prisma.watchlistsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.watchlistsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlistsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.watchlistsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlistsPayload>;
          };
          findFirst: {
            args: Prisma.watchlistsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlistsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.watchlistsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlistsPayload>;
          };
          findMany: {
            args: Prisma.watchlistsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlistsPayload>[];
          };
          create: {
            args: Prisma.watchlistsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlistsPayload>;
          };
          createMany: {
            args: Prisma.watchlistsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.watchlistsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlistsPayload>[];
          };
          delete: {
            args: Prisma.watchlistsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlistsPayload>;
          };
          update: {
            args: Prisma.watchlistsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlistsPayload>;
          };
          deleteMany: {
            args: Prisma.watchlistsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.watchlistsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.watchlistsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlistsPayload>[];
          };
          upsert: {
            args: Prisma.watchlistsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$watchlistsPayload>;
          };
          aggregate: {
            args: Prisma.WatchlistsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateWatchlists>;
          };
          groupBy: {
            args: Prisma.watchlistsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<WatchlistsGroupByOutputType>[];
          };
          count: {
            args: Prisma.watchlistsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<WatchlistsCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory;
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string;
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[];
  }
  export type GlobalOmitConfig = {
    app_problem_report?: app_problem_reportOmit;
    app_version_support?: app_version_supportOmit;
    comments?: commentsOmit;
    in_app_announcements?: in_app_announcementsOmit;
    investment_insights?: investment_insightsOmit;
    market_recap?: market_recapOmit;
    news_comments?: news_commentsOmit;
    news_config?: news_configOmit;
    payment_history?: payment_historyOmit;
    permissions?: permissionsOmit;
    portfolio?: portfolioOmit;
    portfolio_holdings?: portfolio_holdingsOmit;
    portfolio_stocks?: portfolio_stocksOmit;
    price_alerts?: price_alertsOmit;
    promotion_articles?: promotion_articlesOmit;
    stock_news?: stock_newsOmit;
    stock_news_read_history?: stock_news_read_historyOmit;
    stock_news_related_symbols?: stock_news_related_symbolsOmit;
    stock_news_translation?: stock_news_translationOmit;
    subscriptions?: subscriptionsOmit;
    superinvestor_holdings?: superinvestor_holdingsOmit;
    superinvestor_holdings_list?: superinvestor_holdings_listOmit;
    superinvestor_sector_analysis?: superinvestor_sector_analysisOmit;
    symbol?: symbolOmit;
    user_devices?: user_devicesOmit;
    user_subscriptions?: user_subscriptionsOmit;
    users?: usersOmit;
    watchlist_items?: watchlist_itemsOmit;
    watchlists?: watchlistsOmit;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type CommentsCountOutputType
   */

  export type CommentsCountOutputType = {
    other_comments: number;
  };

  export type CommentsCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    other_comments?: boolean | CommentsCountOutputTypeCountOther_commentsArgs;
  };

  // Custom InputTypes
  /**
   * CommentsCountOutputType without action
   */
  export type CommentsCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CommentsCountOutputType
     */
    select?: CommentsCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CommentsCountOutputType without action
   */
  export type CommentsCountOutputTypeCountOther_commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: commentsWhereInput;
  };

  /**
   * Count Type News_commentsCountOutputType
   */

  export type News_commentsCountOutputType = {
    other_news_comments: number;
  };

  export type News_commentsCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    other_news_comments?:
      | boolean
      | News_commentsCountOutputTypeCountOther_news_commentsArgs;
  };

  // Custom InputTypes
  /**
   * News_commentsCountOutputType without action
   */
  export type News_commentsCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the News_commentsCountOutputType
     */
    select?: News_commentsCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * News_commentsCountOutputType without action
   */
  export type News_commentsCountOutputTypeCountOther_news_commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: news_commentsWhereInput;
  };

  /**
   * Count Type Stock_newsCountOutputType
   */

  export type Stock_newsCountOutputType = {
    news_comments: number;
    stock_news_read_history: number;
    stock_news_related_symbols: number;
    stock_news_translation: number;
  };

  export type Stock_newsCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    news_comments?: boolean | Stock_newsCountOutputTypeCountNews_commentsArgs;
    stock_news_read_history?:
      | boolean
      | Stock_newsCountOutputTypeCountStock_news_read_historyArgs;
    stock_news_related_symbols?:
      | boolean
      | Stock_newsCountOutputTypeCountStock_news_related_symbolsArgs;
    stock_news_translation?:
      | boolean
      | Stock_newsCountOutputTypeCountStock_news_translationArgs;
  };

  // Custom InputTypes
  /**
   * Stock_newsCountOutputType without action
   */
  export type Stock_newsCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Stock_newsCountOutputType
     */
    select?: Stock_newsCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * Stock_newsCountOutputType without action
   */
  export type Stock_newsCountOutputTypeCountNews_commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: news_commentsWhereInput;
  };

  /**
   * Stock_newsCountOutputType without action
   */
  export type Stock_newsCountOutputTypeCountStock_news_read_historyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: stock_news_read_historyWhereInput;
  };

  /**
   * Stock_newsCountOutputType without action
   */
  export type Stock_newsCountOutputTypeCountStock_news_related_symbolsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: stock_news_related_symbolsWhereInput;
  };

  /**
   * Stock_newsCountOutputType without action
   */
  export type Stock_newsCountOutputTypeCountStock_news_translationArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: stock_news_translationWhereInput;
  };

  /**
   * Count Type SubscriptionsCountOutputType
   */

  export type SubscriptionsCountOutputType = {
    permissions: number;
    user_subscriptions: number;
  };

  export type SubscriptionsCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    permissions?: boolean | SubscriptionsCountOutputTypeCountPermissionsArgs;
    user_subscriptions?:
      | boolean
      | SubscriptionsCountOutputTypeCountUser_subscriptionsArgs;
  };

  // Custom InputTypes
  /**
   * SubscriptionsCountOutputType without action
   */
  export type SubscriptionsCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the SubscriptionsCountOutputType
     */
    select?: SubscriptionsCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * SubscriptionsCountOutputType without action
   */
  export type SubscriptionsCountOutputTypeCountPermissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: permissionsWhereInput;
  };

  /**
   * SubscriptionsCountOutputType without action
   */
  export type SubscriptionsCountOutputTypeCountUser_subscriptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: user_subscriptionsWhereInput;
  };

  /**
   * Count Type Superinvestor_holdingsCountOutputType
   */

  export type Superinvestor_holdingsCountOutputType = {
    superinvestor_holdings_list: number;
    superinvestor_sector_analysis: number;
  };

  export type Superinvestor_holdingsCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    superinvestor_holdings_list?:
      | boolean
      | Superinvestor_holdingsCountOutputTypeCountSuperinvestor_holdings_listArgs;
    superinvestor_sector_analysis?:
      | boolean
      | Superinvestor_holdingsCountOutputTypeCountSuperinvestor_sector_analysisArgs;
  };

  // Custom InputTypes
  /**
   * Superinvestor_holdingsCountOutputType without action
   */
  export type Superinvestor_holdingsCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Superinvestor_holdingsCountOutputType
     */
    select?: Superinvestor_holdingsCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * Superinvestor_holdingsCountOutputType without action
   */
  export type Superinvestor_holdingsCountOutputTypeCountSuperinvestor_holdings_listArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: superinvestor_holdings_listWhereInput;
  };

  /**
   * Superinvestor_holdingsCountOutputType without action
   */
  export type Superinvestor_holdingsCountOutputTypeCountSuperinvestor_sector_analysisArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: superinvestor_sector_analysisWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model app_problem_report
   */

  export type AggregateApp_problem_report = {
    _count: App_problem_reportCountAggregateOutputType | null;
    _min: App_problem_reportMinAggregateOutputType | null;
    _max: App_problem_reportMaxAggregateOutputType | null;
  };

  export type App_problem_reportMinAggregateOutputType = {
    id: string | null;
    topic: string | null;
    details: string | null;
    status: string | null;
    updated_at: Date | null;
    created_at: Date | null;
  };

  export type App_problem_reportMaxAggregateOutputType = {
    id: string | null;
    topic: string | null;
    details: string | null;
    status: string | null;
    updated_at: Date | null;
    created_at: Date | null;
  };

  export type App_problem_reportCountAggregateOutputType = {
    id: number;
    topic: number;
    details: number;
    status: number;
    updated_at: number;
    created_at: number;
    _all: number;
  };

  export type App_problem_reportMinAggregateInputType = {
    id?: true;
    topic?: true;
    details?: true;
    status?: true;
    updated_at?: true;
    created_at?: true;
  };

  export type App_problem_reportMaxAggregateInputType = {
    id?: true;
    topic?: true;
    details?: true;
    status?: true;
    updated_at?: true;
    created_at?: true;
  };

  export type App_problem_reportCountAggregateInputType = {
    id?: true;
    topic?: true;
    details?: true;
    status?: true;
    updated_at?: true;
    created_at?: true;
    _all?: true;
  };

  export type App_problem_reportAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which app_problem_report to aggregate.
     */
    where?: app_problem_reportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of app_problem_reports to fetch.
     */
    orderBy?:
      | app_problem_reportOrderByWithRelationInput
      | app_problem_reportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: app_problem_reportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` app_problem_reports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` app_problem_reports.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned app_problem_reports
     **/
    _count?: true | App_problem_reportCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: App_problem_reportMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: App_problem_reportMaxAggregateInputType;
  };

  export type GetApp_problem_reportAggregateType<
    T extends App_problem_reportAggregateArgs
  > = {
    [P in keyof T & keyof AggregateApp_problem_report]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_problem_report[P]>
      : GetScalarType<T[P], AggregateApp_problem_report[P]>;
  };

  export type app_problem_reportGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: app_problem_reportWhereInput;
    orderBy?:
      | app_problem_reportOrderByWithAggregationInput
      | app_problem_reportOrderByWithAggregationInput[];
    by: App_problem_reportScalarFieldEnum[] | App_problem_reportScalarFieldEnum;
    having?: app_problem_reportScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: App_problem_reportCountAggregateInputType | true;
    _min?: App_problem_reportMinAggregateInputType;
    _max?: App_problem_reportMaxAggregateInputType;
  };

  export type App_problem_reportGroupByOutputType = {
    id: string;
    topic: string | null;
    details: string | null;
    status: string | null;
    updated_at: Date | null;
    created_at: Date | null;
    _count: App_problem_reportCountAggregateOutputType | null;
    _min: App_problem_reportMinAggregateOutputType | null;
    _max: App_problem_reportMaxAggregateOutputType | null;
  };

  type GetApp_problem_reportGroupByPayload<
    T extends app_problem_reportGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_problem_reportGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof App_problem_reportGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], App_problem_reportGroupByOutputType[P]>
          : GetScalarType<T[P], App_problem_reportGroupByOutputType[P]>;
      }
    >
  >;

  export type app_problem_reportSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      topic?: boolean;
      details?: boolean;
      status?: boolean;
      updated_at?: boolean;
      created_at?: boolean;
    },
    ExtArgs['result']['app_problem_report']
  >;

  export type app_problem_reportSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      topic?: boolean;
      details?: boolean;
      status?: boolean;
      updated_at?: boolean;
      created_at?: boolean;
    },
    ExtArgs['result']['app_problem_report']
  >;

  export type app_problem_reportSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      topic?: boolean;
      details?: boolean;
      status?: boolean;
      updated_at?: boolean;
      created_at?: boolean;
    },
    ExtArgs['result']['app_problem_report']
  >;

  export type app_problem_reportSelectScalar = {
    id?: boolean;
    topic?: boolean;
    details?: boolean;
    status?: boolean;
    updated_at?: boolean;
    created_at?: boolean;
  };

  export type app_problem_reportOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id' | 'topic' | 'details' | 'status' | 'updated_at' | 'created_at',
    ExtArgs['result']['app_problem_report']
  >;

  export type $app_problem_reportPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'app_problem_report';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        topic: string | null;
        details: string | null;
        status: string | null;
        updated_at: Date | null;
        created_at: Date | null;
      },
      ExtArgs['result']['app_problem_report']
    >;
    composites: {};
  };

  type app_problem_reportGetPayload<
    S extends boolean | null | undefined | app_problem_reportDefaultArgs
  > = $Result.GetResult<Prisma.$app_problem_reportPayload, S>;

  type app_problem_reportCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    app_problem_reportFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: App_problem_reportCountAggregateInputType | true;
  };

  export interface app_problem_reportDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['app_problem_report'];
      meta: { name: 'app_problem_report' };
    };
    /**
     * Find zero or one App_problem_report that matches the filter.
     * @param {app_problem_reportFindUniqueArgs} args - Arguments to find a App_problem_report
     * @example
     * // Get one App_problem_report
     * const app_problem_report = await prisma.app_problem_report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_problem_reportFindUniqueArgs>(
      args: SelectSubset<T, app_problem_reportFindUniqueArgs<ExtArgs>>
    ): Prisma__app_problem_reportClient<
      $Result.GetResult<
        Prisma.$app_problem_reportPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one App_problem_report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {app_problem_reportFindUniqueOrThrowArgs} args - Arguments to find a App_problem_report
     * @example
     * // Get one App_problem_report
     * const app_problem_report = await prisma.app_problem_report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_problem_reportFindUniqueOrThrowArgs>(
      args: SelectSubset<T, app_problem_reportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__app_problem_reportClient<
      $Result.GetResult<
        Prisma.$app_problem_reportPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first App_problem_report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_problem_reportFindFirstArgs} args - Arguments to find a App_problem_report
     * @example
     * // Get one App_problem_report
     * const app_problem_report = await prisma.app_problem_report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_problem_reportFindFirstArgs>(
      args?: SelectSubset<T, app_problem_reportFindFirstArgs<ExtArgs>>
    ): Prisma__app_problem_reportClient<
      $Result.GetResult<
        Prisma.$app_problem_reportPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first App_problem_report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_problem_reportFindFirstOrThrowArgs} args - Arguments to find a App_problem_report
     * @example
     * // Get one App_problem_report
     * const app_problem_report = await prisma.app_problem_report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_problem_reportFindFirstOrThrowArgs>(
      args?: SelectSubset<T, app_problem_reportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__app_problem_reportClient<
      $Result.GetResult<
        Prisma.$app_problem_reportPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more App_problem_reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_problem_reportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_problem_reports
     * const app_problem_reports = await prisma.app_problem_report.findMany()
     *
     * // Get first 10 App_problem_reports
     * const app_problem_reports = await prisma.app_problem_report.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const app_problem_reportWithIdOnly = await prisma.app_problem_report.findMany({ select: { id: true } })
     *
     */
    findMany<T extends app_problem_reportFindManyArgs>(
      args?: SelectSubset<T, app_problem_reportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$app_problem_reportPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a App_problem_report.
     * @param {app_problem_reportCreateArgs} args - Arguments to create a App_problem_report.
     * @example
     * // Create one App_problem_report
     * const App_problem_report = await prisma.app_problem_report.create({
     *   data: {
     *     // ... data to create a App_problem_report
     *   }
     * })
     *
     */
    create<T extends app_problem_reportCreateArgs>(
      args: SelectSubset<T, app_problem_reportCreateArgs<ExtArgs>>
    ): Prisma__app_problem_reportClient<
      $Result.GetResult<
        Prisma.$app_problem_reportPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many App_problem_reports.
     * @param {app_problem_reportCreateManyArgs} args - Arguments to create many App_problem_reports.
     * @example
     * // Create many App_problem_reports
     * const app_problem_report = await prisma.app_problem_report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends app_problem_reportCreateManyArgs>(
      args?: SelectSubset<T, app_problem_reportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many App_problem_reports and returns the data saved in the database.
     * @param {app_problem_reportCreateManyAndReturnArgs} args - Arguments to create many App_problem_reports.
     * @example
     * // Create many App_problem_reports
     * const app_problem_report = await prisma.app_problem_report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many App_problem_reports and only return the `id`
     * const app_problem_reportWithIdOnly = await prisma.app_problem_report.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends app_problem_reportCreateManyAndReturnArgs>(
      args?: SelectSubset<T, app_problem_reportCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$app_problem_reportPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a App_problem_report.
     * @param {app_problem_reportDeleteArgs} args - Arguments to delete one App_problem_report.
     * @example
     * // Delete one App_problem_report
     * const App_problem_report = await prisma.app_problem_report.delete({
     *   where: {
     *     // ... filter to delete one App_problem_report
     *   }
     * })
     *
     */
    delete<T extends app_problem_reportDeleteArgs>(
      args: SelectSubset<T, app_problem_reportDeleteArgs<ExtArgs>>
    ): Prisma__app_problem_reportClient<
      $Result.GetResult<
        Prisma.$app_problem_reportPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one App_problem_report.
     * @param {app_problem_reportUpdateArgs} args - Arguments to update one App_problem_report.
     * @example
     * // Update one App_problem_report
     * const app_problem_report = await prisma.app_problem_report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends app_problem_reportUpdateArgs>(
      args: SelectSubset<T, app_problem_reportUpdateArgs<ExtArgs>>
    ): Prisma__app_problem_reportClient<
      $Result.GetResult<
        Prisma.$app_problem_reportPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more App_problem_reports.
     * @param {app_problem_reportDeleteManyArgs} args - Arguments to filter App_problem_reports to delete.
     * @example
     * // Delete a few App_problem_reports
     * const { count } = await prisma.app_problem_report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends app_problem_reportDeleteManyArgs>(
      args?: SelectSubset<T, app_problem_reportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more App_problem_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_problem_reportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_problem_reports
     * const app_problem_report = await prisma.app_problem_report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends app_problem_reportUpdateManyArgs>(
      args: SelectSubset<T, app_problem_reportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more App_problem_reports and returns the data updated in the database.
     * @param {app_problem_reportUpdateManyAndReturnArgs} args - Arguments to update many App_problem_reports.
     * @example
     * // Update many App_problem_reports
     * const app_problem_report = await prisma.app_problem_report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more App_problem_reports and only return the `id`
     * const app_problem_reportWithIdOnly = await prisma.app_problem_report.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends app_problem_reportUpdateManyAndReturnArgs>(
      args: SelectSubset<T, app_problem_reportUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$app_problem_reportPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one App_problem_report.
     * @param {app_problem_reportUpsertArgs} args - Arguments to update or create a App_problem_report.
     * @example
     * // Update or create a App_problem_report
     * const app_problem_report = await prisma.app_problem_report.upsert({
     *   create: {
     *     // ... data to create a App_problem_report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_problem_report we want to update
     *   }
     * })
     */
    upsert<T extends app_problem_reportUpsertArgs>(
      args: SelectSubset<T, app_problem_reportUpsertArgs<ExtArgs>>
    ): Prisma__app_problem_reportClient<
      $Result.GetResult<
        Prisma.$app_problem_reportPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of App_problem_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_problem_reportCountArgs} args - Arguments to filter App_problem_reports to count.
     * @example
     * // Count the number of App_problem_reports
     * const count = await prisma.app_problem_report.count({
     *   where: {
     *     // ... the filter for the App_problem_reports we want to count
     *   }
     * })
     **/
    count<T extends app_problem_reportCountArgs>(
      args?: Subset<T, app_problem_reportCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              App_problem_reportCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a App_problem_report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_problem_reportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends App_problem_reportAggregateArgs>(
      args: Subset<T, App_problem_reportAggregateArgs>
    ): Prisma.PrismaPromise<GetApp_problem_reportAggregateType<T>>;

    /**
     * Group by App_problem_report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_problem_reportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends app_problem_reportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_problem_reportGroupByArgs['orderBy'] }
        : { orderBy?: app_problem_reportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, app_problem_reportGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetApp_problem_reportGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the app_problem_report model
     */
    readonly fields: app_problem_reportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_problem_report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_problem_reportClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the app_problem_report model
   */
  interface app_problem_reportFieldRefs {
    readonly id: FieldRef<'app_problem_report', 'String'>;
    readonly topic: FieldRef<'app_problem_report', 'String'>;
    readonly details: FieldRef<'app_problem_report', 'String'>;
    readonly status: FieldRef<'app_problem_report', 'String'>;
    readonly updated_at: FieldRef<'app_problem_report', 'DateTime'>;
    readonly created_at: FieldRef<'app_problem_report', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * app_problem_report findUnique
   */
  export type app_problem_reportFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_problem_report
     */
    select?: app_problem_reportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_problem_report
     */
    omit?: app_problem_reportOmit<ExtArgs> | null;
    /**
     * Filter, which app_problem_report to fetch.
     */
    where: app_problem_reportWhereUniqueInput;
  };

  /**
   * app_problem_report findUniqueOrThrow
   */
  export type app_problem_reportFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_problem_report
     */
    select?: app_problem_reportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_problem_report
     */
    omit?: app_problem_reportOmit<ExtArgs> | null;
    /**
     * Filter, which app_problem_report to fetch.
     */
    where: app_problem_reportWhereUniqueInput;
  };

  /**
   * app_problem_report findFirst
   */
  export type app_problem_reportFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_problem_report
     */
    select?: app_problem_reportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_problem_report
     */
    omit?: app_problem_reportOmit<ExtArgs> | null;
    /**
     * Filter, which app_problem_report to fetch.
     */
    where?: app_problem_reportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of app_problem_reports to fetch.
     */
    orderBy?:
      | app_problem_reportOrderByWithRelationInput
      | app_problem_reportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for app_problem_reports.
     */
    cursor?: app_problem_reportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` app_problem_reports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` app_problem_reports.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of app_problem_reports.
     */
    distinct?:
      | App_problem_reportScalarFieldEnum
      | App_problem_reportScalarFieldEnum[];
  };

  /**
   * app_problem_report findFirstOrThrow
   */
  export type app_problem_reportFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_problem_report
     */
    select?: app_problem_reportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_problem_report
     */
    omit?: app_problem_reportOmit<ExtArgs> | null;
    /**
     * Filter, which app_problem_report to fetch.
     */
    where?: app_problem_reportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of app_problem_reports to fetch.
     */
    orderBy?:
      | app_problem_reportOrderByWithRelationInput
      | app_problem_reportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for app_problem_reports.
     */
    cursor?: app_problem_reportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` app_problem_reports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` app_problem_reports.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of app_problem_reports.
     */
    distinct?:
      | App_problem_reportScalarFieldEnum
      | App_problem_reportScalarFieldEnum[];
  };

  /**
   * app_problem_report findMany
   */
  export type app_problem_reportFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_problem_report
     */
    select?: app_problem_reportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_problem_report
     */
    omit?: app_problem_reportOmit<ExtArgs> | null;
    /**
     * Filter, which app_problem_reports to fetch.
     */
    where?: app_problem_reportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of app_problem_reports to fetch.
     */
    orderBy?:
      | app_problem_reportOrderByWithRelationInput
      | app_problem_reportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing app_problem_reports.
     */
    cursor?: app_problem_reportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` app_problem_reports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` app_problem_reports.
     */
    skip?: number;
    distinct?:
      | App_problem_reportScalarFieldEnum
      | App_problem_reportScalarFieldEnum[];
  };

  /**
   * app_problem_report create
   */
  export type app_problem_reportCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_problem_report
     */
    select?: app_problem_reportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_problem_report
     */
    omit?: app_problem_reportOmit<ExtArgs> | null;
    /**
     * The data needed to create a app_problem_report.
     */
    data: XOR<
      app_problem_reportCreateInput,
      app_problem_reportUncheckedCreateInput
    >;
  };

  /**
   * app_problem_report createMany
   */
  export type app_problem_reportCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many app_problem_reports.
     */
    data:
      | app_problem_reportCreateManyInput
      | app_problem_reportCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * app_problem_report createManyAndReturn
   */
  export type app_problem_reportCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_problem_report
     */
    select?: app_problem_reportSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the app_problem_report
     */
    omit?: app_problem_reportOmit<ExtArgs> | null;
    /**
     * The data used to create many app_problem_reports.
     */
    data:
      | app_problem_reportCreateManyInput
      | app_problem_reportCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * app_problem_report update
   */
  export type app_problem_reportUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_problem_report
     */
    select?: app_problem_reportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_problem_report
     */
    omit?: app_problem_reportOmit<ExtArgs> | null;
    /**
     * The data needed to update a app_problem_report.
     */
    data: XOR<
      app_problem_reportUpdateInput,
      app_problem_reportUncheckedUpdateInput
    >;
    /**
     * Choose, which app_problem_report to update.
     */
    where: app_problem_reportWhereUniqueInput;
  };

  /**
   * app_problem_report updateMany
   */
  export type app_problem_reportUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update app_problem_reports.
     */
    data: XOR<
      app_problem_reportUpdateManyMutationInput,
      app_problem_reportUncheckedUpdateManyInput
    >;
    /**
     * Filter which app_problem_reports to update
     */
    where?: app_problem_reportWhereInput;
    /**
     * Limit how many app_problem_reports to update.
     */
    limit?: number;
  };

  /**
   * app_problem_report updateManyAndReturn
   */
  export type app_problem_reportUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_problem_report
     */
    select?: app_problem_reportSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the app_problem_report
     */
    omit?: app_problem_reportOmit<ExtArgs> | null;
    /**
     * The data used to update app_problem_reports.
     */
    data: XOR<
      app_problem_reportUpdateManyMutationInput,
      app_problem_reportUncheckedUpdateManyInput
    >;
    /**
     * Filter which app_problem_reports to update
     */
    where?: app_problem_reportWhereInput;
    /**
     * Limit how many app_problem_reports to update.
     */
    limit?: number;
  };

  /**
   * app_problem_report upsert
   */
  export type app_problem_reportUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_problem_report
     */
    select?: app_problem_reportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_problem_report
     */
    omit?: app_problem_reportOmit<ExtArgs> | null;
    /**
     * The filter to search for the app_problem_report to update in case it exists.
     */
    where: app_problem_reportWhereUniqueInput;
    /**
     * In case the app_problem_report found by the `where` argument doesn't exist, create a new app_problem_report with this data.
     */
    create: XOR<
      app_problem_reportCreateInput,
      app_problem_reportUncheckedCreateInput
    >;
    /**
     * In case the app_problem_report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      app_problem_reportUpdateInput,
      app_problem_reportUncheckedUpdateInput
    >;
  };

  /**
   * app_problem_report delete
   */
  export type app_problem_reportDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_problem_report
     */
    select?: app_problem_reportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_problem_report
     */
    omit?: app_problem_reportOmit<ExtArgs> | null;
    /**
     * Filter which app_problem_report to delete.
     */
    where: app_problem_reportWhereUniqueInput;
  };

  /**
   * app_problem_report deleteMany
   */
  export type app_problem_reportDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which app_problem_reports to delete
     */
    where?: app_problem_reportWhereInput;
    /**
     * Limit how many app_problem_reports to delete.
     */
    limit?: number;
  };

  /**
   * app_problem_report without action
   */
  export type app_problem_reportDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_problem_report
     */
    select?: app_problem_reportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_problem_report
     */
    omit?: app_problem_reportOmit<ExtArgs> | null;
  };

  /**
   * Model app_version_support
   */

  export type AggregateApp_version_support = {
    _count: App_version_supportCountAggregateOutputType | null;
    _avg: App_version_supportAvgAggregateOutputType | null;
    _sum: App_version_supportSumAggregateOutputType | null;
    _min: App_version_supportMinAggregateOutputType | null;
    _max: App_version_supportMaxAggregateOutputType | null;
  };

  export type App_version_supportAvgAggregateOutputType = {
    id: number | null;
    build_number: number | null;
  };

  export type App_version_supportSumAggregateOutputType = {
    id: number | null;
    build_number: number | null;
  };

  export type App_version_supportMinAggregateOutputType = {
    id: number | null;
    version: string | null;
    platform: string | null;
    build_number: number | null;
    status: string | null;
    min_supported_version: string | null;
    is_active: boolean | null;
    critical_update: boolean | null;
    force_update_message: string | null;
    release_notes: string | null;
    download_url: string | null;
    release_date: Date | null;
    deprecation_date: Date | null;
    end_of_support_date: Date | null;
    created_at: Date | null;
    updated_at: Date | null;
  };

  export type App_version_supportMaxAggregateOutputType = {
    id: number | null;
    version: string | null;
    platform: string | null;
    build_number: number | null;
    status: string | null;
    min_supported_version: string | null;
    is_active: boolean | null;
    critical_update: boolean | null;
    force_update_message: string | null;
    release_notes: string | null;
    download_url: string | null;
    release_date: Date | null;
    deprecation_date: Date | null;
    end_of_support_date: Date | null;
    created_at: Date | null;
    updated_at: Date | null;
  };

  export type App_version_supportCountAggregateOutputType = {
    id: number;
    version: number;
    platform: number;
    build_number: number;
    status: number;
    min_supported_version: number;
    is_active: number;
    critical_update: number;
    force_update_message: number;
    release_notes: number;
    download_url: number;
    release_date: number;
    deprecation_date: number;
    end_of_support_date: number;
    metadata: number;
    created_at: number;
    updated_at: number;
    _all: number;
  };

  export type App_version_supportAvgAggregateInputType = {
    id?: true;
    build_number?: true;
  };

  export type App_version_supportSumAggregateInputType = {
    id?: true;
    build_number?: true;
  };

  export type App_version_supportMinAggregateInputType = {
    id?: true;
    version?: true;
    platform?: true;
    build_number?: true;
    status?: true;
    min_supported_version?: true;
    is_active?: true;
    critical_update?: true;
    force_update_message?: true;
    release_notes?: true;
    download_url?: true;
    release_date?: true;
    deprecation_date?: true;
    end_of_support_date?: true;
    created_at?: true;
    updated_at?: true;
  };

  export type App_version_supportMaxAggregateInputType = {
    id?: true;
    version?: true;
    platform?: true;
    build_number?: true;
    status?: true;
    min_supported_version?: true;
    is_active?: true;
    critical_update?: true;
    force_update_message?: true;
    release_notes?: true;
    download_url?: true;
    release_date?: true;
    deprecation_date?: true;
    end_of_support_date?: true;
    created_at?: true;
    updated_at?: true;
  };

  export type App_version_supportCountAggregateInputType = {
    id?: true;
    version?: true;
    platform?: true;
    build_number?: true;
    status?: true;
    min_supported_version?: true;
    is_active?: true;
    critical_update?: true;
    force_update_message?: true;
    release_notes?: true;
    download_url?: true;
    release_date?: true;
    deprecation_date?: true;
    end_of_support_date?: true;
    metadata?: true;
    created_at?: true;
    updated_at?: true;
    _all?: true;
  };

  export type App_version_supportAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which app_version_support to aggregate.
     */
    where?: app_version_supportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of app_version_supports to fetch.
     */
    orderBy?:
      | app_version_supportOrderByWithRelationInput
      | app_version_supportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: app_version_supportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` app_version_supports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` app_version_supports.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned app_version_supports
     **/
    _count?: true | App_version_supportCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: App_version_supportAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: App_version_supportSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: App_version_supportMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: App_version_supportMaxAggregateInputType;
  };

  export type GetApp_version_supportAggregateType<
    T extends App_version_supportAggregateArgs
  > = {
    [P in keyof T & keyof AggregateApp_version_support]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_version_support[P]>
      : GetScalarType<T[P], AggregateApp_version_support[P]>;
  };

  export type app_version_supportGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: app_version_supportWhereInput;
    orderBy?:
      | app_version_supportOrderByWithAggregationInput
      | app_version_supportOrderByWithAggregationInput[];
    by:
      | App_version_supportScalarFieldEnum[]
      | App_version_supportScalarFieldEnum;
    having?: app_version_supportScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: App_version_supportCountAggregateInputType | true;
    _avg?: App_version_supportAvgAggregateInputType;
    _sum?: App_version_supportSumAggregateInputType;
    _min?: App_version_supportMinAggregateInputType;
    _max?: App_version_supportMaxAggregateInputType;
  };

  export type App_version_supportGroupByOutputType = {
    id: number;
    version: string;
    platform: string;
    build_number: number | null;
    status: string;
    min_supported_version: string | null;
    is_active: boolean | null;
    critical_update: boolean | null;
    force_update_message: string | null;
    release_notes: string | null;
    download_url: string | null;
    release_date: Date | null;
    deprecation_date: Date | null;
    end_of_support_date: Date | null;
    metadata: JsonValue | null;
    created_at: Date | null;
    updated_at: Date | null;
    _count: App_version_supportCountAggregateOutputType | null;
    _avg: App_version_supportAvgAggregateOutputType | null;
    _sum: App_version_supportSumAggregateOutputType | null;
    _min: App_version_supportMinAggregateOutputType | null;
    _max: App_version_supportMaxAggregateOutputType | null;
  };

  type GetApp_version_supportGroupByPayload<
    T extends app_version_supportGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_version_supportGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof App_version_supportGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], App_version_supportGroupByOutputType[P]>
          : GetScalarType<T[P], App_version_supportGroupByOutputType[P]>;
      }
    >
  >;

  export type app_version_supportSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      version?: boolean;
      platform?: boolean;
      build_number?: boolean;
      status?: boolean;
      min_supported_version?: boolean;
      is_active?: boolean;
      critical_update?: boolean;
      force_update_message?: boolean;
      release_notes?: boolean;
      download_url?: boolean;
      release_date?: boolean;
      deprecation_date?: boolean;
      end_of_support_date?: boolean;
      metadata?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['app_version_support']
  >;

  export type app_version_supportSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      version?: boolean;
      platform?: boolean;
      build_number?: boolean;
      status?: boolean;
      min_supported_version?: boolean;
      is_active?: boolean;
      critical_update?: boolean;
      force_update_message?: boolean;
      release_notes?: boolean;
      download_url?: boolean;
      release_date?: boolean;
      deprecation_date?: boolean;
      end_of_support_date?: boolean;
      metadata?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['app_version_support']
  >;

  export type app_version_supportSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      version?: boolean;
      platform?: boolean;
      build_number?: boolean;
      status?: boolean;
      min_supported_version?: boolean;
      is_active?: boolean;
      critical_update?: boolean;
      force_update_message?: boolean;
      release_notes?: boolean;
      download_url?: boolean;
      release_date?: boolean;
      deprecation_date?: boolean;
      end_of_support_date?: boolean;
      metadata?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['app_version_support']
  >;

  export type app_version_supportSelectScalar = {
    id?: boolean;
    version?: boolean;
    platform?: boolean;
    build_number?: boolean;
    status?: boolean;
    min_supported_version?: boolean;
    is_active?: boolean;
    critical_update?: boolean;
    force_update_message?: boolean;
    release_notes?: boolean;
    download_url?: boolean;
    release_date?: boolean;
    deprecation_date?: boolean;
    end_of_support_date?: boolean;
    metadata?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
  };

  export type app_version_supportOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'version'
    | 'platform'
    | 'build_number'
    | 'status'
    | 'min_supported_version'
    | 'is_active'
    | 'critical_update'
    | 'force_update_message'
    | 'release_notes'
    | 'download_url'
    | 'release_date'
    | 'deprecation_date'
    | 'end_of_support_date'
    | 'metadata'
    | 'created_at'
    | 'updated_at',
    ExtArgs['result']['app_version_support']
  >;

  export type $app_version_supportPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'app_version_support';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        version: string;
        platform: string;
        build_number: number | null;
        status: string;
        min_supported_version: string | null;
        is_active: boolean | null;
        critical_update: boolean | null;
        force_update_message: string | null;
        release_notes: string | null;
        download_url: string | null;
        release_date: Date | null;
        deprecation_date: Date | null;
        end_of_support_date: Date | null;
        metadata: Prisma.JsonValue | null;
        created_at: Date | null;
        updated_at: Date | null;
      },
      ExtArgs['result']['app_version_support']
    >;
    composites: {};
  };

  type app_version_supportGetPayload<
    S extends boolean | null | undefined | app_version_supportDefaultArgs
  > = $Result.GetResult<Prisma.$app_version_supportPayload, S>;

  type app_version_supportCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    app_version_supportFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: App_version_supportCountAggregateInputType | true;
  };

  export interface app_version_supportDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['app_version_support'];
      meta: { name: 'app_version_support' };
    };
    /**
     * Find zero or one App_version_support that matches the filter.
     * @param {app_version_supportFindUniqueArgs} args - Arguments to find a App_version_support
     * @example
     * // Get one App_version_support
     * const app_version_support = await prisma.app_version_support.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_version_supportFindUniqueArgs>(
      args: SelectSubset<T, app_version_supportFindUniqueArgs<ExtArgs>>
    ): Prisma__app_version_supportClient<
      $Result.GetResult<
        Prisma.$app_version_supportPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one App_version_support that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {app_version_supportFindUniqueOrThrowArgs} args - Arguments to find a App_version_support
     * @example
     * // Get one App_version_support
     * const app_version_support = await prisma.app_version_support.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_version_supportFindUniqueOrThrowArgs>(
      args: SelectSubset<T, app_version_supportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__app_version_supportClient<
      $Result.GetResult<
        Prisma.$app_version_supportPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first App_version_support that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_version_supportFindFirstArgs} args - Arguments to find a App_version_support
     * @example
     * // Get one App_version_support
     * const app_version_support = await prisma.app_version_support.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_version_supportFindFirstArgs>(
      args?: SelectSubset<T, app_version_supportFindFirstArgs<ExtArgs>>
    ): Prisma__app_version_supportClient<
      $Result.GetResult<
        Prisma.$app_version_supportPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first App_version_support that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_version_supportFindFirstOrThrowArgs} args - Arguments to find a App_version_support
     * @example
     * // Get one App_version_support
     * const app_version_support = await prisma.app_version_support.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_version_supportFindFirstOrThrowArgs>(
      args?: SelectSubset<T, app_version_supportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__app_version_supportClient<
      $Result.GetResult<
        Prisma.$app_version_supportPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more App_version_supports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_version_supportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_version_supports
     * const app_version_supports = await prisma.app_version_support.findMany()
     *
     * // Get first 10 App_version_supports
     * const app_version_supports = await prisma.app_version_support.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const app_version_supportWithIdOnly = await prisma.app_version_support.findMany({ select: { id: true } })
     *
     */
    findMany<T extends app_version_supportFindManyArgs>(
      args?: SelectSubset<T, app_version_supportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$app_version_supportPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a App_version_support.
     * @param {app_version_supportCreateArgs} args - Arguments to create a App_version_support.
     * @example
     * // Create one App_version_support
     * const App_version_support = await prisma.app_version_support.create({
     *   data: {
     *     // ... data to create a App_version_support
     *   }
     * })
     *
     */
    create<T extends app_version_supportCreateArgs>(
      args: SelectSubset<T, app_version_supportCreateArgs<ExtArgs>>
    ): Prisma__app_version_supportClient<
      $Result.GetResult<
        Prisma.$app_version_supportPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many App_version_supports.
     * @param {app_version_supportCreateManyArgs} args - Arguments to create many App_version_supports.
     * @example
     * // Create many App_version_supports
     * const app_version_support = await prisma.app_version_support.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends app_version_supportCreateManyArgs>(
      args?: SelectSubset<T, app_version_supportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many App_version_supports and returns the data saved in the database.
     * @param {app_version_supportCreateManyAndReturnArgs} args - Arguments to create many App_version_supports.
     * @example
     * // Create many App_version_supports
     * const app_version_support = await prisma.app_version_support.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many App_version_supports and only return the `id`
     * const app_version_supportWithIdOnly = await prisma.app_version_support.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends app_version_supportCreateManyAndReturnArgs>(
      args?: SelectSubset<
        T,
        app_version_supportCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$app_version_supportPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a App_version_support.
     * @param {app_version_supportDeleteArgs} args - Arguments to delete one App_version_support.
     * @example
     * // Delete one App_version_support
     * const App_version_support = await prisma.app_version_support.delete({
     *   where: {
     *     // ... filter to delete one App_version_support
     *   }
     * })
     *
     */
    delete<T extends app_version_supportDeleteArgs>(
      args: SelectSubset<T, app_version_supportDeleteArgs<ExtArgs>>
    ): Prisma__app_version_supportClient<
      $Result.GetResult<
        Prisma.$app_version_supportPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one App_version_support.
     * @param {app_version_supportUpdateArgs} args - Arguments to update one App_version_support.
     * @example
     * // Update one App_version_support
     * const app_version_support = await prisma.app_version_support.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends app_version_supportUpdateArgs>(
      args: SelectSubset<T, app_version_supportUpdateArgs<ExtArgs>>
    ): Prisma__app_version_supportClient<
      $Result.GetResult<
        Prisma.$app_version_supportPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more App_version_supports.
     * @param {app_version_supportDeleteManyArgs} args - Arguments to filter App_version_supports to delete.
     * @example
     * // Delete a few App_version_supports
     * const { count } = await prisma.app_version_support.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends app_version_supportDeleteManyArgs>(
      args?: SelectSubset<T, app_version_supportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more App_version_supports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_version_supportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_version_supports
     * const app_version_support = await prisma.app_version_support.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends app_version_supportUpdateManyArgs>(
      args: SelectSubset<T, app_version_supportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more App_version_supports and returns the data updated in the database.
     * @param {app_version_supportUpdateManyAndReturnArgs} args - Arguments to update many App_version_supports.
     * @example
     * // Update many App_version_supports
     * const app_version_support = await prisma.app_version_support.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more App_version_supports and only return the `id`
     * const app_version_supportWithIdOnly = await prisma.app_version_support.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends app_version_supportUpdateManyAndReturnArgs>(
      args: SelectSubset<T, app_version_supportUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$app_version_supportPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one App_version_support.
     * @param {app_version_supportUpsertArgs} args - Arguments to update or create a App_version_support.
     * @example
     * // Update or create a App_version_support
     * const app_version_support = await prisma.app_version_support.upsert({
     *   create: {
     *     // ... data to create a App_version_support
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_version_support we want to update
     *   }
     * })
     */
    upsert<T extends app_version_supportUpsertArgs>(
      args: SelectSubset<T, app_version_supportUpsertArgs<ExtArgs>>
    ): Prisma__app_version_supportClient<
      $Result.GetResult<
        Prisma.$app_version_supportPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of App_version_supports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_version_supportCountArgs} args - Arguments to filter App_version_supports to count.
     * @example
     * // Count the number of App_version_supports
     * const count = await prisma.app_version_support.count({
     *   where: {
     *     // ... the filter for the App_version_supports we want to count
     *   }
     * })
     **/
    count<T extends app_version_supportCountArgs>(
      args?: Subset<T, app_version_supportCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              App_version_supportCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a App_version_support.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_version_supportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends App_version_supportAggregateArgs>(
      args: Subset<T, App_version_supportAggregateArgs>
    ): Prisma.PrismaPromise<GetApp_version_supportAggregateType<T>>;

    /**
     * Group by App_version_support.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_version_supportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends app_version_supportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_version_supportGroupByArgs['orderBy'] }
        : { orderBy?: app_version_supportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, app_version_supportGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetApp_version_supportGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the app_version_support model
     */
    readonly fields: app_version_supportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_version_support.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_version_supportClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the app_version_support model
   */
  interface app_version_supportFieldRefs {
    readonly id: FieldRef<'app_version_support', 'Int'>;
    readonly version: FieldRef<'app_version_support', 'String'>;
    readonly platform: FieldRef<'app_version_support', 'String'>;
    readonly build_number: FieldRef<'app_version_support', 'Int'>;
    readonly status: FieldRef<'app_version_support', 'String'>;
    readonly min_supported_version: FieldRef<'app_version_support', 'String'>;
    readonly is_active: FieldRef<'app_version_support', 'Boolean'>;
    readonly critical_update: FieldRef<'app_version_support', 'Boolean'>;
    readonly force_update_message: FieldRef<'app_version_support', 'String'>;
    readonly release_notes: FieldRef<'app_version_support', 'String'>;
    readonly download_url: FieldRef<'app_version_support', 'String'>;
    readonly release_date: FieldRef<'app_version_support', 'DateTime'>;
    readonly deprecation_date: FieldRef<'app_version_support', 'DateTime'>;
    readonly end_of_support_date: FieldRef<'app_version_support', 'DateTime'>;
    readonly metadata: FieldRef<'app_version_support', 'Json'>;
    readonly created_at: FieldRef<'app_version_support', 'DateTime'>;
    readonly updated_at: FieldRef<'app_version_support', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * app_version_support findUnique
   */
  export type app_version_supportFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_version_support
     */
    select?: app_version_supportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_version_support
     */
    omit?: app_version_supportOmit<ExtArgs> | null;
    /**
     * Filter, which app_version_support to fetch.
     */
    where: app_version_supportWhereUniqueInput;
  };

  /**
   * app_version_support findUniqueOrThrow
   */
  export type app_version_supportFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_version_support
     */
    select?: app_version_supportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_version_support
     */
    omit?: app_version_supportOmit<ExtArgs> | null;
    /**
     * Filter, which app_version_support to fetch.
     */
    where: app_version_supportWhereUniqueInput;
  };

  /**
   * app_version_support findFirst
   */
  export type app_version_supportFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_version_support
     */
    select?: app_version_supportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_version_support
     */
    omit?: app_version_supportOmit<ExtArgs> | null;
    /**
     * Filter, which app_version_support to fetch.
     */
    where?: app_version_supportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of app_version_supports to fetch.
     */
    orderBy?:
      | app_version_supportOrderByWithRelationInput
      | app_version_supportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for app_version_supports.
     */
    cursor?: app_version_supportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` app_version_supports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` app_version_supports.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of app_version_supports.
     */
    distinct?:
      | App_version_supportScalarFieldEnum
      | App_version_supportScalarFieldEnum[];
  };

  /**
   * app_version_support findFirstOrThrow
   */
  export type app_version_supportFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_version_support
     */
    select?: app_version_supportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_version_support
     */
    omit?: app_version_supportOmit<ExtArgs> | null;
    /**
     * Filter, which app_version_support to fetch.
     */
    where?: app_version_supportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of app_version_supports to fetch.
     */
    orderBy?:
      | app_version_supportOrderByWithRelationInput
      | app_version_supportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for app_version_supports.
     */
    cursor?: app_version_supportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` app_version_supports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` app_version_supports.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of app_version_supports.
     */
    distinct?:
      | App_version_supportScalarFieldEnum
      | App_version_supportScalarFieldEnum[];
  };

  /**
   * app_version_support findMany
   */
  export type app_version_supportFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_version_support
     */
    select?: app_version_supportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_version_support
     */
    omit?: app_version_supportOmit<ExtArgs> | null;
    /**
     * Filter, which app_version_supports to fetch.
     */
    where?: app_version_supportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of app_version_supports to fetch.
     */
    orderBy?:
      | app_version_supportOrderByWithRelationInput
      | app_version_supportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing app_version_supports.
     */
    cursor?: app_version_supportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` app_version_supports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` app_version_supports.
     */
    skip?: number;
    distinct?:
      | App_version_supportScalarFieldEnum
      | App_version_supportScalarFieldEnum[];
  };

  /**
   * app_version_support create
   */
  export type app_version_supportCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_version_support
     */
    select?: app_version_supportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_version_support
     */
    omit?: app_version_supportOmit<ExtArgs> | null;
    /**
     * The data needed to create a app_version_support.
     */
    data: XOR<
      app_version_supportCreateInput,
      app_version_supportUncheckedCreateInput
    >;
  };

  /**
   * app_version_support createMany
   */
  export type app_version_supportCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many app_version_supports.
     */
    data:
      | app_version_supportCreateManyInput
      | app_version_supportCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * app_version_support createManyAndReturn
   */
  export type app_version_supportCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_version_support
     */
    select?: app_version_supportSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the app_version_support
     */
    omit?: app_version_supportOmit<ExtArgs> | null;
    /**
     * The data used to create many app_version_supports.
     */
    data:
      | app_version_supportCreateManyInput
      | app_version_supportCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * app_version_support update
   */
  export type app_version_supportUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_version_support
     */
    select?: app_version_supportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_version_support
     */
    omit?: app_version_supportOmit<ExtArgs> | null;
    /**
     * The data needed to update a app_version_support.
     */
    data: XOR<
      app_version_supportUpdateInput,
      app_version_supportUncheckedUpdateInput
    >;
    /**
     * Choose, which app_version_support to update.
     */
    where: app_version_supportWhereUniqueInput;
  };

  /**
   * app_version_support updateMany
   */
  export type app_version_supportUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update app_version_supports.
     */
    data: XOR<
      app_version_supportUpdateManyMutationInput,
      app_version_supportUncheckedUpdateManyInput
    >;
    /**
     * Filter which app_version_supports to update
     */
    where?: app_version_supportWhereInput;
    /**
     * Limit how many app_version_supports to update.
     */
    limit?: number;
  };

  /**
   * app_version_support updateManyAndReturn
   */
  export type app_version_supportUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_version_support
     */
    select?: app_version_supportSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the app_version_support
     */
    omit?: app_version_supportOmit<ExtArgs> | null;
    /**
     * The data used to update app_version_supports.
     */
    data: XOR<
      app_version_supportUpdateManyMutationInput,
      app_version_supportUncheckedUpdateManyInput
    >;
    /**
     * Filter which app_version_supports to update
     */
    where?: app_version_supportWhereInput;
    /**
     * Limit how many app_version_supports to update.
     */
    limit?: number;
  };

  /**
   * app_version_support upsert
   */
  export type app_version_supportUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_version_support
     */
    select?: app_version_supportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_version_support
     */
    omit?: app_version_supportOmit<ExtArgs> | null;
    /**
     * The filter to search for the app_version_support to update in case it exists.
     */
    where: app_version_supportWhereUniqueInput;
    /**
     * In case the app_version_support found by the `where` argument doesn't exist, create a new app_version_support with this data.
     */
    create: XOR<
      app_version_supportCreateInput,
      app_version_supportUncheckedCreateInput
    >;
    /**
     * In case the app_version_support was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      app_version_supportUpdateInput,
      app_version_supportUncheckedUpdateInput
    >;
  };

  /**
   * app_version_support delete
   */
  export type app_version_supportDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_version_support
     */
    select?: app_version_supportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_version_support
     */
    omit?: app_version_supportOmit<ExtArgs> | null;
    /**
     * Filter which app_version_support to delete.
     */
    where: app_version_supportWhereUniqueInput;
  };

  /**
   * app_version_support deleteMany
   */
  export type app_version_supportDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which app_version_supports to delete
     */
    where?: app_version_supportWhereInput;
    /**
     * Limit how many app_version_supports to delete.
     */
    limit?: number;
  };

  /**
   * app_version_support without action
   */
  export type app_version_supportDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the app_version_support
     */
    select?: app_version_supportSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the app_version_support
     */
    omit?: app_version_supportOmit<ExtArgs> | null;
  };

  /**
   * Model comments
   */

  export type AggregateComments = {
    _count: CommentsCountAggregateOutputType | null;
    _avg: CommentsAvgAggregateOutputType | null;
    _sum: CommentsSumAggregateOutputType | null;
    _min: CommentsMinAggregateOutputType | null;
    _max: CommentsMaxAggregateOutputType | null;
  };

  export type CommentsAvgAggregateOutputType = {
    id: number | null;
    user_id: number | null;
    parent_id: number | null;
    likes: number | null;
  };

  export type CommentsSumAggregateOutputType = {
    id: number | null;
    user_id: number | null;
    parent_id: number | null;
    likes: number | null;
  };

  export type CommentsMinAggregateOutputType = {
    id: number | null;
    symbol: string | null;
    content: string | null;
    user_id: number | null;
    parent_id: number | null;
    likes: number | null;
    created_at: Date | null;
    updated_at: Date | null;
  };

  export type CommentsMaxAggregateOutputType = {
    id: number | null;
    symbol: string | null;
    content: string | null;
    user_id: number | null;
    parent_id: number | null;
    likes: number | null;
    created_at: Date | null;
    updated_at: Date | null;
  };

  export type CommentsCountAggregateOutputType = {
    id: number;
    symbol: number;
    content: number;
    user_id: number;
    parent_id: number;
    likes: number;
    created_at: number;
    updated_at: number;
    _all: number;
  };

  export type CommentsAvgAggregateInputType = {
    id?: true;
    user_id?: true;
    parent_id?: true;
    likes?: true;
  };

  export type CommentsSumAggregateInputType = {
    id?: true;
    user_id?: true;
    parent_id?: true;
    likes?: true;
  };

  export type CommentsMinAggregateInputType = {
    id?: true;
    symbol?: true;
    content?: true;
    user_id?: true;
    parent_id?: true;
    likes?: true;
    created_at?: true;
    updated_at?: true;
  };

  export type CommentsMaxAggregateInputType = {
    id?: true;
    symbol?: true;
    content?: true;
    user_id?: true;
    parent_id?: true;
    likes?: true;
    created_at?: true;
    updated_at?: true;
  };

  export type CommentsCountAggregateInputType = {
    id?: true;
    symbol?: true;
    content?: true;
    user_id?: true;
    parent_id?: true;
    likes?: true;
    created_at?: true;
    updated_at?: true;
    _all?: true;
  };

  export type CommentsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which comments to aggregate.
     */
    where?: commentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of comments to fetch.
     */
    orderBy?:
      | commentsOrderByWithRelationInput
      | commentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: commentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` comments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned comments
     **/
    _count?: true | CommentsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CommentsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CommentsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CommentsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CommentsMaxAggregateInputType;
  };

  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {
    [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComments[P]>
      : GetScalarType<T[P], AggregateComments[P]>;
  };

  export type commentsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: commentsWhereInput;
    orderBy?:
      | commentsOrderByWithAggregationInput
      | commentsOrderByWithAggregationInput[];
    by: CommentsScalarFieldEnum[] | CommentsScalarFieldEnum;
    having?: commentsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CommentsCountAggregateInputType | true;
    _avg?: CommentsAvgAggregateInputType;
    _sum?: CommentsSumAggregateInputType;
    _min?: CommentsMinAggregateInputType;
    _max?: CommentsMaxAggregateInputType;
  };

  export type CommentsGroupByOutputType = {
    id: number;
    symbol: string;
    content: string;
    user_id: number;
    parent_id: number | null;
    likes: number | null;
    created_at: Date | null;
    updated_at: Date | null;
    _count: CommentsCountAggregateOutputType | null;
    _avg: CommentsAvgAggregateOutputType | null;
    _sum: CommentsSumAggregateOutputType | null;
    _min: CommentsMinAggregateOutputType | null;
    _max: CommentsMaxAggregateOutputType | null;
  };

  type GetCommentsGroupByPayload<T extends commentsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CommentsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof CommentsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentsGroupByOutputType[P]>
            : GetScalarType<T[P], CommentsGroupByOutputType[P]>;
        }
      >
    >;

  export type commentsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      symbol?: boolean;
      content?: boolean;
      user_id?: boolean;
      parent_id?: boolean;
      likes?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      comments?: boolean | comments$commentsArgs<ExtArgs>;
      other_comments?: boolean | comments$other_commentsArgs<ExtArgs>;
      _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['comments']
  >;

  export type commentsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      symbol?: boolean;
      content?: boolean;
      user_id?: boolean;
      parent_id?: boolean;
      likes?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      comments?: boolean | comments$commentsArgs<ExtArgs>;
    },
    ExtArgs['result']['comments']
  >;

  export type commentsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      symbol?: boolean;
      content?: boolean;
      user_id?: boolean;
      parent_id?: boolean;
      likes?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      comments?: boolean | comments$commentsArgs<ExtArgs>;
    },
    ExtArgs['result']['comments']
  >;

  export type commentsSelectScalar = {
    id?: boolean;
    symbol?: boolean;
    content?: boolean;
    user_id?: boolean;
    parent_id?: boolean;
    likes?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
  };

  export type commentsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'symbol'
    | 'content'
    | 'user_id'
    | 'parent_id'
    | 'likes'
    | 'created_at'
    | 'updated_at',
    ExtArgs['result']['comments']
  >;
  export type commentsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    comments?: boolean | comments$commentsArgs<ExtArgs>;
    other_comments?: boolean | comments$other_commentsArgs<ExtArgs>;
    _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type commentsIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    comments?: boolean | comments$commentsArgs<ExtArgs>;
  };
  export type commentsIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    comments?: boolean | comments$commentsArgs<ExtArgs>;
  };

  export type $commentsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'comments';
    objects: {
      comments: Prisma.$commentsPayload<ExtArgs> | null;
      other_comments: Prisma.$commentsPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        symbol: string;
        content: string;
        user_id: number;
        parent_id: number | null;
        likes: number | null;
        created_at: Date | null;
        updated_at: Date | null;
      },
      ExtArgs['result']['comments']
    >;
    composites: {};
  };

  type commentsGetPayload<
    S extends boolean | null | undefined | commentsDefaultArgs
  > = $Result.GetResult<Prisma.$commentsPayload, S>;

  type commentsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<commentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CommentsCountAggregateInputType | true;
  };

  export interface commentsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['comments'];
      meta: { name: 'comments' };
    };
    /**
     * Find zero or one Comments that matches the filter.
     * @param {commentsFindUniqueArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends commentsFindUniqueArgs>(
      args: SelectSubset<T, commentsFindUniqueArgs<ExtArgs>>
    ): Prisma__commentsClient<
      $Result.GetResult<
        Prisma.$commentsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Comments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {commentsFindUniqueOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends commentsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, commentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__commentsClient<
      $Result.GetResult<
        Prisma.$commentsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends commentsFindFirstArgs>(
      args?: SelectSubset<T, commentsFindFirstArgs<ExtArgs>>
    ): Prisma__commentsClient<
      $Result.GetResult<
        Prisma.$commentsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Comments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends commentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, commentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__commentsClient<
      $Result.GetResult<
        Prisma.$commentsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comments.findMany()
     *
     * // Get first 10 Comments
     * const comments = await prisma.comments.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const commentsWithIdOnly = await prisma.comments.findMany({ select: { id: true } })
     *
     */
    findMany<T extends commentsFindManyArgs>(
      args?: SelectSubset<T, commentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$commentsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Comments.
     * @param {commentsCreateArgs} args - Arguments to create a Comments.
     * @example
     * // Create one Comments
     * const Comments = await prisma.comments.create({
     *   data: {
     *     // ... data to create a Comments
     *   }
     * })
     *
     */
    create<T extends commentsCreateArgs>(
      args: SelectSubset<T, commentsCreateArgs<ExtArgs>>
    ): Prisma__commentsClient<
      $Result.GetResult<
        Prisma.$commentsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Comments.
     * @param {commentsCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends commentsCreateManyArgs>(
      args?: SelectSubset<T, commentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {commentsCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Comments and only return the `id`
     * const commentsWithIdOnly = await prisma.comments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends commentsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, commentsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$commentsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Comments.
     * @param {commentsDeleteArgs} args - Arguments to delete one Comments.
     * @example
     * // Delete one Comments
     * const Comments = await prisma.comments.delete({
     *   where: {
     *     // ... filter to delete one Comments
     *   }
     * })
     *
     */
    delete<T extends commentsDeleteArgs>(
      args: SelectSubset<T, commentsDeleteArgs<ExtArgs>>
    ): Prisma__commentsClient<
      $Result.GetResult<
        Prisma.$commentsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Comments.
     * @param {commentsUpdateArgs} args - Arguments to update one Comments.
     * @example
     * // Update one Comments
     * const comments = await prisma.comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends commentsUpdateArgs>(
      args: SelectSubset<T, commentsUpdateArgs<ExtArgs>>
    ): Prisma__commentsClient<
      $Result.GetResult<
        Prisma.$commentsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Comments.
     * @param {commentsDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends commentsDeleteManyArgs>(
      args?: SelectSubset<T, commentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends commentsUpdateManyArgs>(
      args: SelectSubset<T, commentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {commentsUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Comments and only return the `id`
     * const commentsWithIdOnly = await prisma.comments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends commentsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, commentsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$commentsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Comments.
     * @param {commentsUpsertArgs} args - Arguments to update or create a Comments.
     * @example
     * // Update or create a Comments
     * const comments = await prisma.comments.upsert({
     *   create: {
     *     // ... data to create a Comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comments we want to update
     *   }
     * })
     */
    upsert<T extends commentsUpsertArgs>(
      args: SelectSubset<T, commentsUpsertArgs<ExtArgs>>
    ): Prisma__commentsClient<
      $Result.GetResult<
        Prisma.$commentsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comments.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
     **/
    count<T extends commentsCountArgs>(
      args?: Subset<T, commentsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CommentsAggregateArgs>(
      args: Subset<T, CommentsAggregateArgs>
    ): Prisma.PrismaPromise<GetCommentsAggregateType<T>>;

    /**
     * Group by Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends commentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: commentsGroupByArgs['orderBy'] }
        : { orderBy?: commentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, commentsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetCommentsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the comments model
     */
    readonly fields: commentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__commentsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    comments<T extends comments$commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, comments$commentsArgs<ExtArgs>>
    ): Prisma__commentsClient<
      $Result.GetResult<
        Prisma.$commentsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    other_comments<T extends comments$other_commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, comments$other_commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$commentsPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the comments model
   */
  interface commentsFieldRefs {
    readonly id: FieldRef<'comments', 'Int'>;
    readonly symbol: FieldRef<'comments', 'String'>;
    readonly content: FieldRef<'comments', 'String'>;
    readonly user_id: FieldRef<'comments', 'Int'>;
    readonly parent_id: FieldRef<'comments', 'Int'>;
    readonly likes: FieldRef<'comments', 'Int'>;
    readonly created_at: FieldRef<'comments', 'DateTime'>;
    readonly updated_at: FieldRef<'comments', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * comments findUnique
   */
  export type commentsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null;
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput;
  };

  /**
   * comments findUniqueOrThrow
   */
  export type commentsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null;
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput;
  };

  /**
   * comments findFirst
   */
  export type commentsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null;
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of comments to fetch.
     */
    orderBy?:
      | commentsOrderByWithRelationInput
      | commentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` comments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[];
  };

  /**
   * comments findFirstOrThrow
   */
  export type commentsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null;
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of comments to fetch.
     */
    orderBy?:
      | commentsOrderByWithRelationInput
      | commentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` comments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[];
  };

  /**
   * comments findMany
   */
  export type commentsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null;
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of comments to fetch.
     */
    orderBy?:
      | commentsOrderByWithRelationInput
      | commentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing comments.
     */
    cursor?: commentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` comments.
     */
    skip?: number;
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[];
  };

  /**
   * comments create
   */
  export type commentsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null;
    /**
     * The data needed to create a comments.
     */
    data: XOR<commentsCreateInput, commentsUncheckedCreateInput>;
  };

  /**
   * comments createMany
   */
  export type commentsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many comments.
     */
    data: commentsCreateManyInput | commentsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * comments createManyAndReturn
   */
  export type commentsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null;
    /**
     * The data used to create many comments.
     */
    data: commentsCreateManyInput | commentsCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * comments update
   */
  export type commentsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null;
    /**
     * The data needed to update a comments.
     */
    data: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>;
    /**
     * Choose, which comments to update.
     */
    where: commentsWhereUniqueInput;
  };

  /**
   * comments updateMany
   */
  export type commentsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update comments.
     */
    data: XOR<
      commentsUpdateManyMutationInput,
      commentsUncheckedUpdateManyInput
    >;
    /**
     * Filter which comments to update
     */
    where?: commentsWhereInput;
    /**
     * Limit how many comments to update.
     */
    limit?: number;
  };

  /**
   * comments updateManyAndReturn
   */
  export type commentsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null;
    /**
     * The data used to update comments.
     */
    data: XOR<
      commentsUpdateManyMutationInput,
      commentsUncheckedUpdateManyInput
    >;
    /**
     * Filter which comments to update
     */
    where?: commentsWhereInput;
    /**
     * Limit how many comments to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * comments upsert
   */
  export type commentsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null;
    /**
     * The filter to search for the comments to update in case it exists.
     */
    where: commentsWhereUniqueInput;
    /**
     * In case the comments found by the `where` argument doesn't exist, create a new comments with this data.
     */
    create: XOR<commentsCreateInput, commentsUncheckedCreateInput>;
    /**
     * In case the comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>;
  };

  /**
   * comments delete
   */
  export type commentsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null;
    /**
     * Filter which comments to delete.
     */
    where: commentsWhereUniqueInput;
  };

  /**
   * comments deleteMany
   */
  export type commentsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which comments to delete
     */
    where?: commentsWhereInput;
    /**
     * Limit how many comments to delete.
     */
    limit?: number;
  };

  /**
   * comments.comments
   */
  export type comments$commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null;
    where?: commentsWhereInput;
  };

  /**
   * comments.other_comments
   */
  export type comments$other_commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null;
    where?: commentsWhereInput;
    orderBy?:
      | commentsOrderByWithRelationInput
      | commentsOrderByWithRelationInput[];
    cursor?: commentsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[];
  };

  /**
   * comments without action
   */
  export type commentsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null;
  };

  /**
   * Model in_app_announcements
   */

  export type AggregateIn_app_announcements = {
    _count: In_app_announcementsCountAggregateOutputType | null;
    _avg: In_app_announcementsAvgAggregateOutputType | null;
    _sum: In_app_announcementsSumAggregateOutputType | null;
    _min: In_app_announcementsMinAggregateOutputType | null;
    _max: In_app_announcementsMaxAggregateOutputType | null;
  };

  export type In_app_announcementsAvgAggregateOutputType = {
    id: number | null;
    priority: number | null;
  };

  export type In_app_announcementsSumAggregateOutputType = {
    id: number | null;
    priority: number | null;
  };

  export type In_app_announcementsMinAggregateOutputType = {
    id: number | null;
    type: string | null;
    display_type: string | null;
    title_en: string | null;
    title_th: string | null;
    message_en: string | null;
    message_th: string | null;
    button_text_en: string | null;
    button_text_th: string | null;
    action_type: string | null;
    action_value: string | null;
    platform: string | null;
    min_app_version: string | null;
    max_app_version: string | null;
    start_at: Date | null;
    end_at: Date | null;
    priority: number | null;
    is_active: boolean | null;
    dismissible: boolean | null;
    created_at: Date | null;
    updated_at: Date | null;
  };

  export type In_app_announcementsMaxAggregateOutputType = {
    id: number | null;
    type: string | null;
    display_type: string | null;
    title_en: string | null;
    title_th: string | null;
    message_en: string | null;
    message_th: string | null;
    button_text_en: string | null;
    button_text_th: string | null;
    action_type: string | null;
    action_value: string | null;
    platform: string | null;
    min_app_version: string | null;
    max_app_version: string | null;
    start_at: Date | null;
    end_at: Date | null;
    priority: number | null;
    is_active: boolean | null;
    dismissible: boolean | null;
    created_at: Date | null;
    updated_at: Date | null;
  };

  export type In_app_announcementsCountAggregateOutputType = {
    id: number;
    type: number;
    display_type: number;
    title_en: number;
    title_th: number;
    message_en: number;
    message_th: number;
    button_text_en: number;
    button_text_th: number;
    action_type: number;
    action_value: number;
    platform: number;
    min_app_version: number;
    max_app_version: number;
    start_at: number;
    end_at: number;
    priority: number;
    is_active: number;
    dismissible: number;
    created_at: number;
    updated_at: number;
    _all: number;
  };

  export type In_app_announcementsAvgAggregateInputType = {
    id?: true;
    priority?: true;
  };

  export type In_app_announcementsSumAggregateInputType = {
    id?: true;
    priority?: true;
  };

  export type In_app_announcementsMinAggregateInputType = {
    id?: true;
    type?: true;
    display_type?: true;
    title_en?: true;
    title_th?: true;
    message_en?: true;
    message_th?: true;
    button_text_en?: true;
    button_text_th?: true;
    action_type?: true;
    action_value?: true;
    platform?: true;
    min_app_version?: true;
    max_app_version?: true;
    start_at?: true;
    end_at?: true;
    priority?: true;
    is_active?: true;
    dismissible?: true;
    created_at?: true;
    updated_at?: true;
  };

  export type In_app_announcementsMaxAggregateInputType = {
    id?: true;
    type?: true;
    display_type?: true;
    title_en?: true;
    title_th?: true;
    message_en?: true;
    message_th?: true;
    button_text_en?: true;
    button_text_th?: true;
    action_type?: true;
    action_value?: true;
    platform?: true;
    min_app_version?: true;
    max_app_version?: true;
    start_at?: true;
    end_at?: true;
    priority?: true;
    is_active?: true;
    dismissible?: true;
    created_at?: true;
    updated_at?: true;
  };

  export type In_app_announcementsCountAggregateInputType = {
    id?: true;
    type?: true;
    display_type?: true;
    title_en?: true;
    title_th?: true;
    message_en?: true;
    message_th?: true;
    button_text_en?: true;
    button_text_th?: true;
    action_type?: true;
    action_value?: true;
    platform?: true;
    min_app_version?: true;
    max_app_version?: true;
    start_at?: true;
    end_at?: true;
    priority?: true;
    is_active?: true;
    dismissible?: true;
    created_at?: true;
    updated_at?: true;
    _all?: true;
  };

  export type In_app_announcementsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which in_app_announcements to aggregate.
     */
    where?: in_app_announcementsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of in_app_announcements to fetch.
     */
    orderBy?:
      | in_app_announcementsOrderByWithRelationInput
      | in_app_announcementsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: in_app_announcementsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` in_app_announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` in_app_announcements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned in_app_announcements
     **/
    _count?: true | In_app_announcementsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: In_app_announcementsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: In_app_announcementsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: In_app_announcementsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: In_app_announcementsMaxAggregateInputType;
  };

  export type GetIn_app_announcementsAggregateType<
    T extends In_app_announcementsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateIn_app_announcements]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIn_app_announcements[P]>
      : GetScalarType<T[P], AggregateIn_app_announcements[P]>;
  };

  export type in_app_announcementsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: in_app_announcementsWhereInput;
    orderBy?:
      | in_app_announcementsOrderByWithAggregationInput
      | in_app_announcementsOrderByWithAggregationInput[];
    by:
      | In_app_announcementsScalarFieldEnum[]
      | In_app_announcementsScalarFieldEnum;
    having?: in_app_announcementsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: In_app_announcementsCountAggregateInputType | true;
    _avg?: In_app_announcementsAvgAggregateInputType;
    _sum?: In_app_announcementsSumAggregateInputType;
    _min?: In_app_announcementsMinAggregateInputType;
    _max?: In_app_announcementsMaxAggregateInputType;
  };

  export type In_app_announcementsGroupByOutputType = {
    id: number;
    type: string;
    display_type: string;
    title_en: string;
    title_th: string;
    message_en: string;
    message_th: string;
    button_text_en: string | null;
    button_text_th: string | null;
    action_type: string | null;
    action_value: string | null;
    platform: string | null;
    min_app_version: string | null;
    max_app_version: string | null;
    start_at: Date | null;
    end_at: Date | null;
    priority: number | null;
    is_active: boolean | null;
    dismissible: boolean | null;
    created_at: Date | null;
    updated_at: Date | null;
    _count: In_app_announcementsCountAggregateOutputType | null;
    _avg: In_app_announcementsAvgAggregateOutputType | null;
    _sum: In_app_announcementsSumAggregateOutputType | null;
    _min: In_app_announcementsMinAggregateOutputType | null;
    _max: In_app_announcementsMaxAggregateOutputType | null;
  };

  type GetIn_app_announcementsGroupByPayload<
    T extends in_app_announcementsGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<In_app_announcementsGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof In_app_announcementsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], In_app_announcementsGroupByOutputType[P]>
          : GetScalarType<T[P], In_app_announcementsGroupByOutputType[P]>;
      }
    >
  >;

  export type in_app_announcementsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      type?: boolean;
      display_type?: boolean;
      title_en?: boolean;
      title_th?: boolean;
      message_en?: boolean;
      message_th?: boolean;
      button_text_en?: boolean;
      button_text_th?: boolean;
      action_type?: boolean;
      action_value?: boolean;
      platform?: boolean;
      min_app_version?: boolean;
      max_app_version?: boolean;
      start_at?: boolean;
      end_at?: boolean;
      priority?: boolean;
      is_active?: boolean;
      dismissible?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['in_app_announcements']
  >;

  export type in_app_announcementsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      type?: boolean;
      display_type?: boolean;
      title_en?: boolean;
      title_th?: boolean;
      message_en?: boolean;
      message_th?: boolean;
      button_text_en?: boolean;
      button_text_th?: boolean;
      action_type?: boolean;
      action_value?: boolean;
      platform?: boolean;
      min_app_version?: boolean;
      max_app_version?: boolean;
      start_at?: boolean;
      end_at?: boolean;
      priority?: boolean;
      is_active?: boolean;
      dismissible?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['in_app_announcements']
  >;

  export type in_app_announcementsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      type?: boolean;
      display_type?: boolean;
      title_en?: boolean;
      title_th?: boolean;
      message_en?: boolean;
      message_th?: boolean;
      button_text_en?: boolean;
      button_text_th?: boolean;
      action_type?: boolean;
      action_value?: boolean;
      platform?: boolean;
      min_app_version?: boolean;
      max_app_version?: boolean;
      start_at?: boolean;
      end_at?: boolean;
      priority?: boolean;
      is_active?: boolean;
      dismissible?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['in_app_announcements']
  >;

  export type in_app_announcementsSelectScalar = {
    id?: boolean;
    type?: boolean;
    display_type?: boolean;
    title_en?: boolean;
    title_th?: boolean;
    message_en?: boolean;
    message_th?: boolean;
    button_text_en?: boolean;
    button_text_th?: boolean;
    action_type?: boolean;
    action_value?: boolean;
    platform?: boolean;
    min_app_version?: boolean;
    max_app_version?: boolean;
    start_at?: boolean;
    end_at?: boolean;
    priority?: boolean;
    is_active?: boolean;
    dismissible?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
  };

  export type in_app_announcementsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'type'
    | 'display_type'
    | 'title_en'
    | 'title_th'
    | 'message_en'
    | 'message_th'
    | 'button_text_en'
    | 'button_text_th'
    | 'action_type'
    | 'action_value'
    | 'platform'
    | 'min_app_version'
    | 'max_app_version'
    | 'start_at'
    | 'end_at'
    | 'priority'
    | 'is_active'
    | 'dismissible'
    | 'created_at'
    | 'updated_at',
    ExtArgs['result']['in_app_announcements']
  >;

  export type $in_app_announcementsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'in_app_announcements';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        type: string;
        display_type: string;
        title_en: string;
        title_th: string;
        message_en: string;
        message_th: string;
        button_text_en: string | null;
        button_text_th: string | null;
        action_type: string | null;
        action_value: string | null;
        platform: string | null;
        min_app_version: string | null;
        max_app_version: string | null;
        start_at: Date | null;
        end_at: Date | null;
        priority: number | null;
        is_active: boolean | null;
        dismissible: boolean | null;
        created_at: Date | null;
        updated_at: Date | null;
      },
      ExtArgs['result']['in_app_announcements']
    >;
    composites: {};
  };

  type in_app_announcementsGetPayload<
    S extends boolean | null | undefined | in_app_announcementsDefaultArgs
  > = $Result.GetResult<Prisma.$in_app_announcementsPayload, S>;

  type in_app_announcementsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    in_app_announcementsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: In_app_announcementsCountAggregateInputType | true;
  };

  export interface in_app_announcementsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['in_app_announcements'];
      meta: { name: 'in_app_announcements' };
    };
    /**
     * Find zero or one In_app_announcements that matches the filter.
     * @param {in_app_announcementsFindUniqueArgs} args - Arguments to find a In_app_announcements
     * @example
     * // Get one In_app_announcements
     * const in_app_announcements = await prisma.in_app_announcements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends in_app_announcementsFindUniqueArgs>(
      args: SelectSubset<T, in_app_announcementsFindUniqueArgs<ExtArgs>>
    ): Prisma__in_app_announcementsClient<
      $Result.GetResult<
        Prisma.$in_app_announcementsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one In_app_announcements that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {in_app_announcementsFindUniqueOrThrowArgs} args - Arguments to find a In_app_announcements
     * @example
     * // Get one In_app_announcements
     * const in_app_announcements = await prisma.in_app_announcements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends in_app_announcementsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, in_app_announcementsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__in_app_announcementsClient<
      $Result.GetResult<
        Prisma.$in_app_announcementsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first In_app_announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in_app_announcementsFindFirstArgs} args - Arguments to find a In_app_announcements
     * @example
     * // Get one In_app_announcements
     * const in_app_announcements = await prisma.in_app_announcements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends in_app_announcementsFindFirstArgs>(
      args?: SelectSubset<T, in_app_announcementsFindFirstArgs<ExtArgs>>
    ): Prisma__in_app_announcementsClient<
      $Result.GetResult<
        Prisma.$in_app_announcementsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first In_app_announcements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in_app_announcementsFindFirstOrThrowArgs} args - Arguments to find a In_app_announcements
     * @example
     * // Get one In_app_announcements
     * const in_app_announcements = await prisma.in_app_announcements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends in_app_announcementsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, in_app_announcementsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__in_app_announcementsClient<
      $Result.GetResult<
        Prisma.$in_app_announcementsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more In_app_announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in_app_announcementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all In_app_announcements
     * const in_app_announcements = await prisma.in_app_announcements.findMany()
     *
     * // Get first 10 In_app_announcements
     * const in_app_announcements = await prisma.in_app_announcements.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const in_app_announcementsWithIdOnly = await prisma.in_app_announcements.findMany({ select: { id: true } })
     *
     */
    findMany<T extends in_app_announcementsFindManyArgs>(
      args?: SelectSubset<T, in_app_announcementsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$in_app_announcementsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a In_app_announcements.
     * @param {in_app_announcementsCreateArgs} args - Arguments to create a In_app_announcements.
     * @example
     * // Create one In_app_announcements
     * const In_app_announcements = await prisma.in_app_announcements.create({
     *   data: {
     *     // ... data to create a In_app_announcements
     *   }
     * })
     *
     */
    create<T extends in_app_announcementsCreateArgs>(
      args: SelectSubset<T, in_app_announcementsCreateArgs<ExtArgs>>
    ): Prisma__in_app_announcementsClient<
      $Result.GetResult<
        Prisma.$in_app_announcementsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many In_app_announcements.
     * @param {in_app_announcementsCreateManyArgs} args - Arguments to create many In_app_announcements.
     * @example
     * // Create many In_app_announcements
     * const in_app_announcements = await prisma.in_app_announcements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends in_app_announcementsCreateManyArgs>(
      args?: SelectSubset<T, in_app_announcementsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many In_app_announcements and returns the data saved in the database.
     * @param {in_app_announcementsCreateManyAndReturnArgs} args - Arguments to create many In_app_announcements.
     * @example
     * // Create many In_app_announcements
     * const in_app_announcements = await prisma.in_app_announcements.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many In_app_announcements and only return the `id`
     * const in_app_announcementsWithIdOnly = await prisma.in_app_announcements.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends in_app_announcementsCreateManyAndReturnArgs>(
      args?: SelectSubset<
        T,
        in_app_announcementsCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$in_app_announcementsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a In_app_announcements.
     * @param {in_app_announcementsDeleteArgs} args - Arguments to delete one In_app_announcements.
     * @example
     * // Delete one In_app_announcements
     * const In_app_announcements = await prisma.in_app_announcements.delete({
     *   where: {
     *     // ... filter to delete one In_app_announcements
     *   }
     * })
     *
     */
    delete<T extends in_app_announcementsDeleteArgs>(
      args: SelectSubset<T, in_app_announcementsDeleteArgs<ExtArgs>>
    ): Prisma__in_app_announcementsClient<
      $Result.GetResult<
        Prisma.$in_app_announcementsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one In_app_announcements.
     * @param {in_app_announcementsUpdateArgs} args - Arguments to update one In_app_announcements.
     * @example
     * // Update one In_app_announcements
     * const in_app_announcements = await prisma.in_app_announcements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends in_app_announcementsUpdateArgs>(
      args: SelectSubset<T, in_app_announcementsUpdateArgs<ExtArgs>>
    ): Prisma__in_app_announcementsClient<
      $Result.GetResult<
        Prisma.$in_app_announcementsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more In_app_announcements.
     * @param {in_app_announcementsDeleteManyArgs} args - Arguments to filter In_app_announcements to delete.
     * @example
     * // Delete a few In_app_announcements
     * const { count } = await prisma.in_app_announcements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends in_app_announcementsDeleteManyArgs>(
      args?: SelectSubset<T, in_app_announcementsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more In_app_announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in_app_announcementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many In_app_announcements
     * const in_app_announcements = await prisma.in_app_announcements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends in_app_announcementsUpdateManyArgs>(
      args: SelectSubset<T, in_app_announcementsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more In_app_announcements and returns the data updated in the database.
     * @param {in_app_announcementsUpdateManyAndReturnArgs} args - Arguments to update many In_app_announcements.
     * @example
     * // Update many In_app_announcements
     * const in_app_announcements = await prisma.in_app_announcements.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more In_app_announcements and only return the `id`
     * const in_app_announcementsWithIdOnly = await prisma.in_app_announcements.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends in_app_announcementsUpdateManyAndReturnArgs>(
      args: SelectSubset<
        T,
        in_app_announcementsUpdateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$in_app_announcementsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one In_app_announcements.
     * @param {in_app_announcementsUpsertArgs} args - Arguments to update or create a In_app_announcements.
     * @example
     * // Update or create a In_app_announcements
     * const in_app_announcements = await prisma.in_app_announcements.upsert({
     *   create: {
     *     // ... data to create a In_app_announcements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the In_app_announcements we want to update
     *   }
     * })
     */
    upsert<T extends in_app_announcementsUpsertArgs>(
      args: SelectSubset<T, in_app_announcementsUpsertArgs<ExtArgs>>
    ): Prisma__in_app_announcementsClient<
      $Result.GetResult<
        Prisma.$in_app_announcementsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of In_app_announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in_app_announcementsCountArgs} args - Arguments to filter In_app_announcements to count.
     * @example
     * // Count the number of In_app_announcements
     * const count = await prisma.in_app_announcements.count({
     *   where: {
     *     // ... the filter for the In_app_announcements we want to count
     *   }
     * })
     **/
    count<T extends in_app_announcementsCountArgs>(
      args?: Subset<T, in_app_announcementsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              In_app_announcementsCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a In_app_announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {In_app_announcementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends In_app_announcementsAggregateArgs>(
      args: Subset<T, In_app_announcementsAggregateArgs>
    ): Prisma.PrismaPromise<GetIn_app_announcementsAggregateType<T>>;

    /**
     * Group by In_app_announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in_app_announcementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends in_app_announcementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: in_app_announcementsGroupByArgs['orderBy'] }
        : { orderBy?: in_app_announcementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, in_app_announcementsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetIn_app_announcementsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the in_app_announcements model
     */
    readonly fields: in_app_announcementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for in_app_announcements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__in_app_announcementsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the in_app_announcements model
   */
  interface in_app_announcementsFieldRefs {
    readonly id: FieldRef<'in_app_announcements', 'Int'>;
    readonly type: FieldRef<'in_app_announcements', 'String'>;
    readonly display_type: FieldRef<'in_app_announcements', 'String'>;
    readonly title_en: FieldRef<'in_app_announcements', 'String'>;
    readonly title_th: FieldRef<'in_app_announcements', 'String'>;
    readonly message_en: FieldRef<'in_app_announcements', 'String'>;
    readonly message_th: FieldRef<'in_app_announcements', 'String'>;
    readonly button_text_en: FieldRef<'in_app_announcements', 'String'>;
    readonly button_text_th: FieldRef<'in_app_announcements', 'String'>;
    readonly action_type: FieldRef<'in_app_announcements', 'String'>;
    readonly action_value: FieldRef<'in_app_announcements', 'String'>;
    readonly platform: FieldRef<'in_app_announcements', 'String'>;
    readonly min_app_version: FieldRef<'in_app_announcements', 'String'>;
    readonly max_app_version: FieldRef<'in_app_announcements', 'String'>;
    readonly start_at: FieldRef<'in_app_announcements', 'DateTime'>;
    readonly end_at: FieldRef<'in_app_announcements', 'DateTime'>;
    readonly priority: FieldRef<'in_app_announcements', 'Int'>;
    readonly is_active: FieldRef<'in_app_announcements', 'Boolean'>;
    readonly dismissible: FieldRef<'in_app_announcements', 'Boolean'>;
    readonly created_at: FieldRef<'in_app_announcements', 'DateTime'>;
    readonly updated_at: FieldRef<'in_app_announcements', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * in_app_announcements findUnique
   */
  export type in_app_announcementsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the in_app_announcements
     */
    select?: in_app_announcementsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the in_app_announcements
     */
    omit?: in_app_announcementsOmit<ExtArgs> | null;
    /**
     * Filter, which in_app_announcements to fetch.
     */
    where: in_app_announcementsWhereUniqueInput;
  };

  /**
   * in_app_announcements findUniqueOrThrow
   */
  export type in_app_announcementsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the in_app_announcements
     */
    select?: in_app_announcementsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the in_app_announcements
     */
    omit?: in_app_announcementsOmit<ExtArgs> | null;
    /**
     * Filter, which in_app_announcements to fetch.
     */
    where: in_app_announcementsWhereUniqueInput;
  };

  /**
   * in_app_announcements findFirst
   */
  export type in_app_announcementsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the in_app_announcements
     */
    select?: in_app_announcementsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the in_app_announcements
     */
    omit?: in_app_announcementsOmit<ExtArgs> | null;
    /**
     * Filter, which in_app_announcements to fetch.
     */
    where?: in_app_announcementsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of in_app_announcements to fetch.
     */
    orderBy?:
      | in_app_announcementsOrderByWithRelationInput
      | in_app_announcementsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for in_app_announcements.
     */
    cursor?: in_app_announcementsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` in_app_announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` in_app_announcements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of in_app_announcements.
     */
    distinct?:
      | In_app_announcementsScalarFieldEnum
      | In_app_announcementsScalarFieldEnum[];
  };

  /**
   * in_app_announcements findFirstOrThrow
   */
  export type in_app_announcementsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the in_app_announcements
     */
    select?: in_app_announcementsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the in_app_announcements
     */
    omit?: in_app_announcementsOmit<ExtArgs> | null;
    /**
     * Filter, which in_app_announcements to fetch.
     */
    where?: in_app_announcementsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of in_app_announcements to fetch.
     */
    orderBy?:
      | in_app_announcementsOrderByWithRelationInput
      | in_app_announcementsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for in_app_announcements.
     */
    cursor?: in_app_announcementsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` in_app_announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` in_app_announcements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of in_app_announcements.
     */
    distinct?:
      | In_app_announcementsScalarFieldEnum
      | In_app_announcementsScalarFieldEnum[];
  };

  /**
   * in_app_announcements findMany
   */
  export type in_app_announcementsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the in_app_announcements
     */
    select?: in_app_announcementsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the in_app_announcements
     */
    omit?: in_app_announcementsOmit<ExtArgs> | null;
    /**
     * Filter, which in_app_announcements to fetch.
     */
    where?: in_app_announcementsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of in_app_announcements to fetch.
     */
    orderBy?:
      | in_app_announcementsOrderByWithRelationInput
      | in_app_announcementsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing in_app_announcements.
     */
    cursor?: in_app_announcementsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` in_app_announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` in_app_announcements.
     */
    skip?: number;
    distinct?:
      | In_app_announcementsScalarFieldEnum
      | In_app_announcementsScalarFieldEnum[];
  };

  /**
   * in_app_announcements create
   */
  export type in_app_announcementsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the in_app_announcements
     */
    select?: in_app_announcementsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the in_app_announcements
     */
    omit?: in_app_announcementsOmit<ExtArgs> | null;
    /**
     * The data needed to create a in_app_announcements.
     */
    data: XOR<
      in_app_announcementsCreateInput,
      in_app_announcementsUncheckedCreateInput
    >;
  };

  /**
   * in_app_announcements createMany
   */
  export type in_app_announcementsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many in_app_announcements.
     */
    data:
      | in_app_announcementsCreateManyInput
      | in_app_announcementsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * in_app_announcements createManyAndReturn
   */
  export type in_app_announcementsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the in_app_announcements
     */
    select?: in_app_announcementsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the in_app_announcements
     */
    omit?: in_app_announcementsOmit<ExtArgs> | null;
    /**
     * The data used to create many in_app_announcements.
     */
    data:
      | in_app_announcementsCreateManyInput
      | in_app_announcementsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * in_app_announcements update
   */
  export type in_app_announcementsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the in_app_announcements
     */
    select?: in_app_announcementsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the in_app_announcements
     */
    omit?: in_app_announcementsOmit<ExtArgs> | null;
    /**
     * The data needed to update a in_app_announcements.
     */
    data: XOR<
      in_app_announcementsUpdateInput,
      in_app_announcementsUncheckedUpdateInput
    >;
    /**
     * Choose, which in_app_announcements to update.
     */
    where: in_app_announcementsWhereUniqueInput;
  };

  /**
   * in_app_announcements updateMany
   */
  export type in_app_announcementsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update in_app_announcements.
     */
    data: XOR<
      in_app_announcementsUpdateManyMutationInput,
      in_app_announcementsUncheckedUpdateManyInput
    >;
    /**
     * Filter which in_app_announcements to update
     */
    where?: in_app_announcementsWhereInput;
    /**
     * Limit how many in_app_announcements to update.
     */
    limit?: number;
  };

  /**
   * in_app_announcements updateManyAndReturn
   */
  export type in_app_announcementsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the in_app_announcements
     */
    select?: in_app_announcementsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the in_app_announcements
     */
    omit?: in_app_announcementsOmit<ExtArgs> | null;
    /**
     * The data used to update in_app_announcements.
     */
    data: XOR<
      in_app_announcementsUpdateManyMutationInput,
      in_app_announcementsUncheckedUpdateManyInput
    >;
    /**
     * Filter which in_app_announcements to update
     */
    where?: in_app_announcementsWhereInput;
    /**
     * Limit how many in_app_announcements to update.
     */
    limit?: number;
  };

  /**
   * in_app_announcements upsert
   */
  export type in_app_announcementsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the in_app_announcements
     */
    select?: in_app_announcementsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the in_app_announcements
     */
    omit?: in_app_announcementsOmit<ExtArgs> | null;
    /**
     * The filter to search for the in_app_announcements to update in case it exists.
     */
    where: in_app_announcementsWhereUniqueInput;
    /**
     * In case the in_app_announcements found by the `where` argument doesn't exist, create a new in_app_announcements with this data.
     */
    create: XOR<
      in_app_announcementsCreateInput,
      in_app_announcementsUncheckedCreateInput
    >;
    /**
     * In case the in_app_announcements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      in_app_announcementsUpdateInput,
      in_app_announcementsUncheckedUpdateInput
    >;
  };

  /**
   * in_app_announcements delete
   */
  export type in_app_announcementsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the in_app_announcements
     */
    select?: in_app_announcementsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the in_app_announcements
     */
    omit?: in_app_announcementsOmit<ExtArgs> | null;
    /**
     * Filter which in_app_announcements to delete.
     */
    where: in_app_announcementsWhereUniqueInput;
  };

  /**
   * in_app_announcements deleteMany
   */
  export type in_app_announcementsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which in_app_announcements to delete
     */
    where?: in_app_announcementsWhereInput;
    /**
     * Limit how many in_app_announcements to delete.
     */
    limit?: number;
  };

  /**
   * in_app_announcements without action
   */
  export type in_app_announcementsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the in_app_announcements
     */
    select?: in_app_announcementsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the in_app_announcements
     */
    omit?: in_app_announcementsOmit<ExtArgs> | null;
  };

  /**
   * Model investment_insights
   */

  export type AggregateInvestment_insights = {
    _count: Investment_insightsCountAggregateOutputType | null;
    _avg: Investment_insightsAvgAggregateOutputType | null;
    _sum: Investment_insightsSumAggregateOutputType | null;
    _min: Investment_insightsMinAggregateOutputType | null;
    _max: Investment_insightsMaxAggregateOutputType | null;
  };

  export type Investment_insightsAvgAggregateOutputType = {
    id: number | null;
  };

  export type Investment_insightsSumAggregateOutputType = {
    id: number | null;
  };

  export type Investment_insightsMinAggregateOutputType = {
    id: number | null;
    symbol: string | null;
    name: string | null;
    type: string | null;
    reason: string | null;
    recommendation: string | null;
    analysis: string | null;
    created_at: Date | null;
    reason_th: string | null;
    analysis_th: string | null;
    thesis_en: string | null;
    takeaway_en: string | null;
    thesis_th: string | null;
    takeaway_th: string | null;
  };

  export type Investment_insightsMaxAggregateOutputType = {
    id: number | null;
    symbol: string | null;
    name: string | null;
    type: string | null;
    reason: string | null;
    recommendation: string | null;
    analysis: string | null;
    created_at: Date | null;
    reason_th: string | null;
    analysis_th: string | null;
    thesis_en: string | null;
    takeaway_en: string | null;
    thesis_th: string | null;
    takeaway_th: string | null;
  };

  export type Investment_insightsCountAggregateOutputType = {
    id: number;
    symbol: number;
    name: number;
    type: number;
    reason: number;
    recommendation: number;
    analysis: number;
    created_at: number;
    reason_th: number;
    analysis_th: number;
    thesis_en: number;
    takeaway_en: number;
    thesis_th: number;
    takeaway_th: number;
    _all: number;
  };

  export type Investment_insightsAvgAggregateInputType = {
    id?: true;
  };

  export type Investment_insightsSumAggregateInputType = {
    id?: true;
  };

  export type Investment_insightsMinAggregateInputType = {
    id?: true;
    symbol?: true;
    name?: true;
    type?: true;
    reason?: true;
    recommendation?: true;
    analysis?: true;
    created_at?: true;
    reason_th?: true;
    analysis_th?: true;
    thesis_en?: true;
    takeaway_en?: true;
    thesis_th?: true;
    takeaway_th?: true;
  };

  export type Investment_insightsMaxAggregateInputType = {
    id?: true;
    symbol?: true;
    name?: true;
    type?: true;
    reason?: true;
    recommendation?: true;
    analysis?: true;
    created_at?: true;
    reason_th?: true;
    analysis_th?: true;
    thesis_en?: true;
    takeaway_en?: true;
    thesis_th?: true;
    takeaway_th?: true;
  };

  export type Investment_insightsCountAggregateInputType = {
    id?: true;
    symbol?: true;
    name?: true;
    type?: true;
    reason?: true;
    recommendation?: true;
    analysis?: true;
    created_at?: true;
    reason_th?: true;
    analysis_th?: true;
    thesis_en?: true;
    takeaway_en?: true;
    thesis_th?: true;
    takeaway_th?: true;
    _all?: true;
  };

  export type Investment_insightsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which investment_insights to aggregate.
     */
    where?: investment_insightsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of investment_insights to fetch.
     */
    orderBy?:
      | investment_insightsOrderByWithRelationInput
      | investment_insightsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: investment_insightsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` investment_insights from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` investment_insights.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned investment_insights
     **/
    _count?: true | Investment_insightsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Investment_insightsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Investment_insightsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Investment_insightsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Investment_insightsMaxAggregateInputType;
  };

  export type GetInvestment_insightsAggregateType<
    T extends Investment_insightsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateInvestment_insights]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestment_insights[P]>
      : GetScalarType<T[P], AggregateInvestment_insights[P]>;
  };

  export type investment_insightsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: investment_insightsWhereInput;
    orderBy?:
      | investment_insightsOrderByWithAggregationInput
      | investment_insightsOrderByWithAggregationInput[];
    by:
      | Investment_insightsScalarFieldEnum[]
      | Investment_insightsScalarFieldEnum;
    having?: investment_insightsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Investment_insightsCountAggregateInputType | true;
    _avg?: Investment_insightsAvgAggregateInputType;
    _sum?: Investment_insightsSumAggregateInputType;
    _min?: Investment_insightsMinAggregateInputType;
    _max?: Investment_insightsMaxAggregateInputType;
  };

  export type Investment_insightsGroupByOutputType = {
    id: number;
    symbol: string;
    name: string;
    type: string;
    reason: string;
    recommendation: string;
    analysis: string;
    created_at: Date | null;
    reason_th: string | null;
    analysis_th: string | null;
    thesis_en: string | null;
    takeaway_en: string | null;
    thesis_th: string | null;
    takeaway_th: string | null;
    _count: Investment_insightsCountAggregateOutputType | null;
    _avg: Investment_insightsAvgAggregateOutputType | null;
    _sum: Investment_insightsSumAggregateOutputType | null;
    _min: Investment_insightsMinAggregateOutputType | null;
    _max: Investment_insightsMaxAggregateOutputType | null;
  };

  type GetInvestment_insightsGroupByPayload<
    T extends investment_insightsGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Investment_insightsGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof Investment_insightsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], Investment_insightsGroupByOutputType[P]>
          : GetScalarType<T[P], Investment_insightsGroupByOutputType[P]>;
      }
    >
  >;

  export type investment_insightsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      symbol?: boolean;
      name?: boolean;
      type?: boolean;
      reason?: boolean;
      recommendation?: boolean;
      analysis?: boolean;
      created_at?: boolean;
      reason_th?: boolean;
      analysis_th?: boolean;
      thesis_en?: boolean;
      takeaway_en?: boolean;
      thesis_th?: boolean;
      takeaway_th?: boolean;
    },
    ExtArgs['result']['investment_insights']
  >;

  export type investment_insightsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      symbol?: boolean;
      name?: boolean;
      type?: boolean;
      reason?: boolean;
      recommendation?: boolean;
      analysis?: boolean;
      created_at?: boolean;
      reason_th?: boolean;
      analysis_th?: boolean;
      thesis_en?: boolean;
      takeaway_en?: boolean;
      thesis_th?: boolean;
      takeaway_th?: boolean;
    },
    ExtArgs['result']['investment_insights']
  >;

  export type investment_insightsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      symbol?: boolean;
      name?: boolean;
      type?: boolean;
      reason?: boolean;
      recommendation?: boolean;
      analysis?: boolean;
      created_at?: boolean;
      reason_th?: boolean;
      analysis_th?: boolean;
      thesis_en?: boolean;
      takeaway_en?: boolean;
      thesis_th?: boolean;
      takeaway_th?: boolean;
    },
    ExtArgs['result']['investment_insights']
  >;

  export type investment_insightsSelectScalar = {
    id?: boolean;
    symbol?: boolean;
    name?: boolean;
    type?: boolean;
    reason?: boolean;
    recommendation?: boolean;
    analysis?: boolean;
    created_at?: boolean;
    reason_th?: boolean;
    analysis_th?: boolean;
    thesis_en?: boolean;
    takeaway_en?: boolean;
    thesis_th?: boolean;
    takeaway_th?: boolean;
  };

  export type investment_insightsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'symbol'
    | 'name'
    | 'type'
    | 'reason'
    | 'recommendation'
    | 'analysis'
    | 'created_at'
    | 'reason_th'
    | 'analysis_th'
    | 'thesis_en'
    | 'takeaway_en'
    | 'thesis_th'
    | 'takeaway_th',
    ExtArgs['result']['investment_insights']
  >;

  export type $investment_insightsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'investment_insights';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        symbol: string;
        name: string;
        type: string;
        reason: string;
        recommendation: string;
        analysis: string;
        created_at: Date | null;
        reason_th: string | null;
        analysis_th: string | null;
        thesis_en: string | null;
        takeaway_en: string | null;
        thesis_th: string | null;
        takeaway_th: string | null;
      },
      ExtArgs['result']['investment_insights']
    >;
    composites: {};
  };

  type investment_insightsGetPayload<
    S extends boolean | null | undefined | investment_insightsDefaultArgs
  > = $Result.GetResult<Prisma.$investment_insightsPayload, S>;

  type investment_insightsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    investment_insightsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Investment_insightsCountAggregateInputType | true;
  };

  export interface investment_insightsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['investment_insights'];
      meta: { name: 'investment_insights' };
    };
    /**
     * Find zero or one Investment_insights that matches the filter.
     * @param {investment_insightsFindUniqueArgs} args - Arguments to find a Investment_insights
     * @example
     * // Get one Investment_insights
     * const investment_insights = await prisma.investment_insights.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends investment_insightsFindUniqueArgs>(
      args: SelectSubset<T, investment_insightsFindUniqueArgs<ExtArgs>>
    ): Prisma__investment_insightsClient<
      $Result.GetResult<
        Prisma.$investment_insightsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Investment_insights that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {investment_insightsFindUniqueOrThrowArgs} args - Arguments to find a Investment_insights
     * @example
     * // Get one Investment_insights
     * const investment_insights = await prisma.investment_insights.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends investment_insightsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, investment_insightsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__investment_insightsClient<
      $Result.GetResult<
        Prisma.$investment_insightsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Investment_insights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investment_insightsFindFirstArgs} args - Arguments to find a Investment_insights
     * @example
     * // Get one Investment_insights
     * const investment_insights = await prisma.investment_insights.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends investment_insightsFindFirstArgs>(
      args?: SelectSubset<T, investment_insightsFindFirstArgs<ExtArgs>>
    ): Prisma__investment_insightsClient<
      $Result.GetResult<
        Prisma.$investment_insightsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Investment_insights that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investment_insightsFindFirstOrThrowArgs} args - Arguments to find a Investment_insights
     * @example
     * // Get one Investment_insights
     * const investment_insights = await prisma.investment_insights.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends investment_insightsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, investment_insightsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__investment_insightsClient<
      $Result.GetResult<
        Prisma.$investment_insightsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Investment_insights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investment_insightsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investment_insights
     * const investment_insights = await prisma.investment_insights.findMany()
     *
     * // Get first 10 Investment_insights
     * const investment_insights = await prisma.investment_insights.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const investment_insightsWithIdOnly = await prisma.investment_insights.findMany({ select: { id: true } })
     *
     */
    findMany<T extends investment_insightsFindManyArgs>(
      args?: SelectSubset<T, investment_insightsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$investment_insightsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Investment_insights.
     * @param {investment_insightsCreateArgs} args - Arguments to create a Investment_insights.
     * @example
     * // Create one Investment_insights
     * const Investment_insights = await prisma.investment_insights.create({
     *   data: {
     *     // ... data to create a Investment_insights
     *   }
     * })
     *
     */
    create<T extends investment_insightsCreateArgs>(
      args: SelectSubset<T, investment_insightsCreateArgs<ExtArgs>>
    ): Prisma__investment_insightsClient<
      $Result.GetResult<
        Prisma.$investment_insightsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Investment_insights.
     * @param {investment_insightsCreateManyArgs} args - Arguments to create many Investment_insights.
     * @example
     * // Create many Investment_insights
     * const investment_insights = await prisma.investment_insights.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends investment_insightsCreateManyArgs>(
      args?: SelectSubset<T, investment_insightsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Investment_insights and returns the data saved in the database.
     * @param {investment_insightsCreateManyAndReturnArgs} args - Arguments to create many Investment_insights.
     * @example
     * // Create many Investment_insights
     * const investment_insights = await prisma.investment_insights.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Investment_insights and only return the `id`
     * const investment_insightsWithIdOnly = await prisma.investment_insights.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends investment_insightsCreateManyAndReturnArgs>(
      args?: SelectSubset<
        T,
        investment_insightsCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$investment_insightsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Investment_insights.
     * @param {investment_insightsDeleteArgs} args - Arguments to delete one Investment_insights.
     * @example
     * // Delete one Investment_insights
     * const Investment_insights = await prisma.investment_insights.delete({
     *   where: {
     *     // ... filter to delete one Investment_insights
     *   }
     * })
     *
     */
    delete<T extends investment_insightsDeleteArgs>(
      args: SelectSubset<T, investment_insightsDeleteArgs<ExtArgs>>
    ): Prisma__investment_insightsClient<
      $Result.GetResult<
        Prisma.$investment_insightsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Investment_insights.
     * @param {investment_insightsUpdateArgs} args - Arguments to update one Investment_insights.
     * @example
     * // Update one Investment_insights
     * const investment_insights = await prisma.investment_insights.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends investment_insightsUpdateArgs>(
      args: SelectSubset<T, investment_insightsUpdateArgs<ExtArgs>>
    ): Prisma__investment_insightsClient<
      $Result.GetResult<
        Prisma.$investment_insightsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Investment_insights.
     * @param {investment_insightsDeleteManyArgs} args - Arguments to filter Investment_insights to delete.
     * @example
     * // Delete a few Investment_insights
     * const { count } = await prisma.investment_insights.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends investment_insightsDeleteManyArgs>(
      args?: SelectSubset<T, investment_insightsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Investment_insights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investment_insightsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investment_insights
     * const investment_insights = await prisma.investment_insights.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends investment_insightsUpdateManyArgs>(
      args: SelectSubset<T, investment_insightsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Investment_insights and returns the data updated in the database.
     * @param {investment_insightsUpdateManyAndReturnArgs} args - Arguments to update many Investment_insights.
     * @example
     * // Update many Investment_insights
     * const investment_insights = await prisma.investment_insights.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Investment_insights and only return the `id`
     * const investment_insightsWithIdOnly = await prisma.investment_insights.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends investment_insightsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, investment_insightsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$investment_insightsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Investment_insights.
     * @param {investment_insightsUpsertArgs} args - Arguments to update or create a Investment_insights.
     * @example
     * // Update or create a Investment_insights
     * const investment_insights = await prisma.investment_insights.upsert({
     *   create: {
     *     // ... data to create a Investment_insights
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investment_insights we want to update
     *   }
     * })
     */
    upsert<T extends investment_insightsUpsertArgs>(
      args: SelectSubset<T, investment_insightsUpsertArgs<ExtArgs>>
    ): Prisma__investment_insightsClient<
      $Result.GetResult<
        Prisma.$investment_insightsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Investment_insights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investment_insightsCountArgs} args - Arguments to filter Investment_insights to count.
     * @example
     * // Count the number of Investment_insights
     * const count = await prisma.investment_insights.count({
     *   where: {
     *     // ... the filter for the Investment_insights we want to count
     *   }
     * })
     **/
    count<T extends investment_insightsCountArgs>(
      args?: Subset<T, investment_insightsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              Investment_insightsCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Investment_insights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Investment_insightsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Investment_insightsAggregateArgs>(
      args: Subset<T, Investment_insightsAggregateArgs>
    ): Prisma.PrismaPromise<GetInvestment_insightsAggregateType<T>>;

    /**
     * Group by Investment_insights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investment_insightsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends investment_insightsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: investment_insightsGroupByArgs['orderBy'] }
        : { orderBy?: investment_insightsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, investment_insightsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetInvestment_insightsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the investment_insights model
     */
    readonly fields: investment_insightsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for investment_insights.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__investment_insightsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the investment_insights model
   */
  interface investment_insightsFieldRefs {
    readonly id: FieldRef<'investment_insights', 'Int'>;
    readonly symbol: FieldRef<'investment_insights', 'String'>;
    readonly name: FieldRef<'investment_insights', 'String'>;
    readonly type: FieldRef<'investment_insights', 'String'>;
    readonly reason: FieldRef<'investment_insights', 'String'>;
    readonly recommendation: FieldRef<'investment_insights', 'String'>;
    readonly analysis: FieldRef<'investment_insights', 'String'>;
    readonly created_at: FieldRef<'investment_insights', 'DateTime'>;
    readonly reason_th: FieldRef<'investment_insights', 'String'>;
    readonly analysis_th: FieldRef<'investment_insights', 'String'>;
    readonly thesis_en: FieldRef<'investment_insights', 'String'>;
    readonly takeaway_en: FieldRef<'investment_insights', 'String'>;
    readonly thesis_th: FieldRef<'investment_insights', 'String'>;
    readonly takeaway_th: FieldRef<'investment_insights', 'String'>;
  }

  // Custom InputTypes
  /**
   * investment_insights findUnique
   */
  export type investment_insightsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the investment_insights
     */
    select?: investment_insightsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the investment_insights
     */
    omit?: investment_insightsOmit<ExtArgs> | null;
    /**
     * Filter, which investment_insights to fetch.
     */
    where: investment_insightsWhereUniqueInput;
  };

  /**
   * investment_insights findUniqueOrThrow
   */
  export type investment_insightsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the investment_insights
     */
    select?: investment_insightsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the investment_insights
     */
    omit?: investment_insightsOmit<ExtArgs> | null;
    /**
     * Filter, which investment_insights to fetch.
     */
    where: investment_insightsWhereUniqueInput;
  };

  /**
   * investment_insights findFirst
   */
  export type investment_insightsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the investment_insights
     */
    select?: investment_insightsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the investment_insights
     */
    omit?: investment_insightsOmit<ExtArgs> | null;
    /**
     * Filter, which investment_insights to fetch.
     */
    where?: investment_insightsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of investment_insights to fetch.
     */
    orderBy?:
      | investment_insightsOrderByWithRelationInput
      | investment_insightsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for investment_insights.
     */
    cursor?: investment_insightsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` investment_insights from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` investment_insights.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of investment_insights.
     */
    distinct?:
      | Investment_insightsScalarFieldEnum
      | Investment_insightsScalarFieldEnum[];
  };

  /**
   * investment_insights findFirstOrThrow
   */
  export type investment_insightsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the investment_insights
     */
    select?: investment_insightsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the investment_insights
     */
    omit?: investment_insightsOmit<ExtArgs> | null;
    /**
     * Filter, which investment_insights to fetch.
     */
    where?: investment_insightsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of investment_insights to fetch.
     */
    orderBy?:
      | investment_insightsOrderByWithRelationInput
      | investment_insightsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for investment_insights.
     */
    cursor?: investment_insightsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` investment_insights from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` investment_insights.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of investment_insights.
     */
    distinct?:
      | Investment_insightsScalarFieldEnum
      | Investment_insightsScalarFieldEnum[];
  };

  /**
   * investment_insights findMany
   */
  export type investment_insightsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the investment_insights
     */
    select?: investment_insightsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the investment_insights
     */
    omit?: investment_insightsOmit<ExtArgs> | null;
    /**
     * Filter, which investment_insights to fetch.
     */
    where?: investment_insightsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of investment_insights to fetch.
     */
    orderBy?:
      | investment_insightsOrderByWithRelationInput
      | investment_insightsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing investment_insights.
     */
    cursor?: investment_insightsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` investment_insights from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` investment_insights.
     */
    skip?: number;
    distinct?:
      | Investment_insightsScalarFieldEnum
      | Investment_insightsScalarFieldEnum[];
  };

  /**
   * investment_insights create
   */
  export type investment_insightsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the investment_insights
     */
    select?: investment_insightsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the investment_insights
     */
    omit?: investment_insightsOmit<ExtArgs> | null;
    /**
     * The data needed to create a investment_insights.
     */
    data: XOR<
      investment_insightsCreateInput,
      investment_insightsUncheckedCreateInput
    >;
  };

  /**
   * investment_insights createMany
   */
  export type investment_insightsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many investment_insights.
     */
    data:
      | investment_insightsCreateManyInput
      | investment_insightsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * investment_insights createManyAndReturn
   */
  export type investment_insightsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the investment_insights
     */
    select?: investment_insightsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the investment_insights
     */
    omit?: investment_insightsOmit<ExtArgs> | null;
    /**
     * The data used to create many investment_insights.
     */
    data:
      | investment_insightsCreateManyInput
      | investment_insightsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * investment_insights update
   */
  export type investment_insightsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the investment_insights
     */
    select?: investment_insightsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the investment_insights
     */
    omit?: investment_insightsOmit<ExtArgs> | null;
    /**
     * The data needed to update a investment_insights.
     */
    data: XOR<
      investment_insightsUpdateInput,
      investment_insightsUncheckedUpdateInput
    >;
    /**
     * Choose, which investment_insights to update.
     */
    where: investment_insightsWhereUniqueInput;
  };

  /**
   * investment_insights updateMany
   */
  export type investment_insightsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update investment_insights.
     */
    data: XOR<
      investment_insightsUpdateManyMutationInput,
      investment_insightsUncheckedUpdateManyInput
    >;
    /**
     * Filter which investment_insights to update
     */
    where?: investment_insightsWhereInput;
    /**
     * Limit how many investment_insights to update.
     */
    limit?: number;
  };

  /**
   * investment_insights updateManyAndReturn
   */
  export type investment_insightsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the investment_insights
     */
    select?: investment_insightsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the investment_insights
     */
    omit?: investment_insightsOmit<ExtArgs> | null;
    /**
     * The data used to update investment_insights.
     */
    data: XOR<
      investment_insightsUpdateManyMutationInput,
      investment_insightsUncheckedUpdateManyInput
    >;
    /**
     * Filter which investment_insights to update
     */
    where?: investment_insightsWhereInput;
    /**
     * Limit how many investment_insights to update.
     */
    limit?: number;
  };

  /**
   * investment_insights upsert
   */
  export type investment_insightsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the investment_insights
     */
    select?: investment_insightsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the investment_insights
     */
    omit?: investment_insightsOmit<ExtArgs> | null;
    /**
     * The filter to search for the investment_insights to update in case it exists.
     */
    where: investment_insightsWhereUniqueInput;
    /**
     * In case the investment_insights found by the `where` argument doesn't exist, create a new investment_insights with this data.
     */
    create: XOR<
      investment_insightsCreateInput,
      investment_insightsUncheckedCreateInput
    >;
    /**
     * In case the investment_insights was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      investment_insightsUpdateInput,
      investment_insightsUncheckedUpdateInput
    >;
  };

  /**
   * investment_insights delete
   */
  export type investment_insightsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the investment_insights
     */
    select?: investment_insightsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the investment_insights
     */
    omit?: investment_insightsOmit<ExtArgs> | null;
    /**
     * Filter which investment_insights to delete.
     */
    where: investment_insightsWhereUniqueInput;
  };

  /**
   * investment_insights deleteMany
   */
  export type investment_insightsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which investment_insights to delete
     */
    where?: investment_insightsWhereInput;
    /**
     * Limit how many investment_insights to delete.
     */
    limit?: number;
  };

  /**
   * investment_insights without action
   */
  export type investment_insightsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the investment_insights
     */
    select?: investment_insightsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the investment_insights
     */
    omit?: investment_insightsOmit<ExtArgs> | null;
  };

  /**
   * Model market_recap
   */

  export type AggregateMarket_recap = {
    _count: Market_recapCountAggregateOutputType | null;
    _avg: Market_recapAvgAggregateOutputType | null;
    _sum: Market_recapSumAggregateOutputType | null;
    _min: Market_recapMinAggregateOutputType | null;
    _max: Market_recapMaxAggregateOutputType | null;
  };

  export type Market_recapAvgAggregateOutputType = {
    id: number | null;
  };

  export type Market_recapSumAggregateOutputType = {
    id: number | null;
  };

  export type Market_recapMinAggregateOutputType = {
    stock_market_recap_en: string | null;
    stock_market_recap_th: string | null;
    sector_performance_en: string | null;
    sector_performance_th: string | null;
    economic_data_and_potential_concerns_en: string | null;
    economic_data_and_potential_concerns_th: string | null;
    other_market_activity_en: string | null;
    other_market_activity_th: string | null;
    summary_en: string | null;
    summary_th: string | null;
    id: number | null;
    created_at: Date | null;
    updated_at: Date | null;
  };

  export type Market_recapMaxAggregateOutputType = {
    stock_market_recap_en: string | null;
    stock_market_recap_th: string | null;
    sector_performance_en: string | null;
    sector_performance_th: string | null;
    economic_data_and_potential_concerns_en: string | null;
    economic_data_and_potential_concerns_th: string | null;
    other_market_activity_en: string | null;
    other_market_activity_th: string | null;
    summary_en: string | null;
    summary_th: string | null;
    id: number | null;
    created_at: Date | null;
    updated_at: Date | null;
  };

  export type Market_recapCountAggregateOutputType = {
    stock_market_recap_en: number;
    stock_market_recap_th: number;
    sector_performance_en: number;
    sector_performance_th: number;
    economic_data_and_potential_concerns_en: number;
    economic_data_and_potential_concerns_th: number;
    other_market_activity_en: number;
    other_market_activity_th: number;
    summary_en: number;
    summary_th: number;
    id: number;
    created_at: number;
    updated_at: number;
    _all: number;
  };

  export type Market_recapAvgAggregateInputType = {
    id?: true;
  };

  export type Market_recapSumAggregateInputType = {
    id?: true;
  };

  export type Market_recapMinAggregateInputType = {
    stock_market_recap_en?: true;
    stock_market_recap_th?: true;
    sector_performance_en?: true;
    sector_performance_th?: true;
    economic_data_and_potential_concerns_en?: true;
    economic_data_and_potential_concerns_th?: true;
    other_market_activity_en?: true;
    other_market_activity_th?: true;
    summary_en?: true;
    summary_th?: true;
    id?: true;
    created_at?: true;
    updated_at?: true;
  };

  export type Market_recapMaxAggregateInputType = {
    stock_market_recap_en?: true;
    stock_market_recap_th?: true;
    sector_performance_en?: true;
    sector_performance_th?: true;
    economic_data_and_potential_concerns_en?: true;
    economic_data_and_potential_concerns_th?: true;
    other_market_activity_en?: true;
    other_market_activity_th?: true;
    summary_en?: true;
    summary_th?: true;
    id?: true;
    created_at?: true;
    updated_at?: true;
  };

  export type Market_recapCountAggregateInputType = {
    stock_market_recap_en?: true;
    stock_market_recap_th?: true;
    sector_performance_en?: true;
    sector_performance_th?: true;
    economic_data_and_potential_concerns_en?: true;
    economic_data_and_potential_concerns_th?: true;
    other_market_activity_en?: true;
    other_market_activity_th?: true;
    summary_en?: true;
    summary_th?: true;
    id?: true;
    created_at?: true;
    updated_at?: true;
    _all?: true;
  };

  export type Market_recapAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which market_recap to aggregate.
     */
    where?: market_recapWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of market_recaps to fetch.
     */
    orderBy?:
      | market_recapOrderByWithRelationInput
      | market_recapOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: market_recapWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` market_recaps from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` market_recaps.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned market_recaps
     **/
    _count?: true | Market_recapCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Market_recapAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Market_recapSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Market_recapMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Market_recapMaxAggregateInputType;
  };

  export type GetMarket_recapAggregateType<
    T extends Market_recapAggregateArgs
  > = {
    [P in keyof T & keyof AggregateMarket_recap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarket_recap[P]>
      : GetScalarType<T[P], AggregateMarket_recap[P]>;
  };

  export type market_recapGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: market_recapWhereInput;
    orderBy?:
      | market_recapOrderByWithAggregationInput
      | market_recapOrderByWithAggregationInput[];
    by: Market_recapScalarFieldEnum[] | Market_recapScalarFieldEnum;
    having?: market_recapScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Market_recapCountAggregateInputType | true;
    _avg?: Market_recapAvgAggregateInputType;
    _sum?: Market_recapSumAggregateInputType;
    _min?: Market_recapMinAggregateInputType;
    _max?: Market_recapMaxAggregateInputType;
  };

  export type Market_recapGroupByOutputType = {
    stock_market_recap_en: string | null;
    stock_market_recap_th: string | null;
    sector_performance_en: string | null;
    sector_performance_th: string | null;
    economic_data_and_potential_concerns_en: string | null;
    economic_data_and_potential_concerns_th: string | null;
    other_market_activity_en: string | null;
    other_market_activity_th: string | null;
    summary_en: string | null;
    summary_th: string | null;
    id: number;
    created_at: Date | null;
    updated_at: Date | null;
    _count: Market_recapCountAggregateOutputType | null;
    _avg: Market_recapAvgAggregateOutputType | null;
    _sum: Market_recapSumAggregateOutputType | null;
    _min: Market_recapMinAggregateOutputType | null;
    _max: Market_recapMaxAggregateOutputType | null;
  };

  type GetMarket_recapGroupByPayload<T extends market_recapGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<Market_recapGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof Market_recapGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Market_recapGroupByOutputType[P]>
            : GetScalarType<T[P], Market_recapGroupByOutputType[P]>;
        }
      >
    >;

  export type market_recapSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      stock_market_recap_en?: boolean;
      stock_market_recap_th?: boolean;
      sector_performance_en?: boolean;
      sector_performance_th?: boolean;
      economic_data_and_potential_concerns_en?: boolean;
      economic_data_and_potential_concerns_th?: boolean;
      other_market_activity_en?: boolean;
      other_market_activity_th?: boolean;
      summary_en?: boolean;
      summary_th?: boolean;
      id?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['market_recap']
  >;

  export type market_recapSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      stock_market_recap_en?: boolean;
      stock_market_recap_th?: boolean;
      sector_performance_en?: boolean;
      sector_performance_th?: boolean;
      economic_data_and_potential_concerns_en?: boolean;
      economic_data_and_potential_concerns_th?: boolean;
      other_market_activity_en?: boolean;
      other_market_activity_th?: boolean;
      summary_en?: boolean;
      summary_th?: boolean;
      id?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['market_recap']
  >;

  export type market_recapSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      stock_market_recap_en?: boolean;
      stock_market_recap_th?: boolean;
      sector_performance_en?: boolean;
      sector_performance_th?: boolean;
      economic_data_and_potential_concerns_en?: boolean;
      economic_data_and_potential_concerns_th?: boolean;
      other_market_activity_en?: boolean;
      other_market_activity_th?: boolean;
      summary_en?: boolean;
      summary_th?: boolean;
      id?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['market_recap']
  >;

  export type market_recapSelectScalar = {
    stock_market_recap_en?: boolean;
    stock_market_recap_th?: boolean;
    sector_performance_en?: boolean;
    sector_performance_th?: boolean;
    economic_data_and_potential_concerns_en?: boolean;
    economic_data_and_potential_concerns_th?: boolean;
    other_market_activity_en?: boolean;
    other_market_activity_th?: boolean;
    summary_en?: boolean;
    summary_th?: boolean;
    id?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
  };

  export type market_recapOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'stock_market_recap_en'
    | 'stock_market_recap_th'
    | 'sector_performance_en'
    | 'sector_performance_th'
    | 'economic_data_and_potential_concerns_en'
    | 'economic_data_and_potential_concerns_th'
    | 'other_market_activity_en'
    | 'other_market_activity_th'
    | 'summary_en'
    | 'summary_th'
    | 'id'
    | 'created_at'
    | 'updated_at',
    ExtArgs['result']['market_recap']
  >;

  export type $market_recapPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'market_recap';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        stock_market_recap_en: string | null;
        stock_market_recap_th: string | null;
        sector_performance_en: string | null;
        sector_performance_th: string | null;
        economic_data_and_potential_concerns_en: string | null;
        economic_data_and_potential_concerns_th: string | null;
        other_market_activity_en: string | null;
        other_market_activity_th: string | null;
        summary_en: string | null;
        summary_th: string | null;
        id: number;
        created_at: Date | null;
        updated_at: Date | null;
      },
      ExtArgs['result']['market_recap']
    >;
    composites: {};
  };

  type market_recapGetPayload<
    S extends boolean | null | undefined | market_recapDefaultArgs
  > = $Result.GetResult<Prisma.$market_recapPayload, S>;

  type market_recapCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    market_recapFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Market_recapCountAggregateInputType | true;
  };

  export interface market_recapDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['market_recap'];
      meta: { name: 'market_recap' };
    };
    /**
     * Find zero or one Market_recap that matches the filter.
     * @param {market_recapFindUniqueArgs} args - Arguments to find a Market_recap
     * @example
     * // Get one Market_recap
     * const market_recap = await prisma.market_recap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends market_recapFindUniqueArgs>(
      args: SelectSubset<T, market_recapFindUniqueArgs<ExtArgs>>
    ): Prisma__market_recapClient<
      $Result.GetResult<
        Prisma.$market_recapPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Market_recap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {market_recapFindUniqueOrThrowArgs} args - Arguments to find a Market_recap
     * @example
     * // Get one Market_recap
     * const market_recap = await prisma.market_recap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends market_recapFindUniqueOrThrowArgs>(
      args: SelectSubset<T, market_recapFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__market_recapClient<
      $Result.GetResult<
        Prisma.$market_recapPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Market_recap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_recapFindFirstArgs} args - Arguments to find a Market_recap
     * @example
     * // Get one Market_recap
     * const market_recap = await prisma.market_recap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends market_recapFindFirstArgs>(
      args?: SelectSubset<T, market_recapFindFirstArgs<ExtArgs>>
    ): Prisma__market_recapClient<
      $Result.GetResult<
        Prisma.$market_recapPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Market_recap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_recapFindFirstOrThrowArgs} args - Arguments to find a Market_recap
     * @example
     * // Get one Market_recap
     * const market_recap = await prisma.market_recap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends market_recapFindFirstOrThrowArgs>(
      args?: SelectSubset<T, market_recapFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__market_recapClient<
      $Result.GetResult<
        Prisma.$market_recapPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Market_recaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_recapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Market_recaps
     * const market_recaps = await prisma.market_recap.findMany()
     *
     * // Get first 10 Market_recaps
     * const market_recaps = await prisma.market_recap.findMany({ take: 10 })
     *
     * // Only select the `stock_market_recap_en`
     * const market_recapWithStock_market_recap_enOnly = await prisma.market_recap.findMany({ select: { stock_market_recap_en: true } })
     *
     */
    findMany<T extends market_recapFindManyArgs>(
      args?: SelectSubset<T, market_recapFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$market_recapPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Market_recap.
     * @param {market_recapCreateArgs} args - Arguments to create a Market_recap.
     * @example
     * // Create one Market_recap
     * const Market_recap = await prisma.market_recap.create({
     *   data: {
     *     // ... data to create a Market_recap
     *   }
     * })
     *
     */
    create<T extends market_recapCreateArgs>(
      args: SelectSubset<T, market_recapCreateArgs<ExtArgs>>
    ): Prisma__market_recapClient<
      $Result.GetResult<
        Prisma.$market_recapPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Market_recaps.
     * @param {market_recapCreateManyArgs} args - Arguments to create many Market_recaps.
     * @example
     * // Create many Market_recaps
     * const market_recap = await prisma.market_recap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends market_recapCreateManyArgs>(
      args?: SelectSubset<T, market_recapCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Market_recaps and returns the data saved in the database.
     * @param {market_recapCreateManyAndReturnArgs} args - Arguments to create many Market_recaps.
     * @example
     * // Create many Market_recaps
     * const market_recap = await prisma.market_recap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Market_recaps and only return the `stock_market_recap_en`
     * const market_recapWithStock_market_recap_enOnly = await prisma.market_recap.createManyAndReturn({
     *   select: { stock_market_recap_en: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends market_recapCreateManyAndReturnArgs>(
      args?: SelectSubset<T, market_recapCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$market_recapPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Market_recap.
     * @param {market_recapDeleteArgs} args - Arguments to delete one Market_recap.
     * @example
     * // Delete one Market_recap
     * const Market_recap = await prisma.market_recap.delete({
     *   where: {
     *     // ... filter to delete one Market_recap
     *   }
     * })
     *
     */
    delete<T extends market_recapDeleteArgs>(
      args: SelectSubset<T, market_recapDeleteArgs<ExtArgs>>
    ): Prisma__market_recapClient<
      $Result.GetResult<
        Prisma.$market_recapPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Market_recap.
     * @param {market_recapUpdateArgs} args - Arguments to update one Market_recap.
     * @example
     * // Update one Market_recap
     * const market_recap = await prisma.market_recap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends market_recapUpdateArgs>(
      args: SelectSubset<T, market_recapUpdateArgs<ExtArgs>>
    ): Prisma__market_recapClient<
      $Result.GetResult<
        Prisma.$market_recapPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Market_recaps.
     * @param {market_recapDeleteManyArgs} args - Arguments to filter Market_recaps to delete.
     * @example
     * // Delete a few Market_recaps
     * const { count } = await prisma.market_recap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends market_recapDeleteManyArgs>(
      args?: SelectSubset<T, market_recapDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Market_recaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_recapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Market_recaps
     * const market_recap = await prisma.market_recap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends market_recapUpdateManyArgs>(
      args: SelectSubset<T, market_recapUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Market_recaps and returns the data updated in the database.
     * @param {market_recapUpdateManyAndReturnArgs} args - Arguments to update many Market_recaps.
     * @example
     * // Update many Market_recaps
     * const market_recap = await prisma.market_recap.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Market_recaps and only return the `stock_market_recap_en`
     * const market_recapWithStock_market_recap_enOnly = await prisma.market_recap.updateManyAndReturn({
     *   select: { stock_market_recap_en: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends market_recapUpdateManyAndReturnArgs>(
      args: SelectSubset<T, market_recapUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$market_recapPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Market_recap.
     * @param {market_recapUpsertArgs} args - Arguments to update or create a Market_recap.
     * @example
     * // Update or create a Market_recap
     * const market_recap = await prisma.market_recap.upsert({
     *   create: {
     *     // ... data to create a Market_recap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Market_recap we want to update
     *   }
     * })
     */
    upsert<T extends market_recapUpsertArgs>(
      args: SelectSubset<T, market_recapUpsertArgs<ExtArgs>>
    ): Prisma__market_recapClient<
      $Result.GetResult<
        Prisma.$market_recapPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Market_recaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_recapCountArgs} args - Arguments to filter Market_recaps to count.
     * @example
     * // Count the number of Market_recaps
     * const count = await prisma.market_recap.count({
     *   where: {
     *     // ... the filter for the Market_recaps we want to count
     *   }
     * })
     **/
    count<T extends market_recapCountArgs>(
      args?: Subset<T, market_recapCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Market_recapCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Market_recap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Market_recapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Market_recapAggregateArgs>(
      args: Subset<T, Market_recapAggregateArgs>
    ): Prisma.PrismaPromise<GetMarket_recapAggregateType<T>>;

    /**
     * Group by Market_recap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_recapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends market_recapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: market_recapGroupByArgs['orderBy'] }
        : { orderBy?: market_recapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, market_recapGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetMarket_recapGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the market_recap model
     */
    readonly fields: market_recapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for market_recap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__market_recapClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the market_recap model
   */
  interface market_recapFieldRefs {
    readonly stock_market_recap_en: FieldRef<'market_recap', 'String'>;
    readonly stock_market_recap_th: FieldRef<'market_recap', 'String'>;
    readonly sector_performance_en: FieldRef<'market_recap', 'String'>;
    readonly sector_performance_th: FieldRef<'market_recap', 'String'>;
    readonly economic_data_and_potential_concerns_en: FieldRef<
      'market_recap',
      'String'
    >;
    readonly economic_data_and_potential_concerns_th: FieldRef<
      'market_recap',
      'String'
    >;
    readonly other_market_activity_en: FieldRef<'market_recap', 'String'>;
    readonly other_market_activity_th: FieldRef<'market_recap', 'String'>;
    readonly summary_en: FieldRef<'market_recap', 'String'>;
    readonly summary_th: FieldRef<'market_recap', 'String'>;
    readonly id: FieldRef<'market_recap', 'Int'>;
    readonly created_at: FieldRef<'market_recap', 'DateTime'>;
    readonly updated_at: FieldRef<'market_recap', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * market_recap findUnique
   */
  export type market_recapFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the market_recap
     */
    select?: market_recapSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the market_recap
     */
    omit?: market_recapOmit<ExtArgs> | null;
    /**
     * Filter, which market_recap to fetch.
     */
    where: market_recapWhereUniqueInput;
  };

  /**
   * market_recap findUniqueOrThrow
   */
  export type market_recapFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the market_recap
     */
    select?: market_recapSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the market_recap
     */
    omit?: market_recapOmit<ExtArgs> | null;
    /**
     * Filter, which market_recap to fetch.
     */
    where: market_recapWhereUniqueInput;
  };

  /**
   * market_recap findFirst
   */
  export type market_recapFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the market_recap
     */
    select?: market_recapSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the market_recap
     */
    omit?: market_recapOmit<ExtArgs> | null;
    /**
     * Filter, which market_recap to fetch.
     */
    where?: market_recapWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of market_recaps to fetch.
     */
    orderBy?:
      | market_recapOrderByWithRelationInput
      | market_recapOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for market_recaps.
     */
    cursor?: market_recapWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` market_recaps from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` market_recaps.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of market_recaps.
     */
    distinct?: Market_recapScalarFieldEnum | Market_recapScalarFieldEnum[];
  };

  /**
   * market_recap findFirstOrThrow
   */
  export type market_recapFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the market_recap
     */
    select?: market_recapSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the market_recap
     */
    omit?: market_recapOmit<ExtArgs> | null;
    /**
     * Filter, which market_recap to fetch.
     */
    where?: market_recapWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of market_recaps to fetch.
     */
    orderBy?:
      | market_recapOrderByWithRelationInput
      | market_recapOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for market_recaps.
     */
    cursor?: market_recapWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` market_recaps from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` market_recaps.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of market_recaps.
     */
    distinct?: Market_recapScalarFieldEnum | Market_recapScalarFieldEnum[];
  };

  /**
   * market_recap findMany
   */
  export type market_recapFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the market_recap
     */
    select?: market_recapSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the market_recap
     */
    omit?: market_recapOmit<ExtArgs> | null;
    /**
     * Filter, which market_recaps to fetch.
     */
    where?: market_recapWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of market_recaps to fetch.
     */
    orderBy?:
      | market_recapOrderByWithRelationInput
      | market_recapOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing market_recaps.
     */
    cursor?: market_recapWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` market_recaps from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` market_recaps.
     */
    skip?: number;
    distinct?: Market_recapScalarFieldEnum | Market_recapScalarFieldEnum[];
  };

  /**
   * market_recap create
   */
  export type market_recapCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the market_recap
     */
    select?: market_recapSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the market_recap
     */
    omit?: market_recapOmit<ExtArgs> | null;
    /**
     * The data needed to create a market_recap.
     */
    data?: XOR<market_recapCreateInput, market_recapUncheckedCreateInput>;
  };

  /**
   * market_recap createMany
   */
  export type market_recapCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many market_recaps.
     */
    data: market_recapCreateManyInput | market_recapCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * market_recap createManyAndReturn
   */
  export type market_recapCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the market_recap
     */
    select?: market_recapSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the market_recap
     */
    omit?: market_recapOmit<ExtArgs> | null;
    /**
     * The data used to create many market_recaps.
     */
    data: market_recapCreateManyInput | market_recapCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * market_recap update
   */
  export type market_recapUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the market_recap
     */
    select?: market_recapSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the market_recap
     */
    omit?: market_recapOmit<ExtArgs> | null;
    /**
     * The data needed to update a market_recap.
     */
    data: XOR<market_recapUpdateInput, market_recapUncheckedUpdateInput>;
    /**
     * Choose, which market_recap to update.
     */
    where: market_recapWhereUniqueInput;
  };

  /**
   * market_recap updateMany
   */
  export type market_recapUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update market_recaps.
     */
    data: XOR<
      market_recapUpdateManyMutationInput,
      market_recapUncheckedUpdateManyInput
    >;
    /**
     * Filter which market_recaps to update
     */
    where?: market_recapWhereInput;
    /**
     * Limit how many market_recaps to update.
     */
    limit?: number;
  };

  /**
   * market_recap updateManyAndReturn
   */
  export type market_recapUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the market_recap
     */
    select?: market_recapSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the market_recap
     */
    omit?: market_recapOmit<ExtArgs> | null;
    /**
     * The data used to update market_recaps.
     */
    data: XOR<
      market_recapUpdateManyMutationInput,
      market_recapUncheckedUpdateManyInput
    >;
    /**
     * Filter which market_recaps to update
     */
    where?: market_recapWhereInput;
    /**
     * Limit how many market_recaps to update.
     */
    limit?: number;
  };

  /**
   * market_recap upsert
   */
  export type market_recapUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the market_recap
     */
    select?: market_recapSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the market_recap
     */
    omit?: market_recapOmit<ExtArgs> | null;
    /**
     * The filter to search for the market_recap to update in case it exists.
     */
    where: market_recapWhereUniqueInput;
    /**
     * In case the market_recap found by the `where` argument doesn't exist, create a new market_recap with this data.
     */
    create: XOR<market_recapCreateInput, market_recapUncheckedCreateInput>;
    /**
     * In case the market_recap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<market_recapUpdateInput, market_recapUncheckedUpdateInput>;
  };

  /**
   * market_recap delete
   */
  export type market_recapDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the market_recap
     */
    select?: market_recapSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the market_recap
     */
    omit?: market_recapOmit<ExtArgs> | null;
    /**
     * Filter which market_recap to delete.
     */
    where: market_recapWhereUniqueInput;
  };

  /**
   * market_recap deleteMany
   */
  export type market_recapDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which market_recaps to delete
     */
    where?: market_recapWhereInput;
    /**
     * Limit how many market_recaps to delete.
     */
    limit?: number;
  };

  /**
   * market_recap without action
   */
  export type market_recapDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the market_recap
     */
    select?: market_recapSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the market_recap
     */
    omit?: market_recapOmit<ExtArgs> | null;
  };

  /**
   * Model news_comments
   */

  export type AggregateNews_comments = {
    _count: News_commentsCountAggregateOutputType | null;
    _avg: News_commentsAvgAggregateOutputType | null;
    _sum: News_commentsSumAggregateOutputType | null;
    _min: News_commentsMinAggregateOutputType | null;
    _max: News_commentsMaxAggregateOutputType | null;
  };

  export type News_commentsAvgAggregateOutputType = {
    id: number | null;
    parent_comment_id: number | null;
    like_count: number | null;
    reply_count: number | null;
    user_id: number | null;
  };

  export type News_commentsSumAggregateOutputType = {
    id: number | null;
    parent_comment_id: number | null;
    like_count: number | null;
    reply_count: number | null;
    user_id: number | null;
  };

  export type News_commentsMinAggregateOutputType = {
    id: number | null;
    news_id: string | null;
    parent_comment_id: number | null;
    content: string | null;
    like_count: number | null;
    reply_count: number | null;
    is_active: boolean | null;
    created_at: Date | null;
    updated_at: Date | null;
    user_id: number | null;
  };

  export type News_commentsMaxAggregateOutputType = {
    id: number | null;
    news_id: string | null;
    parent_comment_id: number | null;
    content: string | null;
    like_count: number | null;
    reply_count: number | null;
    is_active: boolean | null;
    created_at: Date | null;
    updated_at: Date | null;
    user_id: number | null;
  };

  export type News_commentsCountAggregateOutputType = {
    id: number;
    news_id: number;
    parent_comment_id: number;
    content: number;
    like_count: number;
    reply_count: number;
    is_active: number;
    created_at: number;
    updated_at: number;
    user_id: number;
    _all: number;
  };

  export type News_commentsAvgAggregateInputType = {
    id?: true;
    parent_comment_id?: true;
    like_count?: true;
    reply_count?: true;
    user_id?: true;
  };

  export type News_commentsSumAggregateInputType = {
    id?: true;
    parent_comment_id?: true;
    like_count?: true;
    reply_count?: true;
    user_id?: true;
  };

  export type News_commentsMinAggregateInputType = {
    id?: true;
    news_id?: true;
    parent_comment_id?: true;
    content?: true;
    like_count?: true;
    reply_count?: true;
    is_active?: true;
    created_at?: true;
    updated_at?: true;
    user_id?: true;
  };

  export type News_commentsMaxAggregateInputType = {
    id?: true;
    news_id?: true;
    parent_comment_id?: true;
    content?: true;
    like_count?: true;
    reply_count?: true;
    is_active?: true;
    created_at?: true;
    updated_at?: true;
    user_id?: true;
  };

  export type News_commentsCountAggregateInputType = {
    id?: true;
    news_id?: true;
    parent_comment_id?: true;
    content?: true;
    like_count?: true;
    reply_count?: true;
    is_active?: true;
    created_at?: true;
    updated_at?: true;
    user_id?: true;
    _all?: true;
  };

  export type News_commentsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which news_comments to aggregate.
     */
    where?: news_commentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of news_comments to fetch.
     */
    orderBy?:
      | news_commentsOrderByWithRelationInput
      | news_commentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: news_commentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` news_comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` news_comments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned news_comments
     **/
    _count?: true | News_commentsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: News_commentsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: News_commentsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: News_commentsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: News_commentsMaxAggregateInputType;
  };

  export type GetNews_commentsAggregateType<
    T extends News_commentsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateNews_comments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews_comments[P]>
      : GetScalarType<T[P], AggregateNews_comments[P]>;
  };

  export type news_commentsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: news_commentsWhereInput;
    orderBy?:
      | news_commentsOrderByWithAggregationInput
      | news_commentsOrderByWithAggregationInput[];
    by: News_commentsScalarFieldEnum[] | News_commentsScalarFieldEnum;
    having?: news_commentsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: News_commentsCountAggregateInputType | true;
    _avg?: News_commentsAvgAggregateInputType;
    _sum?: News_commentsSumAggregateInputType;
    _min?: News_commentsMinAggregateInputType;
    _max?: News_commentsMaxAggregateInputType;
  };

  export type News_commentsGroupByOutputType = {
    id: number;
    news_id: string;
    parent_comment_id: number | null;
    content: string;
    like_count: number | null;
    reply_count: number | null;
    is_active: boolean | null;
    created_at: Date | null;
    updated_at: Date | null;
    user_id: number;
    _count: News_commentsCountAggregateOutputType | null;
    _avg: News_commentsAvgAggregateOutputType | null;
    _sum: News_commentsSumAggregateOutputType | null;
    _min: News_commentsMinAggregateOutputType | null;
    _max: News_commentsMaxAggregateOutputType | null;
  };

  type GetNews_commentsGroupByPayload<T extends news_commentsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<News_commentsGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof News_commentsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], News_commentsGroupByOutputType[P]>
            : GetScalarType<T[P], News_commentsGroupByOutputType[P]>;
        }
      >
    >;

  export type news_commentsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      news_id?: boolean;
      parent_comment_id?: boolean;
      content?: boolean;
      like_count?: boolean;
      reply_count?: boolean;
      is_active?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      user_id?: boolean;
      stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
      news_comments?: boolean | news_comments$news_commentsArgs<ExtArgs>;
      other_news_comments?:
        | boolean
        | news_comments$other_news_commentsArgs<ExtArgs>;
      _count?: boolean | News_commentsCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['news_comments']
  >;

  export type news_commentsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      news_id?: boolean;
      parent_comment_id?: boolean;
      content?: boolean;
      like_count?: boolean;
      reply_count?: boolean;
      is_active?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      user_id?: boolean;
      stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
      news_comments?: boolean | news_comments$news_commentsArgs<ExtArgs>;
    },
    ExtArgs['result']['news_comments']
  >;

  export type news_commentsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      news_id?: boolean;
      parent_comment_id?: boolean;
      content?: boolean;
      like_count?: boolean;
      reply_count?: boolean;
      is_active?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      user_id?: boolean;
      stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
      news_comments?: boolean | news_comments$news_commentsArgs<ExtArgs>;
    },
    ExtArgs['result']['news_comments']
  >;

  export type news_commentsSelectScalar = {
    id?: boolean;
    news_id?: boolean;
    parent_comment_id?: boolean;
    content?: boolean;
    like_count?: boolean;
    reply_count?: boolean;
    is_active?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    user_id?: boolean;
  };

  export type news_commentsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'news_id'
    | 'parent_comment_id'
    | 'content'
    | 'like_count'
    | 'reply_count'
    | 'is_active'
    | 'created_at'
    | 'updated_at'
    | 'user_id',
    ExtArgs['result']['news_comments']
  >;
  export type news_commentsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
    news_comments?: boolean | news_comments$news_commentsArgs<ExtArgs>;
    other_news_comments?:
      | boolean
      | news_comments$other_news_commentsArgs<ExtArgs>;
    _count?: boolean | News_commentsCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type news_commentsIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
    news_comments?: boolean | news_comments$news_commentsArgs<ExtArgs>;
  };
  export type news_commentsIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
    news_comments?: boolean | news_comments$news_commentsArgs<ExtArgs>;
  };

  export type $news_commentsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'news_comments';
    objects: {
      stock_news: Prisma.$stock_newsPayload<ExtArgs>;
      news_comments: Prisma.$news_commentsPayload<ExtArgs> | null;
      other_news_comments: Prisma.$news_commentsPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        news_id: string;
        parent_comment_id: number | null;
        content: string;
        like_count: number | null;
        reply_count: number | null;
        is_active: boolean | null;
        created_at: Date | null;
        updated_at: Date | null;
        user_id: number;
      },
      ExtArgs['result']['news_comments']
    >;
    composites: {};
  };

  type news_commentsGetPayload<
    S extends boolean | null | undefined | news_commentsDefaultArgs
  > = $Result.GetResult<Prisma.$news_commentsPayload, S>;

  type news_commentsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    news_commentsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: News_commentsCountAggregateInputType | true;
  };

  export interface news_commentsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['news_comments'];
      meta: { name: 'news_comments' };
    };
    /**
     * Find zero or one News_comments that matches the filter.
     * @param {news_commentsFindUniqueArgs} args - Arguments to find a News_comments
     * @example
     * // Get one News_comments
     * const news_comments = await prisma.news_comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends news_commentsFindUniqueArgs>(
      args: SelectSubset<T, news_commentsFindUniqueArgs<ExtArgs>>
    ): Prisma__news_commentsClient<
      $Result.GetResult<
        Prisma.$news_commentsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one News_comments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {news_commentsFindUniqueOrThrowArgs} args - Arguments to find a News_comments
     * @example
     * // Get one News_comments
     * const news_comments = await prisma.news_comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends news_commentsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, news_commentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__news_commentsClient<
      $Result.GetResult<
        Prisma.$news_commentsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first News_comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_commentsFindFirstArgs} args - Arguments to find a News_comments
     * @example
     * // Get one News_comments
     * const news_comments = await prisma.news_comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends news_commentsFindFirstArgs>(
      args?: SelectSubset<T, news_commentsFindFirstArgs<ExtArgs>>
    ): Prisma__news_commentsClient<
      $Result.GetResult<
        Prisma.$news_commentsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first News_comments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_commentsFindFirstOrThrowArgs} args - Arguments to find a News_comments
     * @example
     * // Get one News_comments
     * const news_comments = await prisma.news_comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends news_commentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, news_commentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__news_commentsClient<
      $Result.GetResult<
        Prisma.$news_commentsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more News_comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_commentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News_comments
     * const news_comments = await prisma.news_comments.findMany()
     *
     * // Get first 10 News_comments
     * const news_comments = await prisma.news_comments.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const news_commentsWithIdOnly = await prisma.news_comments.findMany({ select: { id: true } })
     *
     */
    findMany<T extends news_commentsFindManyArgs>(
      args?: SelectSubset<T, news_commentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$news_commentsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a News_comments.
     * @param {news_commentsCreateArgs} args - Arguments to create a News_comments.
     * @example
     * // Create one News_comments
     * const News_comments = await prisma.news_comments.create({
     *   data: {
     *     // ... data to create a News_comments
     *   }
     * })
     *
     */
    create<T extends news_commentsCreateArgs>(
      args: SelectSubset<T, news_commentsCreateArgs<ExtArgs>>
    ): Prisma__news_commentsClient<
      $Result.GetResult<
        Prisma.$news_commentsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many News_comments.
     * @param {news_commentsCreateManyArgs} args - Arguments to create many News_comments.
     * @example
     * // Create many News_comments
     * const news_comments = await prisma.news_comments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends news_commentsCreateManyArgs>(
      args?: SelectSubset<T, news_commentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many News_comments and returns the data saved in the database.
     * @param {news_commentsCreateManyAndReturnArgs} args - Arguments to create many News_comments.
     * @example
     * // Create many News_comments
     * const news_comments = await prisma.news_comments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many News_comments and only return the `id`
     * const news_commentsWithIdOnly = await prisma.news_comments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends news_commentsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, news_commentsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$news_commentsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a News_comments.
     * @param {news_commentsDeleteArgs} args - Arguments to delete one News_comments.
     * @example
     * // Delete one News_comments
     * const News_comments = await prisma.news_comments.delete({
     *   where: {
     *     // ... filter to delete one News_comments
     *   }
     * })
     *
     */
    delete<T extends news_commentsDeleteArgs>(
      args: SelectSubset<T, news_commentsDeleteArgs<ExtArgs>>
    ): Prisma__news_commentsClient<
      $Result.GetResult<
        Prisma.$news_commentsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one News_comments.
     * @param {news_commentsUpdateArgs} args - Arguments to update one News_comments.
     * @example
     * // Update one News_comments
     * const news_comments = await prisma.news_comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends news_commentsUpdateArgs>(
      args: SelectSubset<T, news_commentsUpdateArgs<ExtArgs>>
    ): Prisma__news_commentsClient<
      $Result.GetResult<
        Prisma.$news_commentsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more News_comments.
     * @param {news_commentsDeleteManyArgs} args - Arguments to filter News_comments to delete.
     * @example
     * // Delete a few News_comments
     * const { count } = await prisma.news_comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends news_commentsDeleteManyArgs>(
      args?: SelectSubset<T, news_commentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more News_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_commentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News_comments
     * const news_comments = await prisma.news_comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends news_commentsUpdateManyArgs>(
      args: SelectSubset<T, news_commentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more News_comments and returns the data updated in the database.
     * @param {news_commentsUpdateManyAndReturnArgs} args - Arguments to update many News_comments.
     * @example
     * // Update many News_comments
     * const news_comments = await prisma.news_comments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more News_comments and only return the `id`
     * const news_commentsWithIdOnly = await prisma.news_comments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends news_commentsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, news_commentsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$news_commentsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one News_comments.
     * @param {news_commentsUpsertArgs} args - Arguments to update or create a News_comments.
     * @example
     * // Update or create a News_comments
     * const news_comments = await prisma.news_comments.upsert({
     *   create: {
     *     // ... data to create a News_comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News_comments we want to update
     *   }
     * })
     */
    upsert<T extends news_commentsUpsertArgs>(
      args: SelectSubset<T, news_commentsUpsertArgs<ExtArgs>>
    ): Prisma__news_commentsClient<
      $Result.GetResult<
        Prisma.$news_commentsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of News_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_commentsCountArgs} args - Arguments to filter News_comments to count.
     * @example
     * // Count the number of News_comments
     * const count = await prisma.news_comments.count({
     *   where: {
     *     // ... the filter for the News_comments we want to count
     *   }
     * })
     **/
    count<T extends news_commentsCountArgs>(
      args?: Subset<T, news_commentsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], News_commentsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a News_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {News_commentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends News_commentsAggregateArgs>(
      args: Subset<T, News_commentsAggregateArgs>
    ): Prisma.PrismaPromise<GetNews_commentsAggregateType<T>>;

    /**
     * Group by News_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_commentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends news_commentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: news_commentsGroupByArgs['orderBy'] }
        : { orderBy?: news_commentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, news_commentsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetNews_commentsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the news_comments model
     */
    readonly fields: news_commentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for news_comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__news_commentsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    stock_news<T extends stock_newsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, stock_newsDefaultArgs<ExtArgs>>
    ): Prisma__stock_newsClient<
      | $Result.GetResult<
          Prisma.$stock_newsPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    news_comments<T extends news_comments$news_commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, news_comments$news_commentsArgs<ExtArgs>>
    ): Prisma__news_commentsClient<
      $Result.GetResult<
        Prisma.$news_commentsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    other_news_comments<
      T extends news_comments$other_news_commentsArgs<ExtArgs> = {}
    >(
      args?: Subset<T, news_comments$other_news_commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$news_commentsPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the news_comments model
   */
  interface news_commentsFieldRefs {
    readonly id: FieldRef<'news_comments', 'Int'>;
    readonly news_id: FieldRef<'news_comments', 'String'>;
    readonly parent_comment_id: FieldRef<'news_comments', 'Int'>;
    readonly content: FieldRef<'news_comments', 'String'>;
    readonly like_count: FieldRef<'news_comments', 'Int'>;
    readonly reply_count: FieldRef<'news_comments', 'Int'>;
    readonly is_active: FieldRef<'news_comments', 'Boolean'>;
    readonly created_at: FieldRef<'news_comments', 'DateTime'>;
    readonly updated_at: FieldRef<'news_comments', 'DateTime'>;
    readonly user_id: FieldRef<'news_comments', 'Int'>;
  }

  // Custom InputTypes
  /**
   * news_comments findUnique
   */
  export type news_commentsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_comments
     */
    select?: news_commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_comments
     */
    omit?: news_commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_commentsInclude<ExtArgs> | null;
    /**
     * Filter, which news_comments to fetch.
     */
    where: news_commentsWhereUniqueInput;
  };

  /**
   * news_comments findUniqueOrThrow
   */
  export type news_commentsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_comments
     */
    select?: news_commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_comments
     */
    omit?: news_commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_commentsInclude<ExtArgs> | null;
    /**
     * Filter, which news_comments to fetch.
     */
    where: news_commentsWhereUniqueInput;
  };

  /**
   * news_comments findFirst
   */
  export type news_commentsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_comments
     */
    select?: news_commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_comments
     */
    omit?: news_commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_commentsInclude<ExtArgs> | null;
    /**
     * Filter, which news_comments to fetch.
     */
    where?: news_commentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of news_comments to fetch.
     */
    orderBy?:
      | news_commentsOrderByWithRelationInput
      | news_commentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for news_comments.
     */
    cursor?: news_commentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` news_comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` news_comments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of news_comments.
     */
    distinct?: News_commentsScalarFieldEnum | News_commentsScalarFieldEnum[];
  };

  /**
   * news_comments findFirstOrThrow
   */
  export type news_commentsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_comments
     */
    select?: news_commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_comments
     */
    omit?: news_commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_commentsInclude<ExtArgs> | null;
    /**
     * Filter, which news_comments to fetch.
     */
    where?: news_commentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of news_comments to fetch.
     */
    orderBy?:
      | news_commentsOrderByWithRelationInput
      | news_commentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for news_comments.
     */
    cursor?: news_commentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` news_comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` news_comments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of news_comments.
     */
    distinct?: News_commentsScalarFieldEnum | News_commentsScalarFieldEnum[];
  };

  /**
   * news_comments findMany
   */
  export type news_commentsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_comments
     */
    select?: news_commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_comments
     */
    omit?: news_commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_commentsInclude<ExtArgs> | null;
    /**
     * Filter, which news_comments to fetch.
     */
    where?: news_commentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of news_comments to fetch.
     */
    orderBy?:
      | news_commentsOrderByWithRelationInput
      | news_commentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing news_comments.
     */
    cursor?: news_commentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` news_comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` news_comments.
     */
    skip?: number;
    distinct?: News_commentsScalarFieldEnum | News_commentsScalarFieldEnum[];
  };

  /**
   * news_comments create
   */
  export type news_commentsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_comments
     */
    select?: news_commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_comments
     */
    omit?: news_commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_commentsInclude<ExtArgs> | null;
    /**
     * The data needed to create a news_comments.
     */
    data: XOR<news_commentsCreateInput, news_commentsUncheckedCreateInput>;
  };

  /**
   * news_comments createMany
   */
  export type news_commentsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many news_comments.
     */
    data: news_commentsCreateManyInput | news_commentsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * news_comments createManyAndReturn
   */
  export type news_commentsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_comments
     */
    select?: news_commentsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the news_comments
     */
    omit?: news_commentsOmit<ExtArgs> | null;
    /**
     * The data used to create many news_comments.
     */
    data: news_commentsCreateManyInput | news_commentsCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_commentsIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * news_comments update
   */
  export type news_commentsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_comments
     */
    select?: news_commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_comments
     */
    omit?: news_commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_commentsInclude<ExtArgs> | null;
    /**
     * The data needed to update a news_comments.
     */
    data: XOR<news_commentsUpdateInput, news_commentsUncheckedUpdateInput>;
    /**
     * Choose, which news_comments to update.
     */
    where: news_commentsWhereUniqueInput;
  };

  /**
   * news_comments updateMany
   */
  export type news_commentsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update news_comments.
     */
    data: XOR<
      news_commentsUpdateManyMutationInput,
      news_commentsUncheckedUpdateManyInput
    >;
    /**
     * Filter which news_comments to update
     */
    where?: news_commentsWhereInput;
    /**
     * Limit how many news_comments to update.
     */
    limit?: number;
  };

  /**
   * news_comments updateManyAndReturn
   */
  export type news_commentsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_comments
     */
    select?: news_commentsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the news_comments
     */
    omit?: news_commentsOmit<ExtArgs> | null;
    /**
     * The data used to update news_comments.
     */
    data: XOR<
      news_commentsUpdateManyMutationInput,
      news_commentsUncheckedUpdateManyInput
    >;
    /**
     * Filter which news_comments to update
     */
    where?: news_commentsWhereInput;
    /**
     * Limit how many news_comments to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_commentsIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * news_comments upsert
   */
  export type news_commentsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_comments
     */
    select?: news_commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_comments
     */
    omit?: news_commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_commentsInclude<ExtArgs> | null;
    /**
     * The filter to search for the news_comments to update in case it exists.
     */
    where: news_commentsWhereUniqueInput;
    /**
     * In case the news_comments found by the `where` argument doesn't exist, create a new news_comments with this data.
     */
    create: XOR<news_commentsCreateInput, news_commentsUncheckedCreateInput>;
    /**
     * In case the news_comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<news_commentsUpdateInput, news_commentsUncheckedUpdateInput>;
  };

  /**
   * news_comments delete
   */
  export type news_commentsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_comments
     */
    select?: news_commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_comments
     */
    omit?: news_commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_commentsInclude<ExtArgs> | null;
    /**
     * Filter which news_comments to delete.
     */
    where: news_commentsWhereUniqueInput;
  };

  /**
   * news_comments deleteMany
   */
  export type news_commentsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which news_comments to delete
     */
    where?: news_commentsWhereInput;
    /**
     * Limit how many news_comments to delete.
     */
    limit?: number;
  };

  /**
   * news_comments.news_comments
   */
  export type news_comments$news_commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_comments
     */
    select?: news_commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_comments
     */
    omit?: news_commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_commentsInclude<ExtArgs> | null;
    where?: news_commentsWhereInput;
  };

  /**
   * news_comments.other_news_comments
   */
  export type news_comments$other_news_commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_comments
     */
    select?: news_commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_comments
     */
    omit?: news_commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_commentsInclude<ExtArgs> | null;
    where?: news_commentsWhereInput;
    orderBy?:
      | news_commentsOrderByWithRelationInput
      | news_commentsOrderByWithRelationInput[];
    cursor?: news_commentsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: News_commentsScalarFieldEnum | News_commentsScalarFieldEnum[];
  };

  /**
   * news_comments without action
   */
  export type news_commentsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_comments
     */
    select?: news_commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_comments
     */
    omit?: news_commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_commentsInclude<ExtArgs> | null;
  };

  /**
   * Model news_config
   */

  export type AggregateNews_config = {
    _count: News_configCountAggregateOutputType | null;
    _min: News_configMinAggregateOutputType | null;
    _max: News_configMaxAggregateOutputType | null;
  };

  export type News_configMinAggregateOutputType = {
    name: string | null;
  };

  export type News_configMaxAggregateOutputType = {
    name: string | null;
  };

  export type News_configCountAggregateOutputType = {
    name: number;
    value: number;
    _all: number;
  };

  export type News_configMinAggregateInputType = {
    name?: true;
  };

  export type News_configMaxAggregateInputType = {
    name?: true;
  };

  export type News_configCountAggregateInputType = {
    name?: true;
    value?: true;
    _all?: true;
  };

  export type News_configAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which news_config to aggregate.
     */
    where?: news_configWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of news_configs to fetch.
     */
    orderBy?:
      | news_configOrderByWithRelationInput
      | news_configOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: news_configWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` news_configs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` news_configs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned news_configs
     **/
    _count?: true | News_configCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: News_configMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: News_configMaxAggregateInputType;
  };

  export type GetNews_configAggregateType<T extends News_configAggregateArgs> =
    {
      [P in keyof T & keyof AggregateNews_config]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateNews_config[P]>
        : GetScalarType<T[P], AggregateNews_config[P]>;
    };

  export type news_configGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: news_configWhereInput;
    orderBy?:
      | news_configOrderByWithAggregationInput
      | news_configOrderByWithAggregationInput[];
    by: News_configScalarFieldEnum[] | News_configScalarFieldEnum;
    having?: news_configScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: News_configCountAggregateInputType | true;
    _min?: News_configMinAggregateInputType;
    _max?: News_configMaxAggregateInputType;
  };

  export type News_configGroupByOutputType = {
    name: string;
    value: JsonValue;
    _count: News_configCountAggregateOutputType | null;
    _min: News_configMinAggregateOutputType | null;
    _max: News_configMaxAggregateOutputType | null;
  };

  type GetNews_configGroupByPayload<T extends news_configGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<News_configGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof News_configGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], News_configGroupByOutputType[P]>
            : GetScalarType<T[P], News_configGroupByOutputType[P]>;
        }
      >
    >;

  export type news_configSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      name?: boolean;
      value?: boolean;
    },
    ExtArgs['result']['news_config']
  >;

  export type news_configSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      name?: boolean;
      value?: boolean;
    },
    ExtArgs['result']['news_config']
  >;

  export type news_configSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      name?: boolean;
      value?: boolean;
    },
    ExtArgs['result']['news_config']
  >;

  export type news_configSelectScalar = {
    name?: boolean;
    value?: boolean;
  };

  export type news_configOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<'name' | 'value', ExtArgs['result']['news_config']>;

  export type $news_configPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'news_config';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        name: string;
        value: Prisma.JsonValue;
      },
      ExtArgs['result']['news_config']
    >;
    composites: {};
  };

  type news_configGetPayload<
    S extends boolean | null | undefined | news_configDefaultArgs
  > = $Result.GetResult<Prisma.$news_configPayload, S>;

  type news_configCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    news_configFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: News_configCountAggregateInputType | true;
  };

  export interface news_configDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['news_config'];
      meta: { name: 'news_config' };
    };
    /**
     * Find zero or one News_config that matches the filter.
     * @param {news_configFindUniqueArgs} args - Arguments to find a News_config
     * @example
     * // Get one News_config
     * const news_config = await prisma.news_config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends news_configFindUniqueArgs>(
      args: SelectSubset<T, news_configFindUniqueArgs<ExtArgs>>
    ): Prisma__news_configClient<
      $Result.GetResult<
        Prisma.$news_configPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one News_config that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {news_configFindUniqueOrThrowArgs} args - Arguments to find a News_config
     * @example
     * // Get one News_config
     * const news_config = await prisma.news_config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends news_configFindUniqueOrThrowArgs>(
      args: SelectSubset<T, news_configFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__news_configClient<
      $Result.GetResult<
        Prisma.$news_configPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first News_config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_configFindFirstArgs} args - Arguments to find a News_config
     * @example
     * // Get one News_config
     * const news_config = await prisma.news_config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends news_configFindFirstArgs>(
      args?: SelectSubset<T, news_configFindFirstArgs<ExtArgs>>
    ): Prisma__news_configClient<
      $Result.GetResult<
        Prisma.$news_configPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first News_config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_configFindFirstOrThrowArgs} args - Arguments to find a News_config
     * @example
     * // Get one News_config
     * const news_config = await prisma.news_config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends news_configFindFirstOrThrowArgs>(
      args?: SelectSubset<T, news_configFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__news_configClient<
      $Result.GetResult<
        Prisma.$news_configPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more News_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News_configs
     * const news_configs = await prisma.news_config.findMany()
     *
     * // Get first 10 News_configs
     * const news_configs = await prisma.news_config.findMany({ take: 10 })
     *
     * // Only select the `name`
     * const news_configWithNameOnly = await prisma.news_config.findMany({ select: { name: true } })
     *
     */
    findMany<T extends news_configFindManyArgs>(
      args?: SelectSubset<T, news_configFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$news_configPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a News_config.
     * @param {news_configCreateArgs} args - Arguments to create a News_config.
     * @example
     * // Create one News_config
     * const News_config = await prisma.news_config.create({
     *   data: {
     *     // ... data to create a News_config
     *   }
     * })
     *
     */
    create<T extends news_configCreateArgs>(
      args: SelectSubset<T, news_configCreateArgs<ExtArgs>>
    ): Prisma__news_configClient<
      $Result.GetResult<
        Prisma.$news_configPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many News_configs.
     * @param {news_configCreateManyArgs} args - Arguments to create many News_configs.
     * @example
     * // Create many News_configs
     * const news_config = await prisma.news_config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends news_configCreateManyArgs>(
      args?: SelectSubset<T, news_configCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many News_configs and returns the data saved in the database.
     * @param {news_configCreateManyAndReturnArgs} args - Arguments to create many News_configs.
     * @example
     * // Create many News_configs
     * const news_config = await prisma.news_config.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many News_configs and only return the `name`
     * const news_configWithNameOnly = await prisma.news_config.createManyAndReturn({
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends news_configCreateManyAndReturnArgs>(
      args?: SelectSubset<T, news_configCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$news_configPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a News_config.
     * @param {news_configDeleteArgs} args - Arguments to delete one News_config.
     * @example
     * // Delete one News_config
     * const News_config = await prisma.news_config.delete({
     *   where: {
     *     // ... filter to delete one News_config
     *   }
     * })
     *
     */
    delete<T extends news_configDeleteArgs>(
      args: SelectSubset<T, news_configDeleteArgs<ExtArgs>>
    ): Prisma__news_configClient<
      $Result.GetResult<
        Prisma.$news_configPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one News_config.
     * @param {news_configUpdateArgs} args - Arguments to update one News_config.
     * @example
     * // Update one News_config
     * const news_config = await prisma.news_config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends news_configUpdateArgs>(
      args: SelectSubset<T, news_configUpdateArgs<ExtArgs>>
    ): Prisma__news_configClient<
      $Result.GetResult<
        Prisma.$news_configPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more News_configs.
     * @param {news_configDeleteManyArgs} args - Arguments to filter News_configs to delete.
     * @example
     * // Delete a few News_configs
     * const { count } = await prisma.news_config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends news_configDeleteManyArgs>(
      args?: SelectSubset<T, news_configDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more News_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News_configs
     * const news_config = await prisma.news_config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends news_configUpdateManyArgs>(
      args: SelectSubset<T, news_configUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more News_configs and returns the data updated in the database.
     * @param {news_configUpdateManyAndReturnArgs} args - Arguments to update many News_configs.
     * @example
     * // Update many News_configs
     * const news_config = await prisma.news_config.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more News_configs and only return the `name`
     * const news_configWithNameOnly = await prisma.news_config.updateManyAndReturn({
     *   select: { name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends news_configUpdateManyAndReturnArgs>(
      args: SelectSubset<T, news_configUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$news_configPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one News_config.
     * @param {news_configUpsertArgs} args - Arguments to update or create a News_config.
     * @example
     * // Update or create a News_config
     * const news_config = await prisma.news_config.upsert({
     *   create: {
     *     // ... data to create a News_config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News_config we want to update
     *   }
     * })
     */
    upsert<T extends news_configUpsertArgs>(
      args: SelectSubset<T, news_configUpsertArgs<ExtArgs>>
    ): Prisma__news_configClient<
      $Result.GetResult<
        Prisma.$news_configPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of News_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_configCountArgs} args - Arguments to filter News_configs to count.
     * @example
     * // Count the number of News_configs
     * const count = await prisma.news_config.count({
     *   where: {
     *     // ... the filter for the News_configs we want to count
     *   }
     * })
     **/
    count<T extends news_configCountArgs>(
      args?: Subset<T, news_configCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], News_configCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a News_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {News_configAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends News_configAggregateArgs>(
      args: Subset<T, News_configAggregateArgs>
    ): Prisma.PrismaPromise<GetNews_configAggregateType<T>>;

    /**
     * Group by News_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends news_configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: news_configGroupByArgs['orderBy'] }
        : { orderBy?: news_configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, news_configGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetNews_configGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the news_config model
     */
    readonly fields: news_configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for news_config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__news_configClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the news_config model
   */
  interface news_configFieldRefs {
    readonly name: FieldRef<'news_config', 'String'>;
    readonly value: FieldRef<'news_config', 'Json'>;
  }

  // Custom InputTypes
  /**
   * news_config findUnique
   */
  export type news_configFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_config
     */
    select?: news_configSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_config
     */
    omit?: news_configOmit<ExtArgs> | null;
    /**
     * Filter, which news_config to fetch.
     */
    where: news_configWhereUniqueInput;
  };

  /**
   * news_config findUniqueOrThrow
   */
  export type news_configFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_config
     */
    select?: news_configSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_config
     */
    omit?: news_configOmit<ExtArgs> | null;
    /**
     * Filter, which news_config to fetch.
     */
    where: news_configWhereUniqueInput;
  };

  /**
   * news_config findFirst
   */
  export type news_configFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_config
     */
    select?: news_configSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_config
     */
    omit?: news_configOmit<ExtArgs> | null;
    /**
     * Filter, which news_config to fetch.
     */
    where?: news_configWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of news_configs to fetch.
     */
    orderBy?:
      | news_configOrderByWithRelationInput
      | news_configOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for news_configs.
     */
    cursor?: news_configWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` news_configs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` news_configs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of news_configs.
     */
    distinct?: News_configScalarFieldEnum | News_configScalarFieldEnum[];
  };

  /**
   * news_config findFirstOrThrow
   */
  export type news_configFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_config
     */
    select?: news_configSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_config
     */
    omit?: news_configOmit<ExtArgs> | null;
    /**
     * Filter, which news_config to fetch.
     */
    where?: news_configWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of news_configs to fetch.
     */
    orderBy?:
      | news_configOrderByWithRelationInput
      | news_configOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for news_configs.
     */
    cursor?: news_configWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` news_configs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` news_configs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of news_configs.
     */
    distinct?: News_configScalarFieldEnum | News_configScalarFieldEnum[];
  };

  /**
   * news_config findMany
   */
  export type news_configFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_config
     */
    select?: news_configSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_config
     */
    omit?: news_configOmit<ExtArgs> | null;
    /**
     * Filter, which news_configs to fetch.
     */
    where?: news_configWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of news_configs to fetch.
     */
    orderBy?:
      | news_configOrderByWithRelationInput
      | news_configOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing news_configs.
     */
    cursor?: news_configWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` news_configs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` news_configs.
     */
    skip?: number;
    distinct?: News_configScalarFieldEnum | News_configScalarFieldEnum[];
  };

  /**
   * news_config create
   */
  export type news_configCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_config
     */
    select?: news_configSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_config
     */
    omit?: news_configOmit<ExtArgs> | null;
    /**
     * The data needed to create a news_config.
     */
    data: XOR<news_configCreateInput, news_configUncheckedCreateInput>;
  };

  /**
   * news_config createMany
   */
  export type news_configCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many news_configs.
     */
    data: news_configCreateManyInput | news_configCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * news_config createManyAndReturn
   */
  export type news_configCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_config
     */
    select?: news_configSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the news_config
     */
    omit?: news_configOmit<ExtArgs> | null;
    /**
     * The data used to create many news_configs.
     */
    data: news_configCreateManyInput | news_configCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * news_config update
   */
  export type news_configUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_config
     */
    select?: news_configSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_config
     */
    omit?: news_configOmit<ExtArgs> | null;
    /**
     * The data needed to update a news_config.
     */
    data: XOR<news_configUpdateInput, news_configUncheckedUpdateInput>;
    /**
     * Choose, which news_config to update.
     */
    where: news_configWhereUniqueInput;
  };

  /**
   * news_config updateMany
   */
  export type news_configUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update news_configs.
     */
    data: XOR<
      news_configUpdateManyMutationInput,
      news_configUncheckedUpdateManyInput
    >;
    /**
     * Filter which news_configs to update
     */
    where?: news_configWhereInput;
    /**
     * Limit how many news_configs to update.
     */
    limit?: number;
  };

  /**
   * news_config updateManyAndReturn
   */
  export type news_configUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_config
     */
    select?: news_configSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the news_config
     */
    omit?: news_configOmit<ExtArgs> | null;
    /**
     * The data used to update news_configs.
     */
    data: XOR<
      news_configUpdateManyMutationInput,
      news_configUncheckedUpdateManyInput
    >;
    /**
     * Filter which news_configs to update
     */
    where?: news_configWhereInput;
    /**
     * Limit how many news_configs to update.
     */
    limit?: number;
  };

  /**
   * news_config upsert
   */
  export type news_configUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_config
     */
    select?: news_configSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_config
     */
    omit?: news_configOmit<ExtArgs> | null;
    /**
     * The filter to search for the news_config to update in case it exists.
     */
    where: news_configWhereUniqueInput;
    /**
     * In case the news_config found by the `where` argument doesn't exist, create a new news_config with this data.
     */
    create: XOR<news_configCreateInput, news_configUncheckedCreateInput>;
    /**
     * In case the news_config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<news_configUpdateInput, news_configUncheckedUpdateInput>;
  };

  /**
   * news_config delete
   */
  export type news_configDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_config
     */
    select?: news_configSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_config
     */
    omit?: news_configOmit<ExtArgs> | null;
    /**
     * Filter which news_config to delete.
     */
    where: news_configWhereUniqueInput;
  };

  /**
   * news_config deleteMany
   */
  export type news_configDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which news_configs to delete
     */
    where?: news_configWhereInput;
    /**
     * Limit how many news_configs to delete.
     */
    limit?: number;
  };

  /**
   * news_config without action
   */
  export type news_configDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_config
     */
    select?: news_configSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_config
     */
    omit?: news_configOmit<ExtArgs> | null;
  };

  /**
   * Model payment_history
   */

  export type AggregatePayment_history = {
    _count: Payment_historyCountAggregateOutputType | null;
    _avg: Payment_historyAvgAggregateOutputType | null;
    _sum: Payment_historySumAggregateOutputType | null;
    _min: Payment_historyMinAggregateOutputType | null;
    _max: Payment_historyMaxAggregateOutputType | null;
  };

  export type Payment_historyAvgAggregateOutputType = {
    payment_id: number | null;
    user_subscription_id: number | null;
    amount: Decimal | null;
  };

  export type Payment_historySumAggregateOutputType = {
    payment_id: number | null;
    user_subscription_id: number | null;
    amount: Decimal | null;
  };

  export type Payment_historyMinAggregateOutputType = {
    payment_id: number | null;
    user_subscription_id: number | null;
    amount: Decimal | null;
    currency: string | null;
    payment_status: string | null;
    stripe_payment_intent_id: string | null;
    payment_method_id: string | null;
    payment_date: Date | null;
    billing_period_start: Date | null;
    billing_period_end: Date | null;
    invoice_url: string | null;
    error_message: string | null;
    stripe_invoice_id: string | null;
  };

  export type Payment_historyMaxAggregateOutputType = {
    payment_id: number | null;
    user_subscription_id: number | null;
    amount: Decimal | null;
    currency: string | null;
    payment_status: string | null;
    stripe_payment_intent_id: string | null;
    payment_method_id: string | null;
    payment_date: Date | null;
    billing_period_start: Date | null;
    billing_period_end: Date | null;
    invoice_url: string | null;
    error_message: string | null;
    stripe_invoice_id: string | null;
  };

  export type Payment_historyCountAggregateOutputType = {
    payment_id: number;
    user_subscription_id: number;
    amount: number;
    currency: number;
    payment_status: number;
    stripe_payment_intent_id: number;
    payment_method_id: number;
    payment_date: number;
    billing_period_start: number;
    billing_period_end: number;
    invoice_url: number;
    error_message: number;
    stripe_invoice_id: number;
    _all: number;
  };

  export type Payment_historyAvgAggregateInputType = {
    payment_id?: true;
    user_subscription_id?: true;
    amount?: true;
  };

  export type Payment_historySumAggregateInputType = {
    payment_id?: true;
    user_subscription_id?: true;
    amount?: true;
  };

  export type Payment_historyMinAggregateInputType = {
    payment_id?: true;
    user_subscription_id?: true;
    amount?: true;
    currency?: true;
    payment_status?: true;
    stripe_payment_intent_id?: true;
    payment_method_id?: true;
    payment_date?: true;
    billing_period_start?: true;
    billing_period_end?: true;
    invoice_url?: true;
    error_message?: true;
    stripe_invoice_id?: true;
  };

  export type Payment_historyMaxAggregateInputType = {
    payment_id?: true;
    user_subscription_id?: true;
    amount?: true;
    currency?: true;
    payment_status?: true;
    stripe_payment_intent_id?: true;
    payment_method_id?: true;
    payment_date?: true;
    billing_period_start?: true;
    billing_period_end?: true;
    invoice_url?: true;
    error_message?: true;
    stripe_invoice_id?: true;
  };

  export type Payment_historyCountAggregateInputType = {
    payment_id?: true;
    user_subscription_id?: true;
    amount?: true;
    currency?: true;
    payment_status?: true;
    stripe_payment_intent_id?: true;
    payment_method_id?: true;
    payment_date?: true;
    billing_period_start?: true;
    billing_period_end?: true;
    invoice_url?: true;
    error_message?: true;
    stripe_invoice_id?: true;
    _all?: true;
  };

  export type Payment_historyAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which payment_history to aggregate.
     */
    where?: payment_historyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of payment_histories to fetch.
     */
    orderBy?:
      | payment_historyOrderByWithRelationInput
      | payment_historyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: payment_historyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` payment_histories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` payment_histories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned payment_histories
     **/
    _count?: true | Payment_historyCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Payment_historyAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Payment_historySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Payment_historyMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Payment_historyMaxAggregateInputType;
  };

  export type GetPayment_historyAggregateType<
    T extends Payment_historyAggregateArgs
  > = {
    [P in keyof T & keyof AggregatePayment_history]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_history[P]>
      : GetScalarType<T[P], AggregatePayment_history[P]>;
  };

  export type payment_historyGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: payment_historyWhereInput;
    orderBy?:
      | payment_historyOrderByWithAggregationInput
      | payment_historyOrderByWithAggregationInput[];
    by: Payment_historyScalarFieldEnum[] | Payment_historyScalarFieldEnum;
    having?: payment_historyScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Payment_historyCountAggregateInputType | true;
    _avg?: Payment_historyAvgAggregateInputType;
    _sum?: Payment_historySumAggregateInputType;
    _min?: Payment_historyMinAggregateInputType;
    _max?: Payment_historyMaxAggregateInputType;
  };

  export type Payment_historyGroupByOutputType = {
    payment_id: number;
    user_subscription_id: number | null;
    amount: Decimal;
    currency: string | null;
    payment_status: string;
    stripe_payment_intent_id: string | null;
    payment_method_id: string | null;
    payment_date: Date | null;
    billing_period_start: Date | null;
    billing_period_end: Date | null;
    invoice_url: string | null;
    error_message: string | null;
    stripe_invoice_id: string | null;
    _count: Payment_historyCountAggregateOutputType | null;
    _avg: Payment_historyAvgAggregateOutputType | null;
    _sum: Payment_historySumAggregateOutputType | null;
    _min: Payment_historyMinAggregateOutputType | null;
    _max: Payment_historyMaxAggregateOutputType | null;
  };

  type GetPayment_historyGroupByPayload<T extends payment_historyGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<Payment_historyGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof Payment_historyGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_historyGroupByOutputType[P]>;
        }
      >
    >;

  export type payment_historySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      payment_id?: boolean;
      user_subscription_id?: boolean;
      amount?: boolean;
      currency?: boolean;
      payment_status?: boolean;
      stripe_payment_intent_id?: boolean;
      payment_method_id?: boolean;
      payment_date?: boolean;
      billing_period_start?: boolean;
      billing_period_end?: boolean;
      invoice_url?: boolean;
      error_message?: boolean;
      stripe_invoice_id?: boolean;
    },
    ExtArgs['result']['payment_history']
  >;

  export type payment_historySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      payment_id?: boolean;
      user_subscription_id?: boolean;
      amount?: boolean;
      currency?: boolean;
      payment_status?: boolean;
      stripe_payment_intent_id?: boolean;
      payment_method_id?: boolean;
      payment_date?: boolean;
      billing_period_start?: boolean;
      billing_period_end?: boolean;
      invoice_url?: boolean;
      error_message?: boolean;
      stripe_invoice_id?: boolean;
    },
    ExtArgs['result']['payment_history']
  >;

  export type payment_historySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      payment_id?: boolean;
      user_subscription_id?: boolean;
      amount?: boolean;
      currency?: boolean;
      payment_status?: boolean;
      stripe_payment_intent_id?: boolean;
      payment_method_id?: boolean;
      payment_date?: boolean;
      billing_period_start?: boolean;
      billing_period_end?: boolean;
      invoice_url?: boolean;
      error_message?: boolean;
      stripe_invoice_id?: boolean;
    },
    ExtArgs['result']['payment_history']
  >;

  export type payment_historySelectScalar = {
    payment_id?: boolean;
    user_subscription_id?: boolean;
    amount?: boolean;
    currency?: boolean;
    payment_status?: boolean;
    stripe_payment_intent_id?: boolean;
    payment_method_id?: boolean;
    payment_date?: boolean;
    billing_period_start?: boolean;
    billing_period_end?: boolean;
    invoice_url?: boolean;
    error_message?: boolean;
    stripe_invoice_id?: boolean;
  };

  export type payment_historyOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'payment_id'
    | 'user_subscription_id'
    | 'amount'
    | 'currency'
    | 'payment_status'
    | 'stripe_payment_intent_id'
    | 'payment_method_id'
    | 'payment_date'
    | 'billing_period_start'
    | 'billing_period_end'
    | 'invoice_url'
    | 'error_message'
    | 'stripe_invoice_id',
    ExtArgs['result']['payment_history']
  >;

  export type $payment_historyPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'payment_history';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        payment_id: number;
        user_subscription_id: number | null;
        amount: Prisma.Decimal;
        currency: string | null;
        payment_status: string;
        stripe_payment_intent_id: string | null;
        payment_method_id: string | null;
        payment_date: Date | null;
        billing_period_start: Date | null;
        billing_period_end: Date | null;
        invoice_url: string | null;
        error_message: string | null;
        stripe_invoice_id: string | null;
      },
      ExtArgs['result']['payment_history']
    >;
    composites: {};
  };

  type payment_historyGetPayload<
    S extends boolean | null | undefined | payment_historyDefaultArgs
  > = $Result.GetResult<Prisma.$payment_historyPayload, S>;

  type payment_historyCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    payment_historyFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Payment_historyCountAggregateInputType | true;
  };

  export interface payment_historyDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['payment_history'];
      meta: { name: 'payment_history' };
    };
    /**
     * Find zero or one Payment_history that matches the filter.
     * @param {payment_historyFindUniqueArgs} args - Arguments to find a Payment_history
     * @example
     * // Get one Payment_history
     * const payment_history = await prisma.payment_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_historyFindUniqueArgs>(
      args: SelectSubset<T, payment_historyFindUniqueArgs<ExtArgs>>
    ): Prisma__payment_historyClient<
      $Result.GetResult<
        Prisma.$payment_historyPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Payment_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_historyFindUniqueOrThrowArgs} args - Arguments to find a Payment_history
     * @example
     * // Get one Payment_history
     * const payment_history = await prisma.payment_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_historyFindUniqueOrThrowArgs>(
      args: SelectSubset<T, payment_historyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__payment_historyClient<
      $Result.GetResult<
        Prisma.$payment_historyPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Payment_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_historyFindFirstArgs} args - Arguments to find a Payment_history
     * @example
     * // Get one Payment_history
     * const payment_history = await prisma.payment_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_historyFindFirstArgs>(
      args?: SelectSubset<T, payment_historyFindFirstArgs<ExtArgs>>
    ): Prisma__payment_historyClient<
      $Result.GetResult<
        Prisma.$payment_historyPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Payment_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_historyFindFirstOrThrowArgs} args - Arguments to find a Payment_history
     * @example
     * // Get one Payment_history
     * const payment_history = await prisma.payment_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_historyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, payment_historyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__payment_historyClient<
      $Result.GetResult<
        Prisma.$payment_historyPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Payment_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_histories
     * const payment_histories = await prisma.payment_history.findMany()
     *
     * // Get first 10 Payment_histories
     * const payment_histories = await prisma.payment_history.findMany({ take: 10 })
     *
     * // Only select the `payment_id`
     * const payment_historyWithPayment_idOnly = await prisma.payment_history.findMany({ select: { payment_id: true } })
     *
     */
    findMany<T extends payment_historyFindManyArgs>(
      args?: SelectSubset<T, payment_historyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$payment_historyPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Payment_history.
     * @param {payment_historyCreateArgs} args - Arguments to create a Payment_history.
     * @example
     * // Create one Payment_history
     * const Payment_history = await prisma.payment_history.create({
     *   data: {
     *     // ... data to create a Payment_history
     *   }
     * })
     *
     */
    create<T extends payment_historyCreateArgs>(
      args: SelectSubset<T, payment_historyCreateArgs<ExtArgs>>
    ): Prisma__payment_historyClient<
      $Result.GetResult<
        Prisma.$payment_historyPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Payment_histories.
     * @param {payment_historyCreateManyArgs} args - Arguments to create many Payment_histories.
     * @example
     * // Create many Payment_histories
     * const payment_history = await prisma.payment_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends payment_historyCreateManyArgs>(
      args?: SelectSubset<T, payment_historyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Payment_histories and returns the data saved in the database.
     * @param {payment_historyCreateManyAndReturnArgs} args - Arguments to create many Payment_histories.
     * @example
     * // Create many Payment_histories
     * const payment_history = await prisma.payment_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Payment_histories and only return the `payment_id`
     * const payment_historyWithPayment_idOnly = await prisma.payment_history.createManyAndReturn({
     *   select: { payment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends payment_historyCreateManyAndReturnArgs>(
      args?: SelectSubset<T, payment_historyCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$payment_historyPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Payment_history.
     * @param {payment_historyDeleteArgs} args - Arguments to delete one Payment_history.
     * @example
     * // Delete one Payment_history
     * const Payment_history = await prisma.payment_history.delete({
     *   where: {
     *     // ... filter to delete one Payment_history
     *   }
     * })
     *
     */
    delete<T extends payment_historyDeleteArgs>(
      args: SelectSubset<T, payment_historyDeleteArgs<ExtArgs>>
    ): Prisma__payment_historyClient<
      $Result.GetResult<
        Prisma.$payment_historyPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Payment_history.
     * @param {payment_historyUpdateArgs} args - Arguments to update one Payment_history.
     * @example
     * // Update one Payment_history
     * const payment_history = await prisma.payment_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends payment_historyUpdateArgs>(
      args: SelectSubset<T, payment_historyUpdateArgs<ExtArgs>>
    ): Prisma__payment_historyClient<
      $Result.GetResult<
        Prisma.$payment_historyPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Payment_histories.
     * @param {payment_historyDeleteManyArgs} args - Arguments to filter Payment_histories to delete.
     * @example
     * // Delete a few Payment_histories
     * const { count } = await prisma.payment_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends payment_historyDeleteManyArgs>(
      args?: SelectSubset<T, payment_historyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Payment_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_histories
     * const payment_history = await prisma.payment_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends payment_historyUpdateManyArgs>(
      args: SelectSubset<T, payment_historyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Payment_histories and returns the data updated in the database.
     * @param {payment_historyUpdateManyAndReturnArgs} args - Arguments to update many Payment_histories.
     * @example
     * // Update many Payment_histories
     * const payment_history = await prisma.payment_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Payment_histories and only return the `payment_id`
     * const payment_historyWithPayment_idOnly = await prisma.payment_history.updateManyAndReturn({
     *   select: { payment_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends payment_historyUpdateManyAndReturnArgs>(
      args: SelectSubset<T, payment_historyUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$payment_historyPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Payment_history.
     * @param {payment_historyUpsertArgs} args - Arguments to update or create a Payment_history.
     * @example
     * // Update or create a Payment_history
     * const payment_history = await prisma.payment_history.upsert({
     *   create: {
     *     // ... data to create a Payment_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_history we want to update
     *   }
     * })
     */
    upsert<T extends payment_historyUpsertArgs>(
      args: SelectSubset<T, payment_historyUpsertArgs<ExtArgs>>
    ): Prisma__payment_historyClient<
      $Result.GetResult<
        Prisma.$payment_historyPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Payment_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_historyCountArgs} args - Arguments to filter Payment_histories to count.
     * @example
     * // Count the number of Payment_histories
     * const count = await prisma.payment_history.count({
     *   where: {
     *     // ... the filter for the Payment_histories we want to count
     *   }
     * })
     **/
    count<T extends payment_historyCountArgs>(
      args?: Subset<T, payment_historyCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_historyCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Payment_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Payment_historyAggregateArgs>(
      args: Subset<T, Payment_historyAggregateArgs>
    ): Prisma.PrismaPromise<GetPayment_historyAggregateType<T>>;

    /**
     * Group by Payment_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends payment_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_historyGroupByArgs['orderBy'] }
        : { orderBy?: payment_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, payment_historyGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetPayment_historyGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the payment_history model
     */
    readonly fields: payment_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_historyClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the payment_history model
   */
  interface payment_historyFieldRefs {
    readonly payment_id: FieldRef<'payment_history', 'Int'>;
    readonly user_subscription_id: FieldRef<'payment_history', 'Int'>;
    readonly amount: FieldRef<'payment_history', 'Decimal'>;
    readonly currency: FieldRef<'payment_history', 'String'>;
    readonly payment_status: FieldRef<'payment_history', 'String'>;
    readonly stripe_payment_intent_id: FieldRef<'payment_history', 'String'>;
    readonly payment_method_id: FieldRef<'payment_history', 'String'>;
    readonly payment_date: FieldRef<'payment_history', 'DateTime'>;
    readonly billing_period_start: FieldRef<'payment_history', 'DateTime'>;
    readonly billing_period_end: FieldRef<'payment_history', 'DateTime'>;
    readonly invoice_url: FieldRef<'payment_history', 'String'>;
    readonly error_message: FieldRef<'payment_history', 'String'>;
    readonly stripe_invoice_id: FieldRef<'payment_history', 'String'>;
  }

  // Custom InputTypes
  /**
   * payment_history findUnique
   */
  export type payment_historyFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the payment_history
     */
    select?: payment_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_history
     */
    omit?: payment_historyOmit<ExtArgs> | null;
    /**
     * Filter, which payment_history to fetch.
     */
    where: payment_historyWhereUniqueInput;
  };

  /**
   * payment_history findUniqueOrThrow
   */
  export type payment_historyFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the payment_history
     */
    select?: payment_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_history
     */
    omit?: payment_historyOmit<ExtArgs> | null;
    /**
     * Filter, which payment_history to fetch.
     */
    where: payment_historyWhereUniqueInput;
  };

  /**
   * payment_history findFirst
   */
  export type payment_historyFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the payment_history
     */
    select?: payment_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_history
     */
    omit?: payment_historyOmit<ExtArgs> | null;
    /**
     * Filter, which payment_history to fetch.
     */
    where?: payment_historyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of payment_histories to fetch.
     */
    orderBy?:
      | payment_historyOrderByWithRelationInput
      | payment_historyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for payment_histories.
     */
    cursor?: payment_historyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` payment_histories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` payment_histories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of payment_histories.
     */
    distinct?:
      | Payment_historyScalarFieldEnum
      | Payment_historyScalarFieldEnum[];
  };

  /**
   * payment_history findFirstOrThrow
   */
  export type payment_historyFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the payment_history
     */
    select?: payment_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_history
     */
    omit?: payment_historyOmit<ExtArgs> | null;
    /**
     * Filter, which payment_history to fetch.
     */
    where?: payment_historyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of payment_histories to fetch.
     */
    orderBy?:
      | payment_historyOrderByWithRelationInput
      | payment_historyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for payment_histories.
     */
    cursor?: payment_historyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` payment_histories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` payment_histories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of payment_histories.
     */
    distinct?:
      | Payment_historyScalarFieldEnum
      | Payment_historyScalarFieldEnum[];
  };

  /**
   * payment_history findMany
   */
  export type payment_historyFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the payment_history
     */
    select?: payment_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_history
     */
    omit?: payment_historyOmit<ExtArgs> | null;
    /**
     * Filter, which payment_histories to fetch.
     */
    where?: payment_historyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of payment_histories to fetch.
     */
    orderBy?:
      | payment_historyOrderByWithRelationInput
      | payment_historyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing payment_histories.
     */
    cursor?: payment_historyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` payment_histories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` payment_histories.
     */
    skip?: number;
    distinct?:
      | Payment_historyScalarFieldEnum
      | Payment_historyScalarFieldEnum[];
  };

  /**
   * payment_history create
   */
  export type payment_historyCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the payment_history
     */
    select?: payment_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_history
     */
    omit?: payment_historyOmit<ExtArgs> | null;
    /**
     * The data needed to create a payment_history.
     */
    data: XOR<payment_historyCreateInput, payment_historyUncheckedCreateInput>;
  };

  /**
   * payment_history createMany
   */
  export type payment_historyCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many payment_histories.
     */
    data: payment_historyCreateManyInput | payment_historyCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * payment_history createManyAndReturn
   */
  export type payment_historyCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the payment_history
     */
    select?: payment_historySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_history
     */
    omit?: payment_historyOmit<ExtArgs> | null;
    /**
     * The data used to create many payment_histories.
     */
    data: payment_historyCreateManyInput | payment_historyCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * payment_history update
   */
  export type payment_historyUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the payment_history
     */
    select?: payment_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_history
     */
    omit?: payment_historyOmit<ExtArgs> | null;
    /**
     * The data needed to update a payment_history.
     */
    data: XOR<payment_historyUpdateInput, payment_historyUncheckedUpdateInput>;
    /**
     * Choose, which payment_history to update.
     */
    where: payment_historyWhereUniqueInput;
  };

  /**
   * payment_history updateMany
   */
  export type payment_historyUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update payment_histories.
     */
    data: XOR<
      payment_historyUpdateManyMutationInput,
      payment_historyUncheckedUpdateManyInput
    >;
    /**
     * Filter which payment_histories to update
     */
    where?: payment_historyWhereInput;
    /**
     * Limit how many payment_histories to update.
     */
    limit?: number;
  };

  /**
   * payment_history updateManyAndReturn
   */
  export type payment_historyUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the payment_history
     */
    select?: payment_historySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_history
     */
    omit?: payment_historyOmit<ExtArgs> | null;
    /**
     * The data used to update payment_histories.
     */
    data: XOR<
      payment_historyUpdateManyMutationInput,
      payment_historyUncheckedUpdateManyInput
    >;
    /**
     * Filter which payment_histories to update
     */
    where?: payment_historyWhereInput;
    /**
     * Limit how many payment_histories to update.
     */
    limit?: number;
  };

  /**
   * payment_history upsert
   */
  export type payment_historyUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the payment_history
     */
    select?: payment_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_history
     */
    omit?: payment_historyOmit<ExtArgs> | null;
    /**
     * The filter to search for the payment_history to update in case it exists.
     */
    where: payment_historyWhereUniqueInput;
    /**
     * In case the payment_history found by the `where` argument doesn't exist, create a new payment_history with this data.
     */
    create: XOR<
      payment_historyCreateInput,
      payment_historyUncheckedCreateInput
    >;
    /**
     * In case the payment_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      payment_historyUpdateInput,
      payment_historyUncheckedUpdateInput
    >;
  };

  /**
   * payment_history delete
   */
  export type payment_historyDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the payment_history
     */
    select?: payment_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_history
     */
    omit?: payment_historyOmit<ExtArgs> | null;
    /**
     * Filter which payment_history to delete.
     */
    where: payment_historyWhereUniqueInput;
  };

  /**
   * payment_history deleteMany
   */
  export type payment_historyDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which payment_histories to delete
     */
    where?: payment_historyWhereInput;
    /**
     * Limit how many payment_histories to delete.
     */
    limit?: number;
  };

  /**
   * payment_history without action
   */
  export type payment_historyDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the payment_history
     */
    select?: payment_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_history
     */
    omit?: payment_historyOmit<ExtArgs> | null;
  };

  /**
   * Model permissions
   */

  export type AggregatePermissions = {
    _count: PermissionsCountAggregateOutputType | null;
    _avg: PermissionsAvgAggregateOutputType | null;
    _sum: PermissionsSumAggregateOutputType | null;
    _min: PermissionsMinAggregateOutputType | null;
    _max: PermissionsMaxAggregateOutputType | null;
  };

  export type PermissionsAvgAggregateOutputType = {
    permission_id: number | null;
    subscription_id: number | null;
  };

  export type PermissionsSumAggregateOutputType = {
    permission_id: number | null;
    subscription_id: number | null;
  };

  export type PermissionsMinAggregateOutputType = {
    permission_id: number | null;
    subscription_id: number | null;
    feature: string | null;
    is_enabled: boolean | null;
    limit_access: string | null;
  };

  export type PermissionsMaxAggregateOutputType = {
    permission_id: number | null;
    subscription_id: number | null;
    feature: string | null;
    is_enabled: boolean | null;
    limit_access: string | null;
  };

  export type PermissionsCountAggregateOutputType = {
    permission_id: number;
    subscription_id: number;
    feature: number;
    is_enabled: number;
    limit_access: number;
    _all: number;
  };

  export type PermissionsAvgAggregateInputType = {
    permission_id?: true;
    subscription_id?: true;
  };

  export type PermissionsSumAggregateInputType = {
    permission_id?: true;
    subscription_id?: true;
  };

  export type PermissionsMinAggregateInputType = {
    permission_id?: true;
    subscription_id?: true;
    feature?: true;
    is_enabled?: true;
    limit_access?: true;
  };

  export type PermissionsMaxAggregateInputType = {
    permission_id?: true;
    subscription_id?: true;
    feature?: true;
    is_enabled?: true;
    limit_access?: true;
  };

  export type PermissionsCountAggregateInputType = {
    permission_id?: true;
    subscription_id?: true;
    feature?: true;
    is_enabled?: true;
    limit_access?: true;
    _all?: true;
  };

  export type PermissionsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which permissions to aggregate.
     */
    where?: permissionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of permissions to fetch.
     */
    orderBy?:
      | permissionsOrderByWithRelationInput
      | permissionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: permissionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` permissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned permissions
     **/
    _count?: true | PermissionsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PermissionsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PermissionsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PermissionsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PermissionsMaxAggregateInputType;
  };

  export type GetPermissionsAggregateType<T extends PermissionsAggregateArgs> =
    {
      [P in keyof T & keyof AggregatePermissions]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregatePermissions[P]>
        : GetScalarType<T[P], AggregatePermissions[P]>;
    };

  export type permissionsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: permissionsWhereInput;
    orderBy?:
      | permissionsOrderByWithAggregationInput
      | permissionsOrderByWithAggregationInput[];
    by: PermissionsScalarFieldEnum[] | PermissionsScalarFieldEnum;
    having?: permissionsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PermissionsCountAggregateInputType | true;
    _avg?: PermissionsAvgAggregateInputType;
    _sum?: PermissionsSumAggregateInputType;
    _min?: PermissionsMinAggregateInputType;
    _max?: PermissionsMaxAggregateInputType;
  };

  export type PermissionsGroupByOutputType = {
    permission_id: number;
    subscription_id: number | null;
    feature: string | null;
    is_enabled: boolean | null;
    limit_access: string | null;
    _count: PermissionsCountAggregateOutputType | null;
    _avg: PermissionsAvgAggregateOutputType | null;
    _sum: PermissionsSumAggregateOutputType | null;
    _min: PermissionsMinAggregateOutputType | null;
    _max: PermissionsMaxAggregateOutputType | null;
  };

  type GetPermissionsGroupByPayload<T extends permissionsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PermissionsGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof PermissionsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionsGroupByOutputType[P]>;
        }
      >
    >;

  export type permissionsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      permission_id?: boolean;
      subscription_id?: boolean;
      feature?: boolean;
      is_enabled?: boolean;
      limit_access?: boolean;
      subscriptions?: boolean | permissions$subscriptionsArgs<ExtArgs>;
    },
    ExtArgs['result']['permissions']
  >;

  export type permissionsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      permission_id?: boolean;
      subscription_id?: boolean;
      feature?: boolean;
      is_enabled?: boolean;
      limit_access?: boolean;
      subscriptions?: boolean | permissions$subscriptionsArgs<ExtArgs>;
    },
    ExtArgs['result']['permissions']
  >;

  export type permissionsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      permission_id?: boolean;
      subscription_id?: boolean;
      feature?: boolean;
      is_enabled?: boolean;
      limit_access?: boolean;
      subscriptions?: boolean | permissions$subscriptionsArgs<ExtArgs>;
    },
    ExtArgs['result']['permissions']
  >;

  export type permissionsSelectScalar = {
    permission_id?: boolean;
    subscription_id?: boolean;
    feature?: boolean;
    is_enabled?: boolean;
    limit_access?: boolean;
  };

  export type permissionsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'permission_id'
    | 'subscription_id'
    | 'feature'
    | 'is_enabled'
    | 'limit_access',
    ExtArgs['result']['permissions']
  >;
  export type permissionsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    subscriptions?: boolean | permissions$subscriptionsArgs<ExtArgs>;
  };
  export type permissionsIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    subscriptions?: boolean | permissions$subscriptionsArgs<ExtArgs>;
  };
  export type permissionsIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    subscriptions?: boolean | permissions$subscriptionsArgs<ExtArgs>;
  };

  export type $permissionsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'permissions';
    objects: {
      subscriptions: Prisma.$subscriptionsPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        permission_id: number;
        subscription_id: number | null;
        feature: string | null;
        is_enabled: boolean | null;
        limit_access: string | null;
      },
      ExtArgs['result']['permissions']
    >;
    composites: {};
  };

  type permissionsGetPayload<
    S extends boolean | null | undefined | permissionsDefaultArgs
  > = $Result.GetResult<Prisma.$permissionsPayload, S>;

  type permissionsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    permissionsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: PermissionsCountAggregateInputType | true;
  };

  export interface permissionsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['permissions'];
      meta: { name: 'permissions' };
    };
    /**
     * Find zero or one Permissions that matches the filter.
     * @param {permissionsFindUniqueArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permissionsFindUniqueArgs>(
      args: SelectSubset<T, permissionsFindUniqueArgs<ExtArgs>>
    ): Prisma__permissionsClient<
      $Result.GetResult<
        Prisma.$permissionsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {permissionsFindUniqueOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permissionsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, permissionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__permissionsClient<
      $Result.GetResult<
        Prisma.$permissionsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindFirstArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permissionsFindFirstArgs>(
      args?: SelectSubset<T, permissionsFindFirstArgs<ExtArgs>>
    ): Prisma__permissionsClient<
      $Result.GetResult<
        Prisma.$permissionsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindFirstOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permissionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, permissionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__permissionsClient<
      $Result.GetResult<
        Prisma.$permissionsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permissions.findMany()
     *
     * // Get first 10 Permissions
     * const permissions = await prisma.permissions.findMany({ take: 10 })
     *
     * // Only select the `permission_id`
     * const permissionsWithPermission_idOnly = await prisma.permissions.findMany({ select: { permission_id: true } })
     *
     */
    findMany<T extends permissionsFindManyArgs>(
      args?: SelectSubset<T, permissionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$permissionsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Permissions.
     * @param {permissionsCreateArgs} args - Arguments to create a Permissions.
     * @example
     * // Create one Permissions
     * const Permissions = await prisma.permissions.create({
     *   data: {
     *     // ... data to create a Permissions
     *   }
     * })
     *
     */
    create<T extends permissionsCreateArgs>(
      args: SelectSubset<T, permissionsCreateArgs<ExtArgs>>
    ): Prisma__permissionsClient<
      $Result.GetResult<
        Prisma.$permissionsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Permissions.
     * @param {permissionsCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends permissionsCreateManyArgs>(
      args?: SelectSubset<T, permissionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {permissionsCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Permissions and only return the `permission_id`
     * const permissionsWithPermission_idOnly = await prisma.permissions.createManyAndReturn({
     *   select: { permission_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends permissionsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, permissionsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$permissionsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Permissions.
     * @param {permissionsDeleteArgs} args - Arguments to delete one Permissions.
     * @example
     * // Delete one Permissions
     * const Permissions = await prisma.permissions.delete({
     *   where: {
     *     // ... filter to delete one Permissions
     *   }
     * })
     *
     */
    delete<T extends permissionsDeleteArgs>(
      args: SelectSubset<T, permissionsDeleteArgs<ExtArgs>>
    ): Prisma__permissionsClient<
      $Result.GetResult<
        Prisma.$permissionsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Permissions.
     * @param {permissionsUpdateArgs} args - Arguments to update one Permissions.
     * @example
     * // Update one Permissions
     * const permissions = await prisma.permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends permissionsUpdateArgs>(
      args: SelectSubset<T, permissionsUpdateArgs<ExtArgs>>
    ): Prisma__permissionsClient<
      $Result.GetResult<
        Prisma.$permissionsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Permissions.
     * @param {permissionsDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends permissionsDeleteManyArgs>(
      args?: SelectSubset<T, permissionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends permissionsUpdateManyArgs>(
      args: SelectSubset<T, permissionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {permissionsUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Permissions and only return the `permission_id`
     * const permissionsWithPermission_idOnly = await prisma.permissions.updateManyAndReturn({
     *   select: { permission_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends permissionsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, permissionsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$permissionsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Permissions.
     * @param {permissionsUpsertArgs} args - Arguments to update or create a Permissions.
     * @example
     * // Update or create a Permissions
     * const permissions = await prisma.permissions.upsert({
     *   create: {
     *     // ... data to create a Permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissions we want to update
     *   }
     * })
     */
    upsert<T extends permissionsUpsertArgs>(
      args: SelectSubset<T, permissionsUpsertArgs<ExtArgs>>
    ): Prisma__permissionsClient<
      $Result.GetResult<
        Prisma.$permissionsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permissions.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
     **/
    count<T extends permissionsCountArgs>(
      args?: Subset<T, permissionsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PermissionsAggregateArgs>(
      args: Subset<T, PermissionsAggregateArgs>
    ): Prisma.PrismaPromise<GetPermissionsAggregateType<T>>;

    /**
     * Group by Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissionsGroupByArgs['orderBy'] }
        : { orderBy?: permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, permissionsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetPermissionsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the permissions model
     */
    readonly fields: permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permissionsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    subscriptions<T extends permissions$subscriptionsArgs<ExtArgs> = {}>(
      args?: Subset<T, permissions$subscriptionsArgs<ExtArgs>>
    ): Prisma__subscriptionsClient<
      $Result.GetResult<
        Prisma.$subscriptionsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the permissions model
   */
  interface permissionsFieldRefs {
    readonly permission_id: FieldRef<'permissions', 'Int'>;
    readonly subscription_id: FieldRef<'permissions', 'Int'>;
    readonly feature: FieldRef<'permissions', 'String'>;
    readonly is_enabled: FieldRef<'permissions', 'Boolean'>;
    readonly limit_access: FieldRef<'permissions', 'String'>;
  }

  // Custom InputTypes
  /**
   * permissions findUnique
   */
  export type permissionsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null;
    /**
     * Filter, which permissions to fetch.
     */
    where: permissionsWhereUniqueInput;
  };

  /**
   * permissions findUniqueOrThrow
   */
  export type permissionsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null;
    /**
     * Filter, which permissions to fetch.
     */
    where: permissionsWhereUniqueInput;
  };

  /**
   * permissions findFirst
   */
  export type permissionsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null;
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of permissions to fetch.
     */
    orderBy?:
      | permissionsOrderByWithRelationInput
      | permissionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for permissions.
     */
    cursor?: permissionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` permissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[];
  };

  /**
   * permissions findFirstOrThrow
   */
  export type permissionsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null;
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of permissions to fetch.
     */
    orderBy?:
      | permissionsOrderByWithRelationInput
      | permissionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for permissions.
     */
    cursor?: permissionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` permissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[];
  };

  /**
   * permissions findMany
   */
  export type permissionsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null;
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of permissions to fetch.
     */
    orderBy?:
      | permissionsOrderByWithRelationInput
      | permissionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing permissions.
     */
    cursor?: permissionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` permissions.
     */
    skip?: number;
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[];
  };

  /**
   * permissions create
   */
  export type permissionsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null;
    /**
     * The data needed to create a permissions.
     */
    data?: XOR<permissionsCreateInput, permissionsUncheckedCreateInput>;
  };

  /**
   * permissions createMany
   */
  export type permissionsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many permissions.
     */
    data: permissionsCreateManyInput | permissionsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * permissions createManyAndReturn
   */
  export type permissionsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null;
    /**
     * The data used to create many permissions.
     */
    data: permissionsCreateManyInput | permissionsCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * permissions update
   */
  export type permissionsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null;
    /**
     * The data needed to update a permissions.
     */
    data: XOR<permissionsUpdateInput, permissionsUncheckedUpdateInput>;
    /**
     * Choose, which permissions to update.
     */
    where: permissionsWhereUniqueInput;
  };

  /**
   * permissions updateMany
   */
  export type permissionsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update permissions.
     */
    data: XOR<
      permissionsUpdateManyMutationInput,
      permissionsUncheckedUpdateManyInput
    >;
    /**
     * Filter which permissions to update
     */
    where?: permissionsWhereInput;
    /**
     * Limit how many permissions to update.
     */
    limit?: number;
  };

  /**
   * permissions updateManyAndReturn
   */
  export type permissionsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null;
    /**
     * The data used to update permissions.
     */
    data: XOR<
      permissionsUpdateManyMutationInput,
      permissionsUncheckedUpdateManyInput
    >;
    /**
     * Filter which permissions to update
     */
    where?: permissionsWhereInput;
    /**
     * Limit how many permissions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * permissions upsert
   */
  export type permissionsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null;
    /**
     * The filter to search for the permissions to update in case it exists.
     */
    where: permissionsWhereUniqueInput;
    /**
     * In case the permissions found by the `where` argument doesn't exist, create a new permissions with this data.
     */
    create: XOR<permissionsCreateInput, permissionsUncheckedCreateInput>;
    /**
     * In case the permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionsUpdateInput, permissionsUncheckedUpdateInput>;
  };

  /**
   * permissions delete
   */
  export type permissionsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null;
    /**
     * Filter which permissions to delete.
     */
    where: permissionsWhereUniqueInput;
  };

  /**
   * permissions deleteMany
   */
  export type permissionsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which permissions to delete
     */
    where?: permissionsWhereInput;
    /**
     * Limit how many permissions to delete.
     */
    limit?: number;
  };

  /**
   * permissions.subscriptions
   */
  export type permissions$subscriptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null;
    where?: subscriptionsWhereInput;
  };

  /**
   * permissions without action
   */
  export type permissionsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null;
  };

  /**
   * Model portfolio
   */

  export type AggregatePortfolio = {
    _count: PortfolioCountAggregateOutputType | null;
    _avg: PortfolioAvgAggregateOutputType | null;
    _sum: PortfolioSumAggregateOutputType | null;
    _min: PortfolioMinAggregateOutputType | null;
    _max: PortfolioMaxAggregateOutputType | null;
  };

  export type PortfolioAvgAggregateOutputType = {
    portfolio_id: number | null;
    user_id: number | null;
    total_value: Decimal | null;
  };

  export type PortfolioSumAggregateOutputType = {
    portfolio_id: number | null;
    user_id: number | null;
    total_value: Decimal | null;
  };

  export type PortfolioMinAggregateOutputType = {
    portfolio_id: number | null;
    user_id: number | null;
    total_value: Decimal | null;
    updated_at: Date | null;
  };

  export type PortfolioMaxAggregateOutputType = {
    portfolio_id: number | null;
    user_id: number | null;
    total_value: Decimal | null;
    updated_at: Date | null;
  };

  export type PortfolioCountAggregateOutputType = {
    portfolio_id: number;
    user_id: number;
    total_value: number;
    updated_at: number;
    _all: number;
  };

  export type PortfolioAvgAggregateInputType = {
    portfolio_id?: true;
    user_id?: true;
    total_value?: true;
  };

  export type PortfolioSumAggregateInputType = {
    portfolio_id?: true;
    user_id?: true;
    total_value?: true;
  };

  export type PortfolioMinAggregateInputType = {
    portfolio_id?: true;
    user_id?: true;
    total_value?: true;
    updated_at?: true;
  };

  export type PortfolioMaxAggregateInputType = {
    portfolio_id?: true;
    user_id?: true;
    total_value?: true;
    updated_at?: true;
  };

  export type PortfolioCountAggregateInputType = {
    portfolio_id?: true;
    user_id?: true;
    total_value?: true;
    updated_at?: true;
    _all?: true;
  };

  export type PortfolioAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which portfolio to aggregate.
     */
    where?: portfolioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of portfolios to fetch.
     */
    orderBy?:
      | portfolioOrderByWithRelationInput
      | portfolioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: portfolioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` portfolios from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` portfolios.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned portfolios
     **/
    _count?: true | PortfolioCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PortfolioAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PortfolioSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PortfolioMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PortfolioMaxAggregateInputType;
  };

  export type GetPortfolioAggregateType<T extends PortfolioAggregateArgs> = {
    [P in keyof T & keyof AggregatePortfolio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolio[P]>
      : GetScalarType<T[P], AggregatePortfolio[P]>;
  };

  export type portfolioGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: portfolioWhereInput;
    orderBy?:
      | portfolioOrderByWithAggregationInput
      | portfolioOrderByWithAggregationInput[];
    by: PortfolioScalarFieldEnum[] | PortfolioScalarFieldEnum;
    having?: portfolioScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PortfolioCountAggregateInputType | true;
    _avg?: PortfolioAvgAggregateInputType;
    _sum?: PortfolioSumAggregateInputType;
    _min?: PortfolioMinAggregateInputType;
    _max?: PortfolioMaxAggregateInputType;
  };

  export type PortfolioGroupByOutputType = {
    portfolio_id: number;
    user_id: number;
    total_value: Decimal | null;
    updated_at: Date | null;
    _count: PortfolioCountAggregateOutputType | null;
    _avg: PortfolioAvgAggregateOutputType | null;
    _sum: PortfolioSumAggregateOutputType | null;
    _min: PortfolioMinAggregateOutputType | null;
    _max: PortfolioMaxAggregateOutputType | null;
  };

  type GetPortfolioGroupByPayload<T extends portfolioGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PortfolioGroupByOutputType, T['by']> & {
          [P in keyof T & keyof PortfolioGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioGroupByOutputType[P]>;
        }
      >
    >;

  export type portfolioSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      portfolio_id?: boolean;
      user_id?: boolean;
      total_value?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['portfolio']
  >;

  export type portfolioSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      portfolio_id?: boolean;
      user_id?: boolean;
      total_value?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['portfolio']
  >;

  export type portfolioSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      portfolio_id?: boolean;
      user_id?: boolean;
      total_value?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['portfolio']
  >;

  export type portfolioSelectScalar = {
    portfolio_id?: boolean;
    user_id?: boolean;
    total_value?: boolean;
    updated_at?: boolean;
  };

  export type portfolioOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'portfolio_id' | 'user_id' | 'total_value' | 'updated_at',
    ExtArgs['result']['portfolio']
  >;

  export type $portfolioPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'portfolio';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        portfolio_id: number;
        user_id: number;
        total_value: Prisma.Decimal | null;
        updated_at: Date | null;
      },
      ExtArgs['result']['portfolio']
    >;
    composites: {};
  };

  type portfolioGetPayload<
    S extends boolean | null | undefined | portfolioDefaultArgs
  > = $Result.GetResult<Prisma.$portfolioPayload, S>;

  type portfolioCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    portfolioFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: PortfolioCountAggregateInputType | true;
  };

  export interface portfolioDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['portfolio'];
      meta: { name: 'portfolio' };
    };
    /**
     * Find zero or one Portfolio that matches the filter.
     * @param {portfolioFindUniqueArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends portfolioFindUniqueArgs>(
      args: SelectSubset<T, portfolioFindUniqueArgs<ExtArgs>>
    ): Prisma__portfolioClient<
      $Result.GetResult<
        Prisma.$portfolioPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Portfolio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {portfolioFindUniqueOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends portfolioFindUniqueOrThrowArgs>(
      args: SelectSubset<T, portfolioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__portfolioClient<
      $Result.GetResult<
        Prisma.$portfolioPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Portfolio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioFindFirstArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends portfolioFindFirstArgs>(
      args?: SelectSubset<T, portfolioFindFirstArgs<ExtArgs>>
    ): Prisma__portfolioClient<
      $Result.GetResult<
        Prisma.$portfolioPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Portfolio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioFindFirstOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends portfolioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, portfolioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__portfolioClient<
      $Result.GetResult<
        Prisma.$portfolioPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Portfolios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Portfolios
     * const portfolios = await prisma.portfolio.findMany()
     *
     * // Get first 10 Portfolios
     * const portfolios = await prisma.portfolio.findMany({ take: 10 })
     *
     * // Only select the `portfolio_id`
     * const portfolioWithPortfolio_idOnly = await prisma.portfolio.findMany({ select: { portfolio_id: true } })
     *
     */
    findMany<T extends portfolioFindManyArgs>(
      args?: SelectSubset<T, portfolioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$portfolioPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Portfolio.
     * @param {portfolioCreateArgs} args - Arguments to create a Portfolio.
     * @example
     * // Create one Portfolio
     * const Portfolio = await prisma.portfolio.create({
     *   data: {
     *     // ... data to create a Portfolio
     *   }
     * })
     *
     */
    create<T extends portfolioCreateArgs>(
      args: SelectSubset<T, portfolioCreateArgs<ExtArgs>>
    ): Prisma__portfolioClient<
      $Result.GetResult<
        Prisma.$portfolioPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Portfolios.
     * @param {portfolioCreateManyArgs} args - Arguments to create many Portfolios.
     * @example
     * // Create many Portfolios
     * const portfolio = await prisma.portfolio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends portfolioCreateManyArgs>(
      args?: SelectSubset<T, portfolioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Portfolios and returns the data saved in the database.
     * @param {portfolioCreateManyAndReturnArgs} args - Arguments to create many Portfolios.
     * @example
     * // Create many Portfolios
     * const portfolio = await prisma.portfolio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Portfolios and only return the `portfolio_id`
     * const portfolioWithPortfolio_idOnly = await prisma.portfolio.createManyAndReturn({
     *   select: { portfolio_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends portfolioCreateManyAndReturnArgs>(
      args?: SelectSubset<T, portfolioCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$portfolioPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Portfolio.
     * @param {portfolioDeleteArgs} args - Arguments to delete one Portfolio.
     * @example
     * // Delete one Portfolio
     * const Portfolio = await prisma.portfolio.delete({
     *   where: {
     *     // ... filter to delete one Portfolio
     *   }
     * })
     *
     */
    delete<T extends portfolioDeleteArgs>(
      args: SelectSubset<T, portfolioDeleteArgs<ExtArgs>>
    ): Prisma__portfolioClient<
      $Result.GetResult<
        Prisma.$portfolioPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Portfolio.
     * @param {portfolioUpdateArgs} args - Arguments to update one Portfolio.
     * @example
     * // Update one Portfolio
     * const portfolio = await prisma.portfolio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends portfolioUpdateArgs>(
      args: SelectSubset<T, portfolioUpdateArgs<ExtArgs>>
    ): Prisma__portfolioClient<
      $Result.GetResult<
        Prisma.$portfolioPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Portfolios.
     * @param {portfolioDeleteManyArgs} args - Arguments to filter Portfolios to delete.
     * @example
     * // Delete a few Portfolios
     * const { count } = await prisma.portfolio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends portfolioDeleteManyArgs>(
      args?: SelectSubset<T, portfolioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Portfolios
     * const portfolio = await prisma.portfolio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends portfolioUpdateManyArgs>(
      args: SelectSubset<T, portfolioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Portfolios and returns the data updated in the database.
     * @param {portfolioUpdateManyAndReturnArgs} args - Arguments to update many Portfolios.
     * @example
     * // Update many Portfolios
     * const portfolio = await prisma.portfolio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Portfolios and only return the `portfolio_id`
     * const portfolioWithPortfolio_idOnly = await prisma.portfolio.updateManyAndReturn({
     *   select: { portfolio_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends portfolioUpdateManyAndReturnArgs>(
      args: SelectSubset<T, portfolioUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$portfolioPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Portfolio.
     * @param {portfolioUpsertArgs} args - Arguments to update or create a Portfolio.
     * @example
     * // Update or create a Portfolio
     * const portfolio = await prisma.portfolio.upsert({
     *   create: {
     *     // ... data to create a Portfolio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Portfolio we want to update
     *   }
     * })
     */
    upsert<T extends portfolioUpsertArgs>(
      args: SelectSubset<T, portfolioUpsertArgs<ExtArgs>>
    ): Prisma__portfolioClient<
      $Result.GetResult<
        Prisma.$portfolioPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioCountArgs} args - Arguments to filter Portfolios to count.
     * @example
     * // Count the number of Portfolios
     * const count = await prisma.portfolio.count({
     *   where: {
     *     // ... the filter for the Portfolios we want to count
     *   }
     * })
     **/
    count<T extends portfolioCountArgs>(
      args?: Subset<T, portfolioCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PortfolioAggregateArgs>(
      args: Subset<T, PortfolioAggregateArgs>
    ): Prisma.PrismaPromise<GetPortfolioAggregateType<T>>;

    /**
     * Group by Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends portfolioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: portfolioGroupByArgs['orderBy'] }
        : { orderBy?: portfolioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, portfolioGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetPortfolioGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the portfolio model
     */
    readonly fields: portfolioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for portfolio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__portfolioClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the portfolio model
   */
  interface portfolioFieldRefs {
    readonly portfolio_id: FieldRef<'portfolio', 'Int'>;
    readonly user_id: FieldRef<'portfolio', 'Int'>;
    readonly total_value: FieldRef<'portfolio', 'Decimal'>;
    readonly updated_at: FieldRef<'portfolio', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * portfolio findUnique
   */
  export type portfolioFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio
     */
    omit?: portfolioOmit<ExtArgs> | null;
    /**
     * Filter, which portfolio to fetch.
     */
    where: portfolioWhereUniqueInput;
  };

  /**
   * portfolio findUniqueOrThrow
   */
  export type portfolioFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio
     */
    omit?: portfolioOmit<ExtArgs> | null;
    /**
     * Filter, which portfolio to fetch.
     */
    where: portfolioWhereUniqueInput;
  };

  /**
   * portfolio findFirst
   */
  export type portfolioFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio
     */
    omit?: portfolioOmit<ExtArgs> | null;
    /**
     * Filter, which portfolio to fetch.
     */
    where?: portfolioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of portfolios to fetch.
     */
    orderBy?:
      | portfolioOrderByWithRelationInput
      | portfolioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for portfolios.
     */
    cursor?: portfolioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` portfolios from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` portfolios.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of portfolios.
     */
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[];
  };

  /**
   * portfolio findFirstOrThrow
   */
  export type portfolioFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio
     */
    omit?: portfolioOmit<ExtArgs> | null;
    /**
     * Filter, which portfolio to fetch.
     */
    where?: portfolioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of portfolios to fetch.
     */
    orderBy?:
      | portfolioOrderByWithRelationInput
      | portfolioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for portfolios.
     */
    cursor?: portfolioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` portfolios from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` portfolios.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of portfolios.
     */
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[];
  };

  /**
   * portfolio findMany
   */
  export type portfolioFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio
     */
    omit?: portfolioOmit<ExtArgs> | null;
    /**
     * Filter, which portfolios to fetch.
     */
    where?: portfolioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of portfolios to fetch.
     */
    orderBy?:
      | portfolioOrderByWithRelationInput
      | portfolioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing portfolios.
     */
    cursor?: portfolioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` portfolios from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` portfolios.
     */
    skip?: number;
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[];
  };

  /**
   * portfolio create
   */
  export type portfolioCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio
     */
    omit?: portfolioOmit<ExtArgs> | null;
    /**
     * The data needed to create a portfolio.
     */
    data: XOR<portfolioCreateInput, portfolioUncheckedCreateInput>;
  };

  /**
   * portfolio createMany
   */
  export type portfolioCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many portfolios.
     */
    data: portfolioCreateManyInput | portfolioCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * portfolio createManyAndReturn
   */
  export type portfolioCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio
     */
    omit?: portfolioOmit<ExtArgs> | null;
    /**
     * The data used to create many portfolios.
     */
    data: portfolioCreateManyInput | portfolioCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * portfolio update
   */
  export type portfolioUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio
     */
    omit?: portfolioOmit<ExtArgs> | null;
    /**
     * The data needed to update a portfolio.
     */
    data: XOR<portfolioUpdateInput, portfolioUncheckedUpdateInput>;
    /**
     * Choose, which portfolio to update.
     */
    where: portfolioWhereUniqueInput;
  };

  /**
   * portfolio updateMany
   */
  export type portfolioUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update portfolios.
     */
    data: XOR<
      portfolioUpdateManyMutationInput,
      portfolioUncheckedUpdateManyInput
    >;
    /**
     * Filter which portfolios to update
     */
    where?: portfolioWhereInput;
    /**
     * Limit how many portfolios to update.
     */
    limit?: number;
  };

  /**
   * portfolio updateManyAndReturn
   */
  export type portfolioUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio
     */
    omit?: portfolioOmit<ExtArgs> | null;
    /**
     * The data used to update portfolios.
     */
    data: XOR<
      portfolioUpdateManyMutationInput,
      portfolioUncheckedUpdateManyInput
    >;
    /**
     * Filter which portfolios to update
     */
    where?: portfolioWhereInput;
    /**
     * Limit how many portfolios to update.
     */
    limit?: number;
  };

  /**
   * portfolio upsert
   */
  export type portfolioUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio
     */
    omit?: portfolioOmit<ExtArgs> | null;
    /**
     * The filter to search for the portfolio to update in case it exists.
     */
    where: portfolioWhereUniqueInput;
    /**
     * In case the portfolio found by the `where` argument doesn't exist, create a new portfolio with this data.
     */
    create: XOR<portfolioCreateInput, portfolioUncheckedCreateInput>;
    /**
     * In case the portfolio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<portfolioUpdateInput, portfolioUncheckedUpdateInput>;
  };

  /**
   * portfolio delete
   */
  export type portfolioDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio
     */
    omit?: portfolioOmit<ExtArgs> | null;
    /**
     * Filter which portfolio to delete.
     */
    where: portfolioWhereUniqueInput;
  };

  /**
   * portfolio deleteMany
   */
  export type portfolioDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which portfolios to delete
     */
    where?: portfolioWhereInput;
    /**
     * Limit how many portfolios to delete.
     */
    limit?: number;
  };

  /**
   * portfolio without action
   */
  export type portfolioDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio
     */
    omit?: portfolioOmit<ExtArgs> | null;
  };

  /**
   * Model portfolio_holdings
   */

  export type AggregatePortfolio_holdings = {
    _count: Portfolio_holdingsCountAggregateOutputType | null;
    _avg: Portfolio_holdingsAvgAggregateOutputType | null;
    _sum: Portfolio_holdingsSumAggregateOutputType | null;
    _min: Portfolio_holdingsMinAggregateOutputType | null;
    _max: Portfolio_holdingsMaxAggregateOutputType | null;
  };

  export type Portfolio_holdingsAvgAggregateOutputType = {
    id: number | null;
    portfolio_id: number | null;
    total_quantity: Decimal | null;
    average_price: Decimal | null;
    total_invested: Decimal | null;
  };

  export type Portfolio_holdingsSumAggregateOutputType = {
    id: number | null;
    portfolio_id: number | null;
    total_quantity: Decimal | null;
    average_price: Decimal | null;
    total_invested: Decimal | null;
  };

  export type Portfolio_holdingsMinAggregateOutputType = {
    id: number | null;
    portfolio_id: number | null;
    symbol: string | null;
    total_quantity: Decimal | null;
    average_price: Decimal | null;
    total_invested: Decimal | null;
    updated_at: Date | null;
  };

  export type Portfolio_holdingsMaxAggregateOutputType = {
    id: number | null;
    portfolio_id: number | null;
    symbol: string | null;
    total_quantity: Decimal | null;
    average_price: Decimal | null;
    total_invested: Decimal | null;
    updated_at: Date | null;
  };

  export type Portfolio_holdingsCountAggregateOutputType = {
    id: number;
    portfolio_id: number;
    symbol: number;
    total_quantity: number;
    average_price: number;
    total_invested: number;
    updated_at: number;
    _all: number;
  };

  export type Portfolio_holdingsAvgAggregateInputType = {
    id?: true;
    portfolio_id?: true;
    total_quantity?: true;
    average_price?: true;
    total_invested?: true;
  };

  export type Portfolio_holdingsSumAggregateInputType = {
    id?: true;
    portfolio_id?: true;
    total_quantity?: true;
    average_price?: true;
    total_invested?: true;
  };

  export type Portfolio_holdingsMinAggregateInputType = {
    id?: true;
    portfolio_id?: true;
    symbol?: true;
    total_quantity?: true;
    average_price?: true;
    total_invested?: true;
    updated_at?: true;
  };

  export type Portfolio_holdingsMaxAggregateInputType = {
    id?: true;
    portfolio_id?: true;
    symbol?: true;
    total_quantity?: true;
    average_price?: true;
    total_invested?: true;
    updated_at?: true;
  };

  export type Portfolio_holdingsCountAggregateInputType = {
    id?: true;
    portfolio_id?: true;
    symbol?: true;
    total_quantity?: true;
    average_price?: true;
    total_invested?: true;
    updated_at?: true;
    _all?: true;
  };

  export type Portfolio_holdingsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which portfolio_holdings to aggregate.
     */
    where?: portfolio_holdingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of portfolio_holdings to fetch.
     */
    orderBy?:
      | portfolio_holdingsOrderByWithRelationInput
      | portfolio_holdingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: portfolio_holdingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` portfolio_holdings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` portfolio_holdings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned portfolio_holdings
     **/
    _count?: true | Portfolio_holdingsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Portfolio_holdingsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Portfolio_holdingsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Portfolio_holdingsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Portfolio_holdingsMaxAggregateInputType;
  };

  export type GetPortfolio_holdingsAggregateType<
    T extends Portfolio_holdingsAggregateArgs
  > = {
    [P in keyof T & keyof AggregatePortfolio_holdings]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolio_holdings[P]>
      : GetScalarType<T[P], AggregatePortfolio_holdings[P]>;
  };

  export type portfolio_holdingsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: portfolio_holdingsWhereInput;
    orderBy?:
      | portfolio_holdingsOrderByWithAggregationInput
      | portfolio_holdingsOrderByWithAggregationInput[];
    by: Portfolio_holdingsScalarFieldEnum[] | Portfolio_holdingsScalarFieldEnum;
    having?: portfolio_holdingsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Portfolio_holdingsCountAggregateInputType | true;
    _avg?: Portfolio_holdingsAvgAggregateInputType;
    _sum?: Portfolio_holdingsSumAggregateInputType;
    _min?: Portfolio_holdingsMinAggregateInputType;
    _max?: Portfolio_holdingsMaxAggregateInputType;
  };

  export type Portfolio_holdingsGroupByOutputType = {
    id: number;
    portfolio_id: number;
    symbol: string;
    total_quantity: Decimal | null;
    average_price: Decimal | null;
    total_invested: Decimal | null;
    updated_at: Date | null;
    _count: Portfolio_holdingsCountAggregateOutputType | null;
    _avg: Portfolio_holdingsAvgAggregateOutputType | null;
    _sum: Portfolio_holdingsSumAggregateOutputType | null;
    _min: Portfolio_holdingsMinAggregateOutputType | null;
    _max: Portfolio_holdingsMaxAggregateOutputType | null;
  };

  type GetPortfolio_holdingsGroupByPayload<
    T extends portfolio_holdingsGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Portfolio_holdingsGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof Portfolio_holdingsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], Portfolio_holdingsGroupByOutputType[P]>
          : GetScalarType<T[P], Portfolio_holdingsGroupByOutputType[P]>;
      }
    >
  >;

  export type portfolio_holdingsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      portfolio_id?: boolean;
      symbol?: boolean;
      total_quantity?: boolean;
      average_price?: boolean;
      total_invested?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['portfolio_holdings']
  >;

  export type portfolio_holdingsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      portfolio_id?: boolean;
      symbol?: boolean;
      total_quantity?: boolean;
      average_price?: boolean;
      total_invested?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['portfolio_holdings']
  >;

  export type portfolio_holdingsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      portfolio_id?: boolean;
      symbol?: boolean;
      total_quantity?: boolean;
      average_price?: boolean;
      total_invested?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['portfolio_holdings']
  >;

  export type portfolio_holdingsSelectScalar = {
    id?: boolean;
    portfolio_id?: boolean;
    symbol?: boolean;
    total_quantity?: boolean;
    average_price?: boolean;
    total_invested?: boolean;
    updated_at?: boolean;
  };

  export type portfolio_holdingsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'portfolio_id'
    | 'symbol'
    | 'total_quantity'
    | 'average_price'
    | 'total_invested'
    | 'updated_at',
    ExtArgs['result']['portfolio_holdings']
  >;

  export type $portfolio_holdingsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'portfolio_holdings';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        portfolio_id: number;
        symbol: string;
        total_quantity: Prisma.Decimal | null;
        average_price: Prisma.Decimal | null;
        total_invested: Prisma.Decimal | null;
        updated_at: Date | null;
      },
      ExtArgs['result']['portfolio_holdings']
    >;
    composites: {};
  };

  type portfolio_holdingsGetPayload<
    S extends boolean | null | undefined | portfolio_holdingsDefaultArgs
  > = $Result.GetResult<Prisma.$portfolio_holdingsPayload, S>;

  type portfolio_holdingsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    portfolio_holdingsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Portfolio_holdingsCountAggregateInputType | true;
  };

  export interface portfolio_holdingsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['portfolio_holdings'];
      meta: { name: 'portfolio_holdings' };
    };
    /**
     * Find zero or one Portfolio_holdings that matches the filter.
     * @param {portfolio_holdingsFindUniqueArgs} args - Arguments to find a Portfolio_holdings
     * @example
     * // Get one Portfolio_holdings
     * const portfolio_holdings = await prisma.portfolio_holdings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends portfolio_holdingsFindUniqueArgs>(
      args: SelectSubset<T, portfolio_holdingsFindUniqueArgs<ExtArgs>>
    ): Prisma__portfolio_holdingsClient<
      $Result.GetResult<
        Prisma.$portfolio_holdingsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Portfolio_holdings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {portfolio_holdingsFindUniqueOrThrowArgs} args - Arguments to find a Portfolio_holdings
     * @example
     * // Get one Portfolio_holdings
     * const portfolio_holdings = await prisma.portfolio_holdings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends portfolio_holdingsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, portfolio_holdingsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__portfolio_holdingsClient<
      $Result.GetResult<
        Prisma.$portfolio_holdingsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Portfolio_holdings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_holdingsFindFirstArgs} args - Arguments to find a Portfolio_holdings
     * @example
     * // Get one Portfolio_holdings
     * const portfolio_holdings = await prisma.portfolio_holdings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends portfolio_holdingsFindFirstArgs>(
      args?: SelectSubset<T, portfolio_holdingsFindFirstArgs<ExtArgs>>
    ): Prisma__portfolio_holdingsClient<
      $Result.GetResult<
        Prisma.$portfolio_holdingsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Portfolio_holdings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_holdingsFindFirstOrThrowArgs} args - Arguments to find a Portfolio_holdings
     * @example
     * // Get one Portfolio_holdings
     * const portfolio_holdings = await prisma.portfolio_holdings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends portfolio_holdingsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, portfolio_holdingsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__portfolio_holdingsClient<
      $Result.GetResult<
        Prisma.$portfolio_holdingsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Portfolio_holdings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_holdingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Portfolio_holdings
     * const portfolio_holdings = await prisma.portfolio_holdings.findMany()
     *
     * // Get first 10 Portfolio_holdings
     * const portfolio_holdings = await prisma.portfolio_holdings.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const portfolio_holdingsWithIdOnly = await prisma.portfolio_holdings.findMany({ select: { id: true } })
     *
     */
    findMany<T extends portfolio_holdingsFindManyArgs>(
      args?: SelectSubset<T, portfolio_holdingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$portfolio_holdingsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Portfolio_holdings.
     * @param {portfolio_holdingsCreateArgs} args - Arguments to create a Portfolio_holdings.
     * @example
     * // Create one Portfolio_holdings
     * const Portfolio_holdings = await prisma.portfolio_holdings.create({
     *   data: {
     *     // ... data to create a Portfolio_holdings
     *   }
     * })
     *
     */
    create<T extends portfolio_holdingsCreateArgs>(
      args: SelectSubset<T, portfolio_holdingsCreateArgs<ExtArgs>>
    ): Prisma__portfolio_holdingsClient<
      $Result.GetResult<
        Prisma.$portfolio_holdingsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Portfolio_holdings.
     * @param {portfolio_holdingsCreateManyArgs} args - Arguments to create many Portfolio_holdings.
     * @example
     * // Create many Portfolio_holdings
     * const portfolio_holdings = await prisma.portfolio_holdings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends portfolio_holdingsCreateManyArgs>(
      args?: SelectSubset<T, portfolio_holdingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Portfolio_holdings and returns the data saved in the database.
     * @param {portfolio_holdingsCreateManyAndReturnArgs} args - Arguments to create many Portfolio_holdings.
     * @example
     * // Create many Portfolio_holdings
     * const portfolio_holdings = await prisma.portfolio_holdings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Portfolio_holdings and only return the `id`
     * const portfolio_holdingsWithIdOnly = await prisma.portfolio_holdings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends portfolio_holdingsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, portfolio_holdingsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$portfolio_holdingsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Portfolio_holdings.
     * @param {portfolio_holdingsDeleteArgs} args - Arguments to delete one Portfolio_holdings.
     * @example
     * // Delete one Portfolio_holdings
     * const Portfolio_holdings = await prisma.portfolio_holdings.delete({
     *   where: {
     *     // ... filter to delete one Portfolio_holdings
     *   }
     * })
     *
     */
    delete<T extends portfolio_holdingsDeleteArgs>(
      args: SelectSubset<T, portfolio_holdingsDeleteArgs<ExtArgs>>
    ): Prisma__portfolio_holdingsClient<
      $Result.GetResult<
        Prisma.$portfolio_holdingsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Portfolio_holdings.
     * @param {portfolio_holdingsUpdateArgs} args - Arguments to update one Portfolio_holdings.
     * @example
     * // Update one Portfolio_holdings
     * const portfolio_holdings = await prisma.portfolio_holdings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends portfolio_holdingsUpdateArgs>(
      args: SelectSubset<T, portfolio_holdingsUpdateArgs<ExtArgs>>
    ): Prisma__portfolio_holdingsClient<
      $Result.GetResult<
        Prisma.$portfolio_holdingsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Portfolio_holdings.
     * @param {portfolio_holdingsDeleteManyArgs} args - Arguments to filter Portfolio_holdings to delete.
     * @example
     * // Delete a few Portfolio_holdings
     * const { count } = await prisma.portfolio_holdings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends portfolio_holdingsDeleteManyArgs>(
      args?: SelectSubset<T, portfolio_holdingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Portfolio_holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_holdingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Portfolio_holdings
     * const portfolio_holdings = await prisma.portfolio_holdings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends portfolio_holdingsUpdateManyArgs>(
      args: SelectSubset<T, portfolio_holdingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Portfolio_holdings and returns the data updated in the database.
     * @param {portfolio_holdingsUpdateManyAndReturnArgs} args - Arguments to update many Portfolio_holdings.
     * @example
     * // Update many Portfolio_holdings
     * const portfolio_holdings = await prisma.portfolio_holdings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Portfolio_holdings and only return the `id`
     * const portfolio_holdingsWithIdOnly = await prisma.portfolio_holdings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends portfolio_holdingsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, portfolio_holdingsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$portfolio_holdingsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Portfolio_holdings.
     * @param {portfolio_holdingsUpsertArgs} args - Arguments to update or create a Portfolio_holdings.
     * @example
     * // Update or create a Portfolio_holdings
     * const portfolio_holdings = await prisma.portfolio_holdings.upsert({
     *   create: {
     *     // ... data to create a Portfolio_holdings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Portfolio_holdings we want to update
     *   }
     * })
     */
    upsert<T extends portfolio_holdingsUpsertArgs>(
      args: SelectSubset<T, portfolio_holdingsUpsertArgs<ExtArgs>>
    ): Prisma__portfolio_holdingsClient<
      $Result.GetResult<
        Prisma.$portfolio_holdingsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Portfolio_holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_holdingsCountArgs} args - Arguments to filter Portfolio_holdings to count.
     * @example
     * // Count the number of Portfolio_holdings
     * const count = await prisma.portfolio_holdings.count({
     *   where: {
     *     // ... the filter for the Portfolio_holdings we want to count
     *   }
     * })
     **/
    count<T extends portfolio_holdingsCountArgs>(
      args?: Subset<T, portfolio_holdingsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              Portfolio_holdingsCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Portfolio_holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Portfolio_holdingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Portfolio_holdingsAggregateArgs>(
      args: Subset<T, Portfolio_holdingsAggregateArgs>
    ): Prisma.PrismaPromise<GetPortfolio_holdingsAggregateType<T>>;

    /**
     * Group by Portfolio_holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_holdingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends portfolio_holdingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: portfolio_holdingsGroupByArgs['orderBy'] }
        : { orderBy?: portfolio_holdingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, portfolio_holdingsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetPortfolio_holdingsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the portfolio_holdings model
     */
    readonly fields: portfolio_holdingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for portfolio_holdings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__portfolio_holdingsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the portfolio_holdings model
   */
  interface portfolio_holdingsFieldRefs {
    readonly id: FieldRef<'portfolio_holdings', 'Int'>;
    readonly portfolio_id: FieldRef<'portfolio_holdings', 'Int'>;
    readonly symbol: FieldRef<'portfolio_holdings', 'String'>;
    readonly total_quantity: FieldRef<'portfolio_holdings', 'Decimal'>;
    readonly average_price: FieldRef<'portfolio_holdings', 'Decimal'>;
    readonly total_invested: FieldRef<'portfolio_holdings', 'Decimal'>;
    readonly updated_at: FieldRef<'portfolio_holdings', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * portfolio_holdings findUnique
   */
  export type portfolio_holdingsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_holdings
     */
    select?: portfolio_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_holdings
     */
    omit?: portfolio_holdingsOmit<ExtArgs> | null;
    /**
     * Filter, which portfolio_holdings to fetch.
     */
    where: portfolio_holdingsWhereUniqueInput;
  };

  /**
   * portfolio_holdings findUniqueOrThrow
   */
  export type portfolio_holdingsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_holdings
     */
    select?: portfolio_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_holdings
     */
    omit?: portfolio_holdingsOmit<ExtArgs> | null;
    /**
     * Filter, which portfolio_holdings to fetch.
     */
    where: portfolio_holdingsWhereUniqueInput;
  };

  /**
   * portfolio_holdings findFirst
   */
  export type portfolio_holdingsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_holdings
     */
    select?: portfolio_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_holdings
     */
    omit?: portfolio_holdingsOmit<ExtArgs> | null;
    /**
     * Filter, which portfolio_holdings to fetch.
     */
    where?: portfolio_holdingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of portfolio_holdings to fetch.
     */
    orderBy?:
      | portfolio_holdingsOrderByWithRelationInput
      | portfolio_holdingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for portfolio_holdings.
     */
    cursor?: portfolio_holdingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` portfolio_holdings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` portfolio_holdings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of portfolio_holdings.
     */
    distinct?:
      | Portfolio_holdingsScalarFieldEnum
      | Portfolio_holdingsScalarFieldEnum[];
  };

  /**
   * portfolio_holdings findFirstOrThrow
   */
  export type portfolio_holdingsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_holdings
     */
    select?: portfolio_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_holdings
     */
    omit?: portfolio_holdingsOmit<ExtArgs> | null;
    /**
     * Filter, which portfolio_holdings to fetch.
     */
    where?: portfolio_holdingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of portfolio_holdings to fetch.
     */
    orderBy?:
      | portfolio_holdingsOrderByWithRelationInput
      | portfolio_holdingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for portfolio_holdings.
     */
    cursor?: portfolio_holdingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` portfolio_holdings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` portfolio_holdings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of portfolio_holdings.
     */
    distinct?:
      | Portfolio_holdingsScalarFieldEnum
      | Portfolio_holdingsScalarFieldEnum[];
  };

  /**
   * portfolio_holdings findMany
   */
  export type portfolio_holdingsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_holdings
     */
    select?: portfolio_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_holdings
     */
    omit?: portfolio_holdingsOmit<ExtArgs> | null;
    /**
     * Filter, which portfolio_holdings to fetch.
     */
    where?: portfolio_holdingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of portfolio_holdings to fetch.
     */
    orderBy?:
      | portfolio_holdingsOrderByWithRelationInput
      | portfolio_holdingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing portfolio_holdings.
     */
    cursor?: portfolio_holdingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` portfolio_holdings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` portfolio_holdings.
     */
    skip?: number;
    distinct?:
      | Portfolio_holdingsScalarFieldEnum
      | Portfolio_holdingsScalarFieldEnum[];
  };

  /**
   * portfolio_holdings create
   */
  export type portfolio_holdingsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_holdings
     */
    select?: portfolio_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_holdings
     */
    omit?: portfolio_holdingsOmit<ExtArgs> | null;
    /**
     * The data needed to create a portfolio_holdings.
     */
    data: XOR<
      portfolio_holdingsCreateInput,
      portfolio_holdingsUncheckedCreateInput
    >;
  };

  /**
   * portfolio_holdings createMany
   */
  export type portfolio_holdingsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many portfolio_holdings.
     */
    data:
      | portfolio_holdingsCreateManyInput
      | portfolio_holdingsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * portfolio_holdings createManyAndReturn
   */
  export type portfolio_holdingsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_holdings
     */
    select?: portfolio_holdingsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_holdings
     */
    omit?: portfolio_holdingsOmit<ExtArgs> | null;
    /**
     * The data used to create many portfolio_holdings.
     */
    data:
      | portfolio_holdingsCreateManyInput
      | portfolio_holdingsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * portfolio_holdings update
   */
  export type portfolio_holdingsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_holdings
     */
    select?: portfolio_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_holdings
     */
    omit?: portfolio_holdingsOmit<ExtArgs> | null;
    /**
     * The data needed to update a portfolio_holdings.
     */
    data: XOR<
      portfolio_holdingsUpdateInput,
      portfolio_holdingsUncheckedUpdateInput
    >;
    /**
     * Choose, which portfolio_holdings to update.
     */
    where: portfolio_holdingsWhereUniqueInput;
  };

  /**
   * portfolio_holdings updateMany
   */
  export type portfolio_holdingsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update portfolio_holdings.
     */
    data: XOR<
      portfolio_holdingsUpdateManyMutationInput,
      portfolio_holdingsUncheckedUpdateManyInput
    >;
    /**
     * Filter which portfolio_holdings to update
     */
    where?: portfolio_holdingsWhereInput;
    /**
     * Limit how many portfolio_holdings to update.
     */
    limit?: number;
  };

  /**
   * portfolio_holdings updateManyAndReturn
   */
  export type portfolio_holdingsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_holdings
     */
    select?: portfolio_holdingsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_holdings
     */
    omit?: portfolio_holdingsOmit<ExtArgs> | null;
    /**
     * The data used to update portfolio_holdings.
     */
    data: XOR<
      portfolio_holdingsUpdateManyMutationInput,
      portfolio_holdingsUncheckedUpdateManyInput
    >;
    /**
     * Filter which portfolio_holdings to update
     */
    where?: portfolio_holdingsWhereInput;
    /**
     * Limit how many portfolio_holdings to update.
     */
    limit?: number;
  };

  /**
   * portfolio_holdings upsert
   */
  export type portfolio_holdingsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_holdings
     */
    select?: portfolio_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_holdings
     */
    omit?: portfolio_holdingsOmit<ExtArgs> | null;
    /**
     * The filter to search for the portfolio_holdings to update in case it exists.
     */
    where: portfolio_holdingsWhereUniqueInput;
    /**
     * In case the portfolio_holdings found by the `where` argument doesn't exist, create a new portfolio_holdings with this data.
     */
    create: XOR<
      portfolio_holdingsCreateInput,
      portfolio_holdingsUncheckedCreateInput
    >;
    /**
     * In case the portfolio_holdings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      portfolio_holdingsUpdateInput,
      portfolio_holdingsUncheckedUpdateInput
    >;
  };

  /**
   * portfolio_holdings delete
   */
  export type portfolio_holdingsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_holdings
     */
    select?: portfolio_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_holdings
     */
    omit?: portfolio_holdingsOmit<ExtArgs> | null;
    /**
     * Filter which portfolio_holdings to delete.
     */
    where: portfolio_holdingsWhereUniqueInput;
  };

  /**
   * portfolio_holdings deleteMany
   */
  export type portfolio_holdingsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which portfolio_holdings to delete
     */
    where?: portfolio_holdingsWhereInput;
    /**
     * Limit how many portfolio_holdings to delete.
     */
    limit?: number;
  };

  /**
   * portfolio_holdings without action
   */
  export type portfolio_holdingsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_holdings
     */
    select?: portfolio_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_holdings
     */
    omit?: portfolio_holdingsOmit<ExtArgs> | null;
  };

  /**
   * Model portfolio_stocks
   */

  export type AggregatePortfolio_stocks = {
    _count: Portfolio_stocksCountAggregateOutputType | null;
    _avg: Portfolio_stocksAvgAggregateOutputType | null;
    _sum: Portfolio_stocksSumAggregateOutputType | null;
    _min: Portfolio_stocksMinAggregateOutputType | null;
    _max: Portfolio_stocksMaxAggregateOutputType | null;
  };

  export type Portfolio_stocksAvgAggregateOutputType = {
    id: number | null;
    portfolio_id: number | null;
    quantity: Decimal | null;
    price: Decimal | null;
    total_amount: Decimal | null;
  };

  export type Portfolio_stocksSumAggregateOutputType = {
    id: number | null;
    portfolio_id: number | null;
    quantity: Decimal | null;
    price: Decimal | null;
    total_amount: Decimal | null;
  };

  export type Portfolio_stocksMinAggregateOutputType = {
    id: number | null;
    portfolio_id: number | null;
    symbol: string | null;
    type: string | null;
    quantity: Decimal | null;
    price: Decimal | null;
    total_amount: Decimal | null;
    transaction_date: Date | null;
    created_at: Date | null;
    updated_at: Date | null;
    currency: string | null;
  };

  export type Portfolio_stocksMaxAggregateOutputType = {
    id: number | null;
    portfolio_id: number | null;
    symbol: string | null;
    type: string | null;
    quantity: Decimal | null;
    price: Decimal | null;
    total_amount: Decimal | null;
    transaction_date: Date | null;
    created_at: Date | null;
    updated_at: Date | null;
    currency: string | null;
  };

  export type Portfolio_stocksCountAggregateOutputType = {
    id: number;
    portfolio_id: number;
    symbol: number;
    type: number;
    quantity: number;
    price: number;
    total_amount: number;
    transaction_date: number;
    created_at: number;
    updated_at: number;
    currency: number;
    _all: number;
  };

  export type Portfolio_stocksAvgAggregateInputType = {
    id?: true;
    portfolio_id?: true;
    quantity?: true;
    price?: true;
    total_amount?: true;
  };

  export type Portfolio_stocksSumAggregateInputType = {
    id?: true;
    portfolio_id?: true;
    quantity?: true;
    price?: true;
    total_amount?: true;
  };

  export type Portfolio_stocksMinAggregateInputType = {
    id?: true;
    portfolio_id?: true;
    symbol?: true;
    type?: true;
    quantity?: true;
    price?: true;
    total_amount?: true;
    transaction_date?: true;
    created_at?: true;
    updated_at?: true;
    currency?: true;
  };

  export type Portfolio_stocksMaxAggregateInputType = {
    id?: true;
    portfolio_id?: true;
    symbol?: true;
    type?: true;
    quantity?: true;
    price?: true;
    total_amount?: true;
    transaction_date?: true;
    created_at?: true;
    updated_at?: true;
    currency?: true;
  };

  export type Portfolio_stocksCountAggregateInputType = {
    id?: true;
    portfolio_id?: true;
    symbol?: true;
    type?: true;
    quantity?: true;
    price?: true;
    total_amount?: true;
    transaction_date?: true;
    created_at?: true;
    updated_at?: true;
    currency?: true;
    _all?: true;
  };

  export type Portfolio_stocksAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which portfolio_stocks to aggregate.
     */
    where?: portfolio_stocksWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of portfolio_stocks to fetch.
     */
    orderBy?:
      | portfolio_stocksOrderByWithRelationInput
      | portfolio_stocksOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: portfolio_stocksWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` portfolio_stocks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` portfolio_stocks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned portfolio_stocks
     **/
    _count?: true | Portfolio_stocksCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Portfolio_stocksAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Portfolio_stocksSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Portfolio_stocksMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Portfolio_stocksMaxAggregateInputType;
  };

  export type GetPortfolio_stocksAggregateType<
    T extends Portfolio_stocksAggregateArgs
  > = {
    [P in keyof T & keyof AggregatePortfolio_stocks]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolio_stocks[P]>
      : GetScalarType<T[P], AggregatePortfolio_stocks[P]>;
  };

  export type portfolio_stocksGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: portfolio_stocksWhereInput;
    orderBy?:
      | portfolio_stocksOrderByWithAggregationInput
      | portfolio_stocksOrderByWithAggregationInput[];
    by: Portfolio_stocksScalarFieldEnum[] | Portfolio_stocksScalarFieldEnum;
    having?: portfolio_stocksScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Portfolio_stocksCountAggregateInputType | true;
    _avg?: Portfolio_stocksAvgAggregateInputType;
    _sum?: Portfolio_stocksSumAggregateInputType;
    _min?: Portfolio_stocksMinAggregateInputType;
    _max?: Portfolio_stocksMaxAggregateInputType;
  };

  export type Portfolio_stocksGroupByOutputType = {
    id: number;
    portfolio_id: number;
    symbol: string;
    type: string;
    quantity: Decimal;
    price: Decimal;
    total_amount: Decimal;
    transaction_date: Date | null;
    created_at: Date | null;
    updated_at: Date | null;
    currency: string | null;
    _count: Portfolio_stocksCountAggregateOutputType | null;
    _avg: Portfolio_stocksAvgAggregateOutputType | null;
    _sum: Portfolio_stocksSumAggregateOutputType | null;
    _min: Portfolio_stocksMinAggregateOutputType | null;
    _max: Portfolio_stocksMaxAggregateOutputType | null;
  };

  type GetPortfolio_stocksGroupByPayload<
    T extends portfolio_stocksGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Portfolio_stocksGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof Portfolio_stocksGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], Portfolio_stocksGroupByOutputType[P]>
          : GetScalarType<T[P], Portfolio_stocksGroupByOutputType[P]>;
      }
    >
  >;

  export type portfolio_stocksSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      portfolio_id?: boolean;
      symbol?: boolean;
      type?: boolean;
      quantity?: boolean;
      price?: boolean;
      total_amount?: boolean;
      transaction_date?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      currency?: boolean;
    },
    ExtArgs['result']['portfolio_stocks']
  >;

  export type portfolio_stocksSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      portfolio_id?: boolean;
      symbol?: boolean;
      type?: boolean;
      quantity?: boolean;
      price?: boolean;
      total_amount?: boolean;
      transaction_date?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      currency?: boolean;
    },
    ExtArgs['result']['portfolio_stocks']
  >;

  export type portfolio_stocksSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      portfolio_id?: boolean;
      symbol?: boolean;
      type?: boolean;
      quantity?: boolean;
      price?: boolean;
      total_amount?: boolean;
      transaction_date?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      currency?: boolean;
    },
    ExtArgs['result']['portfolio_stocks']
  >;

  export type portfolio_stocksSelectScalar = {
    id?: boolean;
    portfolio_id?: boolean;
    symbol?: boolean;
    type?: boolean;
    quantity?: boolean;
    price?: boolean;
    total_amount?: boolean;
    transaction_date?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    currency?: boolean;
  };

  export type portfolio_stocksOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'portfolio_id'
    | 'symbol'
    | 'type'
    | 'quantity'
    | 'price'
    | 'total_amount'
    | 'transaction_date'
    | 'created_at'
    | 'updated_at'
    | 'currency',
    ExtArgs['result']['portfolio_stocks']
  >;

  export type $portfolio_stocksPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'portfolio_stocks';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        portfolio_id: number;
        symbol: string;
        type: string;
        quantity: Prisma.Decimal;
        price: Prisma.Decimal;
        total_amount: Prisma.Decimal;
        transaction_date: Date | null;
        created_at: Date | null;
        updated_at: Date | null;
        currency: string | null;
      },
      ExtArgs['result']['portfolio_stocks']
    >;
    composites: {};
  };

  type portfolio_stocksGetPayload<
    S extends boolean | null | undefined | portfolio_stocksDefaultArgs
  > = $Result.GetResult<Prisma.$portfolio_stocksPayload, S>;

  type portfolio_stocksCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    portfolio_stocksFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Portfolio_stocksCountAggregateInputType | true;
  };

  export interface portfolio_stocksDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['portfolio_stocks'];
      meta: { name: 'portfolio_stocks' };
    };
    /**
     * Find zero or one Portfolio_stocks that matches the filter.
     * @param {portfolio_stocksFindUniqueArgs} args - Arguments to find a Portfolio_stocks
     * @example
     * // Get one Portfolio_stocks
     * const portfolio_stocks = await prisma.portfolio_stocks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends portfolio_stocksFindUniqueArgs>(
      args: SelectSubset<T, portfolio_stocksFindUniqueArgs<ExtArgs>>
    ): Prisma__portfolio_stocksClient<
      $Result.GetResult<
        Prisma.$portfolio_stocksPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Portfolio_stocks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {portfolio_stocksFindUniqueOrThrowArgs} args - Arguments to find a Portfolio_stocks
     * @example
     * // Get one Portfolio_stocks
     * const portfolio_stocks = await prisma.portfolio_stocks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends portfolio_stocksFindUniqueOrThrowArgs>(
      args: SelectSubset<T, portfolio_stocksFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__portfolio_stocksClient<
      $Result.GetResult<
        Prisma.$portfolio_stocksPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Portfolio_stocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_stocksFindFirstArgs} args - Arguments to find a Portfolio_stocks
     * @example
     * // Get one Portfolio_stocks
     * const portfolio_stocks = await prisma.portfolio_stocks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends portfolio_stocksFindFirstArgs>(
      args?: SelectSubset<T, portfolio_stocksFindFirstArgs<ExtArgs>>
    ): Prisma__portfolio_stocksClient<
      $Result.GetResult<
        Prisma.$portfolio_stocksPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Portfolio_stocks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_stocksFindFirstOrThrowArgs} args - Arguments to find a Portfolio_stocks
     * @example
     * // Get one Portfolio_stocks
     * const portfolio_stocks = await prisma.portfolio_stocks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends portfolio_stocksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, portfolio_stocksFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__portfolio_stocksClient<
      $Result.GetResult<
        Prisma.$portfolio_stocksPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Portfolio_stocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_stocksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Portfolio_stocks
     * const portfolio_stocks = await prisma.portfolio_stocks.findMany()
     *
     * // Get first 10 Portfolio_stocks
     * const portfolio_stocks = await prisma.portfolio_stocks.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const portfolio_stocksWithIdOnly = await prisma.portfolio_stocks.findMany({ select: { id: true } })
     *
     */
    findMany<T extends portfolio_stocksFindManyArgs>(
      args?: SelectSubset<T, portfolio_stocksFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$portfolio_stocksPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Portfolio_stocks.
     * @param {portfolio_stocksCreateArgs} args - Arguments to create a Portfolio_stocks.
     * @example
     * // Create one Portfolio_stocks
     * const Portfolio_stocks = await prisma.portfolio_stocks.create({
     *   data: {
     *     // ... data to create a Portfolio_stocks
     *   }
     * })
     *
     */
    create<T extends portfolio_stocksCreateArgs>(
      args: SelectSubset<T, portfolio_stocksCreateArgs<ExtArgs>>
    ): Prisma__portfolio_stocksClient<
      $Result.GetResult<
        Prisma.$portfolio_stocksPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Portfolio_stocks.
     * @param {portfolio_stocksCreateManyArgs} args - Arguments to create many Portfolio_stocks.
     * @example
     * // Create many Portfolio_stocks
     * const portfolio_stocks = await prisma.portfolio_stocks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends portfolio_stocksCreateManyArgs>(
      args?: SelectSubset<T, portfolio_stocksCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Portfolio_stocks and returns the data saved in the database.
     * @param {portfolio_stocksCreateManyAndReturnArgs} args - Arguments to create many Portfolio_stocks.
     * @example
     * // Create many Portfolio_stocks
     * const portfolio_stocks = await prisma.portfolio_stocks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Portfolio_stocks and only return the `id`
     * const portfolio_stocksWithIdOnly = await prisma.portfolio_stocks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends portfolio_stocksCreateManyAndReturnArgs>(
      args?: SelectSubset<T, portfolio_stocksCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$portfolio_stocksPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Portfolio_stocks.
     * @param {portfolio_stocksDeleteArgs} args - Arguments to delete one Portfolio_stocks.
     * @example
     * // Delete one Portfolio_stocks
     * const Portfolio_stocks = await prisma.portfolio_stocks.delete({
     *   where: {
     *     // ... filter to delete one Portfolio_stocks
     *   }
     * })
     *
     */
    delete<T extends portfolio_stocksDeleteArgs>(
      args: SelectSubset<T, portfolio_stocksDeleteArgs<ExtArgs>>
    ): Prisma__portfolio_stocksClient<
      $Result.GetResult<
        Prisma.$portfolio_stocksPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Portfolio_stocks.
     * @param {portfolio_stocksUpdateArgs} args - Arguments to update one Portfolio_stocks.
     * @example
     * // Update one Portfolio_stocks
     * const portfolio_stocks = await prisma.portfolio_stocks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends portfolio_stocksUpdateArgs>(
      args: SelectSubset<T, portfolio_stocksUpdateArgs<ExtArgs>>
    ): Prisma__portfolio_stocksClient<
      $Result.GetResult<
        Prisma.$portfolio_stocksPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Portfolio_stocks.
     * @param {portfolio_stocksDeleteManyArgs} args - Arguments to filter Portfolio_stocks to delete.
     * @example
     * // Delete a few Portfolio_stocks
     * const { count } = await prisma.portfolio_stocks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends portfolio_stocksDeleteManyArgs>(
      args?: SelectSubset<T, portfolio_stocksDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Portfolio_stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_stocksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Portfolio_stocks
     * const portfolio_stocks = await prisma.portfolio_stocks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends portfolio_stocksUpdateManyArgs>(
      args: SelectSubset<T, portfolio_stocksUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Portfolio_stocks and returns the data updated in the database.
     * @param {portfolio_stocksUpdateManyAndReturnArgs} args - Arguments to update many Portfolio_stocks.
     * @example
     * // Update many Portfolio_stocks
     * const portfolio_stocks = await prisma.portfolio_stocks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Portfolio_stocks and only return the `id`
     * const portfolio_stocksWithIdOnly = await prisma.portfolio_stocks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends portfolio_stocksUpdateManyAndReturnArgs>(
      args: SelectSubset<T, portfolio_stocksUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$portfolio_stocksPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Portfolio_stocks.
     * @param {portfolio_stocksUpsertArgs} args - Arguments to update or create a Portfolio_stocks.
     * @example
     * // Update or create a Portfolio_stocks
     * const portfolio_stocks = await prisma.portfolio_stocks.upsert({
     *   create: {
     *     // ... data to create a Portfolio_stocks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Portfolio_stocks we want to update
     *   }
     * })
     */
    upsert<T extends portfolio_stocksUpsertArgs>(
      args: SelectSubset<T, portfolio_stocksUpsertArgs<ExtArgs>>
    ): Prisma__portfolio_stocksClient<
      $Result.GetResult<
        Prisma.$portfolio_stocksPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Portfolio_stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_stocksCountArgs} args - Arguments to filter Portfolio_stocks to count.
     * @example
     * // Count the number of Portfolio_stocks
     * const count = await prisma.portfolio_stocks.count({
     *   where: {
     *     // ... the filter for the Portfolio_stocks we want to count
     *   }
     * })
     **/
    count<T extends portfolio_stocksCountArgs>(
      args?: Subset<T, portfolio_stocksCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Portfolio_stocksCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Portfolio_stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Portfolio_stocksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Portfolio_stocksAggregateArgs>(
      args: Subset<T, Portfolio_stocksAggregateArgs>
    ): Prisma.PrismaPromise<GetPortfolio_stocksAggregateType<T>>;

    /**
     * Group by Portfolio_stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_stocksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends portfolio_stocksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: portfolio_stocksGroupByArgs['orderBy'] }
        : { orderBy?: portfolio_stocksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, portfolio_stocksGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetPortfolio_stocksGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the portfolio_stocks model
     */
    readonly fields: portfolio_stocksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for portfolio_stocks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__portfolio_stocksClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the portfolio_stocks model
   */
  interface portfolio_stocksFieldRefs {
    readonly id: FieldRef<'portfolio_stocks', 'Int'>;
    readonly portfolio_id: FieldRef<'portfolio_stocks', 'Int'>;
    readonly symbol: FieldRef<'portfolio_stocks', 'String'>;
    readonly type: FieldRef<'portfolio_stocks', 'String'>;
    readonly quantity: FieldRef<'portfolio_stocks', 'Decimal'>;
    readonly price: FieldRef<'portfolio_stocks', 'Decimal'>;
    readonly total_amount: FieldRef<'portfolio_stocks', 'Decimal'>;
    readonly transaction_date: FieldRef<'portfolio_stocks', 'DateTime'>;
    readonly created_at: FieldRef<'portfolio_stocks', 'DateTime'>;
    readonly updated_at: FieldRef<'portfolio_stocks', 'DateTime'>;
    readonly currency: FieldRef<'portfolio_stocks', 'String'>;
  }

  // Custom InputTypes
  /**
   * portfolio_stocks findUnique
   */
  export type portfolio_stocksFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_stocks
     */
    select?: portfolio_stocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_stocks
     */
    omit?: portfolio_stocksOmit<ExtArgs> | null;
    /**
     * Filter, which portfolio_stocks to fetch.
     */
    where: portfolio_stocksWhereUniqueInput;
  };

  /**
   * portfolio_stocks findUniqueOrThrow
   */
  export type portfolio_stocksFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_stocks
     */
    select?: portfolio_stocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_stocks
     */
    omit?: portfolio_stocksOmit<ExtArgs> | null;
    /**
     * Filter, which portfolio_stocks to fetch.
     */
    where: portfolio_stocksWhereUniqueInput;
  };

  /**
   * portfolio_stocks findFirst
   */
  export type portfolio_stocksFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_stocks
     */
    select?: portfolio_stocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_stocks
     */
    omit?: portfolio_stocksOmit<ExtArgs> | null;
    /**
     * Filter, which portfolio_stocks to fetch.
     */
    where?: portfolio_stocksWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of portfolio_stocks to fetch.
     */
    orderBy?:
      | portfolio_stocksOrderByWithRelationInput
      | portfolio_stocksOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for portfolio_stocks.
     */
    cursor?: portfolio_stocksWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` portfolio_stocks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` portfolio_stocks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of portfolio_stocks.
     */
    distinct?:
      | Portfolio_stocksScalarFieldEnum
      | Portfolio_stocksScalarFieldEnum[];
  };

  /**
   * portfolio_stocks findFirstOrThrow
   */
  export type portfolio_stocksFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_stocks
     */
    select?: portfolio_stocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_stocks
     */
    omit?: portfolio_stocksOmit<ExtArgs> | null;
    /**
     * Filter, which portfolio_stocks to fetch.
     */
    where?: portfolio_stocksWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of portfolio_stocks to fetch.
     */
    orderBy?:
      | portfolio_stocksOrderByWithRelationInput
      | portfolio_stocksOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for portfolio_stocks.
     */
    cursor?: portfolio_stocksWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` portfolio_stocks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` portfolio_stocks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of portfolio_stocks.
     */
    distinct?:
      | Portfolio_stocksScalarFieldEnum
      | Portfolio_stocksScalarFieldEnum[];
  };

  /**
   * portfolio_stocks findMany
   */
  export type portfolio_stocksFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_stocks
     */
    select?: portfolio_stocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_stocks
     */
    omit?: portfolio_stocksOmit<ExtArgs> | null;
    /**
     * Filter, which portfolio_stocks to fetch.
     */
    where?: portfolio_stocksWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of portfolio_stocks to fetch.
     */
    orderBy?:
      | portfolio_stocksOrderByWithRelationInput
      | portfolio_stocksOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing portfolio_stocks.
     */
    cursor?: portfolio_stocksWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` portfolio_stocks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` portfolio_stocks.
     */
    skip?: number;
    distinct?:
      | Portfolio_stocksScalarFieldEnum
      | Portfolio_stocksScalarFieldEnum[];
  };

  /**
   * portfolio_stocks create
   */
  export type portfolio_stocksCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_stocks
     */
    select?: portfolio_stocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_stocks
     */
    omit?: portfolio_stocksOmit<ExtArgs> | null;
    /**
     * The data needed to create a portfolio_stocks.
     */
    data: XOR<
      portfolio_stocksCreateInput,
      portfolio_stocksUncheckedCreateInput
    >;
  };

  /**
   * portfolio_stocks createMany
   */
  export type portfolio_stocksCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many portfolio_stocks.
     */
    data: portfolio_stocksCreateManyInput | portfolio_stocksCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * portfolio_stocks createManyAndReturn
   */
  export type portfolio_stocksCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_stocks
     */
    select?: portfolio_stocksSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_stocks
     */
    omit?: portfolio_stocksOmit<ExtArgs> | null;
    /**
     * The data used to create many portfolio_stocks.
     */
    data: portfolio_stocksCreateManyInput | portfolio_stocksCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * portfolio_stocks update
   */
  export type portfolio_stocksUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_stocks
     */
    select?: portfolio_stocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_stocks
     */
    omit?: portfolio_stocksOmit<ExtArgs> | null;
    /**
     * The data needed to update a portfolio_stocks.
     */
    data: XOR<
      portfolio_stocksUpdateInput,
      portfolio_stocksUncheckedUpdateInput
    >;
    /**
     * Choose, which portfolio_stocks to update.
     */
    where: portfolio_stocksWhereUniqueInput;
  };

  /**
   * portfolio_stocks updateMany
   */
  export type portfolio_stocksUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update portfolio_stocks.
     */
    data: XOR<
      portfolio_stocksUpdateManyMutationInput,
      portfolio_stocksUncheckedUpdateManyInput
    >;
    /**
     * Filter which portfolio_stocks to update
     */
    where?: portfolio_stocksWhereInput;
    /**
     * Limit how many portfolio_stocks to update.
     */
    limit?: number;
  };

  /**
   * portfolio_stocks updateManyAndReturn
   */
  export type portfolio_stocksUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_stocks
     */
    select?: portfolio_stocksSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_stocks
     */
    omit?: portfolio_stocksOmit<ExtArgs> | null;
    /**
     * The data used to update portfolio_stocks.
     */
    data: XOR<
      portfolio_stocksUpdateManyMutationInput,
      portfolio_stocksUncheckedUpdateManyInput
    >;
    /**
     * Filter which portfolio_stocks to update
     */
    where?: portfolio_stocksWhereInput;
    /**
     * Limit how many portfolio_stocks to update.
     */
    limit?: number;
  };

  /**
   * portfolio_stocks upsert
   */
  export type portfolio_stocksUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_stocks
     */
    select?: portfolio_stocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_stocks
     */
    omit?: portfolio_stocksOmit<ExtArgs> | null;
    /**
     * The filter to search for the portfolio_stocks to update in case it exists.
     */
    where: portfolio_stocksWhereUniqueInput;
    /**
     * In case the portfolio_stocks found by the `where` argument doesn't exist, create a new portfolio_stocks with this data.
     */
    create: XOR<
      portfolio_stocksCreateInput,
      portfolio_stocksUncheckedCreateInput
    >;
    /**
     * In case the portfolio_stocks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      portfolio_stocksUpdateInput,
      portfolio_stocksUncheckedUpdateInput
    >;
  };

  /**
   * portfolio_stocks delete
   */
  export type portfolio_stocksDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_stocks
     */
    select?: portfolio_stocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_stocks
     */
    omit?: portfolio_stocksOmit<ExtArgs> | null;
    /**
     * Filter which portfolio_stocks to delete.
     */
    where: portfolio_stocksWhereUniqueInput;
  };

  /**
   * portfolio_stocks deleteMany
   */
  export type portfolio_stocksDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which portfolio_stocks to delete
     */
    where?: portfolio_stocksWhereInput;
    /**
     * Limit how many portfolio_stocks to delete.
     */
    limit?: number;
  };

  /**
   * portfolio_stocks without action
   */
  export type portfolio_stocksDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the portfolio_stocks
     */
    select?: portfolio_stocksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the portfolio_stocks
     */
    omit?: portfolio_stocksOmit<ExtArgs> | null;
  };

  /**
   * Model price_alerts
   */

  export type AggregatePrice_alerts = {
    _count: Price_alertsCountAggregateOutputType | null;
    _avg: Price_alertsAvgAggregateOutputType | null;
    _sum: Price_alertsSumAggregateOutputType | null;
    _min: Price_alertsMinAggregateOutputType | null;
    _max: Price_alertsMaxAggregateOutputType | null;
  };

  export type Price_alertsAvgAggregateOutputType = {
    user_id: number | null;
    target_price: Decimal | null;
  };

  export type Price_alertsSumAggregateOutputType = {
    user_id: number | null;
    target_price: Decimal | null;
  };

  export type Price_alertsMinAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    symbol: string | null;
    asset_type: $Enums.asset_type | null;
    target_price: Decimal | null;
    alert_type: $Enums.alert_type | null;
    status: $Enums.alert_status | null;
    created_at: Date | null;
    updated_at: Date | null;
    triggered_at: Date | null;
    expires_at: Date | null;
  };

  export type Price_alertsMaxAggregateOutputType = {
    id: string | null;
    user_id: number | null;
    symbol: string | null;
    asset_type: $Enums.asset_type | null;
    target_price: Decimal | null;
    alert_type: $Enums.alert_type | null;
    status: $Enums.alert_status | null;
    created_at: Date | null;
    updated_at: Date | null;
    triggered_at: Date | null;
    expires_at: Date | null;
  };

  export type Price_alertsCountAggregateOutputType = {
    id: number;
    user_id: number;
    symbol: number;
    asset_type: number;
    target_price: number;
    alert_type: number;
    status: number;
    created_at: number;
    updated_at: number;
    triggered_at: number;
    expires_at: number;
    _all: number;
  };

  export type Price_alertsAvgAggregateInputType = {
    user_id?: true;
    target_price?: true;
  };

  export type Price_alertsSumAggregateInputType = {
    user_id?: true;
    target_price?: true;
  };

  export type Price_alertsMinAggregateInputType = {
    id?: true;
    user_id?: true;
    symbol?: true;
    asset_type?: true;
    target_price?: true;
    alert_type?: true;
    status?: true;
    created_at?: true;
    updated_at?: true;
    triggered_at?: true;
    expires_at?: true;
  };

  export type Price_alertsMaxAggregateInputType = {
    id?: true;
    user_id?: true;
    symbol?: true;
    asset_type?: true;
    target_price?: true;
    alert_type?: true;
    status?: true;
    created_at?: true;
    updated_at?: true;
    triggered_at?: true;
    expires_at?: true;
  };

  export type Price_alertsCountAggregateInputType = {
    id?: true;
    user_id?: true;
    symbol?: true;
    asset_type?: true;
    target_price?: true;
    alert_type?: true;
    status?: true;
    created_at?: true;
    updated_at?: true;
    triggered_at?: true;
    expires_at?: true;
    _all?: true;
  };

  export type Price_alertsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which price_alerts to aggregate.
     */
    where?: price_alertsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of price_alerts to fetch.
     */
    orderBy?:
      | price_alertsOrderByWithRelationInput
      | price_alertsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: price_alertsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` price_alerts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` price_alerts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned price_alerts
     **/
    _count?: true | Price_alertsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Price_alertsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Price_alertsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Price_alertsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Price_alertsMaxAggregateInputType;
  };

  export type GetPrice_alertsAggregateType<
    T extends Price_alertsAggregateArgs
  > = {
    [P in keyof T & keyof AggregatePrice_alerts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrice_alerts[P]>
      : GetScalarType<T[P], AggregatePrice_alerts[P]>;
  };

  export type price_alertsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: price_alertsWhereInput;
    orderBy?:
      | price_alertsOrderByWithAggregationInput
      | price_alertsOrderByWithAggregationInput[];
    by: Price_alertsScalarFieldEnum[] | Price_alertsScalarFieldEnum;
    having?: price_alertsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Price_alertsCountAggregateInputType | true;
    _avg?: Price_alertsAvgAggregateInputType;
    _sum?: Price_alertsSumAggregateInputType;
    _min?: Price_alertsMinAggregateInputType;
    _max?: Price_alertsMaxAggregateInputType;
  };

  export type Price_alertsGroupByOutputType = {
    id: string;
    user_id: number;
    symbol: string;
    asset_type: $Enums.asset_type;
    target_price: Decimal;
    alert_type: $Enums.alert_type;
    status: $Enums.alert_status;
    created_at: Date | null;
    updated_at: Date | null;
    triggered_at: Date | null;
    expires_at: Date | null;
    _count: Price_alertsCountAggregateOutputType | null;
    _avg: Price_alertsAvgAggregateOutputType | null;
    _sum: Price_alertsSumAggregateOutputType | null;
    _min: Price_alertsMinAggregateOutputType | null;
    _max: Price_alertsMaxAggregateOutputType | null;
  };

  type GetPrice_alertsGroupByPayload<T extends price_alertsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<Price_alertsGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof Price_alertsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Price_alertsGroupByOutputType[P]>
            : GetScalarType<T[P], Price_alertsGroupByOutputType[P]>;
        }
      >
    >;

  export type price_alertsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      symbol?: boolean;
      asset_type?: boolean;
      target_price?: boolean;
      alert_type?: boolean;
      status?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      triggered_at?: boolean;
      expires_at?: boolean;
    },
    ExtArgs['result']['price_alerts']
  >;

  export type price_alertsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      symbol?: boolean;
      asset_type?: boolean;
      target_price?: boolean;
      alert_type?: boolean;
      status?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      triggered_at?: boolean;
      expires_at?: boolean;
    },
    ExtArgs['result']['price_alerts']
  >;

  export type price_alertsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      symbol?: boolean;
      asset_type?: boolean;
      target_price?: boolean;
      alert_type?: boolean;
      status?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      triggered_at?: boolean;
      expires_at?: boolean;
    },
    ExtArgs['result']['price_alerts']
  >;

  export type price_alertsSelectScalar = {
    id?: boolean;
    user_id?: boolean;
    symbol?: boolean;
    asset_type?: boolean;
    target_price?: boolean;
    alert_type?: boolean;
    status?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    triggered_at?: boolean;
    expires_at?: boolean;
  };

  export type price_alertsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'user_id'
    | 'symbol'
    | 'asset_type'
    | 'target_price'
    | 'alert_type'
    | 'status'
    | 'created_at'
    | 'updated_at'
    | 'triggered_at'
    | 'expires_at',
    ExtArgs['result']['price_alerts']
  >;

  export type $price_alertsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'price_alerts';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        user_id: number;
        symbol: string;
        asset_type: $Enums.asset_type;
        target_price: Prisma.Decimal;
        alert_type: $Enums.alert_type;
        status: $Enums.alert_status;
        created_at: Date | null;
        updated_at: Date | null;
        triggered_at: Date | null;
        expires_at: Date | null;
      },
      ExtArgs['result']['price_alerts']
    >;
    composites: {};
  };

  type price_alertsGetPayload<
    S extends boolean | null | undefined | price_alertsDefaultArgs
  > = $Result.GetResult<Prisma.$price_alertsPayload, S>;

  type price_alertsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    price_alertsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Price_alertsCountAggregateInputType | true;
  };

  export interface price_alertsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['price_alerts'];
      meta: { name: 'price_alerts' };
    };
    /**
     * Find zero or one Price_alerts that matches the filter.
     * @param {price_alertsFindUniqueArgs} args - Arguments to find a Price_alerts
     * @example
     * // Get one Price_alerts
     * const price_alerts = await prisma.price_alerts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends price_alertsFindUniqueArgs>(
      args: SelectSubset<T, price_alertsFindUniqueArgs<ExtArgs>>
    ): Prisma__price_alertsClient<
      $Result.GetResult<
        Prisma.$price_alertsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Price_alerts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {price_alertsFindUniqueOrThrowArgs} args - Arguments to find a Price_alerts
     * @example
     * // Get one Price_alerts
     * const price_alerts = await prisma.price_alerts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends price_alertsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, price_alertsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__price_alertsClient<
      $Result.GetResult<
        Prisma.$price_alertsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Price_alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_alertsFindFirstArgs} args - Arguments to find a Price_alerts
     * @example
     * // Get one Price_alerts
     * const price_alerts = await prisma.price_alerts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends price_alertsFindFirstArgs>(
      args?: SelectSubset<T, price_alertsFindFirstArgs<ExtArgs>>
    ): Prisma__price_alertsClient<
      $Result.GetResult<
        Prisma.$price_alertsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Price_alerts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_alertsFindFirstOrThrowArgs} args - Arguments to find a Price_alerts
     * @example
     * // Get one Price_alerts
     * const price_alerts = await prisma.price_alerts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends price_alertsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, price_alertsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__price_alertsClient<
      $Result.GetResult<
        Prisma.$price_alertsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Price_alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_alertsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Price_alerts
     * const price_alerts = await prisma.price_alerts.findMany()
     *
     * // Get first 10 Price_alerts
     * const price_alerts = await prisma.price_alerts.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const price_alertsWithIdOnly = await prisma.price_alerts.findMany({ select: { id: true } })
     *
     */
    findMany<T extends price_alertsFindManyArgs>(
      args?: SelectSubset<T, price_alertsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$price_alertsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Price_alerts.
     * @param {price_alertsCreateArgs} args - Arguments to create a Price_alerts.
     * @example
     * // Create one Price_alerts
     * const Price_alerts = await prisma.price_alerts.create({
     *   data: {
     *     // ... data to create a Price_alerts
     *   }
     * })
     *
     */
    create<T extends price_alertsCreateArgs>(
      args: SelectSubset<T, price_alertsCreateArgs<ExtArgs>>
    ): Prisma__price_alertsClient<
      $Result.GetResult<
        Prisma.$price_alertsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Price_alerts.
     * @param {price_alertsCreateManyArgs} args - Arguments to create many Price_alerts.
     * @example
     * // Create many Price_alerts
     * const price_alerts = await prisma.price_alerts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends price_alertsCreateManyArgs>(
      args?: SelectSubset<T, price_alertsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Price_alerts and returns the data saved in the database.
     * @param {price_alertsCreateManyAndReturnArgs} args - Arguments to create many Price_alerts.
     * @example
     * // Create many Price_alerts
     * const price_alerts = await prisma.price_alerts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Price_alerts and only return the `id`
     * const price_alertsWithIdOnly = await prisma.price_alerts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends price_alertsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, price_alertsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$price_alertsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Price_alerts.
     * @param {price_alertsDeleteArgs} args - Arguments to delete one Price_alerts.
     * @example
     * // Delete one Price_alerts
     * const Price_alerts = await prisma.price_alerts.delete({
     *   where: {
     *     // ... filter to delete one Price_alerts
     *   }
     * })
     *
     */
    delete<T extends price_alertsDeleteArgs>(
      args: SelectSubset<T, price_alertsDeleteArgs<ExtArgs>>
    ): Prisma__price_alertsClient<
      $Result.GetResult<
        Prisma.$price_alertsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Price_alerts.
     * @param {price_alertsUpdateArgs} args - Arguments to update one Price_alerts.
     * @example
     * // Update one Price_alerts
     * const price_alerts = await prisma.price_alerts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends price_alertsUpdateArgs>(
      args: SelectSubset<T, price_alertsUpdateArgs<ExtArgs>>
    ): Prisma__price_alertsClient<
      $Result.GetResult<
        Prisma.$price_alertsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Price_alerts.
     * @param {price_alertsDeleteManyArgs} args - Arguments to filter Price_alerts to delete.
     * @example
     * // Delete a few Price_alerts
     * const { count } = await prisma.price_alerts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends price_alertsDeleteManyArgs>(
      args?: SelectSubset<T, price_alertsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Price_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_alertsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Price_alerts
     * const price_alerts = await prisma.price_alerts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends price_alertsUpdateManyArgs>(
      args: SelectSubset<T, price_alertsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Price_alerts and returns the data updated in the database.
     * @param {price_alertsUpdateManyAndReturnArgs} args - Arguments to update many Price_alerts.
     * @example
     * // Update many Price_alerts
     * const price_alerts = await prisma.price_alerts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Price_alerts and only return the `id`
     * const price_alertsWithIdOnly = await prisma.price_alerts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends price_alertsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, price_alertsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$price_alertsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Price_alerts.
     * @param {price_alertsUpsertArgs} args - Arguments to update or create a Price_alerts.
     * @example
     * // Update or create a Price_alerts
     * const price_alerts = await prisma.price_alerts.upsert({
     *   create: {
     *     // ... data to create a Price_alerts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Price_alerts we want to update
     *   }
     * })
     */
    upsert<T extends price_alertsUpsertArgs>(
      args: SelectSubset<T, price_alertsUpsertArgs<ExtArgs>>
    ): Prisma__price_alertsClient<
      $Result.GetResult<
        Prisma.$price_alertsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Price_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_alertsCountArgs} args - Arguments to filter Price_alerts to count.
     * @example
     * // Count the number of Price_alerts
     * const count = await prisma.price_alerts.count({
     *   where: {
     *     // ... the filter for the Price_alerts we want to count
     *   }
     * })
     **/
    count<T extends price_alertsCountArgs>(
      args?: Subset<T, price_alertsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Price_alertsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Price_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Price_alertsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Price_alertsAggregateArgs>(
      args: Subset<T, Price_alertsAggregateArgs>
    ): Prisma.PrismaPromise<GetPrice_alertsAggregateType<T>>;

    /**
     * Group by Price_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_alertsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends price_alertsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: price_alertsGroupByArgs['orderBy'] }
        : { orderBy?: price_alertsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, price_alertsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetPrice_alertsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the price_alerts model
     */
    readonly fields: price_alertsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for price_alerts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__price_alertsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the price_alerts model
   */
  interface price_alertsFieldRefs {
    readonly id: FieldRef<'price_alerts', 'String'>;
    readonly user_id: FieldRef<'price_alerts', 'Int'>;
    readonly symbol: FieldRef<'price_alerts', 'String'>;
    readonly asset_type: FieldRef<'price_alerts', 'asset_type'>;
    readonly target_price: FieldRef<'price_alerts', 'Decimal'>;
    readonly alert_type: FieldRef<'price_alerts', 'alert_type'>;
    readonly status: FieldRef<'price_alerts', 'alert_status'>;
    readonly created_at: FieldRef<'price_alerts', 'DateTime'>;
    readonly updated_at: FieldRef<'price_alerts', 'DateTime'>;
    readonly triggered_at: FieldRef<'price_alerts', 'DateTime'>;
    readonly expires_at: FieldRef<'price_alerts', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * price_alerts findUnique
   */
  export type price_alertsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the price_alerts
     */
    select?: price_alertsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the price_alerts
     */
    omit?: price_alertsOmit<ExtArgs> | null;
    /**
     * Filter, which price_alerts to fetch.
     */
    where: price_alertsWhereUniqueInput;
  };

  /**
   * price_alerts findUniqueOrThrow
   */
  export type price_alertsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the price_alerts
     */
    select?: price_alertsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the price_alerts
     */
    omit?: price_alertsOmit<ExtArgs> | null;
    /**
     * Filter, which price_alerts to fetch.
     */
    where: price_alertsWhereUniqueInput;
  };

  /**
   * price_alerts findFirst
   */
  export type price_alertsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the price_alerts
     */
    select?: price_alertsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the price_alerts
     */
    omit?: price_alertsOmit<ExtArgs> | null;
    /**
     * Filter, which price_alerts to fetch.
     */
    where?: price_alertsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of price_alerts to fetch.
     */
    orderBy?:
      | price_alertsOrderByWithRelationInput
      | price_alertsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for price_alerts.
     */
    cursor?: price_alertsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` price_alerts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` price_alerts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of price_alerts.
     */
    distinct?: Price_alertsScalarFieldEnum | Price_alertsScalarFieldEnum[];
  };

  /**
   * price_alerts findFirstOrThrow
   */
  export type price_alertsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the price_alerts
     */
    select?: price_alertsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the price_alerts
     */
    omit?: price_alertsOmit<ExtArgs> | null;
    /**
     * Filter, which price_alerts to fetch.
     */
    where?: price_alertsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of price_alerts to fetch.
     */
    orderBy?:
      | price_alertsOrderByWithRelationInput
      | price_alertsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for price_alerts.
     */
    cursor?: price_alertsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` price_alerts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` price_alerts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of price_alerts.
     */
    distinct?: Price_alertsScalarFieldEnum | Price_alertsScalarFieldEnum[];
  };

  /**
   * price_alerts findMany
   */
  export type price_alertsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the price_alerts
     */
    select?: price_alertsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the price_alerts
     */
    omit?: price_alertsOmit<ExtArgs> | null;
    /**
     * Filter, which price_alerts to fetch.
     */
    where?: price_alertsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of price_alerts to fetch.
     */
    orderBy?:
      | price_alertsOrderByWithRelationInput
      | price_alertsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing price_alerts.
     */
    cursor?: price_alertsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` price_alerts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` price_alerts.
     */
    skip?: number;
    distinct?: Price_alertsScalarFieldEnum | Price_alertsScalarFieldEnum[];
  };

  /**
   * price_alerts create
   */
  export type price_alertsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the price_alerts
     */
    select?: price_alertsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the price_alerts
     */
    omit?: price_alertsOmit<ExtArgs> | null;
    /**
     * The data needed to create a price_alerts.
     */
    data: XOR<price_alertsCreateInput, price_alertsUncheckedCreateInput>;
  };

  /**
   * price_alerts createMany
   */
  export type price_alertsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many price_alerts.
     */
    data: price_alertsCreateManyInput | price_alertsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * price_alerts createManyAndReturn
   */
  export type price_alertsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the price_alerts
     */
    select?: price_alertsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the price_alerts
     */
    omit?: price_alertsOmit<ExtArgs> | null;
    /**
     * The data used to create many price_alerts.
     */
    data: price_alertsCreateManyInput | price_alertsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * price_alerts update
   */
  export type price_alertsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the price_alerts
     */
    select?: price_alertsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the price_alerts
     */
    omit?: price_alertsOmit<ExtArgs> | null;
    /**
     * The data needed to update a price_alerts.
     */
    data: XOR<price_alertsUpdateInput, price_alertsUncheckedUpdateInput>;
    /**
     * Choose, which price_alerts to update.
     */
    where: price_alertsWhereUniqueInput;
  };

  /**
   * price_alerts updateMany
   */
  export type price_alertsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update price_alerts.
     */
    data: XOR<
      price_alertsUpdateManyMutationInput,
      price_alertsUncheckedUpdateManyInput
    >;
    /**
     * Filter which price_alerts to update
     */
    where?: price_alertsWhereInput;
    /**
     * Limit how many price_alerts to update.
     */
    limit?: number;
  };

  /**
   * price_alerts updateManyAndReturn
   */
  export type price_alertsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the price_alerts
     */
    select?: price_alertsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the price_alerts
     */
    omit?: price_alertsOmit<ExtArgs> | null;
    /**
     * The data used to update price_alerts.
     */
    data: XOR<
      price_alertsUpdateManyMutationInput,
      price_alertsUncheckedUpdateManyInput
    >;
    /**
     * Filter which price_alerts to update
     */
    where?: price_alertsWhereInput;
    /**
     * Limit how many price_alerts to update.
     */
    limit?: number;
  };

  /**
   * price_alerts upsert
   */
  export type price_alertsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the price_alerts
     */
    select?: price_alertsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the price_alerts
     */
    omit?: price_alertsOmit<ExtArgs> | null;
    /**
     * The filter to search for the price_alerts to update in case it exists.
     */
    where: price_alertsWhereUniqueInput;
    /**
     * In case the price_alerts found by the `where` argument doesn't exist, create a new price_alerts with this data.
     */
    create: XOR<price_alertsCreateInput, price_alertsUncheckedCreateInput>;
    /**
     * In case the price_alerts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<price_alertsUpdateInput, price_alertsUncheckedUpdateInput>;
  };

  /**
   * price_alerts delete
   */
  export type price_alertsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the price_alerts
     */
    select?: price_alertsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the price_alerts
     */
    omit?: price_alertsOmit<ExtArgs> | null;
    /**
     * Filter which price_alerts to delete.
     */
    where: price_alertsWhereUniqueInput;
  };

  /**
   * price_alerts deleteMany
   */
  export type price_alertsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which price_alerts to delete
     */
    where?: price_alertsWhereInput;
    /**
     * Limit how many price_alerts to delete.
     */
    limit?: number;
  };

  /**
   * price_alerts without action
   */
  export type price_alertsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the price_alerts
     */
    select?: price_alertsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the price_alerts
     */
    omit?: price_alertsOmit<ExtArgs> | null;
  };

  /**
   * Model promotion_articles
   */

  export type AggregatePromotion_articles = {
    _count: Promotion_articlesCountAggregateOutputType | null;
    _avg: Promotion_articlesAvgAggregateOutputType | null;
    _sum: Promotion_articlesSumAggregateOutputType | null;
    _min: Promotion_articlesMinAggregateOutputType | null;
    _max: Promotion_articlesMaxAggregateOutputType | null;
  };

  export type Promotion_articlesAvgAggregateOutputType = {
    id: number | null;
  };

  export type Promotion_articlesSumAggregateOutputType = {
    id: number | null;
  };

  export type Promotion_articlesMinAggregateOutputType = {
    image_banner_dark: string | null;
    image_banner_white: string | null;
    title_th: string | null;
    title_en: string | null;
    description_th: string | null;
    description_en: string | null;
    content_th: string | null;
    content_en: string | null;
    button_text_th: string | null;
    button_text_en: string | null;
    path: string | null;
    type: string | null;
    id: number | null;
  };

  export type Promotion_articlesMaxAggregateOutputType = {
    image_banner_dark: string | null;
    image_banner_white: string | null;
    title_th: string | null;
    title_en: string | null;
    description_th: string | null;
    description_en: string | null;
    content_th: string | null;
    content_en: string | null;
    button_text_th: string | null;
    button_text_en: string | null;
    path: string | null;
    type: string | null;
    id: number | null;
  };

  export type Promotion_articlesCountAggregateOutputType = {
    image_banner_dark: number;
    image_banner_white: number;
    title_th: number;
    title_en: number;
    description_th: number;
    description_en: number;
    content_th: number;
    content_en: number;
    button_text_th: number;
    button_text_en: number;
    path: number;
    type: number;
    id: number;
    _all: number;
  };

  export type Promotion_articlesAvgAggregateInputType = {
    id?: true;
  };

  export type Promotion_articlesSumAggregateInputType = {
    id?: true;
  };

  export type Promotion_articlesMinAggregateInputType = {
    image_banner_dark?: true;
    image_banner_white?: true;
    title_th?: true;
    title_en?: true;
    description_th?: true;
    description_en?: true;
    content_th?: true;
    content_en?: true;
    button_text_th?: true;
    button_text_en?: true;
    path?: true;
    type?: true;
    id?: true;
  };

  export type Promotion_articlesMaxAggregateInputType = {
    image_banner_dark?: true;
    image_banner_white?: true;
    title_th?: true;
    title_en?: true;
    description_th?: true;
    description_en?: true;
    content_th?: true;
    content_en?: true;
    button_text_th?: true;
    button_text_en?: true;
    path?: true;
    type?: true;
    id?: true;
  };

  export type Promotion_articlesCountAggregateInputType = {
    image_banner_dark?: true;
    image_banner_white?: true;
    title_th?: true;
    title_en?: true;
    description_th?: true;
    description_en?: true;
    content_th?: true;
    content_en?: true;
    button_text_th?: true;
    button_text_en?: true;
    path?: true;
    type?: true;
    id?: true;
    _all?: true;
  };

  export type Promotion_articlesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which promotion_articles to aggregate.
     */
    where?: promotion_articlesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of promotion_articles to fetch.
     */
    orderBy?:
      | promotion_articlesOrderByWithRelationInput
      | promotion_articlesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: promotion_articlesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` promotion_articles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` promotion_articles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned promotion_articles
     **/
    _count?: true | Promotion_articlesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Promotion_articlesAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Promotion_articlesSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Promotion_articlesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Promotion_articlesMaxAggregateInputType;
  };

  export type GetPromotion_articlesAggregateType<
    T extends Promotion_articlesAggregateArgs
  > = {
    [P in keyof T & keyof AggregatePromotion_articles]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion_articles[P]>
      : GetScalarType<T[P], AggregatePromotion_articles[P]>;
  };

  export type promotion_articlesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: promotion_articlesWhereInput;
    orderBy?:
      | promotion_articlesOrderByWithAggregationInput
      | promotion_articlesOrderByWithAggregationInput[];
    by: Promotion_articlesScalarFieldEnum[] | Promotion_articlesScalarFieldEnum;
    having?: promotion_articlesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Promotion_articlesCountAggregateInputType | true;
    _avg?: Promotion_articlesAvgAggregateInputType;
    _sum?: Promotion_articlesSumAggregateInputType;
    _min?: Promotion_articlesMinAggregateInputType;
    _max?: Promotion_articlesMaxAggregateInputType;
  };

  export type Promotion_articlesGroupByOutputType = {
    image_banner_dark: string | null;
    image_banner_white: string | null;
    title_th: string | null;
    title_en: string | null;
    description_th: string | null;
    description_en: string | null;
    content_th: string | null;
    content_en: string | null;
    button_text_th: string | null;
    button_text_en: string | null;
    path: string | null;
    type: string | null;
    id: number;
    _count: Promotion_articlesCountAggregateOutputType | null;
    _avg: Promotion_articlesAvgAggregateOutputType | null;
    _sum: Promotion_articlesSumAggregateOutputType | null;
    _min: Promotion_articlesMinAggregateOutputType | null;
    _max: Promotion_articlesMaxAggregateOutputType | null;
  };

  type GetPromotion_articlesGroupByPayload<
    T extends promotion_articlesGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Promotion_articlesGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof Promotion_articlesGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], Promotion_articlesGroupByOutputType[P]>
          : GetScalarType<T[P], Promotion_articlesGroupByOutputType[P]>;
      }
    >
  >;

  export type promotion_articlesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      image_banner_dark?: boolean;
      image_banner_white?: boolean;
      title_th?: boolean;
      title_en?: boolean;
      description_th?: boolean;
      description_en?: boolean;
      content_th?: boolean;
      content_en?: boolean;
      button_text_th?: boolean;
      button_text_en?: boolean;
      path?: boolean;
      type?: boolean;
      id?: boolean;
    },
    ExtArgs['result']['promotion_articles']
  >;

  export type promotion_articlesSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      image_banner_dark?: boolean;
      image_banner_white?: boolean;
      title_th?: boolean;
      title_en?: boolean;
      description_th?: boolean;
      description_en?: boolean;
      content_th?: boolean;
      content_en?: boolean;
      button_text_th?: boolean;
      button_text_en?: boolean;
      path?: boolean;
      type?: boolean;
      id?: boolean;
    },
    ExtArgs['result']['promotion_articles']
  >;

  export type promotion_articlesSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      image_banner_dark?: boolean;
      image_banner_white?: boolean;
      title_th?: boolean;
      title_en?: boolean;
      description_th?: boolean;
      description_en?: boolean;
      content_th?: boolean;
      content_en?: boolean;
      button_text_th?: boolean;
      button_text_en?: boolean;
      path?: boolean;
      type?: boolean;
      id?: boolean;
    },
    ExtArgs['result']['promotion_articles']
  >;

  export type promotion_articlesSelectScalar = {
    image_banner_dark?: boolean;
    image_banner_white?: boolean;
    title_th?: boolean;
    title_en?: boolean;
    description_th?: boolean;
    description_en?: boolean;
    content_th?: boolean;
    content_en?: boolean;
    button_text_th?: boolean;
    button_text_en?: boolean;
    path?: boolean;
    type?: boolean;
    id?: boolean;
  };

  export type promotion_articlesOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'image_banner_dark'
    | 'image_banner_white'
    | 'title_th'
    | 'title_en'
    | 'description_th'
    | 'description_en'
    | 'content_th'
    | 'content_en'
    | 'button_text_th'
    | 'button_text_en'
    | 'path'
    | 'type'
    | 'id',
    ExtArgs['result']['promotion_articles']
  >;

  export type $promotion_articlesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'promotion_articles';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        image_banner_dark: string | null;
        image_banner_white: string | null;
        title_th: string | null;
        title_en: string | null;
        description_th: string | null;
        description_en: string | null;
        content_th: string | null;
        content_en: string | null;
        button_text_th: string | null;
        button_text_en: string | null;
        path: string | null;
        type: string | null;
        id: number;
      },
      ExtArgs['result']['promotion_articles']
    >;
    composites: {};
  };

  type promotion_articlesGetPayload<
    S extends boolean | null | undefined | promotion_articlesDefaultArgs
  > = $Result.GetResult<Prisma.$promotion_articlesPayload, S>;

  type promotion_articlesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    promotion_articlesFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Promotion_articlesCountAggregateInputType | true;
  };

  export interface promotion_articlesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['promotion_articles'];
      meta: { name: 'promotion_articles' };
    };
    /**
     * Find zero or one Promotion_articles that matches the filter.
     * @param {promotion_articlesFindUniqueArgs} args - Arguments to find a Promotion_articles
     * @example
     * // Get one Promotion_articles
     * const promotion_articles = await prisma.promotion_articles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends promotion_articlesFindUniqueArgs>(
      args: SelectSubset<T, promotion_articlesFindUniqueArgs<ExtArgs>>
    ): Prisma__promotion_articlesClient<
      $Result.GetResult<
        Prisma.$promotion_articlesPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Promotion_articles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {promotion_articlesFindUniqueOrThrowArgs} args - Arguments to find a Promotion_articles
     * @example
     * // Get one Promotion_articles
     * const promotion_articles = await prisma.promotion_articles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends promotion_articlesFindUniqueOrThrowArgs>(
      args: SelectSubset<T, promotion_articlesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__promotion_articlesClient<
      $Result.GetResult<
        Prisma.$promotion_articlesPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Promotion_articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promotion_articlesFindFirstArgs} args - Arguments to find a Promotion_articles
     * @example
     * // Get one Promotion_articles
     * const promotion_articles = await prisma.promotion_articles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends promotion_articlesFindFirstArgs>(
      args?: SelectSubset<T, promotion_articlesFindFirstArgs<ExtArgs>>
    ): Prisma__promotion_articlesClient<
      $Result.GetResult<
        Prisma.$promotion_articlesPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Promotion_articles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promotion_articlesFindFirstOrThrowArgs} args - Arguments to find a Promotion_articles
     * @example
     * // Get one Promotion_articles
     * const promotion_articles = await prisma.promotion_articles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends promotion_articlesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, promotion_articlesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__promotion_articlesClient<
      $Result.GetResult<
        Prisma.$promotion_articlesPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Promotion_articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promotion_articlesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotion_articles
     * const promotion_articles = await prisma.promotion_articles.findMany()
     *
     * // Get first 10 Promotion_articles
     * const promotion_articles = await prisma.promotion_articles.findMany({ take: 10 })
     *
     * // Only select the `image_banner_dark`
     * const promotion_articlesWithImage_banner_darkOnly = await prisma.promotion_articles.findMany({ select: { image_banner_dark: true } })
     *
     */
    findMany<T extends promotion_articlesFindManyArgs>(
      args?: SelectSubset<T, promotion_articlesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$promotion_articlesPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Promotion_articles.
     * @param {promotion_articlesCreateArgs} args - Arguments to create a Promotion_articles.
     * @example
     * // Create one Promotion_articles
     * const Promotion_articles = await prisma.promotion_articles.create({
     *   data: {
     *     // ... data to create a Promotion_articles
     *   }
     * })
     *
     */
    create<T extends promotion_articlesCreateArgs>(
      args: SelectSubset<T, promotion_articlesCreateArgs<ExtArgs>>
    ): Prisma__promotion_articlesClient<
      $Result.GetResult<
        Prisma.$promotion_articlesPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Promotion_articles.
     * @param {promotion_articlesCreateManyArgs} args - Arguments to create many Promotion_articles.
     * @example
     * // Create many Promotion_articles
     * const promotion_articles = await prisma.promotion_articles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends promotion_articlesCreateManyArgs>(
      args?: SelectSubset<T, promotion_articlesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Promotion_articles and returns the data saved in the database.
     * @param {promotion_articlesCreateManyAndReturnArgs} args - Arguments to create many Promotion_articles.
     * @example
     * // Create many Promotion_articles
     * const promotion_articles = await prisma.promotion_articles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Promotion_articles and only return the `image_banner_dark`
     * const promotion_articlesWithImage_banner_darkOnly = await prisma.promotion_articles.createManyAndReturn({
     *   select: { image_banner_dark: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends promotion_articlesCreateManyAndReturnArgs>(
      args?: SelectSubset<T, promotion_articlesCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$promotion_articlesPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Promotion_articles.
     * @param {promotion_articlesDeleteArgs} args - Arguments to delete one Promotion_articles.
     * @example
     * // Delete one Promotion_articles
     * const Promotion_articles = await prisma.promotion_articles.delete({
     *   where: {
     *     // ... filter to delete one Promotion_articles
     *   }
     * })
     *
     */
    delete<T extends promotion_articlesDeleteArgs>(
      args: SelectSubset<T, promotion_articlesDeleteArgs<ExtArgs>>
    ): Prisma__promotion_articlesClient<
      $Result.GetResult<
        Prisma.$promotion_articlesPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Promotion_articles.
     * @param {promotion_articlesUpdateArgs} args - Arguments to update one Promotion_articles.
     * @example
     * // Update one Promotion_articles
     * const promotion_articles = await prisma.promotion_articles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends promotion_articlesUpdateArgs>(
      args: SelectSubset<T, promotion_articlesUpdateArgs<ExtArgs>>
    ): Prisma__promotion_articlesClient<
      $Result.GetResult<
        Prisma.$promotion_articlesPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Promotion_articles.
     * @param {promotion_articlesDeleteManyArgs} args - Arguments to filter Promotion_articles to delete.
     * @example
     * // Delete a few Promotion_articles
     * const { count } = await prisma.promotion_articles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends promotion_articlesDeleteManyArgs>(
      args?: SelectSubset<T, promotion_articlesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Promotion_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promotion_articlesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotion_articles
     * const promotion_articles = await prisma.promotion_articles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends promotion_articlesUpdateManyArgs>(
      args: SelectSubset<T, promotion_articlesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Promotion_articles and returns the data updated in the database.
     * @param {promotion_articlesUpdateManyAndReturnArgs} args - Arguments to update many Promotion_articles.
     * @example
     * // Update many Promotion_articles
     * const promotion_articles = await prisma.promotion_articles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Promotion_articles and only return the `image_banner_dark`
     * const promotion_articlesWithImage_banner_darkOnly = await prisma.promotion_articles.updateManyAndReturn({
     *   select: { image_banner_dark: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends promotion_articlesUpdateManyAndReturnArgs>(
      args: SelectSubset<T, promotion_articlesUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$promotion_articlesPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Promotion_articles.
     * @param {promotion_articlesUpsertArgs} args - Arguments to update or create a Promotion_articles.
     * @example
     * // Update or create a Promotion_articles
     * const promotion_articles = await prisma.promotion_articles.upsert({
     *   create: {
     *     // ... data to create a Promotion_articles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion_articles we want to update
     *   }
     * })
     */
    upsert<T extends promotion_articlesUpsertArgs>(
      args: SelectSubset<T, promotion_articlesUpsertArgs<ExtArgs>>
    ): Prisma__promotion_articlesClient<
      $Result.GetResult<
        Prisma.$promotion_articlesPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Promotion_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promotion_articlesCountArgs} args - Arguments to filter Promotion_articles to count.
     * @example
     * // Count the number of Promotion_articles
     * const count = await prisma.promotion_articles.count({
     *   where: {
     *     // ... the filter for the Promotion_articles we want to count
     *   }
     * })
     **/
    count<T extends promotion_articlesCountArgs>(
      args?: Subset<T, promotion_articlesCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              Promotion_articlesCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Promotion_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Promotion_articlesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Promotion_articlesAggregateArgs>(
      args: Subset<T, Promotion_articlesAggregateArgs>
    ): Prisma.PrismaPromise<GetPromotion_articlesAggregateType<T>>;

    /**
     * Group by Promotion_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promotion_articlesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends promotion_articlesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: promotion_articlesGroupByArgs['orderBy'] }
        : { orderBy?: promotion_articlesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, promotion_articlesGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetPromotion_articlesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the promotion_articles model
     */
    readonly fields: promotion_articlesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for promotion_articles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__promotion_articlesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the promotion_articles model
   */
  interface promotion_articlesFieldRefs {
    readonly image_banner_dark: FieldRef<'promotion_articles', 'String'>;
    readonly image_banner_white: FieldRef<'promotion_articles', 'String'>;
    readonly title_th: FieldRef<'promotion_articles', 'String'>;
    readonly title_en: FieldRef<'promotion_articles', 'String'>;
    readonly description_th: FieldRef<'promotion_articles', 'String'>;
    readonly description_en: FieldRef<'promotion_articles', 'String'>;
    readonly content_th: FieldRef<'promotion_articles', 'String'>;
    readonly content_en: FieldRef<'promotion_articles', 'String'>;
    readonly button_text_th: FieldRef<'promotion_articles', 'String'>;
    readonly button_text_en: FieldRef<'promotion_articles', 'String'>;
    readonly path: FieldRef<'promotion_articles', 'String'>;
    readonly type: FieldRef<'promotion_articles', 'String'>;
    readonly id: FieldRef<'promotion_articles', 'Int'>;
  }

  // Custom InputTypes
  /**
   * promotion_articles findUnique
   */
  export type promotion_articlesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the promotion_articles
     */
    select?: promotion_articlesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the promotion_articles
     */
    omit?: promotion_articlesOmit<ExtArgs> | null;
    /**
     * Filter, which promotion_articles to fetch.
     */
    where: promotion_articlesWhereUniqueInput;
  };

  /**
   * promotion_articles findUniqueOrThrow
   */
  export type promotion_articlesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the promotion_articles
     */
    select?: promotion_articlesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the promotion_articles
     */
    omit?: promotion_articlesOmit<ExtArgs> | null;
    /**
     * Filter, which promotion_articles to fetch.
     */
    where: promotion_articlesWhereUniqueInput;
  };

  /**
   * promotion_articles findFirst
   */
  export type promotion_articlesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the promotion_articles
     */
    select?: promotion_articlesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the promotion_articles
     */
    omit?: promotion_articlesOmit<ExtArgs> | null;
    /**
     * Filter, which promotion_articles to fetch.
     */
    where?: promotion_articlesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of promotion_articles to fetch.
     */
    orderBy?:
      | promotion_articlesOrderByWithRelationInput
      | promotion_articlesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for promotion_articles.
     */
    cursor?: promotion_articlesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` promotion_articles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` promotion_articles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of promotion_articles.
     */
    distinct?:
      | Promotion_articlesScalarFieldEnum
      | Promotion_articlesScalarFieldEnum[];
  };

  /**
   * promotion_articles findFirstOrThrow
   */
  export type promotion_articlesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the promotion_articles
     */
    select?: promotion_articlesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the promotion_articles
     */
    omit?: promotion_articlesOmit<ExtArgs> | null;
    /**
     * Filter, which promotion_articles to fetch.
     */
    where?: promotion_articlesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of promotion_articles to fetch.
     */
    orderBy?:
      | promotion_articlesOrderByWithRelationInput
      | promotion_articlesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for promotion_articles.
     */
    cursor?: promotion_articlesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` promotion_articles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` promotion_articles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of promotion_articles.
     */
    distinct?:
      | Promotion_articlesScalarFieldEnum
      | Promotion_articlesScalarFieldEnum[];
  };

  /**
   * promotion_articles findMany
   */
  export type promotion_articlesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the promotion_articles
     */
    select?: promotion_articlesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the promotion_articles
     */
    omit?: promotion_articlesOmit<ExtArgs> | null;
    /**
     * Filter, which promotion_articles to fetch.
     */
    where?: promotion_articlesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of promotion_articles to fetch.
     */
    orderBy?:
      | promotion_articlesOrderByWithRelationInput
      | promotion_articlesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing promotion_articles.
     */
    cursor?: promotion_articlesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` promotion_articles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` promotion_articles.
     */
    skip?: number;
    distinct?:
      | Promotion_articlesScalarFieldEnum
      | Promotion_articlesScalarFieldEnum[];
  };

  /**
   * promotion_articles create
   */
  export type promotion_articlesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the promotion_articles
     */
    select?: promotion_articlesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the promotion_articles
     */
    omit?: promotion_articlesOmit<ExtArgs> | null;
    /**
     * The data needed to create a promotion_articles.
     */
    data?: XOR<
      promotion_articlesCreateInput,
      promotion_articlesUncheckedCreateInput
    >;
  };

  /**
   * promotion_articles createMany
   */
  export type promotion_articlesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many promotion_articles.
     */
    data:
      | promotion_articlesCreateManyInput
      | promotion_articlesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * promotion_articles createManyAndReturn
   */
  export type promotion_articlesCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the promotion_articles
     */
    select?: promotion_articlesSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the promotion_articles
     */
    omit?: promotion_articlesOmit<ExtArgs> | null;
    /**
     * The data used to create many promotion_articles.
     */
    data:
      | promotion_articlesCreateManyInput
      | promotion_articlesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * promotion_articles update
   */
  export type promotion_articlesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the promotion_articles
     */
    select?: promotion_articlesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the promotion_articles
     */
    omit?: promotion_articlesOmit<ExtArgs> | null;
    /**
     * The data needed to update a promotion_articles.
     */
    data: XOR<
      promotion_articlesUpdateInput,
      promotion_articlesUncheckedUpdateInput
    >;
    /**
     * Choose, which promotion_articles to update.
     */
    where: promotion_articlesWhereUniqueInput;
  };

  /**
   * promotion_articles updateMany
   */
  export type promotion_articlesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update promotion_articles.
     */
    data: XOR<
      promotion_articlesUpdateManyMutationInput,
      promotion_articlesUncheckedUpdateManyInput
    >;
    /**
     * Filter which promotion_articles to update
     */
    where?: promotion_articlesWhereInput;
    /**
     * Limit how many promotion_articles to update.
     */
    limit?: number;
  };

  /**
   * promotion_articles updateManyAndReturn
   */
  export type promotion_articlesUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the promotion_articles
     */
    select?: promotion_articlesSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the promotion_articles
     */
    omit?: promotion_articlesOmit<ExtArgs> | null;
    /**
     * The data used to update promotion_articles.
     */
    data: XOR<
      promotion_articlesUpdateManyMutationInput,
      promotion_articlesUncheckedUpdateManyInput
    >;
    /**
     * Filter which promotion_articles to update
     */
    where?: promotion_articlesWhereInput;
    /**
     * Limit how many promotion_articles to update.
     */
    limit?: number;
  };

  /**
   * promotion_articles upsert
   */
  export type promotion_articlesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the promotion_articles
     */
    select?: promotion_articlesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the promotion_articles
     */
    omit?: promotion_articlesOmit<ExtArgs> | null;
    /**
     * The filter to search for the promotion_articles to update in case it exists.
     */
    where: promotion_articlesWhereUniqueInput;
    /**
     * In case the promotion_articles found by the `where` argument doesn't exist, create a new promotion_articles with this data.
     */
    create: XOR<
      promotion_articlesCreateInput,
      promotion_articlesUncheckedCreateInput
    >;
    /**
     * In case the promotion_articles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      promotion_articlesUpdateInput,
      promotion_articlesUncheckedUpdateInput
    >;
  };

  /**
   * promotion_articles delete
   */
  export type promotion_articlesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the promotion_articles
     */
    select?: promotion_articlesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the promotion_articles
     */
    omit?: promotion_articlesOmit<ExtArgs> | null;
    /**
     * Filter which promotion_articles to delete.
     */
    where: promotion_articlesWhereUniqueInput;
  };

  /**
   * promotion_articles deleteMany
   */
  export type promotion_articlesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which promotion_articles to delete
     */
    where?: promotion_articlesWhereInput;
    /**
     * Limit how many promotion_articles to delete.
     */
    limit?: number;
  };

  /**
   * promotion_articles without action
   */
  export type promotion_articlesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the promotion_articles
     */
    select?: promotion_articlesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the promotion_articles
     */
    omit?: promotion_articlesOmit<ExtArgs> | null;
  };

  /**
   * Model stock_news
   */

  export type AggregateStock_news = {
    _count: Stock_newsCountAggregateOutputType | null;
    _avg: Stock_newsAvgAggregateOutputType | null;
    _sum: Stock_newsSumAggregateOutputType | null;
    _min: Stock_newsMinAggregateOutputType | null;
    _max: Stock_newsMaxAggregateOutputType | null;
  };

  export type Stock_newsAvgAggregateOutputType = {
    view_count: number | null;
    like_count: number | null;
    share_count: number | null;
  };

  export type Stock_newsSumAggregateOutputType = {
    view_count: number | null;
    like_count: number | null;
    share_count: number | null;
  };

  export type Stock_newsMinAggregateOutputType = {
    id: string | null;
    symbol: string | null;
    exchange: string | null;
    title: string | null;
    content: string | null;
    summary: string | null;
    image_url: string | null;
    source_url: string | null;
    publisher: string | null;
    published_date: Date | null;
    language: string | null;
    view_count: number | null;
    is_featured: boolean | null;
    is_hot: boolean | null;
    like_count: number | null;
    share_count: number | null;
    is_active: boolean | null;
    created_at: Date | null;
    updated_at: Date | null;
  };

  export type Stock_newsMaxAggregateOutputType = {
    id: string | null;
    symbol: string | null;
    exchange: string | null;
    title: string | null;
    content: string | null;
    summary: string | null;
    image_url: string | null;
    source_url: string | null;
    publisher: string | null;
    published_date: Date | null;
    language: string | null;
    view_count: number | null;
    is_featured: boolean | null;
    is_hot: boolean | null;
    like_count: number | null;
    share_count: number | null;
    is_active: boolean | null;
    created_at: Date | null;
    updated_at: Date | null;
  };

  export type Stock_newsCountAggregateOutputType = {
    id: number;
    symbol: number;
    exchange: number;
    title: number;
    content: number;
    summary: number;
    image_url: number;
    source_url: number;
    publisher: number;
    published_date: number;
    language: number;
    view_count: number;
    is_featured: number;
    is_hot: number;
    tags: number;
    metadata: number;
    like_count: number;
    share_count: number;
    is_active: number;
    created_at: number;
    updated_at: number;
    categories: number;
    _all: number;
  };

  export type Stock_newsAvgAggregateInputType = {
    view_count?: true;
    like_count?: true;
    share_count?: true;
  };

  export type Stock_newsSumAggregateInputType = {
    view_count?: true;
    like_count?: true;
    share_count?: true;
  };

  export type Stock_newsMinAggregateInputType = {
    id?: true;
    symbol?: true;
    exchange?: true;
    title?: true;
    content?: true;
    summary?: true;
    image_url?: true;
    source_url?: true;
    publisher?: true;
    published_date?: true;
    language?: true;
    view_count?: true;
    is_featured?: true;
    is_hot?: true;
    like_count?: true;
    share_count?: true;
    is_active?: true;
    created_at?: true;
    updated_at?: true;
  };

  export type Stock_newsMaxAggregateInputType = {
    id?: true;
    symbol?: true;
    exchange?: true;
    title?: true;
    content?: true;
    summary?: true;
    image_url?: true;
    source_url?: true;
    publisher?: true;
    published_date?: true;
    language?: true;
    view_count?: true;
    is_featured?: true;
    is_hot?: true;
    like_count?: true;
    share_count?: true;
    is_active?: true;
    created_at?: true;
    updated_at?: true;
  };

  export type Stock_newsCountAggregateInputType = {
    id?: true;
    symbol?: true;
    exchange?: true;
    title?: true;
    content?: true;
    summary?: true;
    image_url?: true;
    source_url?: true;
    publisher?: true;
    published_date?: true;
    language?: true;
    view_count?: true;
    is_featured?: true;
    is_hot?: true;
    tags?: true;
    metadata?: true;
    like_count?: true;
    share_count?: true;
    is_active?: true;
    created_at?: true;
    updated_at?: true;
    categories?: true;
    _all?: true;
  };

  export type Stock_newsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which stock_news to aggregate.
     */
    where?: stock_newsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news to fetch.
     */
    orderBy?:
      | stock_newsOrderByWithRelationInput
      | stock_newsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: stock_newsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned stock_news
     **/
    _count?: true | Stock_newsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Stock_newsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Stock_newsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Stock_newsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Stock_newsMaxAggregateInputType;
  };

  export type GetStock_newsAggregateType<T extends Stock_newsAggregateArgs> = {
    [P in keyof T & keyof AggregateStock_news]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock_news[P]>
      : GetScalarType<T[P], AggregateStock_news[P]>;
  };

  export type stock_newsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: stock_newsWhereInput;
    orderBy?:
      | stock_newsOrderByWithAggregationInput
      | stock_newsOrderByWithAggregationInput[];
    by: Stock_newsScalarFieldEnum[] | Stock_newsScalarFieldEnum;
    having?: stock_newsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Stock_newsCountAggregateInputType | true;
    _avg?: Stock_newsAvgAggregateInputType;
    _sum?: Stock_newsSumAggregateInputType;
    _min?: Stock_newsMinAggregateInputType;
    _max?: Stock_newsMaxAggregateInputType;
  };

  export type Stock_newsGroupByOutputType = {
    id: string;
    symbol: string;
    exchange: string | null;
    title: string;
    content: string | null;
    summary: string | null;
    image_url: string | null;
    source_url: string | null;
    publisher: string | null;
    published_date: Date;
    language: string | null;
    view_count: number | null;
    is_featured: boolean | null;
    is_hot: boolean | null;
    tags: string[];
    metadata: JsonValue | null;
    like_count: number | null;
    share_count: number | null;
    is_active: boolean | null;
    created_at: Date | null;
    updated_at: Date | null;
    categories: JsonValue | null;
    _count: Stock_newsCountAggregateOutputType | null;
    _avg: Stock_newsAvgAggregateOutputType | null;
    _sum: Stock_newsSumAggregateOutputType | null;
    _min: Stock_newsMinAggregateOutputType | null;
    _max: Stock_newsMaxAggregateOutputType | null;
  };

  type GetStock_newsGroupByPayload<T extends stock_newsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<Stock_newsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof Stock_newsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Stock_newsGroupByOutputType[P]>
            : GetScalarType<T[P], Stock_newsGroupByOutputType[P]>;
        }
      >
    >;

  export type stock_newsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      symbol?: boolean;
      exchange?: boolean;
      title?: boolean;
      content?: boolean;
      summary?: boolean;
      image_url?: boolean;
      source_url?: boolean;
      publisher?: boolean;
      published_date?: boolean;
      language?: boolean;
      view_count?: boolean;
      is_featured?: boolean;
      is_hot?: boolean;
      tags?: boolean;
      metadata?: boolean;
      like_count?: boolean;
      share_count?: boolean;
      is_active?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      categories?: boolean;
      news_comments?: boolean | stock_news$news_commentsArgs<ExtArgs>;
      stock_news_read_history?:
        | boolean
        | stock_news$stock_news_read_historyArgs<ExtArgs>;
      stock_news_related_symbols?:
        | boolean
        | stock_news$stock_news_related_symbolsArgs<ExtArgs>;
      stock_news_translation?:
        | boolean
        | stock_news$stock_news_translationArgs<ExtArgs>;
      _count?: boolean | Stock_newsCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['stock_news']
  >;

  export type stock_newsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      symbol?: boolean;
      exchange?: boolean;
      title?: boolean;
      content?: boolean;
      summary?: boolean;
      image_url?: boolean;
      source_url?: boolean;
      publisher?: boolean;
      published_date?: boolean;
      language?: boolean;
      view_count?: boolean;
      is_featured?: boolean;
      is_hot?: boolean;
      tags?: boolean;
      metadata?: boolean;
      like_count?: boolean;
      share_count?: boolean;
      is_active?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      categories?: boolean;
    },
    ExtArgs['result']['stock_news']
  >;

  export type stock_newsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      symbol?: boolean;
      exchange?: boolean;
      title?: boolean;
      content?: boolean;
      summary?: boolean;
      image_url?: boolean;
      source_url?: boolean;
      publisher?: boolean;
      published_date?: boolean;
      language?: boolean;
      view_count?: boolean;
      is_featured?: boolean;
      is_hot?: boolean;
      tags?: boolean;
      metadata?: boolean;
      like_count?: boolean;
      share_count?: boolean;
      is_active?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      categories?: boolean;
    },
    ExtArgs['result']['stock_news']
  >;

  export type stock_newsSelectScalar = {
    id?: boolean;
    symbol?: boolean;
    exchange?: boolean;
    title?: boolean;
    content?: boolean;
    summary?: boolean;
    image_url?: boolean;
    source_url?: boolean;
    publisher?: boolean;
    published_date?: boolean;
    language?: boolean;
    view_count?: boolean;
    is_featured?: boolean;
    is_hot?: boolean;
    tags?: boolean;
    metadata?: boolean;
    like_count?: boolean;
    share_count?: boolean;
    is_active?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    categories?: boolean;
  };

  export type stock_newsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'symbol'
    | 'exchange'
    | 'title'
    | 'content'
    | 'summary'
    | 'image_url'
    | 'source_url'
    | 'publisher'
    | 'published_date'
    | 'language'
    | 'view_count'
    | 'is_featured'
    | 'is_hot'
    | 'tags'
    | 'metadata'
    | 'like_count'
    | 'share_count'
    | 'is_active'
    | 'created_at'
    | 'updated_at'
    | 'categories',
    ExtArgs['result']['stock_news']
  >;
  export type stock_newsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    news_comments?: boolean | stock_news$news_commentsArgs<ExtArgs>;
    stock_news_read_history?:
      | boolean
      | stock_news$stock_news_read_historyArgs<ExtArgs>;
    stock_news_related_symbols?:
      | boolean
      | stock_news$stock_news_related_symbolsArgs<ExtArgs>;
    stock_news_translation?:
      | boolean
      | stock_news$stock_news_translationArgs<ExtArgs>;
    _count?: boolean | Stock_newsCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type stock_newsIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {};
  export type stock_newsIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {};

  export type $stock_newsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'stock_news';
    objects: {
      news_comments: Prisma.$news_commentsPayload<ExtArgs>[];
      stock_news_read_history: Prisma.$stock_news_read_historyPayload<ExtArgs>[];
      stock_news_related_symbols: Prisma.$stock_news_related_symbolsPayload<ExtArgs>[];
      stock_news_translation: Prisma.$stock_news_translationPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        symbol: string;
        exchange: string | null;
        title: string;
        content: string | null;
        summary: string | null;
        image_url: string | null;
        source_url: string | null;
        publisher: string | null;
        published_date: Date;
        language: string | null;
        view_count: number | null;
        is_featured: boolean | null;
        is_hot: boolean | null;
        tags: string[];
        metadata: Prisma.JsonValue | null;
        like_count: number | null;
        share_count: number | null;
        is_active: boolean | null;
        created_at: Date | null;
        updated_at: Date | null;
        categories: Prisma.JsonValue | null;
      },
      ExtArgs['result']['stock_news']
    >;
    composites: {};
  };

  type stock_newsGetPayload<
    S extends boolean | null | undefined | stock_newsDefaultArgs
  > = $Result.GetResult<Prisma.$stock_newsPayload, S>;

  type stock_newsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    stock_newsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Stock_newsCountAggregateInputType | true;
  };

  export interface stock_newsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['stock_news'];
      meta: { name: 'stock_news' };
    };
    /**
     * Find zero or one Stock_news that matches the filter.
     * @param {stock_newsFindUniqueArgs} args - Arguments to find a Stock_news
     * @example
     * // Get one Stock_news
     * const stock_news = await prisma.stock_news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends stock_newsFindUniqueArgs>(
      args: SelectSubset<T, stock_newsFindUniqueArgs<ExtArgs>>
    ): Prisma__stock_newsClient<
      $Result.GetResult<
        Prisma.$stock_newsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Stock_news that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {stock_newsFindUniqueOrThrowArgs} args - Arguments to find a Stock_news
     * @example
     * // Get one Stock_news
     * const stock_news = await prisma.stock_news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends stock_newsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, stock_newsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__stock_newsClient<
      $Result.GetResult<
        Prisma.$stock_newsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Stock_news that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_newsFindFirstArgs} args - Arguments to find a Stock_news
     * @example
     * // Get one Stock_news
     * const stock_news = await prisma.stock_news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends stock_newsFindFirstArgs>(
      args?: SelectSubset<T, stock_newsFindFirstArgs<ExtArgs>>
    ): Prisma__stock_newsClient<
      $Result.GetResult<
        Prisma.$stock_newsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Stock_news that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_newsFindFirstOrThrowArgs} args - Arguments to find a Stock_news
     * @example
     * // Get one Stock_news
     * const stock_news = await prisma.stock_news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends stock_newsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, stock_newsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__stock_newsClient<
      $Result.GetResult<
        Prisma.$stock_newsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Stock_news that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_newsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stock_news
     * const stock_news = await prisma.stock_news.findMany()
     *
     * // Get first 10 Stock_news
     * const stock_news = await prisma.stock_news.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const stock_newsWithIdOnly = await prisma.stock_news.findMany({ select: { id: true } })
     *
     */
    findMany<T extends stock_newsFindManyArgs>(
      args?: SelectSubset<T, stock_newsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$stock_newsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Stock_news.
     * @param {stock_newsCreateArgs} args - Arguments to create a Stock_news.
     * @example
     * // Create one Stock_news
     * const Stock_news = await prisma.stock_news.create({
     *   data: {
     *     // ... data to create a Stock_news
     *   }
     * })
     *
     */
    create<T extends stock_newsCreateArgs>(
      args: SelectSubset<T, stock_newsCreateArgs<ExtArgs>>
    ): Prisma__stock_newsClient<
      $Result.GetResult<
        Prisma.$stock_newsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Stock_news.
     * @param {stock_newsCreateManyArgs} args - Arguments to create many Stock_news.
     * @example
     * // Create many Stock_news
     * const stock_news = await prisma.stock_news.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends stock_newsCreateManyArgs>(
      args?: SelectSubset<T, stock_newsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Stock_news and returns the data saved in the database.
     * @param {stock_newsCreateManyAndReturnArgs} args - Arguments to create many Stock_news.
     * @example
     * // Create many Stock_news
     * const stock_news = await prisma.stock_news.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Stock_news and only return the `id`
     * const stock_newsWithIdOnly = await prisma.stock_news.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends stock_newsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, stock_newsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$stock_newsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Stock_news.
     * @param {stock_newsDeleteArgs} args - Arguments to delete one Stock_news.
     * @example
     * // Delete one Stock_news
     * const Stock_news = await prisma.stock_news.delete({
     *   where: {
     *     // ... filter to delete one Stock_news
     *   }
     * })
     *
     */
    delete<T extends stock_newsDeleteArgs>(
      args: SelectSubset<T, stock_newsDeleteArgs<ExtArgs>>
    ): Prisma__stock_newsClient<
      $Result.GetResult<
        Prisma.$stock_newsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Stock_news.
     * @param {stock_newsUpdateArgs} args - Arguments to update one Stock_news.
     * @example
     * // Update one Stock_news
     * const stock_news = await prisma.stock_news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends stock_newsUpdateArgs>(
      args: SelectSubset<T, stock_newsUpdateArgs<ExtArgs>>
    ): Prisma__stock_newsClient<
      $Result.GetResult<
        Prisma.$stock_newsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Stock_news.
     * @param {stock_newsDeleteManyArgs} args - Arguments to filter Stock_news to delete.
     * @example
     * // Delete a few Stock_news
     * const { count } = await prisma.stock_news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends stock_newsDeleteManyArgs>(
      args?: SelectSubset<T, stock_newsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Stock_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_newsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stock_news
     * const stock_news = await prisma.stock_news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends stock_newsUpdateManyArgs>(
      args: SelectSubset<T, stock_newsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Stock_news and returns the data updated in the database.
     * @param {stock_newsUpdateManyAndReturnArgs} args - Arguments to update many Stock_news.
     * @example
     * // Update many Stock_news
     * const stock_news = await prisma.stock_news.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Stock_news and only return the `id`
     * const stock_newsWithIdOnly = await prisma.stock_news.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends stock_newsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, stock_newsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$stock_newsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Stock_news.
     * @param {stock_newsUpsertArgs} args - Arguments to update or create a Stock_news.
     * @example
     * // Update or create a Stock_news
     * const stock_news = await prisma.stock_news.upsert({
     *   create: {
     *     // ... data to create a Stock_news
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock_news we want to update
     *   }
     * })
     */
    upsert<T extends stock_newsUpsertArgs>(
      args: SelectSubset<T, stock_newsUpsertArgs<ExtArgs>>
    ): Prisma__stock_newsClient<
      $Result.GetResult<
        Prisma.$stock_newsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Stock_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_newsCountArgs} args - Arguments to filter Stock_news to count.
     * @example
     * // Count the number of Stock_news
     * const count = await prisma.stock_news.count({
     *   where: {
     *     // ... the filter for the Stock_news we want to count
     *   }
     * })
     **/
    count<T extends stock_newsCountArgs>(
      args?: Subset<T, stock_newsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Stock_newsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Stock_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stock_newsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Stock_newsAggregateArgs>(
      args: Subset<T, Stock_newsAggregateArgs>
    ): Prisma.PrismaPromise<GetStock_newsAggregateType<T>>;

    /**
     * Group by Stock_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_newsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends stock_newsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stock_newsGroupByArgs['orderBy'] }
        : { orderBy?: stock_newsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, stock_newsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetStock_newsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the stock_news model
     */
    readonly fields: stock_newsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stock_news.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stock_newsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    news_comments<T extends stock_news$news_commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, stock_news$news_commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$news_commentsPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    stock_news_read_history<
      T extends stock_news$stock_news_read_historyArgs<ExtArgs> = {}
    >(
      args?: Subset<T, stock_news$stock_news_read_historyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$stock_news_read_historyPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    stock_news_related_symbols<
      T extends stock_news$stock_news_related_symbolsArgs<ExtArgs> = {}
    >(
      args?: Subset<T, stock_news$stock_news_related_symbolsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$stock_news_related_symbolsPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    stock_news_translation<
      T extends stock_news$stock_news_translationArgs<ExtArgs> = {}
    >(
      args?: Subset<T, stock_news$stock_news_translationArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$stock_news_translationPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the stock_news model
   */
  interface stock_newsFieldRefs {
    readonly id: FieldRef<'stock_news', 'String'>;
    readonly symbol: FieldRef<'stock_news', 'String'>;
    readonly exchange: FieldRef<'stock_news', 'String'>;
    readonly title: FieldRef<'stock_news', 'String'>;
    readonly content: FieldRef<'stock_news', 'String'>;
    readonly summary: FieldRef<'stock_news', 'String'>;
    readonly image_url: FieldRef<'stock_news', 'String'>;
    readonly source_url: FieldRef<'stock_news', 'String'>;
    readonly publisher: FieldRef<'stock_news', 'String'>;
    readonly published_date: FieldRef<'stock_news', 'DateTime'>;
    readonly language: FieldRef<'stock_news', 'String'>;
    readonly view_count: FieldRef<'stock_news', 'Int'>;
    readonly is_featured: FieldRef<'stock_news', 'Boolean'>;
    readonly is_hot: FieldRef<'stock_news', 'Boolean'>;
    readonly tags: FieldRef<'stock_news', 'String[]'>;
    readonly metadata: FieldRef<'stock_news', 'Json'>;
    readonly like_count: FieldRef<'stock_news', 'Int'>;
    readonly share_count: FieldRef<'stock_news', 'Int'>;
    readonly is_active: FieldRef<'stock_news', 'Boolean'>;
    readonly created_at: FieldRef<'stock_news', 'DateTime'>;
    readonly updated_at: FieldRef<'stock_news', 'DateTime'>;
    readonly categories: FieldRef<'stock_news', 'Json'>;
  }

  // Custom InputTypes
  /**
   * stock_news findUnique
   */
  export type stock_newsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news
     */
    select?: stock_newsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news
     */
    omit?: stock_newsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_newsInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news to fetch.
     */
    where: stock_newsWhereUniqueInput;
  };

  /**
   * stock_news findUniqueOrThrow
   */
  export type stock_newsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news
     */
    select?: stock_newsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news
     */
    omit?: stock_newsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_newsInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news to fetch.
     */
    where: stock_newsWhereUniqueInput;
  };

  /**
   * stock_news findFirst
   */
  export type stock_newsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news
     */
    select?: stock_newsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news
     */
    omit?: stock_newsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_newsInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news to fetch.
     */
    where?: stock_newsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news to fetch.
     */
    orderBy?:
      | stock_newsOrderByWithRelationInput
      | stock_newsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for stock_news.
     */
    cursor?: stock_newsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of stock_news.
     */
    distinct?: Stock_newsScalarFieldEnum | Stock_newsScalarFieldEnum[];
  };

  /**
   * stock_news findFirstOrThrow
   */
  export type stock_newsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news
     */
    select?: stock_newsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news
     */
    omit?: stock_newsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_newsInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news to fetch.
     */
    where?: stock_newsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news to fetch.
     */
    orderBy?:
      | stock_newsOrderByWithRelationInput
      | stock_newsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for stock_news.
     */
    cursor?: stock_newsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of stock_news.
     */
    distinct?: Stock_newsScalarFieldEnum | Stock_newsScalarFieldEnum[];
  };

  /**
   * stock_news findMany
   */
  export type stock_newsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news
     */
    select?: stock_newsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news
     */
    omit?: stock_newsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_newsInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news to fetch.
     */
    where?: stock_newsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news to fetch.
     */
    orderBy?:
      | stock_newsOrderByWithRelationInput
      | stock_newsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing stock_news.
     */
    cursor?: stock_newsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news.
     */
    skip?: number;
    distinct?: Stock_newsScalarFieldEnum | Stock_newsScalarFieldEnum[];
  };

  /**
   * stock_news create
   */
  export type stock_newsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news
     */
    select?: stock_newsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news
     */
    omit?: stock_newsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_newsInclude<ExtArgs> | null;
    /**
     * The data needed to create a stock_news.
     */
    data: XOR<stock_newsCreateInput, stock_newsUncheckedCreateInput>;
  };

  /**
   * stock_news createMany
   */
  export type stock_newsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many stock_news.
     */
    data: stock_newsCreateManyInput | stock_newsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * stock_news createManyAndReturn
   */
  export type stock_newsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news
     */
    select?: stock_newsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news
     */
    omit?: stock_newsOmit<ExtArgs> | null;
    /**
     * The data used to create many stock_news.
     */
    data: stock_newsCreateManyInput | stock_newsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * stock_news update
   */
  export type stock_newsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news
     */
    select?: stock_newsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news
     */
    omit?: stock_newsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_newsInclude<ExtArgs> | null;
    /**
     * The data needed to update a stock_news.
     */
    data: XOR<stock_newsUpdateInput, stock_newsUncheckedUpdateInput>;
    /**
     * Choose, which stock_news to update.
     */
    where: stock_newsWhereUniqueInput;
  };

  /**
   * stock_news updateMany
   */
  export type stock_newsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update stock_news.
     */
    data: XOR<
      stock_newsUpdateManyMutationInput,
      stock_newsUncheckedUpdateManyInput
    >;
    /**
     * Filter which stock_news to update
     */
    where?: stock_newsWhereInput;
    /**
     * Limit how many stock_news to update.
     */
    limit?: number;
  };

  /**
   * stock_news updateManyAndReturn
   */
  export type stock_newsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news
     */
    select?: stock_newsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news
     */
    omit?: stock_newsOmit<ExtArgs> | null;
    /**
     * The data used to update stock_news.
     */
    data: XOR<
      stock_newsUpdateManyMutationInput,
      stock_newsUncheckedUpdateManyInput
    >;
    /**
     * Filter which stock_news to update
     */
    where?: stock_newsWhereInput;
    /**
     * Limit how many stock_news to update.
     */
    limit?: number;
  };

  /**
   * stock_news upsert
   */
  export type stock_newsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news
     */
    select?: stock_newsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news
     */
    omit?: stock_newsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_newsInclude<ExtArgs> | null;
    /**
     * The filter to search for the stock_news to update in case it exists.
     */
    where: stock_newsWhereUniqueInput;
    /**
     * In case the stock_news found by the `where` argument doesn't exist, create a new stock_news with this data.
     */
    create: XOR<stock_newsCreateInput, stock_newsUncheckedCreateInput>;
    /**
     * In case the stock_news was found with the provided `where` argument, update it with this data.
     */
    update: XOR<stock_newsUpdateInput, stock_newsUncheckedUpdateInput>;
  };

  /**
   * stock_news delete
   */
  export type stock_newsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news
     */
    select?: stock_newsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news
     */
    omit?: stock_newsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_newsInclude<ExtArgs> | null;
    /**
     * Filter which stock_news to delete.
     */
    where: stock_newsWhereUniqueInput;
  };

  /**
   * stock_news deleteMany
   */
  export type stock_newsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which stock_news to delete
     */
    where?: stock_newsWhereInput;
    /**
     * Limit how many stock_news to delete.
     */
    limit?: number;
  };

  /**
   * stock_news.news_comments
   */
  export type stock_news$news_commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the news_comments
     */
    select?: news_commentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the news_comments
     */
    omit?: news_commentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: news_commentsInclude<ExtArgs> | null;
    where?: news_commentsWhereInput;
    orderBy?:
      | news_commentsOrderByWithRelationInput
      | news_commentsOrderByWithRelationInput[];
    cursor?: news_commentsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: News_commentsScalarFieldEnum | News_commentsScalarFieldEnum[];
  };

  /**
   * stock_news.stock_news_read_history
   */
  export type stock_news$stock_news_read_historyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_read_history
     */
    select?: stock_news_read_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_read_history
     */
    omit?: stock_news_read_historyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_read_historyInclude<ExtArgs> | null;
    where?: stock_news_read_historyWhereInput;
    orderBy?:
      | stock_news_read_historyOrderByWithRelationInput
      | stock_news_read_historyOrderByWithRelationInput[];
    cursor?: stock_news_read_historyWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | Stock_news_read_historyScalarFieldEnum
      | Stock_news_read_historyScalarFieldEnum[];
  };

  /**
   * stock_news.stock_news_related_symbols
   */
  export type stock_news$stock_news_related_symbolsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_related_symbols
     */
    select?: stock_news_related_symbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_related_symbols
     */
    omit?: stock_news_related_symbolsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_related_symbolsInclude<ExtArgs> | null;
    where?: stock_news_related_symbolsWhereInput;
    orderBy?:
      | stock_news_related_symbolsOrderByWithRelationInput
      | stock_news_related_symbolsOrderByWithRelationInput[];
    cursor?: stock_news_related_symbolsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | Stock_news_related_symbolsScalarFieldEnum
      | Stock_news_related_symbolsScalarFieldEnum[];
  };

  /**
   * stock_news.stock_news_translation
   */
  export type stock_news$stock_news_translationArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_translation
     */
    select?: stock_news_translationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_translation
     */
    omit?: stock_news_translationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_translationInclude<ExtArgs> | null;
    where?: stock_news_translationWhereInput;
    orderBy?:
      | stock_news_translationOrderByWithRelationInput
      | stock_news_translationOrderByWithRelationInput[];
    cursor?: stock_news_translationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | Stock_news_translationScalarFieldEnum
      | Stock_news_translationScalarFieldEnum[];
  };

  /**
   * stock_news without action
   */
  export type stock_newsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news
     */
    select?: stock_newsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news
     */
    omit?: stock_newsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_newsInclude<ExtArgs> | null;
  };

  /**
   * Model stock_news_read_history
   */

  export type AggregateStock_news_read_history = {
    _count: Stock_news_read_historyCountAggregateOutputType | null;
    _avg: Stock_news_read_historyAvgAggregateOutputType | null;
    _sum: Stock_news_read_historySumAggregateOutputType | null;
    _min: Stock_news_read_historyMinAggregateOutputType | null;
    _max: Stock_news_read_historyMaxAggregateOutputType | null;
  };

  export type Stock_news_read_historyAvgAggregateOutputType = {
    read_duration: number | null;
  };

  export type Stock_news_read_historySumAggregateOutputType = {
    read_duration: number | null;
  };

  export type Stock_news_read_historyMinAggregateOutputType = {
    id: string | null;
    news_id: string | null;
    user_id: string | null;
    session_id: string | null;
    read_at: Date | null;
    language_read: string | null;
    read_duration: number | null;
  };

  export type Stock_news_read_historyMaxAggregateOutputType = {
    id: string | null;
    news_id: string | null;
    user_id: string | null;
    session_id: string | null;
    read_at: Date | null;
    language_read: string | null;
    read_duration: number | null;
  };

  export type Stock_news_read_historyCountAggregateOutputType = {
    id: number;
    news_id: number;
    user_id: number;
    session_id: number;
    read_at: number;
    language_read: number;
    read_duration: number;
    metadata: number;
    _all: number;
  };

  export type Stock_news_read_historyAvgAggregateInputType = {
    read_duration?: true;
  };

  export type Stock_news_read_historySumAggregateInputType = {
    read_duration?: true;
  };

  export type Stock_news_read_historyMinAggregateInputType = {
    id?: true;
    news_id?: true;
    user_id?: true;
    session_id?: true;
    read_at?: true;
    language_read?: true;
    read_duration?: true;
  };

  export type Stock_news_read_historyMaxAggregateInputType = {
    id?: true;
    news_id?: true;
    user_id?: true;
    session_id?: true;
    read_at?: true;
    language_read?: true;
    read_duration?: true;
  };

  export type Stock_news_read_historyCountAggregateInputType = {
    id?: true;
    news_id?: true;
    user_id?: true;
    session_id?: true;
    read_at?: true;
    language_read?: true;
    read_duration?: true;
    metadata?: true;
    _all?: true;
  };

  export type Stock_news_read_historyAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which stock_news_read_history to aggregate.
     */
    where?: stock_news_read_historyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news_read_histories to fetch.
     */
    orderBy?:
      | stock_news_read_historyOrderByWithRelationInput
      | stock_news_read_historyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: stock_news_read_historyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news_read_histories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news_read_histories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned stock_news_read_histories
     **/
    _count?: true | Stock_news_read_historyCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Stock_news_read_historyAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Stock_news_read_historySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Stock_news_read_historyMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Stock_news_read_historyMaxAggregateInputType;
  };

  export type GetStock_news_read_historyAggregateType<
    T extends Stock_news_read_historyAggregateArgs
  > = {
    [P in keyof T & keyof AggregateStock_news_read_history]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock_news_read_history[P]>
      : GetScalarType<T[P], AggregateStock_news_read_history[P]>;
  };

  export type stock_news_read_historyGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: stock_news_read_historyWhereInput;
    orderBy?:
      | stock_news_read_historyOrderByWithAggregationInput
      | stock_news_read_historyOrderByWithAggregationInput[];
    by:
      | Stock_news_read_historyScalarFieldEnum[]
      | Stock_news_read_historyScalarFieldEnum;
    having?: stock_news_read_historyScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Stock_news_read_historyCountAggregateInputType | true;
    _avg?: Stock_news_read_historyAvgAggregateInputType;
    _sum?: Stock_news_read_historySumAggregateInputType;
    _min?: Stock_news_read_historyMinAggregateInputType;
    _max?: Stock_news_read_historyMaxAggregateInputType;
  };

  export type Stock_news_read_historyGroupByOutputType = {
    id: string;
    news_id: string;
    user_id: string | null;
    session_id: string | null;
    read_at: Date | null;
    language_read: string | null;
    read_duration: number | null;
    metadata: JsonValue | null;
    _count: Stock_news_read_historyCountAggregateOutputType | null;
    _avg: Stock_news_read_historyAvgAggregateOutputType | null;
    _sum: Stock_news_read_historySumAggregateOutputType | null;
    _min: Stock_news_read_historyMinAggregateOutputType | null;
    _max: Stock_news_read_historyMaxAggregateOutputType | null;
  };

  type GetStock_news_read_historyGroupByPayload<
    T extends stock_news_read_historyGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Stock_news_read_historyGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof Stock_news_read_historyGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], Stock_news_read_historyGroupByOutputType[P]>
          : GetScalarType<T[P], Stock_news_read_historyGroupByOutputType[P]>;
      }
    >
  >;

  export type stock_news_read_historySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      news_id?: boolean;
      user_id?: boolean;
      session_id?: boolean;
      read_at?: boolean;
      language_read?: boolean;
      read_duration?: boolean;
      metadata?: boolean;
      stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['stock_news_read_history']
  >;

  export type stock_news_read_historySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      news_id?: boolean;
      user_id?: boolean;
      session_id?: boolean;
      read_at?: boolean;
      language_read?: boolean;
      read_duration?: boolean;
      metadata?: boolean;
      stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['stock_news_read_history']
  >;

  export type stock_news_read_historySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      news_id?: boolean;
      user_id?: boolean;
      session_id?: boolean;
      read_at?: boolean;
      language_read?: boolean;
      read_duration?: boolean;
      metadata?: boolean;
      stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['stock_news_read_history']
  >;

  export type stock_news_read_historySelectScalar = {
    id?: boolean;
    news_id?: boolean;
    user_id?: boolean;
    session_id?: boolean;
    read_at?: boolean;
    language_read?: boolean;
    read_duration?: boolean;
    metadata?: boolean;
  };

  export type stock_news_read_historyOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'news_id'
    | 'user_id'
    | 'session_id'
    | 'read_at'
    | 'language_read'
    | 'read_duration'
    | 'metadata',
    ExtArgs['result']['stock_news_read_history']
  >;
  export type stock_news_read_historyInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
  };
  export type stock_news_read_historyIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
  };
  export type stock_news_read_historyIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
  };

  export type $stock_news_read_historyPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'stock_news_read_history';
    objects: {
      stock_news: Prisma.$stock_newsPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        news_id: string;
        user_id: string | null;
        session_id: string | null;
        read_at: Date | null;
        language_read: string | null;
        read_duration: number | null;
        metadata: Prisma.JsonValue | null;
      },
      ExtArgs['result']['stock_news_read_history']
    >;
    composites: {};
  };

  type stock_news_read_historyGetPayload<
    S extends boolean | null | undefined | stock_news_read_historyDefaultArgs
  > = $Result.GetResult<Prisma.$stock_news_read_historyPayload, S>;

  type stock_news_read_historyCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    stock_news_read_historyFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Stock_news_read_historyCountAggregateInputType | true;
  };

  export interface stock_news_read_historyDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['stock_news_read_history'];
      meta: { name: 'stock_news_read_history' };
    };
    /**
     * Find zero or one Stock_news_read_history that matches the filter.
     * @param {stock_news_read_historyFindUniqueArgs} args - Arguments to find a Stock_news_read_history
     * @example
     * // Get one Stock_news_read_history
     * const stock_news_read_history = await prisma.stock_news_read_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends stock_news_read_historyFindUniqueArgs>(
      args: SelectSubset<T, stock_news_read_historyFindUniqueArgs<ExtArgs>>
    ): Prisma__stock_news_read_historyClient<
      $Result.GetResult<
        Prisma.$stock_news_read_historyPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Stock_news_read_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {stock_news_read_historyFindUniqueOrThrowArgs} args - Arguments to find a Stock_news_read_history
     * @example
     * // Get one Stock_news_read_history
     * const stock_news_read_history = await prisma.stock_news_read_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends stock_news_read_historyFindUniqueOrThrowArgs>(
      args: SelectSubset<
        T,
        stock_news_read_historyFindUniqueOrThrowArgs<ExtArgs>
      >
    ): Prisma__stock_news_read_historyClient<
      $Result.GetResult<
        Prisma.$stock_news_read_historyPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Stock_news_read_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_read_historyFindFirstArgs} args - Arguments to find a Stock_news_read_history
     * @example
     * // Get one Stock_news_read_history
     * const stock_news_read_history = await prisma.stock_news_read_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends stock_news_read_historyFindFirstArgs>(
      args?: SelectSubset<T, stock_news_read_historyFindFirstArgs<ExtArgs>>
    ): Prisma__stock_news_read_historyClient<
      $Result.GetResult<
        Prisma.$stock_news_read_historyPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Stock_news_read_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_read_historyFindFirstOrThrowArgs} args - Arguments to find a Stock_news_read_history
     * @example
     * // Get one Stock_news_read_history
     * const stock_news_read_history = await prisma.stock_news_read_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends stock_news_read_historyFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        stock_news_read_historyFindFirstOrThrowArgs<ExtArgs>
      >
    ): Prisma__stock_news_read_historyClient<
      $Result.GetResult<
        Prisma.$stock_news_read_historyPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Stock_news_read_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_read_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stock_news_read_histories
     * const stock_news_read_histories = await prisma.stock_news_read_history.findMany()
     *
     * // Get first 10 Stock_news_read_histories
     * const stock_news_read_histories = await prisma.stock_news_read_history.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const stock_news_read_historyWithIdOnly = await prisma.stock_news_read_history.findMany({ select: { id: true } })
     *
     */
    findMany<T extends stock_news_read_historyFindManyArgs>(
      args?: SelectSubset<T, stock_news_read_historyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$stock_news_read_historyPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Stock_news_read_history.
     * @param {stock_news_read_historyCreateArgs} args - Arguments to create a Stock_news_read_history.
     * @example
     * // Create one Stock_news_read_history
     * const Stock_news_read_history = await prisma.stock_news_read_history.create({
     *   data: {
     *     // ... data to create a Stock_news_read_history
     *   }
     * })
     *
     */
    create<T extends stock_news_read_historyCreateArgs>(
      args: SelectSubset<T, stock_news_read_historyCreateArgs<ExtArgs>>
    ): Prisma__stock_news_read_historyClient<
      $Result.GetResult<
        Prisma.$stock_news_read_historyPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Stock_news_read_histories.
     * @param {stock_news_read_historyCreateManyArgs} args - Arguments to create many Stock_news_read_histories.
     * @example
     * // Create many Stock_news_read_histories
     * const stock_news_read_history = await prisma.stock_news_read_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends stock_news_read_historyCreateManyArgs>(
      args?: SelectSubset<T, stock_news_read_historyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Stock_news_read_histories and returns the data saved in the database.
     * @param {stock_news_read_historyCreateManyAndReturnArgs} args - Arguments to create many Stock_news_read_histories.
     * @example
     * // Create many Stock_news_read_histories
     * const stock_news_read_history = await prisma.stock_news_read_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Stock_news_read_histories and only return the `id`
     * const stock_news_read_historyWithIdOnly = await prisma.stock_news_read_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends stock_news_read_historyCreateManyAndReturnArgs
    >(
      args?: SelectSubset<
        T,
        stock_news_read_historyCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$stock_news_read_historyPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Stock_news_read_history.
     * @param {stock_news_read_historyDeleteArgs} args - Arguments to delete one Stock_news_read_history.
     * @example
     * // Delete one Stock_news_read_history
     * const Stock_news_read_history = await prisma.stock_news_read_history.delete({
     *   where: {
     *     // ... filter to delete one Stock_news_read_history
     *   }
     * })
     *
     */
    delete<T extends stock_news_read_historyDeleteArgs>(
      args: SelectSubset<T, stock_news_read_historyDeleteArgs<ExtArgs>>
    ): Prisma__stock_news_read_historyClient<
      $Result.GetResult<
        Prisma.$stock_news_read_historyPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Stock_news_read_history.
     * @param {stock_news_read_historyUpdateArgs} args - Arguments to update one Stock_news_read_history.
     * @example
     * // Update one Stock_news_read_history
     * const stock_news_read_history = await prisma.stock_news_read_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends stock_news_read_historyUpdateArgs>(
      args: SelectSubset<T, stock_news_read_historyUpdateArgs<ExtArgs>>
    ): Prisma__stock_news_read_historyClient<
      $Result.GetResult<
        Prisma.$stock_news_read_historyPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Stock_news_read_histories.
     * @param {stock_news_read_historyDeleteManyArgs} args - Arguments to filter Stock_news_read_histories to delete.
     * @example
     * // Delete a few Stock_news_read_histories
     * const { count } = await prisma.stock_news_read_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends stock_news_read_historyDeleteManyArgs>(
      args?: SelectSubset<T, stock_news_read_historyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Stock_news_read_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_read_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stock_news_read_histories
     * const stock_news_read_history = await prisma.stock_news_read_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends stock_news_read_historyUpdateManyArgs>(
      args: SelectSubset<T, stock_news_read_historyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Stock_news_read_histories and returns the data updated in the database.
     * @param {stock_news_read_historyUpdateManyAndReturnArgs} args - Arguments to update many Stock_news_read_histories.
     * @example
     * // Update many Stock_news_read_histories
     * const stock_news_read_history = await prisma.stock_news_read_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Stock_news_read_histories and only return the `id`
     * const stock_news_read_historyWithIdOnly = await prisma.stock_news_read_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends stock_news_read_historyUpdateManyAndReturnArgs
    >(
      args: SelectSubset<
        T,
        stock_news_read_historyUpdateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$stock_news_read_historyPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Stock_news_read_history.
     * @param {stock_news_read_historyUpsertArgs} args - Arguments to update or create a Stock_news_read_history.
     * @example
     * // Update or create a Stock_news_read_history
     * const stock_news_read_history = await prisma.stock_news_read_history.upsert({
     *   create: {
     *     // ... data to create a Stock_news_read_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock_news_read_history we want to update
     *   }
     * })
     */
    upsert<T extends stock_news_read_historyUpsertArgs>(
      args: SelectSubset<T, stock_news_read_historyUpsertArgs<ExtArgs>>
    ): Prisma__stock_news_read_historyClient<
      $Result.GetResult<
        Prisma.$stock_news_read_historyPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Stock_news_read_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_read_historyCountArgs} args - Arguments to filter Stock_news_read_histories to count.
     * @example
     * // Count the number of Stock_news_read_histories
     * const count = await prisma.stock_news_read_history.count({
     *   where: {
     *     // ... the filter for the Stock_news_read_histories we want to count
     *   }
     * })
     **/
    count<T extends stock_news_read_historyCountArgs>(
      args?: Subset<T, stock_news_read_historyCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              Stock_news_read_historyCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Stock_news_read_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stock_news_read_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Stock_news_read_historyAggregateArgs>(
      args: Subset<T, Stock_news_read_historyAggregateArgs>
    ): Prisma.PrismaPromise<GetStock_news_read_historyAggregateType<T>>;

    /**
     * Group by Stock_news_read_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_read_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends stock_news_read_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stock_news_read_historyGroupByArgs['orderBy'] }
        : { orderBy?: stock_news_read_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<
        T,
        stock_news_read_historyGroupByArgs,
        OrderByArg
      > &
        InputErrors
    ): {} extends InputErrors
      ? GetStock_news_read_historyGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the stock_news_read_history model
     */
    readonly fields: stock_news_read_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stock_news_read_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stock_news_read_historyClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    stock_news<T extends stock_newsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, stock_newsDefaultArgs<ExtArgs>>
    ): Prisma__stock_newsClient<
      | $Result.GetResult<
          Prisma.$stock_newsPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the stock_news_read_history model
   */
  interface stock_news_read_historyFieldRefs {
    readonly id: FieldRef<'stock_news_read_history', 'String'>;
    readonly news_id: FieldRef<'stock_news_read_history', 'String'>;
    readonly user_id: FieldRef<'stock_news_read_history', 'String'>;
    readonly session_id: FieldRef<'stock_news_read_history', 'String'>;
    readonly read_at: FieldRef<'stock_news_read_history', 'DateTime'>;
    readonly language_read: FieldRef<'stock_news_read_history', 'String'>;
    readonly read_duration: FieldRef<'stock_news_read_history', 'Int'>;
    readonly metadata: FieldRef<'stock_news_read_history', 'Json'>;
  }

  // Custom InputTypes
  /**
   * stock_news_read_history findUnique
   */
  export type stock_news_read_historyFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_read_history
     */
    select?: stock_news_read_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_read_history
     */
    omit?: stock_news_read_historyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_read_historyInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news_read_history to fetch.
     */
    where: stock_news_read_historyWhereUniqueInput;
  };

  /**
   * stock_news_read_history findUniqueOrThrow
   */
  export type stock_news_read_historyFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_read_history
     */
    select?: stock_news_read_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_read_history
     */
    omit?: stock_news_read_historyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_read_historyInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news_read_history to fetch.
     */
    where: stock_news_read_historyWhereUniqueInput;
  };

  /**
   * stock_news_read_history findFirst
   */
  export type stock_news_read_historyFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_read_history
     */
    select?: stock_news_read_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_read_history
     */
    omit?: stock_news_read_historyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_read_historyInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news_read_history to fetch.
     */
    where?: stock_news_read_historyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news_read_histories to fetch.
     */
    orderBy?:
      | stock_news_read_historyOrderByWithRelationInput
      | stock_news_read_historyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for stock_news_read_histories.
     */
    cursor?: stock_news_read_historyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news_read_histories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news_read_histories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of stock_news_read_histories.
     */
    distinct?:
      | Stock_news_read_historyScalarFieldEnum
      | Stock_news_read_historyScalarFieldEnum[];
  };

  /**
   * stock_news_read_history findFirstOrThrow
   */
  export type stock_news_read_historyFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_read_history
     */
    select?: stock_news_read_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_read_history
     */
    omit?: stock_news_read_historyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_read_historyInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news_read_history to fetch.
     */
    where?: stock_news_read_historyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news_read_histories to fetch.
     */
    orderBy?:
      | stock_news_read_historyOrderByWithRelationInput
      | stock_news_read_historyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for stock_news_read_histories.
     */
    cursor?: stock_news_read_historyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news_read_histories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news_read_histories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of stock_news_read_histories.
     */
    distinct?:
      | Stock_news_read_historyScalarFieldEnum
      | Stock_news_read_historyScalarFieldEnum[];
  };

  /**
   * stock_news_read_history findMany
   */
  export type stock_news_read_historyFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_read_history
     */
    select?: stock_news_read_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_read_history
     */
    omit?: stock_news_read_historyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_read_historyInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news_read_histories to fetch.
     */
    where?: stock_news_read_historyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news_read_histories to fetch.
     */
    orderBy?:
      | stock_news_read_historyOrderByWithRelationInput
      | stock_news_read_historyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing stock_news_read_histories.
     */
    cursor?: stock_news_read_historyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news_read_histories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news_read_histories.
     */
    skip?: number;
    distinct?:
      | Stock_news_read_historyScalarFieldEnum
      | Stock_news_read_historyScalarFieldEnum[];
  };

  /**
   * stock_news_read_history create
   */
  export type stock_news_read_historyCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_read_history
     */
    select?: stock_news_read_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_read_history
     */
    omit?: stock_news_read_historyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_read_historyInclude<ExtArgs> | null;
    /**
     * The data needed to create a stock_news_read_history.
     */
    data: XOR<
      stock_news_read_historyCreateInput,
      stock_news_read_historyUncheckedCreateInput
    >;
  };

  /**
   * stock_news_read_history createMany
   */
  export type stock_news_read_historyCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many stock_news_read_histories.
     */
    data:
      | stock_news_read_historyCreateManyInput
      | stock_news_read_historyCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * stock_news_read_history createManyAndReturn
   */
  export type stock_news_read_historyCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_read_history
     */
    select?: stock_news_read_historySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_read_history
     */
    omit?: stock_news_read_historyOmit<ExtArgs> | null;
    /**
     * The data used to create many stock_news_read_histories.
     */
    data:
      | stock_news_read_historyCreateManyInput
      | stock_news_read_historyCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_read_historyIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * stock_news_read_history update
   */
  export type stock_news_read_historyUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_read_history
     */
    select?: stock_news_read_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_read_history
     */
    omit?: stock_news_read_historyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_read_historyInclude<ExtArgs> | null;
    /**
     * The data needed to update a stock_news_read_history.
     */
    data: XOR<
      stock_news_read_historyUpdateInput,
      stock_news_read_historyUncheckedUpdateInput
    >;
    /**
     * Choose, which stock_news_read_history to update.
     */
    where: stock_news_read_historyWhereUniqueInput;
  };

  /**
   * stock_news_read_history updateMany
   */
  export type stock_news_read_historyUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update stock_news_read_histories.
     */
    data: XOR<
      stock_news_read_historyUpdateManyMutationInput,
      stock_news_read_historyUncheckedUpdateManyInput
    >;
    /**
     * Filter which stock_news_read_histories to update
     */
    where?: stock_news_read_historyWhereInput;
    /**
     * Limit how many stock_news_read_histories to update.
     */
    limit?: number;
  };

  /**
   * stock_news_read_history updateManyAndReturn
   */
  export type stock_news_read_historyUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_read_history
     */
    select?: stock_news_read_historySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_read_history
     */
    omit?: stock_news_read_historyOmit<ExtArgs> | null;
    /**
     * The data used to update stock_news_read_histories.
     */
    data: XOR<
      stock_news_read_historyUpdateManyMutationInput,
      stock_news_read_historyUncheckedUpdateManyInput
    >;
    /**
     * Filter which stock_news_read_histories to update
     */
    where?: stock_news_read_historyWhereInput;
    /**
     * Limit how many stock_news_read_histories to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_read_historyIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * stock_news_read_history upsert
   */
  export type stock_news_read_historyUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_read_history
     */
    select?: stock_news_read_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_read_history
     */
    omit?: stock_news_read_historyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_read_historyInclude<ExtArgs> | null;
    /**
     * The filter to search for the stock_news_read_history to update in case it exists.
     */
    where: stock_news_read_historyWhereUniqueInput;
    /**
     * In case the stock_news_read_history found by the `where` argument doesn't exist, create a new stock_news_read_history with this data.
     */
    create: XOR<
      stock_news_read_historyCreateInput,
      stock_news_read_historyUncheckedCreateInput
    >;
    /**
     * In case the stock_news_read_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      stock_news_read_historyUpdateInput,
      stock_news_read_historyUncheckedUpdateInput
    >;
  };

  /**
   * stock_news_read_history delete
   */
  export type stock_news_read_historyDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_read_history
     */
    select?: stock_news_read_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_read_history
     */
    omit?: stock_news_read_historyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_read_historyInclude<ExtArgs> | null;
    /**
     * Filter which stock_news_read_history to delete.
     */
    where: stock_news_read_historyWhereUniqueInput;
  };

  /**
   * stock_news_read_history deleteMany
   */
  export type stock_news_read_historyDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which stock_news_read_histories to delete
     */
    where?: stock_news_read_historyWhereInput;
    /**
     * Limit how many stock_news_read_histories to delete.
     */
    limit?: number;
  };

  /**
   * stock_news_read_history without action
   */
  export type stock_news_read_historyDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_read_history
     */
    select?: stock_news_read_historySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_read_history
     */
    omit?: stock_news_read_historyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_read_historyInclude<ExtArgs> | null;
  };

  /**
   * Model stock_news_related_symbols
   */

  export type AggregateStock_news_related_symbols = {
    _count: Stock_news_related_symbolsCountAggregateOutputType | null;
    _min: Stock_news_related_symbolsMinAggregateOutputType | null;
    _max: Stock_news_related_symbolsMaxAggregateOutputType | null;
  };

  export type Stock_news_related_symbolsMinAggregateOutputType = {
    id: string | null;
    news_id: string | null;
    related_symbol: string | null;
    related_exchange: string | null;
    is_primary: boolean | null;
  };

  export type Stock_news_related_symbolsMaxAggregateOutputType = {
    id: string | null;
    news_id: string | null;
    related_symbol: string | null;
    related_exchange: string | null;
    is_primary: boolean | null;
  };

  export type Stock_news_related_symbolsCountAggregateOutputType = {
    id: number;
    news_id: number;
    related_symbol: number;
    related_exchange: number;
    is_primary: number;
    _all: number;
  };

  export type Stock_news_related_symbolsMinAggregateInputType = {
    id?: true;
    news_id?: true;
    related_symbol?: true;
    related_exchange?: true;
    is_primary?: true;
  };

  export type Stock_news_related_symbolsMaxAggregateInputType = {
    id?: true;
    news_id?: true;
    related_symbol?: true;
    related_exchange?: true;
    is_primary?: true;
  };

  export type Stock_news_related_symbolsCountAggregateInputType = {
    id?: true;
    news_id?: true;
    related_symbol?: true;
    related_exchange?: true;
    is_primary?: true;
    _all?: true;
  };

  export type Stock_news_related_symbolsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which stock_news_related_symbols to aggregate.
     */
    where?: stock_news_related_symbolsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news_related_symbols to fetch.
     */
    orderBy?:
      | stock_news_related_symbolsOrderByWithRelationInput
      | stock_news_related_symbolsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: stock_news_related_symbolsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news_related_symbols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news_related_symbols.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned stock_news_related_symbols
     **/
    _count?: true | Stock_news_related_symbolsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Stock_news_related_symbolsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Stock_news_related_symbolsMaxAggregateInputType;
  };

  export type GetStock_news_related_symbolsAggregateType<
    T extends Stock_news_related_symbolsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateStock_news_related_symbols]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock_news_related_symbols[P]>
      : GetScalarType<T[P], AggregateStock_news_related_symbols[P]>;
  };

  export type stock_news_related_symbolsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: stock_news_related_symbolsWhereInput;
    orderBy?:
      | stock_news_related_symbolsOrderByWithAggregationInput
      | stock_news_related_symbolsOrderByWithAggregationInput[];
    by:
      | Stock_news_related_symbolsScalarFieldEnum[]
      | Stock_news_related_symbolsScalarFieldEnum;
    having?: stock_news_related_symbolsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Stock_news_related_symbolsCountAggregateInputType | true;
    _min?: Stock_news_related_symbolsMinAggregateInputType;
    _max?: Stock_news_related_symbolsMaxAggregateInputType;
  };

  export type Stock_news_related_symbolsGroupByOutputType = {
    id: string;
    news_id: string;
    related_symbol: string;
    related_exchange: string | null;
    is_primary: boolean | null;
    _count: Stock_news_related_symbolsCountAggregateOutputType | null;
    _min: Stock_news_related_symbolsMinAggregateOutputType | null;
    _max: Stock_news_related_symbolsMaxAggregateOutputType | null;
  };

  type GetStock_news_related_symbolsGroupByPayload<
    T extends stock_news_related_symbolsGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Stock_news_related_symbolsGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof Stock_news_related_symbolsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<
                T[P],
                Stock_news_related_symbolsGroupByOutputType[P]
              >
          : GetScalarType<T[P], Stock_news_related_symbolsGroupByOutputType[P]>;
      }
    >
  >;

  export type stock_news_related_symbolsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      news_id?: boolean;
      related_symbol?: boolean;
      related_exchange?: boolean;
      is_primary?: boolean;
      stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['stock_news_related_symbols']
  >;

  export type stock_news_related_symbolsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      news_id?: boolean;
      related_symbol?: boolean;
      related_exchange?: boolean;
      is_primary?: boolean;
      stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['stock_news_related_symbols']
  >;

  export type stock_news_related_symbolsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      news_id?: boolean;
      related_symbol?: boolean;
      related_exchange?: boolean;
      is_primary?: boolean;
      stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['stock_news_related_symbols']
  >;

  export type stock_news_related_symbolsSelectScalar = {
    id?: boolean;
    news_id?: boolean;
    related_symbol?: boolean;
    related_exchange?: boolean;
    is_primary?: boolean;
  };

  export type stock_news_related_symbolsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id' | 'news_id' | 'related_symbol' | 'related_exchange' | 'is_primary',
    ExtArgs['result']['stock_news_related_symbols']
  >;
  export type stock_news_related_symbolsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
  };
  export type stock_news_related_symbolsIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
  };
  export type stock_news_related_symbolsIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
  };

  export type $stock_news_related_symbolsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'stock_news_related_symbols';
    objects: {
      stock_news: Prisma.$stock_newsPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        news_id: string;
        related_symbol: string;
        related_exchange: string | null;
        is_primary: boolean | null;
      },
      ExtArgs['result']['stock_news_related_symbols']
    >;
    composites: {};
  };

  type stock_news_related_symbolsGetPayload<
    S extends boolean | null | undefined | stock_news_related_symbolsDefaultArgs
  > = $Result.GetResult<Prisma.$stock_news_related_symbolsPayload, S>;

  type stock_news_related_symbolsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    stock_news_related_symbolsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Stock_news_related_symbolsCountAggregateInputType | true;
  };

  export interface stock_news_related_symbolsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['stock_news_related_symbols'];
      meta: { name: 'stock_news_related_symbols' };
    };
    /**
     * Find zero or one Stock_news_related_symbols that matches the filter.
     * @param {stock_news_related_symbolsFindUniqueArgs} args - Arguments to find a Stock_news_related_symbols
     * @example
     * // Get one Stock_news_related_symbols
     * const stock_news_related_symbols = await prisma.stock_news_related_symbols.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends stock_news_related_symbolsFindUniqueArgs>(
      args: SelectSubset<T, stock_news_related_symbolsFindUniqueArgs<ExtArgs>>
    ): Prisma__stock_news_related_symbolsClient<
      $Result.GetResult<
        Prisma.$stock_news_related_symbolsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Stock_news_related_symbols that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {stock_news_related_symbolsFindUniqueOrThrowArgs} args - Arguments to find a Stock_news_related_symbols
     * @example
     * // Get one Stock_news_related_symbols
     * const stock_news_related_symbols = await prisma.stock_news_related_symbols.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<
      T extends stock_news_related_symbolsFindUniqueOrThrowArgs
    >(
      args: SelectSubset<
        T,
        stock_news_related_symbolsFindUniqueOrThrowArgs<ExtArgs>
      >
    ): Prisma__stock_news_related_symbolsClient<
      $Result.GetResult<
        Prisma.$stock_news_related_symbolsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Stock_news_related_symbols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_related_symbolsFindFirstArgs} args - Arguments to find a Stock_news_related_symbols
     * @example
     * // Get one Stock_news_related_symbols
     * const stock_news_related_symbols = await prisma.stock_news_related_symbols.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends stock_news_related_symbolsFindFirstArgs>(
      args?: SelectSubset<T, stock_news_related_symbolsFindFirstArgs<ExtArgs>>
    ): Prisma__stock_news_related_symbolsClient<
      $Result.GetResult<
        Prisma.$stock_news_related_symbolsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Stock_news_related_symbols that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_related_symbolsFindFirstOrThrowArgs} args - Arguments to find a Stock_news_related_symbols
     * @example
     * // Get one Stock_news_related_symbols
     * const stock_news_related_symbols = await prisma.stock_news_related_symbols.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends stock_news_related_symbolsFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        stock_news_related_symbolsFindFirstOrThrowArgs<ExtArgs>
      >
    ): Prisma__stock_news_related_symbolsClient<
      $Result.GetResult<
        Prisma.$stock_news_related_symbolsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Stock_news_related_symbols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_related_symbolsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stock_news_related_symbols
     * const stock_news_related_symbols = await prisma.stock_news_related_symbols.findMany()
     *
     * // Get first 10 Stock_news_related_symbols
     * const stock_news_related_symbols = await prisma.stock_news_related_symbols.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const stock_news_related_symbolsWithIdOnly = await prisma.stock_news_related_symbols.findMany({ select: { id: true } })
     *
     */
    findMany<T extends stock_news_related_symbolsFindManyArgs>(
      args?: SelectSubset<T, stock_news_related_symbolsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$stock_news_related_symbolsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Stock_news_related_symbols.
     * @param {stock_news_related_symbolsCreateArgs} args - Arguments to create a Stock_news_related_symbols.
     * @example
     * // Create one Stock_news_related_symbols
     * const Stock_news_related_symbols = await prisma.stock_news_related_symbols.create({
     *   data: {
     *     // ... data to create a Stock_news_related_symbols
     *   }
     * })
     *
     */
    create<T extends stock_news_related_symbolsCreateArgs>(
      args: SelectSubset<T, stock_news_related_symbolsCreateArgs<ExtArgs>>
    ): Prisma__stock_news_related_symbolsClient<
      $Result.GetResult<
        Prisma.$stock_news_related_symbolsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Stock_news_related_symbols.
     * @param {stock_news_related_symbolsCreateManyArgs} args - Arguments to create many Stock_news_related_symbols.
     * @example
     * // Create many Stock_news_related_symbols
     * const stock_news_related_symbols = await prisma.stock_news_related_symbols.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends stock_news_related_symbolsCreateManyArgs>(
      args?: SelectSubset<T, stock_news_related_symbolsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Stock_news_related_symbols and returns the data saved in the database.
     * @param {stock_news_related_symbolsCreateManyAndReturnArgs} args - Arguments to create many Stock_news_related_symbols.
     * @example
     * // Create many Stock_news_related_symbols
     * const stock_news_related_symbols = await prisma.stock_news_related_symbols.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Stock_news_related_symbols and only return the `id`
     * const stock_news_related_symbolsWithIdOnly = await prisma.stock_news_related_symbols.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends stock_news_related_symbolsCreateManyAndReturnArgs
    >(
      args?: SelectSubset<
        T,
        stock_news_related_symbolsCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$stock_news_related_symbolsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Stock_news_related_symbols.
     * @param {stock_news_related_symbolsDeleteArgs} args - Arguments to delete one Stock_news_related_symbols.
     * @example
     * // Delete one Stock_news_related_symbols
     * const Stock_news_related_symbols = await prisma.stock_news_related_symbols.delete({
     *   where: {
     *     // ... filter to delete one Stock_news_related_symbols
     *   }
     * })
     *
     */
    delete<T extends stock_news_related_symbolsDeleteArgs>(
      args: SelectSubset<T, stock_news_related_symbolsDeleteArgs<ExtArgs>>
    ): Prisma__stock_news_related_symbolsClient<
      $Result.GetResult<
        Prisma.$stock_news_related_symbolsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Stock_news_related_symbols.
     * @param {stock_news_related_symbolsUpdateArgs} args - Arguments to update one Stock_news_related_symbols.
     * @example
     * // Update one Stock_news_related_symbols
     * const stock_news_related_symbols = await prisma.stock_news_related_symbols.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends stock_news_related_symbolsUpdateArgs>(
      args: SelectSubset<T, stock_news_related_symbolsUpdateArgs<ExtArgs>>
    ): Prisma__stock_news_related_symbolsClient<
      $Result.GetResult<
        Prisma.$stock_news_related_symbolsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Stock_news_related_symbols.
     * @param {stock_news_related_symbolsDeleteManyArgs} args - Arguments to filter Stock_news_related_symbols to delete.
     * @example
     * // Delete a few Stock_news_related_symbols
     * const { count } = await prisma.stock_news_related_symbols.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends stock_news_related_symbolsDeleteManyArgs>(
      args?: SelectSubset<T, stock_news_related_symbolsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Stock_news_related_symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_related_symbolsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stock_news_related_symbols
     * const stock_news_related_symbols = await prisma.stock_news_related_symbols.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends stock_news_related_symbolsUpdateManyArgs>(
      args: SelectSubset<T, stock_news_related_symbolsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Stock_news_related_symbols and returns the data updated in the database.
     * @param {stock_news_related_symbolsUpdateManyAndReturnArgs} args - Arguments to update many Stock_news_related_symbols.
     * @example
     * // Update many Stock_news_related_symbols
     * const stock_news_related_symbols = await prisma.stock_news_related_symbols.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Stock_news_related_symbols and only return the `id`
     * const stock_news_related_symbolsWithIdOnly = await prisma.stock_news_related_symbols.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends stock_news_related_symbolsUpdateManyAndReturnArgs
    >(
      args: SelectSubset<
        T,
        stock_news_related_symbolsUpdateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$stock_news_related_symbolsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Stock_news_related_symbols.
     * @param {stock_news_related_symbolsUpsertArgs} args - Arguments to update or create a Stock_news_related_symbols.
     * @example
     * // Update or create a Stock_news_related_symbols
     * const stock_news_related_symbols = await prisma.stock_news_related_symbols.upsert({
     *   create: {
     *     // ... data to create a Stock_news_related_symbols
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock_news_related_symbols we want to update
     *   }
     * })
     */
    upsert<T extends stock_news_related_symbolsUpsertArgs>(
      args: SelectSubset<T, stock_news_related_symbolsUpsertArgs<ExtArgs>>
    ): Prisma__stock_news_related_symbolsClient<
      $Result.GetResult<
        Prisma.$stock_news_related_symbolsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Stock_news_related_symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_related_symbolsCountArgs} args - Arguments to filter Stock_news_related_symbols to count.
     * @example
     * // Count the number of Stock_news_related_symbols
     * const count = await prisma.stock_news_related_symbols.count({
     *   where: {
     *     // ... the filter for the Stock_news_related_symbols we want to count
     *   }
     * })
     **/
    count<T extends stock_news_related_symbolsCountArgs>(
      args?: Subset<T, stock_news_related_symbolsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              Stock_news_related_symbolsCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Stock_news_related_symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stock_news_related_symbolsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Stock_news_related_symbolsAggregateArgs>(
      args: Subset<T, Stock_news_related_symbolsAggregateArgs>
    ): Prisma.PrismaPromise<GetStock_news_related_symbolsAggregateType<T>>;

    /**
     * Group by Stock_news_related_symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_related_symbolsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends stock_news_related_symbolsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stock_news_related_symbolsGroupByArgs['orderBy'] }
        : { orderBy?: stock_news_related_symbolsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<
        T,
        stock_news_related_symbolsGroupByArgs,
        OrderByArg
      > &
        InputErrors
    ): {} extends InputErrors
      ? GetStock_news_related_symbolsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the stock_news_related_symbols model
     */
    readonly fields: stock_news_related_symbolsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stock_news_related_symbols.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stock_news_related_symbolsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    stock_news<T extends stock_newsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, stock_newsDefaultArgs<ExtArgs>>
    ): Prisma__stock_newsClient<
      | $Result.GetResult<
          Prisma.$stock_newsPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the stock_news_related_symbols model
   */
  interface stock_news_related_symbolsFieldRefs {
    readonly id: FieldRef<'stock_news_related_symbols', 'String'>;
    readonly news_id: FieldRef<'stock_news_related_symbols', 'String'>;
    readonly related_symbol: FieldRef<'stock_news_related_symbols', 'String'>;
    readonly related_exchange: FieldRef<'stock_news_related_symbols', 'String'>;
    readonly is_primary: FieldRef<'stock_news_related_symbols', 'Boolean'>;
  }

  // Custom InputTypes
  /**
   * stock_news_related_symbols findUnique
   */
  export type stock_news_related_symbolsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_related_symbols
     */
    select?: stock_news_related_symbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_related_symbols
     */
    omit?: stock_news_related_symbolsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_related_symbolsInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news_related_symbols to fetch.
     */
    where: stock_news_related_symbolsWhereUniqueInput;
  };

  /**
   * stock_news_related_symbols findUniqueOrThrow
   */
  export type stock_news_related_symbolsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_related_symbols
     */
    select?: stock_news_related_symbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_related_symbols
     */
    omit?: stock_news_related_symbolsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_related_symbolsInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news_related_symbols to fetch.
     */
    where: stock_news_related_symbolsWhereUniqueInput;
  };

  /**
   * stock_news_related_symbols findFirst
   */
  export type stock_news_related_symbolsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_related_symbols
     */
    select?: stock_news_related_symbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_related_symbols
     */
    omit?: stock_news_related_symbolsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_related_symbolsInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news_related_symbols to fetch.
     */
    where?: stock_news_related_symbolsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news_related_symbols to fetch.
     */
    orderBy?:
      | stock_news_related_symbolsOrderByWithRelationInput
      | stock_news_related_symbolsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for stock_news_related_symbols.
     */
    cursor?: stock_news_related_symbolsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news_related_symbols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news_related_symbols.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of stock_news_related_symbols.
     */
    distinct?:
      | Stock_news_related_symbolsScalarFieldEnum
      | Stock_news_related_symbolsScalarFieldEnum[];
  };

  /**
   * stock_news_related_symbols findFirstOrThrow
   */
  export type stock_news_related_symbolsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_related_symbols
     */
    select?: stock_news_related_symbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_related_symbols
     */
    omit?: stock_news_related_symbolsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_related_symbolsInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news_related_symbols to fetch.
     */
    where?: stock_news_related_symbolsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news_related_symbols to fetch.
     */
    orderBy?:
      | stock_news_related_symbolsOrderByWithRelationInput
      | stock_news_related_symbolsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for stock_news_related_symbols.
     */
    cursor?: stock_news_related_symbolsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news_related_symbols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news_related_symbols.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of stock_news_related_symbols.
     */
    distinct?:
      | Stock_news_related_symbolsScalarFieldEnum
      | Stock_news_related_symbolsScalarFieldEnum[];
  };

  /**
   * stock_news_related_symbols findMany
   */
  export type stock_news_related_symbolsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_related_symbols
     */
    select?: stock_news_related_symbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_related_symbols
     */
    omit?: stock_news_related_symbolsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_related_symbolsInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news_related_symbols to fetch.
     */
    where?: stock_news_related_symbolsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news_related_symbols to fetch.
     */
    orderBy?:
      | stock_news_related_symbolsOrderByWithRelationInput
      | stock_news_related_symbolsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing stock_news_related_symbols.
     */
    cursor?: stock_news_related_symbolsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news_related_symbols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news_related_symbols.
     */
    skip?: number;
    distinct?:
      | Stock_news_related_symbolsScalarFieldEnum
      | Stock_news_related_symbolsScalarFieldEnum[];
  };

  /**
   * stock_news_related_symbols create
   */
  export type stock_news_related_symbolsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_related_symbols
     */
    select?: stock_news_related_symbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_related_symbols
     */
    omit?: stock_news_related_symbolsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_related_symbolsInclude<ExtArgs> | null;
    /**
     * The data needed to create a stock_news_related_symbols.
     */
    data: XOR<
      stock_news_related_symbolsCreateInput,
      stock_news_related_symbolsUncheckedCreateInput
    >;
  };

  /**
   * stock_news_related_symbols createMany
   */
  export type stock_news_related_symbolsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many stock_news_related_symbols.
     */
    data:
      | stock_news_related_symbolsCreateManyInput
      | stock_news_related_symbolsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * stock_news_related_symbols createManyAndReturn
   */
  export type stock_news_related_symbolsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_related_symbols
     */
    select?: stock_news_related_symbolsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_related_symbols
     */
    omit?: stock_news_related_symbolsOmit<ExtArgs> | null;
    /**
     * The data used to create many stock_news_related_symbols.
     */
    data:
      | stock_news_related_symbolsCreateManyInput
      | stock_news_related_symbolsCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_related_symbolsIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * stock_news_related_symbols update
   */
  export type stock_news_related_symbolsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_related_symbols
     */
    select?: stock_news_related_symbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_related_symbols
     */
    omit?: stock_news_related_symbolsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_related_symbolsInclude<ExtArgs> | null;
    /**
     * The data needed to update a stock_news_related_symbols.
     */
    data: XOR<
      stock_news_related_symbolsUpdateInput,
      stock_news_related_symbolsUncheckedUpdateInput
    >;
    /**
     * Choose, which stock_news_related_symbols to update.
     */
    where: stock_news_related_symbolsWhereUniqueInput;
  };

  /**
   * stock_news_related_symbols updateMany
   */
  export type stock_news_related_symbolsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update stock_news_related_symbols.
     */
    data: XOR<
      stock_news_related_symbolsUpdateManyMutationInput,
      stock_news_related_symbolsUncheckedUpdateManyInput
    >;
    /**
     * Filter which stock_news_related_symbols to update
     */
    where?: stock_news_related_symbolsWhereInput;
    /**
     * Limit how many stock_news_related_symbols to update.
     */
    limit?: number;
  };

  /**
   * stock_news_related_symbols updateManyAndReturn
   */
  export type stock_news_related_symbolsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_related_symbols
     */
    select?: stock_news_related_symbolsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_related_symbols
     */
    omit?: stock_news_related_symbolsOmit<ExtArgs> | null;
    /**
     * The data used to update stock_news_related_symbols.
     */
    data: XOR<
      stock_news_related_symbolsUpdateManyMutationInput,
      stock_news_related_symbolsUncheckedUpdateManyInput
    >;
    /**
     * Filter which stock_news_related_symbols to update
     */
    where?: stock_news_related_symbolsWhereInput;
    /**
     * Limit how many stock_news_related_symbols to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_related_symbolsIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * stock_news_related_symbols upsert
   */
  export type stock_news_related_symbolsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_related_symbols
     */
    select?: stock_news_related_symbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_related_symbols
     */
    omit?: stock_news_related_symbolsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_related_symbolsInclude<ExtArgs> | null;
    /**
     * The filter to search for the stock_news_related_symbols to update in case it exists.
     */
    where: stock_news_related_symbolsWhereUniqueInput;
    /**
     * In case the stock_news_related_symbols found by the `where` argument doesn't exist, create a new stock_news_related_symbols with this data.
     */
    create: XOR<
      stock_news_related_symbolsCreateInput,
      stock_news_related_symbolsUncheckedCreateInput
    >;
    /**
     * In case the stock_news_related_symbols was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      stock_news_related_symbolsUpdateInput,
      stock_news_related_symbolsUncheckedUpdateInput
    >;
  };

  /**
   * stock_news_related_symbols delete
   */
  export type stock_news_related_symbolsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_related_symbols
     */
    select?: stock_news_related_symbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_related_symbols
     */
    omit?: stock_news_related_symbolsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_related_symbolsInclude<ExtArgs> | null;
    /**
     * Filter which stock_news_related_symbols to delete.
     */
    where: stock_news_related_symbolsWhereUniqueInput;
  };

  /**
   * stock_news_related_symbols deleteMany
   */
  export type stock_news_related_symbolsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which stock_news_related_symbols to delete
     */
    where?: stock_news_related_symbolsWhereInput;
    /**
     * Limit how many stock_news_related_symbols to delete.
     */
    limit?: number;
  };

  /**
   * stock_news_related_symbols without action
   */
  export type stock_news_related_symbolsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_related_symbols
     */
    select?: stock_news_related_symbolsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_related_symbols
     */
    omit?: stock_news_related_symbolsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_related_symbolsInclude<ExtArgs> | null;
  };

  /**
   * Model stock_news_translation
   */

  export type AggregateStock_news_translation = {
    _count: Stock_news_translationCountAggregateOutputType | null;
    _min: Stock_news_translationMinAggregateOutputType | null;
    _max: Stock_news_translationMaxAggregateOutputType | null;
  };

  export type Stock_news_translationMinAggregateOutputType = {
    id: string | null;
    news_id: string | null;
    language: string | null;
    title: string | null;
    content: string | null;
    summary: string | null;
    created_at: Date | null;
    updated_at: Date | null;
  };

  export type Stock_news_translationMaxAggregateOutputType = {
    id: string | null;
    news_id: string | null;
    language: string | null;
    title: string | null;
    content: string | null;
    summary: string | null;
    created_at: Date | null;
    updated_at: Date | null;
  };

  export type Stock_news_translationCountAggregateOutputType = {
    id: number;
    news_id: number;
    language: number;
    title: number;
    content: number;
    summary: number;
    created_at: number;
    updated_at: number;
    _all: number;
  };

  export type Stock_news_translationMinAggregateInputType = {
    id?: true;
    news_id?: true;
    language?: true;
    title?: true;
    content?: true;
    summary?: true;
    created_at?: true;
    updated_at?: true;
  };

  export type Stock_news_translationMaxAggregateInputType = {
    id?: true;
    news_id?: true;
    language?: true;
    title?: true;
    content?: true;
    summary?: true;
    created_at?: true;
    updated_at?: true;
  };

  export type Stock_news_translationCountAggregateInputType = {
    id?: true;
    news_id?: true;
    language?: true;
    title?: true;
    content?: true;
    summary?: true;
    created_at?: true;
    updated_at?: true;
    _all?: true;
  };

  export type Stock_news_translationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which stock_news_translation to aggregate.
     */
    where?: stock_news_translationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news_translations to fetch.
     */
    orderBy?:
      | stock_news_translationOrderByWithRelationInput
      | stock_news_translationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: stock_news_translationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news_translations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news_translations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned stock_news_translations
     **/
    _count?: true | Stock_news_translationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Stock_news_translationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Stock_news_translationMaxAggregateInputType;
  };

  export type GetStock_news_translationAggregateType<
    T extends Stock_news_translationAggregateArgs
  > = {
    [P in keyof T & keyof AggregateStock_news_translation]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock_news_translation[P]>
      : GetScalarType<T[P], AggregateStock_news_translation[P]>;
  };

  export type stock_news_translationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: stock_news_translationWhereInput;
    orderBy?:
      | stock_news_translationOrderByWithAggregationInput
      | stock_news_translationOrderByWithAggregationInput[];
    by:
      | Stock_news_translationScalarFieldEnum[]
      | Stock_news_translationScalarFieldEnum;
    having?: stock_news_translationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Stock_news_translationCountAggregateInputType | true;
    _min?: Stock_news_translationMinAggregateInputType;
    _max?: Stock_news_translationMaxAggregateInputType;
  };

  export type Stock_news_translationGroupByOutputType = {
    id: string;
    news_id: string;
    language: string;
    title: string;
    content: string | null;
    summary: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    _count: Stock_news_translationCountAggregateOutputType | null;
    _min: Stock_news_translationMinAggregateOutputType | null;
    _max: Stock_news_translationMaxAggregateOutputType | null;
  };

  type GetStock_news_translationGroupByPayload<
    T extends stock_news_translationGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Stock_news_translationGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof Stock_news_translationGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], Stock_news_translationGroupByOutputType[P]>
          : GetScalarType<T[P], Stock_news_translationGroupByOutputType[P]>;
      }
    >
  >;

  export type stock_news_translationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      news_id?: boolean;
      language?: boolean;
      title?: boolean;
      content?: boolean;
      summary?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['stock_news_translation']
  >;

  export type stock_news_translationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      news_id?: boolean;
      language?: boolean;
      title?: boolean;
      content?: boolean;
      summary?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['stock_news_translation']
  >;

  export type stock_news_translationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      news_id?: boolean;
      language?: boolean;
      title?: boolean;
      content?: boolean;
      summary?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['stock_news_translation']
  >;

  export type stock_news_translationSelectScalar = {
    id?: boolean;
    news_id?: boolean;
    language?: boolean;
    title?: boolean;
    content?: boolean;
    summary?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
  };

  export type stock_news_translationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'news_id'
    | 'language'
    | 'title'
    | 'content'
    | 'summary'
    | 'created_at'
    | 'updated_at',
    ExtArgs['result']['stock_news_translation']
  >;
  export type stock_news_translationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
  };
  export type stock_news_translationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
  };
  export type stock_news_translationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    stock_news?: boolean | stock_newsDefaultArgs<ExtArgs>;
  };

  export type $stock_news_translationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'stock_news_translation';
    objects: {
      stock_news: Prisma.$stock_newsPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        news_id: string;
        language: string;
        title: string;
        content: string | null;
        summary: string | null;
        created_at: Date | null;
        updated_at: Date | null;
      },
      ExtArgs['result']['stock_news_translation']
    >;
    composites: {};
  };

  type stock_news_translationGetPayload<
    S extends boolean | null | undefined | stock_news_translationDefaultArgs
  > = $Result.GetResult<Prisma.$stock_news_translationPayload, S>;

  type stock_news_translationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    stock_news_translationFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Stock_news_translationCountAggregateInputType | true;
  };

  export interface stock_news_translationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['stock_news_translation'];
      meta: { name: 'stock_news_translation' };
    };
    /**
     * Find zero or one Stock_news_translation that matches the filter.
     * @param {stock_news_translationFindUniqueArgs} args - Arguments to find a Stock_news_translation
     * @example
     * // Get one Stock_news_translation
     * const stock_news_translation = await prisma.stock_news_translation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends stock_news_translationFindUniqueArgs>(
      args: SelectSubset<T, stock_news_translationFindUniqueArgs<ExtArgs>>
    ): Prisma__stock_news_translationClient<
      $Result.GetResult<
        Prisma.$stock_news_translationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Stock_news_translation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {stock_news_translationFindUniqueOrThrowArgs} args - Arguments to find a Stock_news_translation
     * @example
     * // Get one Stock_news_translation
     * const stock_news_translation = await prisma.stock_news_translation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends stock_news_translationFindUniqueOrThrowArgs>(
      args: SelectSubset<
        T,
        stock_news_translationFindUniqueOrThrowArgs<ExtArgs>
      >
    ): Prisma__stock_news_translationClient<
      $Result.GetResult<
        Prisma.$stock_news_translationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Stock_news_translation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_translationFindFirstArgs} args - Arguments to find a Stock_news_translation
     * @example
     * // Get one Stock_news_translation
     * const stock_news_translation = await prisma.stock_news_translation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends stock_news_translationFindFirstArgs>(
      args?: SelectSubset<T, stock_news_translationFindFirstArgs<ExtArgs>>
    ): Prisma__stock_news_translationClient<
      $Result.GetResult<
        Prisma.$stock_news_translationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Stock_news_translation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_translationFindFirstOrThrowArgs} args - Arguments to find a Stock_news_translation
     * @example
     * // Get one Stock_news_translation
     * const stock_news_translation = await prisma.stock_news_translation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends stock_news_translationFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        stock_news_translationFindFirstOrThrowArgs<ExtArgs>
      >
    ): Prisma__stock_news_translationClient<
      $Result.GetResult<
        Prisma.$stock_news_translationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Stock_news_translations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_translationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stock_news_translations
     * const stock_news_translations = await prisma.stock_news_translation.findMany()
     *
     * // Get first 10 Stock_news_translations
     * const stock_news_translations = await prisma.stock_news_translation.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const stock_news_translationWithIdOnly = await prisma.stock_news_translation.findMany({ select: { id: true } })
     *
     */
    findMany<T extends stock_news_translationFindManyArgs>(
      args?: SelectSubset<T, stock_news_translationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$stock_news_translationPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Stock_news_translation.
     * @param {stock_news_translationCreateArgs} args - Arguments to create a Stock_news_translation.
     * @example
     * // Create one Stock_news_translation
     * const Stock_news_translation = await prisma.stock_news_translation.create({
     *   data: {
     *     // ... data to create a Stock_news_translation
     *   }
     * })
     *
     */
    create<T extends stock_news_translationCreateArgs>(
      args: SelectSubset<T, stock_news_translationCreateArgs<ExtArgs>>
    ): Prisma__stock_news_translationClient<
      $Result.GetResult<
        Prisma.$stock_news_translationPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Stock_news_translations.
     * @param {stock_news_translationCreateManyArgs} args - Arguments to create many Stock_news_translations.
     * @example
     * // Create many Stock_news_translations
     * const stock_news_translation = await prisma.stock_news_translation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends stock_news_translationCreateManyArgs>(
      args?: SelectSubset<T, stock_news_translationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Stock_news_translations and returns the data saved in the database.
     * @param {stock_news_translationCreateManyAndReturnArgs} args - Arguments to create many Stock_news_translations.
     * @example
     * // Create many Stock_news_translations
     * const stock_news_translation = await prisma.stock_news_translation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Stock_news_translations and only return the `id`
     * const stock_news_translationWithIdOnly = await prisma.stock_news_translation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends stock_news_translationCreateManyAndReturnArgs
    >(
      args?: SelectSubset<
        T,
        stock_news_translationCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$stock_news_translationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Stock_news_translation.
     * @param {stock_news_translationDeleteArgs} args - Arguments to delete one Stock_news_translation.
     * @example
     * // Delete one Stock_news_translation
     * const Stock_news_translation = await prisma.stock_news_translation.delete({
     *   where: {
     *     // ... filter to delete one Stock_news_translation
     *   }
     * })
     *
     */
    delete<T extends stock_news_translationDeleteArgs>(
      args: SelectSubset<T, stock_news_translationDeleteArgs<ExtArgs>>
    ): Prisma__stock_news_translationClient<
      $Result.GetResult<
        Prisma.$stock_news_translationPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Stock_news_translation.
     * @param {stock_news_translationUpdateArgs} args - Arguments to update one Stock_news_translation.
     * @example
     * // Update one Stock_news_translation
     * const stock_news_translation = await prisma.stock_news_translation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends stock_news_translationUpdateArgs>(
      args: SelectSubset<T, stock_news_translationUpdateArgs<ExtArgs>>
    ): Prisma__stock_news_translationClient<
      $Result.GetResult<
        Prisma.$stock_news_translationPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Stock_news_translations.
     * @param {stock_news_translationDeleteManyArgs} args - Arguments to filter Stock_news_translations to delete.
     * @example
     * // Delete a few Stock_news_translations
     * const { count } = await prisma.stock_news_translation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends stock_news_translationDeleteManyArgs>(
      args?: SelectSubset<T, stock_news_translationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Stock_news_translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_translationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stock_news_translations
     * const stock_news_translation = await prisma.stock_news_translation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends stock_news_translationUpdateManyArgs>(
      args: SelectSubset<T, stock_news_translationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Stock_news_translations and returns the data updated in the database.
     * @param {stock_news_translationUpdateManyAndReturnArgs} args - Arguments to update many Stock_news_translations.
     * @example
     * // Update many Stock_news_translations
     * const stock_news_translation = await prisma.stock_news_translation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Stock_news_translations and only return the `id`
     * const stock_news_translationWithIdOnly = await prisma.stock_news_translation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends stock_news_translationUpdateManyAndReturnArgs
    >(
      args: SelectSubset<
        T,
        stock_news_translationUpdateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$stock_news_translationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Stock_news_translation.
     * @param {stock_news_translationUpsertArgs} args - Arguments to update or create a Stock_news_translation.
     * @example
     * // Update or create a Stock_news_translation
     * const stock_news_translation = await prisma.stock_news_translation.upsert({
     *   create: {
     *     // ... data to create a Stock_news_translation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock_news_translation we want to update
     *   }
     * })
     */
    upsert<T extends stock_news_translationUpsertArgs>(
      args: SelectSubset<T, stock_news_translationUpsertArgs<ExtArgs>>
    ): Prisma__stock_news_translationClient<
      $Result.GetResult<
        Prisma.$stock_news_translationPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Stock_news_translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_translationCountArgs} args - Arguments to filter Stock_news_translations to count.
     * @example
     * // Count the number of Stock_news_translations
     * const count = await prisma.stock_news_translation.count({
     *   where: {
     *     // ... the filter for the Stock_news_translations we want to count
     *   }
     * })
     **/
    count<T extends stock_news_translationCountArgs>(
      args?: Subset<T, stock_news_translationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              Stock_news_translationCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Stock_news_translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stock_news_translationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Stock_news_translationAggregateArgs>(
      args: Subset<T, Stock_news_translationAggregateArgs>
    ): Prisma.PrismaPromise<GetStock_news_translationAggregateType<T>>;

    /**
     * Group by Stock_news_translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_news_translationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends stock_news_translationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stock_news_translationGroupByArgs['orderBy'] }
        : { orderBy?: stock_news_translationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<
        T,
        stock_news_translationGroupByArgs,
        OrderByArg
      > &
        InputErrors
    ): {} extends InputErrors
      ? GetStock_news_translationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the stock_news_translation model
     */
    readonly fields: stock_news_translationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stock_news_translation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stock_news_translationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    stock_news<T extends stock_newsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, stock_newsDefaultArgs<ExtArgs>>
    ): Prisma__stock_newsClient<
      | $Result.GetResult<
          Prisma.$stock_newsPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the stock_news_translation model
   */
  interface stock_news_translationFieldRefs {
    readonly id: FieldRef<'stock_news_translation', 'String'>;
    readonly news_id: FieldRef<'stock_news_translation', 'String'>;
    readonly language: FieldRef<'stock_news_translation', 'String'>;
    readonly title: FieldRef<'stock_news_translation', 'String'>;
    readonly content: FieldRef<'stock_news_translation', 'String'>;
    readonly summary: FieldRef<'stock_news_translation', 'String'>;
    readonly created_at: FieldRef<'stock_news_translation', 'DateTime'>;
    readonly updated_at: FieldRef<'stock_news_translation', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * stock_news_translation findUnique
   */
  export type stock_news_translationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_translation
     */
    select?: stock_news_translationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_translation
     */
    omit?: stock_news_translationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_translationInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news_translation to fetch.
     */
    where: stock_news_translationWhereUniqueInput;
  };

  /**
   * stock_news_translation findUniqueOrThrow
   */
  export type stock_news_translationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_translation
     */
    select?: stock_news_translationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_translation
     */
    omit?: stock_news_translationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_translationInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news_translation to fetch.
     */
    where: stock_news_translationWhereUniqueInput;
  };

  /**
   * stock_news_translation findFirst
   */
  export type stock_news_translationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_translation
     */
    select?: stock_news_translationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_translation
     */
    omit?: stock_news_translationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_translationInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news_translation to fetch.
     */
    where?: stock_news_translationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news_translations to fetch.
     */
    orderBy?:
      | stock_news_translationOrderByWithRelationInput
      | stock_news_translationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for stock_news_translations.
     */
    cursor?: stock_news_translationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news_translations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news_translations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of stock_news_translations.
     */
    distinct?:
      | Stock_news_translationScalarFieldEnum
      | Stock_news_translationScalarFieldEnum[];
  };

  /**
   * stock_news_translation findFirstOrThrow
   */
  export type stock_news_translationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_translation
     */
    select?: stock_news_translationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_translation
     */
    omit?: stock_news_translationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_translationInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news_translation to fetch.
     */
    where?: stock_news_translationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news_translations to fetch.
     */
    orderBy?:
      | stock_news_translationOrderByWithRelationInput
      | stock_news_translationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for stock_news_translations.
     */
    cursor?: stock_news_translationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news_translations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news_translations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of stock_news_translations.
     */
    distinct?:
      | Stock_news_translationScalarFieldEnum
      | Stock_news_translationScalarFieldEnum[];
  };

  /**
   * stock_news_translation findMany
   */
  export type stock_news_translationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_translation
     */
    select?: stock_news_translationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_translation
     */
    omit?: stock_news_translationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_translationInclude<ExtArgs> | null;
    /**
     * Filter, which stock_news_translations to fetch.
     */
    where?: stock_news_translationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of stock_news_translations to fetch.
     */
    orderBy?:
      | stock_news_translationOrderByWithRelationInput
      | stock_news_translationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing stock_news_translations.
     */
    cursor?: stock_news_translationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` stock_news_translations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` stock_news_translations.
     */
    skip?: number;
    distinct?:
      | Stock_news_translationScalarFieldEnum
      | Stock_news_translationScalarFieldEnum[];
  };

  /**
   * stock_news_translation create
   */
  export type stock_news_translationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_translation
     */
    select?: stock_news_translationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_translation
     */
    omit?: stock_news_translationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_translationInclude<ExtArgs> | null;
    /**
     * The data needed to create a stock_news_translation.
     */
    data: XOR<
      stock_news_translationCreateInput,
      stock_news_translationUncheckedCreateInput
    >;
  };

  /**
   * stock_news_translation createMany
   */
  export type stock_news_translationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many stock_news_translations.
     */
    data:
      | stock_news_translationCreateManyInput
      | stock_news_translationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * stock_news_translation createManyAndReturn
   */
  export type stock_news_translationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_translation
     */
    select?: stock_news_translationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_translation
     */
    omit?: stock_news_translationOmit<ExtArgs> | null;
    /**
     * The data used to create many stock_news_translations.
     */
    data:
      | stock_news_translationCreateManyInput
      | stock_news_translationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_translationIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * stock_news_translation update
   */
  export type stock_news_translationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_translation
     */
    select?: stock_news_translationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_translation
     */
    omit?: stock_news_translationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_translationInclude<ExtArgs> | null;
    /**
     * The data needed to update a stock_news_translation.
     */
    data: XOR<
      stock_news_translationUpdateInput,
      stock_news_translationUncheckedUpdateInput
    >;
    /**
     * Choose, which stock_news_translation to update.
     */
    where: stock_news_translationWhereUniqueInput;
  };

  /**
   * stock_news_translation updateMany
   */
  export type stock_news_translationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update stock_news_translations.
     */
    data: XOR<
      stock_news_translationUpdateManyMutationInput,
      stock_news_translationUncheckedUpdateManyInput
    >;
    /**
     * Filter which stock_news_translations to update
     */
    where?: stock_news_translationWhereInput;
    /**
     * Limit how many stock_news_translations to update.
     */
    limit?: number;
  };

  /**
   * stock_news_translation updateManyAndReturn
   */
  export type stock_news_translationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_translation
     */
    select?: stock_news_translationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_translation
     */
    omit?: stock_news_translationOmit<ExtArgs> | null;
    /**
     * The data used to update stock_news_translations.
     */
    data: XOR<
      stock_news_translationUpdateManyMutationInput,
      stock_news_translationUncheckedUpdateManyInput
    >;
    /**
     * Filter which stock_news_translations to update
     */
    where?: stock_news_translationWhereInput;
    /**
     * Limit how many stock_news_translations to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_translationIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * stock_news_translation upsert
   */
  export type stock_news_translationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_translation
     */
    select?: stock_news_translationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_translation
     */
    omit?: stock_news_translationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_translationInclude<ExtArgs> | null;
    /**
     * The filter to search for the stock_news_translation to update in case it exists.
     */
    where: stock_news_translationWhereUniqueInput;
    /**
     * In case the stock_news_translation found by the `where` argument doesn't exist, create a new stock_news_translation with this data.
     */
    create: XOR<
      stock_news_translationCreateInput,
      stock_news_translationUncheckedCreateInput
    >;
    /**
     * In case the stock_news_translation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      stock_news_translationUpdateInput,
      stock_news_translationUncheckedUpdateInput
    >;
  };

  /**
   * stock_news_translation delete
   */
  export type stock_news_translationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_translation
     */
    select?: stock_news_translationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_translation
     */
    omit?: stock_news_translationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_translationInclude<ExtArgs> | null;
    /**
     * Filter which stock_news_translation to delete.
     */
    where: stock_news_translationWhereUniqueInput;
  };

  /**
   * stock_news_translation deleteMany
   */
  export type stock_news_translationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which stock_news_translations to delete
     */
    where?: stock_news_translationWhereInput;
    /**
     * Limit how many stock_news_translations to delete.
     */
    limit?: number;
  };

  /**
   * stock_news_translation without action
   */
  export type stock_news_translationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the stock_news_translation
     */
    select?: stock_news_translationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the stock_news_translation
     */
    omit?: stock_news_translationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stock_news_translationInclude<ExtArgs> | null;
  };

  /**
   * Model subscriptions
   */

  export type AggregateSubscriptions = {
    _count: SubscriptionsCountAggregateOutputType | null;
    _avg: SubscriptionsAvgAggregateOutputType | null;
    _sum: SubscriptionsSumAggregateOutputType | null;
    _min: SubscriptionsMinAggregateOutputType | null;
    _max: SubscriptionsMaxAggregateOutputType | null;
  };

  export type SubscriptionsAvgAggregateOutputType = {
    subscription_id: number | null;
    price: Decimal | null;
    trial_days: number | null;
  };

  export type SubscriptionsSumAggregateOutputType = {
    subscription_id: number | null;
    price: Decimal | null;
    trial_days: number | null;
  };

  export type SubscriptionsMinAggregateOutputType = {
    subscription_id: number | null;
    name: string | null;
    price: Decimal | null;
    created_at: Date | null;
    updated_at: Date | null;
    stripe_price_id: string | null;
    price_amount: string | null;
    currency: string | null;
    billing_interval: string | null;
    is_active: boolean | null;
    trial_days: number | null;
  };

  export type SubscriptionsMaxAggregateOutputType = {
    subscription_id: number | null;
    name: string | null;
    price: Decimal | null;
    created_at: Date | null;
    updated_at: Date | null;
    stripe_price_id: string | null;
    price_amount: string | null;
    currency: string | null;
    billing_interval: string | null;
    is_active: boolean | null;
    trial_days: number | null;
  };

  export type SubscriptionsCountAggregateOutputType = {
    subscription_id: number;
    name: number;
    price: number;
    features: number;
    created_at: number;
    updated_at: number;
    stripe_price_id: number;
    price_amount: number;
    currency: number;
    billing_interval: number;
    is_active: number;
    trial_days: number;
    _all: number;
  };

  export type SubscriptionsAvgAggregateInputType = {
    subscription_id?: true;
    price?: true;
    trial_days?: true;
  };

  export type SubscriptionsSumAggregateInputType = {
    subscription_id?: true;
    price?: true;
    trial_days?: true;
  };

  export type SubscriptionsMinAggregateInputType = {
    subscription_id?: true;
    name?: true;
    price?: true;
    created_at?: true;
    updated_at?: true;
    stripe_price_id?: true;
    price_amount?: true;
    currency?: true;
    billing_interval?: true;
    is_active?: true;
    trial_days?: true;
  };

  export type SubscriptionsMaxAggregateInputType = {
    subscription_id?: true;
    name?: true;
    price?: true;
    created_at?: true;
    updated_at?: true;
    stripe_price_id?: true;
    price_amount?: true;
    currency?: true;
    billing_interval?: true;
    is_active?: true;
    trial_days?: true;
  };

  export type SubscriptionsCountAggregateInputType = {
    subscription_id?: true;
    name?: true;
    price?: true;
    features?: true;
    created_at?: true;
    updated_at?: true;
    stripe_price_id?: true;
    price_amount?: true;
    currency?: true;
    billing_interval?: true;
    is_active?: true;
    trial_days?: true;
    _all?: true;
  };

  export type SubscriptionsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which subscriptions to aggregate.
     */
    where?: subscriptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of subscriptions to fetch.
     */
    orderBy?:
      | subscriptionsOrderByWithRelationInput
      | subscriptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: subscriptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` subscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned subscriptions
     **/
    _count?: true | SubscriptionsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: SubscriptionsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: SubscriptionsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SubscriptionsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SubscriptionsMaxAggregateInputType;
  };

  export type GetSubscriptionsAggregateType<
    T extends SubscriptionsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateSubscriptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptions[P]>
      : GetScalarType<T[P], AggregateSubscriptions[P]>;
  };

  export type subscriptionsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: subscriptionsWhereInput;
    orderBy?:
      | subscriptionsOrderByWithAggregationInput
      | subscriptionsOrderByWithAggregationInput[];
    by: SubscriptionsScalarFieldEnum[] | SubscriptionsScalarFieldEnum;
    having?: subscriptionsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SubscriptionsCountAggregateInputType | true;
    _avg?: SubscriptionsAvgAggregateInputType;
    _sum?: SubscriptionsSumAggregateInputType;
    _min?: SubscriptionsMinAggregateInputType;
    _max?: SubscriptionsMaxAggregateInputType;
  };

  export type SubscriptionsGroupByOutputType = {
    subscription_id: number;
    name: string | null;
    price: Decimal | null;
    features: JsonValue | null;
    created_at: Date | null;
    updated_at: Date | null;
    stripe_price_id: string | null;
    price_amount: string | null;
    currency: string | null;
    billing_interval: string | null;
    is_active: boolean | null;
    trial_days: number | null;
    _count: SubscriptionsCountAggregateOutputType | null;
    _avg: SubscriptionsAvgAggregateOutputType | null;
    _sum: SubscriptionsSumAggregateOutputType | null;
    _min: SubscriptionsMinAggregateOutputType | null;
    _max: SubscriptionsMaxAggregateOutputType | null;
  };

  type GetSubscriptionsGroupByPayload<T extends subscriptionsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SubscriptionsGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof SubscriptionsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>;
        }
      >
    >;

  export type subscriptionsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      subscription_id?: boolean;
      name?: boolean;
      price?: boolean;
      features?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      stripe_price_id?: boolean;
      price_amount?: boolean;
      currency?: boolean;
      billing_interval?: boolean;
      is_active?: boolean;
      trial_days?: boolean;
      permissions?: boolean | subscriptions$permissionsArgs<ExtArgs>;
      user_subscriptions?:
        | boolean
        | subscriptions$user_subscriptionsArgs<ExtArgs>;
      _count?: boolean | SubscriptionsCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['subscriptions']
  >;

  export type subscriptionsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      subscription_id?: boolean;
      name?: boolean;
      price?: boolean;
      features?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      stripe_price_id?: boolean;
      price_amount?: boolean;
      currency?: boolean;
      billing_interval?: boolean;
      is_active?: boolean;
      trial_days?: boolean;
    },
    ExtArgs['result']['subscriptions']
  >;

  export type subscriptionsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      subscription_id?: boolean;
      name?: boolean;
      price?: boolean;
      features?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      stripe_price_id?: boolean;
      price_amount?: boolean;
      currency?: boolean;
      billing_interval?: boolean;
      is_active?: boolean;
      trial_days?: boolean;
    },
    ExtArgs['result']['subscriptions']
  >;

  export type subscriptionsSelectScalar = {
    subscription_id?: boolean;
    name?: boolean;
    price?: boolean;
    features?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    stripe_price_id?: boolean;
    price_amount?: boolean;
    currency?: boolean;
    billing_interval?: boolean;
    is_active?: boolean;
    trial_days?: boolean;
  };

  export type subscriptionsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'subscription_id'
    | 'name'
    | 'price'
    | 'features'
    | 'created_at'
    | 'updated_at'
    | 'stripe_price_id'
    | 'price_amount'
    | 'currency'
    | 'billing_interval'
    | 'is_active'
    | 'trial_days',
    ExtArgs['result']['subscriptions']
  >;
  export type subscriptionsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    permissions?: boolean | subscriptions$permissionsArgs<ExtArgs>;
    user_subscriptions?:
      | boolean
      | subscriptions$user_subscriptionsArgs<ExtArgs>;
    _count?: boolean | SubscriptionsCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type subscriptionsIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {};
  export type subscriptionsIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {};

  export type $subscriptionsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'subscriptions';
    objects: {
      permissions: Prisma.$permissionsPayload<ExtArgs>[];
      user_subscriptions: Prisma.$user_subscriptionsPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        subscription_id: number;
        name: string | null;
        price: Prisma.Decimal | null;
        features: Prisma.JsonValue | null;
        created_at: Date | null;
        updated_at: Date | null;
        stripe_price_id: string | null;
        price_amount: string | null;
        currency: string | null;
        billing_interval: string | null;
        is_active: boolean | null;
        trial_days: number | null;
      },
      ExtArgs['result']['subscriptions']
    >;
    composites: {};
  };

  type subscriptionsGetPayload<
    S extends boolean | null | undefined | subscriptionsDefaultArgs
  > = $Result.GetResult<Prisma.$subscriptionsPayload, S>;

  type subscriptionsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    subscriptionsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: SubscriptionsCountAggregateInputType | true;
  };

  export interface subscriptionsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['subscriptions'];
      meta: { name: 'subscriptions' };
    };
    /**
     * Find zero or one Subscriptions that matches the filter.
     * @param {subscriptionsFindUniqueArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subscriptionsFindUniqueArgs>(
      args: SelectSubset<T, subscriptionsFindUniqueArgs<ExtArgs>>
    ): Prisma__subscriptionsClient<
      $Result.GetResult<
        Prisma.$subscriptionsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Subscriptions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subscriptionsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, subscriptionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__subscriptionsClient<
      $Result.GetResult<
        Prisma.$subscriptionsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subscriptionsFindFirstArgs>(
      args?: SelectSubset<T, subscriptionsFindFirstArgs<ExtArgs>>
    ): Prisma__subscriptionsClient<
      $Result.GetResult<
        Prisma.$subscriptionsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Subscriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subscriptionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, subscriptionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__subscriptionsClient<
      $Result.GetResult<
        Prisma.$subscriptionsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany()
     *
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany({ take: 10 })
     *
     * // Only select the `subscription_id`
     * const subscriptionsWithSubscription_idOnly = await prisma.subscriptions.findMany({ select: { subscription_id: true } })
     *
     */
    findMany<T extends subscriptionsFindManyArgs>(
      args?: SelectSubset<T, subscriptionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$subscriptionsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Subscriptions.
     * @param {subscriptionsCreateArgs} args - Arguments to create a Subscriptions.
     * @example
     * // Create one Subscriptions
     * const Subscriptions = await prisma.subscriptions.create({
     *   data: {
     *     // ... data to create a Subscriptions
     *   }
     * })
     *
     */
    create<T extends subscriptionsCreateArgs>(
      args: SelectSubset<T, subscriptionsCreateArgs<ExtArgs>>
    ): Prisma__subscriptionsClient<
      $Result.GetResult<
        Prisma.$subscriptionsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Subscriptions.
     * @param {subscriptionsCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends subscriptionsCreateManyArgs>(
      args?: SelectSubset<T, subscriptionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {subscriptionsCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Subscriptions and only return the `subscription_id`
     * const subscriptionsWithSubscription_idOnly = await prisma.subscriptions.createManyAndReturn({
     *   select: { subscription_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends subscriptionsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, subscriptionsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$subscriptionsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Subscriptions.
     * @param {subscriptionsDeleteArgs} args - Arguments to delete one Subscriptions.
     * @example
     * // Delete one Subscriptions
     * const Subscriptions = await prisma.subscriptions.delete({
     *   where: {
     *     // ... filter to delete one Subscriptions
     *   }
     * })
     *
     */
    delete<T extends subscriptionsDeleteArgs>(
      args: SelectSubset<T, subscriptionsDeleteArgs<ExtArgs>>
    ): Prisma__subscriptionsClient<
      $Result.GetResult<
        Prisma.$subscriptionsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Subscriptions.
     * @param {subscriptionsUpdateArgs} args - Arguments to update one Subscriptions.
     * @example
     * // Update one Subscriptions
     * const subscriptions = await prisma.subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends subscriptionsUpdateArgs>(
      args: SelectSubset<T, subscriptionsUpdateArgs<ExtArgs>>
    ): Prisma__subscriptionsClient<
      $Result.GetResult<
        Prisma.$subscriptionsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Subscriptions.
     * @param {subscriptionsDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends subscriptionsDeleteManyArgs>(
      args?: SelectSubset<T, subscriptionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends subscriptionsUpdateManyArgs>(
      args: SelectSubset<T, subscriptionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {subscriptionsUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Subscriptions and only return the `subscription_id`
     * const subscriptionsWithSubscription_idOnly = await prisma.subscriptions.updateManyAndReturn({
     *   select: { subscription_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends subscriptionsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, subscriptionsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$subscriptionsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Subscriptions.
     * @param {subscriptionsUpsertArgs} args - Arguments to update or create a Subscriptions.
     * @example
     * // Update or create a Subscriptions
     * const subscriptions = await prisma.subscriptions.upsert({
     *   create: {
     *     // ... data to create a Subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriptions we want to update
     *   }
     * })
     */
    upsert<T extends subscriptionsUpsertArgs>(
      args: SelectSubset<T, subscriptionsUpsertArgs<ExtArgs>>
    ): Prisma__subscriptionsClient<
      $Result.GetResult<
        Prisma.$subscriptionsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscriptions.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
     **/
    count<T extends subscriptionsCountArgs>(
      args?: Subset<T, subscriptionsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SubscriptionsAggregateArgs>(
      args: Subset<T, SubscriptionsAggregateArgs>
    ): Prisma.PrismaPromise<GetSubscriptionsAggregateType<T>>;

    /**
     * Group by Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends subscriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subscriptionsGroupByArgs['orderBy'] }
        : { orderBy?: subscriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, subscriptionsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetSubscriptionsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the subscriptions model
     */
    readonly fields: subscriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subscriptionsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    permissions<T extends subscriptions$permissionsArgs<ExtArgs> = {}>(
      args?: Subset<T, subscriptions$permissionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$permissionsPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    user_subscriptions<
      T extends subscriptions$user_subscriptionsArgs<ExtArgs> = {}
    >(
      args?: Subset<T, subscriptions$user_subscriptionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$user_subscriptionsPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the subscriptions model
   */
  interface subscriptionsFieldRefs {
    readonly subscription_id: FieldRef<'subscriptions', 'Int'>;
    readonly name: FieldRef<'subscriptions', 'String'>;
    readonly price: FieldRef<'subscriptions', 'Decimal'>;
    readonly features: FieldRef<'subscriptions', 'Json'>;
    readonly created_at: FieldRef<'subscriptions', 'DateTime'>;
    readonly updated_at: FieldRef<'subscriptions', 'DateTime'>;
    readonly stripe_price_id: FieldRef<'subscriptions', 'String'>;
    readonly price_amount: FieldRef<'subscriptions', 'String'>;
    readonly currency: FieldRef<'subscriptions', 'String'>;
    readonly billing_interval: FieldRef<'subscriptions', 'String'>;
    readonly is_active: FieldRef<'subscriptions', 'Boolean'>;
    readonly trial_days: FieldRef<'subscriptions', 'Int'>;
  }

  // Custom InputTypes
  /**
   * subscriptions findUnique
   */
  export type subscriptionsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null;
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput;
  };

  /**
   * subscriptions findUniqueOrThrow
   */
  export type subscriptionsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null;
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput;
  };

  /**
   * subscriptions findFirst
   */
  export type subscriptionsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null;
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of subscriptions to fetch.
     */
    orderBy?:
      | subscriptionsOrderByWithRelationInput
      | subscriptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` subscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[];
  };

  /**
   * subscriptions findFirstOrThrow
   */
  export type subscriptionsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null;
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of subscriptions to fetch.
     */
    orderBy?:
      | subscriptionsOrderByWithRelationInput
      | subscriptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` subscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[];
  };

  /**
   * subscriptions findMany
   */
  export type subscriptionsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null;
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of subscriptions to fetch.
     */
    orderBy?:
      | subscriptionsOrderByWithRelationInput
      | subscriptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` subscriptions.
     */
    skip?: number;
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[];
  };

  /**
   * subscriptions create
   */
  export type subscriptionsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null;
    /**
     * The data needed to create a subscriptions.
     */
    data?: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>;
  };

  /**
   * subscriptions createMany
   */
  export type subscriptionsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionsCreateManyInput | subscriptionsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * subscriptions createManyAndReturn
   */
  export type subscriptionsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionsCreateManyInput | subscriptionsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * subscriptions update
   */
  export type subscriptionsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null;
    /**
     * The data needed to update a subscriptions.
     */
    data: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>;
    /**
     * Choose, which subscriptions to update.
     */
    where: subscriptionsWhereUniqueInput;
  };

  /**
   * subscriptions updateMany
   */
  export type subscriptionsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update subscriptions.
     */
    data: XOR<
      subscriptionsUpdateManyMutationInput,
      subscriptionsUncheckedUpdateManyInput
    >;
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionsWhereInput;
    /**
     * Limit how many subscriptions to update.
     */
    limit?: number;
  };

  /**
   * subscriptions updateManyAndReturn
   */
  export type subscriptionsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * The data used to update subscriptions.
     */
    data: XOR<
      subscriptionsUpdateManyMutationInput,
      subscriptionsUncheckedUpdateManyInput
    >;
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionsWhereInput;
    /**
     * Limit how many subscriptions to update.
     */
    limit?: number;
  };

  /**
   * subscriptions upsert
   */
  export type subscriptionsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null;
    /**
     * The filter to search for the subscriptions to update in case it exists.
     */
    where: subscriptionsWhereUniqueInput;
    /**
     * In case the subscriptions found by the `where` argument doesn't exist, create a new subscriptions with this data.
     */
    create: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>;
    /**
     * In case the subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>;
  };

  /**
   * subscriptions delete
   */
  export type subscriptionsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null;
    /**
     * Filter which subscriptions to delete.
     */
    where: subscriptionsWhereUniqueInput;
  };

  /**
   * subscriptions deleteMany
   */
  export type subscriptionsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which subscriptions to delete
     */
    where?: subscriptionsWhereInput;
    /**
     * Limit how many subscriptions to delete.
     */
    limit?: number;
  };

  /**
   * subscriptions.permissions
   */
  export type subscriptions$permissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null;
    where?: permissionsWhereInput;
    orderBy?:
      | permissionsOrderByWithRelationInput
      | permissionsOrderByWithRelationInput[];
    cursor?: permissionsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[];
  };

  /**
   * subscriptions.user_subscriptions
   */
  export type subscriptions$user_subscriptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_subscriptions
     */
    select?: user_subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_subscriptions
     */
    omit?: user_subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_subscriptionsInclude<ExtArgs> | null;
    where?: user_subscriptionsWhereInput;
    orderBy?:
      | user_subscriptionsOrderByWithRelationInput
      | user_subscriptionsOrderByWithRelationInput[];
    cursor?: user_subscriptionsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | User_subscriptionsScalarFieldEnum
      | User_subscriptionsScalarFieldEnum[];
  };

  /**
   * subscriptions without action
   */
  export type subscriptionsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null;
  };

  /**
   * Model superinvestor_holdings
   */

  export type AggregateSuperinvestor_holdings = {
    _count: Superinvestor_holdingsCountAggregateOutputType | null;
    _avg: Superinvestor_holdingsAvgAggregateOutputType | null;
    _sum: Superinvestor_holdingsSumAggregateOutputType | null;
    _min: Superinvestor_holdingsMinAggregateOutputType | null;
    _max: Superinvestor_holdingsMaxAggregateOutputType | null;
  };

  export type Superinvestor_holdingsAvgAggregateOutputType = {
    id: number | null;
    number_of_stocks: number | null;
    portfolio_value: Decimal | null;
  };

  export type Superinvestor_holdingsSumAggregateOutputType = {
    id: number | null;
    number_of_stocks: number | null;
    portfolio_value: Decimal | null;
  };

  export type Superinvestor_holdingsMinAggregateOutputType = {
    id: number | null;
    manager_name: string | null;
    portfolio_value_raw: string | null;
    number_of_stocks: number | null;
    manager_link: string | null;
    image: string | null;
    information_en: string | null;
    information_th: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    portfolio_value: Decimal | null;
  };

  export type Superinvestor_holdingsMaxAggregateOutputType = {
    id: number | null;
    manager_name: string | null;
    portfolio_value_raw: string | null;
    number_of_stocks: number | null;
    manager_link: string | null;
    image: string | null;
    information_en: string | null;
    information_th: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    portfolio_value: Decimal | null;
  };

  export type Superinvestor_holdingsCountAggregateOutputType = {
    id: number;
    manager_name: number;
    portfolio_value_raw: number;
    number_of_stocks: number;
    manager_link: number;
    image: number;
    information_en: number;
    information_th: number;
    created_at: number;
    updated_at: number;
    portfolio_value: number;
    _all: number;
  };

  export type Superinvestor_holdingsAvgAggregateInputType = {
    id?: true;
    number_of_stocks?: true;
    portfolio_value?: true;
  };

  export type Superinvestor_holdingsSumAggregateInputType = {
    id?: true;
    number_of_stocks?: true;
    portfolio_value?: true;
  };

  export type Superinvestor_holdingsMinAggregateInputType = {
    id?: true;
    manager_name?: true;
    portfolio_value_raw?: true;
    number_of_stocks?: true;
    manager_link?: true;
    image?: true;
    information_en?: true;
    information_th?: true;
    created_at?: true;
    updated_at?: true;
    portfolio_value?: true;
  };

  export type Superinvestor_holdingsMaxAggregateInputType = {
    id?: true;
    manager_name?: true;
    portfolio_value_raw?: true;
    number_of_stocks?: true;
    manager_link?: true;
    image?: true;
    information_en?: true;
    information_th?: true;
    created_at?: true;
    updated_at?: true;
    portfolio_value?: true;
  };

  export type Superinvestor_holdingsCountAggregateInputType = {
    id?: true;
    manager_name?: true;
    portfolio_value_raw?: true;
    number_of_stocks?: true;
    manager_link?: true;
    image?: true;
    information_en?: true;
    information_th?: true;
    created_at?: true;
    updated_at?: true;
    portfolio_value?: true;
    _all?: true;
  };

  export type Superinvestor_holdingsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which superinvestor_holdings to aggregate.
     */
    where?: superinvestor_holdingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of superinvestor_holdings to fetch.
     */
    orderBy?:
      | superinvestor_holdingsOrderByWithRelationInput
      | superinvestor_holdingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: superinvestor_holdingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` superinvestor_holdings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` superinvestor_holdings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned superinvestor_holdings
     **/
    _count?: true | Superinvestor_holdingsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Superinvestor_holdingsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Superinvestor_holdingsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Superinvestor_holdingsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Superinvestor_holdingsMaxAggregateInputType;
  };

  export type GetSuperinvestor_holdingsAggregateType<
    T extends Superinvestor_holdingsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateSuperinvestor_holdings]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperinvestor_holdings[P]>
      : GetScalarType<T[P], AggregateSuperinvestor_holdings[P]>;
  };

  export type superinvestor_holdingsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: superinvestor_holdingsWhereInput;
    orderBy?:
      | superinvestor_holdingsOrderByWithAggregationInput
      | superinvestor_holdingsOrderByWithAggregationInput[];
    by:
      | Superinvestor_holdingsScalarFieldEnum[]
      | Superinvestor_holdingsScalarFieldEnum;
    having?: superinvestor_holdingsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Superinvestor_holdingsCountAggregateInputType | true;
    _avg?: Superinvestor_holdingsAvgAggregateInputType;
    _sum?: Superinvestor_holdingsSumAggregateInputType;
    _min?: Superinvestor_holdingsMinAggregateInputType;
    _max?: Superinvestor_holdingsMaxAggregateInputType;
  };

  export type Superinvestor_holdingsGroupByOutputType = {
    id: number;
    manager_name: string | null;
    portfolio_value_raw: string | null;
    number_of_stocks: number | null;
    manager_link: string | null;
    image: string | null;
    information_en: string | null;
    information_th: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    portfolio_value: Decimal | null;
    _count: Superinvestor_holdingsCountAggregateOutputType | null;
    _avg: Superinvestor_holdingsAvgAggregateOutputType | null;
    _sum: Superinvestor_holdingsSumAggregateOutputType | null;
    _min: Superinvestor_holdingsMinAggregateOutputType | null;
    _max: Superinvestor_holdingsMaxAggregateOutputType | null;
  };

  type GetSuperinvestor_holdingsGroupByPayload<
    T extends superinvestor_holdingsGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Superinvestor_holdingsGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof Superinvestor_holdingsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], Superinvestor_holdingsGroupByOutputType[P]>
          : GetScalarType<T[P], Superinvestor_holdingsGroupByOutputType[P]>;
      }
    >
  >;

  export type superinvestor_holdingsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      manager_name?: boolean;
      portfolio_value_raw?: boolean;
      number_of_stocks?: boolean;
      manager_link?: boolean;
      image?: boolean;
      information_en?: boolean;
      information_th?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      portfolio_value?: boolean;
      superinvestor_holdings_list?:
        | boolean
        | superinvestor_holdings$superinvestor_holdings_listArgs<ExtArgs>;
      superinvestor_sector_analysis?:
        | boolean
        | superinvestor_holdings$superinvestor_sector_analysisArgs<ExtArgs>;
      _count?:
        | boolean
        | Superinvestor_holdingsCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['superinvestor_holdings']
  >;

  export type superinvestor_holdingsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      manager_name?: boolean;
      portfolio_value_raw?: boolean;
      number_of_stocks?: boolean;
      manager_link?: boolean;
      image?: boolean;
      information_en?: boolean;
      information_th?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      portfolio_value?: boolean;
    },
    ExtArgs['result']['superinvestor_holdings']
  >;

  export type superinvestor_holdingsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      manager_name?: boolean;
      portfolio_value_raw?: boolean;
      number_of_stocks?: boolean;
      manager_link?: boolean;
      image?: boolean;
      information_en?: boolean;
      information_th?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      portfolio_value?: boolean;
    },
    ExtArgs['result']['superinvestor_holdings']
  >;

  export type superinvestor_holdingsSelectScalar = {
    id?: boolean;
    manager_name?: boolean;
    portfolio_value_raw?: boolean;
    number_of_stocks?: boolean;
    manager_link?: boolean;
    image?: boolean;
    information_en?: boolean;
    information_th?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    portfolio_value?: boolean;
  };

  export type superinvestor_holdingsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'manager_name'
    | 'portfolio_value_raw'
    | 'number_of_stocks'
    | 'manager_link'
    | 'image'
    | 'information_en'
    | 'information_th'
    | 'created_at'
    | 'updated_at'
    | 'portfolio_value',
    ExtArgs['result']['superinvestor_holdings']
  >;
  export type superinvestor_holdingsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    superinvestor_holdings_list?:
      | boolean
      | superinvestor_holdings$superinvestor_holdings_listArgs<ExtArgs>;
    superinvestor_sector_analysis?:
      | boolean
      | superinvestor_holdings$superinvestor_sector_analysisArgs<ExtArgs>;
    _count?:
      | boolean
      | Superinvestor_holdingsCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type superinvestor_holdingsIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {};
  export type superinvestor_holdingsIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {};

  export type $superinvestor_holdingsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'superinvestor_holdings';
    objects: {
      superinvestor_holdings_list: Prisma.$superinvestor_holdings_listPayload<ExtArgs>[];
      superinvestor_sector_analysis: Prisma.$superinvestor_sector_analysisPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        manager_name: string | null;
        portfolio_value_raw: string | null;
        number_of_stocks: number | null;
        manager_link: string | null;
        image: string | null;
        information_en: string | null;
        information_th: string | null;
        created_at: Date | null;
        updated_at: Date | null;
        portfolio_value: Prisma.Decimal | null;
      },
      ExtArgs['result']['superinvestor_holdings']
    >;
    composites: {};
  };

  type superinvestor_holdingsGetPayload<
    S extends boolean | null | undefined | superinvestor_holdingsDefaultArgs
  > = $Result.GetResult<Prisma.$superinvestor_holdingsPayload, S>;

  type superinvestor_holdingsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    superinvestor_holdingsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Superinvestor_holdingsCountAggregateInputType | true;
  };

  export interface superinvestor_holdingsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['superinvestor_holdings'];
      meta: { name: 'superinvestor_holdings' };
    };
    /**
     * Find zero or one Superinvestor_holdings that matches the filter.
     * @param {superinvestor_holdingsFindUniqueArgs} args - Arguments to find a Superinvestor_holdings
     * @example
     * // Get one Superinvestor_holdings
     * const superinvestor_holdings = await prisma.superinvestor_holdings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends superinvestor_holdingsFindUniqueArgs>(
      args: SelectSubset<T, superinvestor_holdingsFindUniqueArgs<ExtArgs>>
    ): Prisma__superinvestor_holdingsClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdingsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Superinvestor_holdings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {superinvestor_holdingsFindUniqueOrThrowArgs} args - Arguments to find a Superinvestor_holdings
     * @example
     * // Get one Superinvestor_holdings
     * const superinvestor_holdings = await prisma.superinvestor_holdings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends superinvestor_holdingsFindUniqueOrThrowArgs>(
      args: SelectSubset<
        T,
        superinvestor_holdingsFindUniqueOrThrowArgs<ExtArgs>
      >
    ): Prisma__superinvestor_holdingsClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdingsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Superinvestor_holdings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_holdingsFindFirstArgs} args - Arguments to find a Superinvestor_holdings
     * @example
     * // Get one Superinvestor_holdings
     * const superinvestor_holdings = await prisma.superinvestor_holdings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends superinvestor_holdingsFindFirstArgs>(
      args?: SelectSubset<T, superinvestor_holdingsFindFirstArgs<ExtArgs>>
    ): Prisma__superinvestor_holdingsClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdingsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Superinvestor_holdings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_holdingsFindFirstOrThrowArgs} args - Arguments to find a Superinvestor_holdings
     * @example
     * // Get one Superinvestor_holdings
     * const superinvestor_holdings = await prisma.superinvestor_holdings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends superinvestor_holdingsFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        superinvestor_holdingsFindFirstOrThrowArgs<ExtArgs>
      >
    ): Prisma__superinvestor_holdingsClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdingsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Superinvestor_holdings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_holdingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Superinvestor_holdings
     * const superinvestor_holdings = await prisma.superinvestor_holdings.findMany()
     *
     * // Get first 10 Superinvestor_holdings
     * const superinvestor_holdings = await prisma.superinvestor_holdings.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const superinvestor_holdingsWithIdOnly = await prisma.superinvestor_holdings.findMany({ select: { id: true } })
     *
     */
    findMany<T extends superinvestor_holdingsFindManyArgs>(
      args?: SelectSubset<T, superinvestor_holdingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$superinvestor_holdingsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Superinvestor_holdings.
     * @param {superinvestor_holdingsCreateArgs} args - Arguments to create a Superinvestor_holdings.
     * @example
     * // Create one Superinvestor_holdings
     * const Superinvestor_holdings = await prisma.superinvestor_holdings.create({
     *   data: {
     *     // ... data to create a Superinvestor_holdings
     *   }
     * })
     *
     */
    create<T extends superinvestor_holdingsCreateArgs>(
      args: SelectSubset<T, superinvestor_holdingsCreateArgs<ExtArgs>>
    ): Prisma__superinvestor_holdingsClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdingsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Superinvestor_holdings.
     * @param {superinvestor_holdingsCreateManyArgs} args - Arguments to create many Superinvestor_holdings.
     * @example
     * // Create many Superinvestor_holdings
     * const superinvestor_holdings = await prisma.superinvestor_holdings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends superinvestor_holdingsCreateManyArgs>(
      args?: SelectSubset<T, superinvestor_holdingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Superinvestor_holdings and returns the data saved in the database.
     * @param {superinvestor_holdingsCreateManyAndReturnArgs} args - Arguments to create many Superinvestor_holdings.
     * @example
     * // Create many Superinvestor_holdings
     * const superinvestor_holdings = await prisma.superinvestor_holdings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Superinvestor_holdings and only return the `id`
     * const superinvestor_holdingsWithIdOnly = await prisma.superinvestor_holdings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends superinvestor_holdingsCreateManyAndReturnArgs
    >(
      args?: SelectSubset<
        T,
        superinvestor_holdingsCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$superinvestor_holdingsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Superinvestor_holdings.
     * @param {superinvestor_holdingsDeleteArgs} args - Arguments to delete one Superinvestor_holdings.
     * @example
     * // Delete one Superinvestor_holdings
     * const Superinvestor_holdings = await prisma.superinvestor_holdings.delete({
     *   where: {
     *     // ... filter to delete one Superinvestor_holdings
     *   }
     * })
     *
     */
    delete<T extends superinvestor_holdingsDeleteArgs>(
      args: SelectSubset<T, superinvestor_holdingsDeleteArgs<ExtArgs>>
    ): Prisma__superinvestor_holdingsClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdingsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Superinvestor_holdings.
     * @param {superinvestor_holdingsUpdateArgs} args - Arguments to update one Superinvestor_holdings.
     * @example
     * // Update one Superinvestor_holdings
     * const superinvestor_holdings = await prisma.superinvestor_holdings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends superinvestor_holdingsUpdateArgs>(
      args: SelectSubset<T, superinvestor_holdingsUpdateArgs<ExtArgs>>
    ): Prisma__superinvestor_holdingsClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdingsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Superinvestor_holdings.
     * @param {superinvestor_holdingsDeleteManyArgs} args - Arguments to filter Superinvestor_holdings to delete.
     * @example
     * // Delete a few Superinvestor_holdings
     * const { count } = await prisma.superinvestor_holdings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends superinvestor_holdingsDeleteManyArgs>(
      args?: SelectSubset<T, superinvestor_holdingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Superinvestor_holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_holdingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Superinvestor_holdings
     * const superinvestor_holdings = await prisma.superinvestor_holdings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends superinvestor_holdingsUpdateManyArgs>(
      args: SelectSubset<T, superinvestor_holdingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Superinvestor_holdings and returns the data updated in the database.
     * @param {superinvestor_holdingsUpdateManyAndReturnArgs} args - Arguments to update many Superinvestor_holdings.
     * @example
     * // Update many Superinvestor_holdings
     * const superinvestor_holdings = await prisma.superinvestor_holdings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Superinvestor_holdings and only return the `id`
     * const superinvestor_holdingsWithIdOnly = await prisma.superinvestor_holdings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends superinvestor_holdingsUpdateManyAndReturnArgs
    >(
      args: SelectSubset<
        T,
        superinvestor_holdingsUpdateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$superinvestor_holdingsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Superinvestor_holdings.
     * @param {superinvestor_holdingsUpsertArgs} args - Arguments to update or create a Superinvestor_holdings.
     * @example
     * // Update or create a Superinvestor_holdings
     * const superinvestor_holdings = await prisma.superinvestor_holdings.upsert({
     *   create: {
     *     // ... data to create a Superinvestor_holdings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Superinvestor_holdings we want to update
     *   }
     * })
     */
    upsert<T extends superinvestor_holdingsUpsertArgs>(
      args: SelectSubset<T, superinvestor_holdingsUpsertArgs<ExtArgs>>
    ): Prisma__superinvestor_holdingsClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdingsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Superinvestor_holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_holdingsCountArgs} args - Arguments to filter Superinvestor_holdings to count.
     * @example
     * // Count the number of Superinvestor_holdings
     * const count = await prisma.superinvestor_holdings.count({
     *   where: {
     *     // ... the filter for the Superinvestor_holdings we want to count
     *   }
     * })
     **/
    count<T extends superinvestor_holdingsCountArgs>(
      args?: Subset<T, superinvestor_holdingsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              Superinvestor_holdingsCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Superinvestor_holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Superinvestor_holdingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Superinvestor_holdingsAggregateArgs>(
      args: Subset<T, Superinvestor_holdingsAggregateArgs>
    ): Prisma.PrismaPromise<GetSuperinvestor_holdingsAggregateType<T>>;

    /**
     * Group by Superinvestor_holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_holdingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends superinvestor_holdingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: superinvestor_holdingsGroupByArgs['orderBy'] }
        : { orderBy?: superinvestor_holdingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<
        T,
        superinvestor_holdingsGroupByArgs,
        OrderByArg
      > &
        InputErrors
    ): {} extends InputErrors
      ? GetSuperinvestor_holdingsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the superinvestor_holdings model
     */
    readonly fields: superinvestor_holdingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for superinvestor_holdings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__superinvestor_holdingsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    superinvestor_holdings_list<
      T extends
        superinvestor_holdings$superinvestor_holdings_listArgs<ExtArgs> = {}
    >(
      args?: Subset<
        T,
        superinvestor_holdings$superinvestor_holdings_listArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$superinvestor_holdings_listPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    superinvestor_sector_analysis<
      T extends
        superinvestor_holdings$superinvestor_sector_analysisArgs<ExtArgs> = {}
    >(
      args?: Subset<
        T,
        superinvestor_holdings$superinvestor_sector_analysisArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$superinvestor_sector_analysisPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the superinvestor_holdings model
   */
  interface superinvestor_holdingsFieldRefs {
    readonly id: FieldRef<'superinvestor_holdings', 'Int'>;
    readonly manager_name: FieldRef<'superinvestor_holdings', 'String'>;
    readonly portfolio_value_raw: FieldRef<'superinvestor_holdings', 'String'>;
    readonly number_of_stocks: FieldRef<'superinvestor_holdings', 'Int'>;
    readonly manager_link: FieldRef<'superinvestor_holdings', 'String'>;
    readonly image: FieldRef<'superinvestor_holdings', 'String'>;
    readonly information_en: FieldRef<'superinvestor_holdings', 'String'>;
    readonly information_th: FieldRef<'superinvestor_holdings', 'String'>;
    readonly created_at: FieldRef<'superinvestor_holdings', 'DateTime'>;
    readonly updated_at: FieldRef<'superinvestor_holdings', 'DateTime'>;
    readonly portfolio_value: FieldRef<'superinvestor_holdings', 'Decimal'>;
  }

  // Custom InputTypes
  /**
   * superinvestor_holdings findUnique
   */
  export type superinvestor_holdingsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings
     */
    select?: superinvestor_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings
     */
    omit?: superinvestor_holdingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdingsInclude<ExtArgs> | null;
    /**
     * Filter, which superinvestor_holdings to fetch.
     */
    where: superinvestor_holdingsWhereUniqueInput;
  };

  /**
   * superinvestor_holdings findUniqueOrThrow
   */
  export type superinvestor_holdingsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings
     */
    select?: superinvestor_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings
     */
    omit?: superinvestor_holdingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdingsInclude<ExtArgs> | null;
    /**
     * Filter, which superinvestor_holdings to fetch.
     */
    where: superinvestor_holdingsWhereUniqueInput;
  };

  /**
   * superinvestor_holdings findFirst
   */
  export type superinvestor_holdingsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings
     */
    select?: superinvestor_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings
     */
    omit?: superinvestor_holdingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdingsInclude<ExtArgs> | null;
    /**
     * Filter, which superinvestor_holdings to fetch.
     */
    where?: superinvestor_holdingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of superinvestor_holdings to fetch.
     */
    orderBy?:
      | superinvestor_holdingsOrderByWithRelationInput
      | superinvestor_holdingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for superinvestor_holdings.
     */
    cursor?: superinvestor_holdingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` superinvestor_holdings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` superinvestor_holdings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of superinvestor_holdings.
     */
    distinct?:
      | Superinvestor_holdingsScalarFieldEnum
      | Superinvestor_holdingsScalarFieldEnum[];
  };

  /**
   * superinvestor_holdings findFirstOrThrow
   */
  export type superinvestor_holdingsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings
     */
    select?: superinvestor_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings
     */
    omit?: superinvestor_holdingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdingsInclude<ExtArgs> | null;
    /**
     * Filter, which superinvestor_holdings to fetch.
     */
    where?: superinvestor_holdingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of superinvestor_holdings to fetch.
     */
    orderBy?:
      | superinvestor_holdingsOrderByWithRelationInput
      | superinvestor_holdingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for superinvestor_holdings.
     */
    cursor?: superinvestor_holdingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` superinvestor_holdings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` superinvestor_holdings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of superinvestor_holdings.
     */
    distinct?:
      | Superinvestor_holdingsScalarFieldEnum
      | Superinvestor_holdingsScalarFieldEnum[];
  };

  /**
   * superinvestor_holdings findMany
   */
  export type superinvestor_holdingsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings
     */
    select?: superinvestor_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings
     */
    omit?: superinvestor_holdingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdingsInclude<ExtArgs> | null;
    /**
     * Filter, which superinvestor_holdings to fetch.
     */
    where?: superinvestor_holdingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of superinvestor_holdings to fetch.
     */
    orderBy?:
      | superinvestor_holdingsOrderByWithRelationInput
      | superinvestor_holdingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing superinvestor_holdings.
     */
    cursor?: superinvestor_holdingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` superinvestor_holdings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` superinvestor_holdings.
     */
    skip?: number;
    distinct?:
      | Superinvestor_holdingsScalarFieldEnum
      | Superinvestor_holdingsScalarFieldEnum[];
  };

  /**
   * superinvestor_holdings create
   */
  export type superinvestor_holdingsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings
     */
    select?: superinvestor_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings
     */
    omit?: superinvestor_holdingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdingsInclude<ExtArgs> | null;
    /**
     * The data needed to create a superinvestor_holdings.
     */
    data?: XOR<
      superinvestor_holdingsCreateInput,
      superinvestor_holdingsUncheckedCreateInput
    >;
  };

  /**
   * superinvestor_holdings createMany
   */
  export type superinvestor_holdingsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many superinvestor_holdings.
     */
    data:
      | superinvestor_holdingsCreateManyInput
      | superinvestor_holdingsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * superinvestor_holdings createManyAndReturn
   */
  export type superinvestor_holdingsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings
     */
    select?: superinvestor_holdingsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings
     */
    omit?: superinvestor_holdingsOmit<ExtArgs> | null;
    /**
     * The data used to create many superinvestor_holdings.
     */
    data:
      | superinvestor_holdingsCreateManyInput
      | superinvestor_holdingsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * superinvestor_holdings update
   */
  export type superinvestor_holdingsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings
     */
    select?: superinvestor_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings
     */
    omit?: superinvestor_holdingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdingsInclude<ExtArgs> | null;
    /**
     * The data needed to update a superinvestor_holdings.
     */
    data: XOR<
      superinvestor_holdingsUpdateInput,
      superinvestor_holdingsUncheckedUpdateInput
    >;
    /**
     * Choose, which superinvestor_holdings to update.
     */
    where: superinvestor_holdingsWhereUniqueInput;
  };

  /**
   * superinvestor_holdings updateMany
   */
  export type superinvestor_holdingsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update superinvestor_holdings.
     */
    data: XOR<
      superinvestor_holdingsUpdateManyMutationInput,
      superinvestor_holdingsUncheckedUpdateManyInput
    >;
    /**
     * Filter which superinvestor_holdings to update
     */
    where?: superinvestor_holdingsWhereInput;
    /**
     * Limit how many superinvestor_holdings to update.
     */
    limit?: number;
  };

  /**
   * superinvestor_holdings updateManyAndReturn
   */
  export type superinvestor_holdingsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings
     */
    select?: superinvestor_holdingsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings
     */
    omit?: superinvestor_holdingsOmit<ExtArgs> | null;
    /**
     * The data used to update superinvestor_holdings.
     */
    data: XOR<
      superinvestor_holdingsUpdateManyMutationInput,
      superinvestor_holdingsUncheckedUpdateManyInput
    >;
    /**
     * Filter which superinvestor_holdings to update
     */
    where?: superinvestor_holdingsWhereInput;
    /**
     * Limit how many superinvestor_holdings to update.
     */
    limit?: number;
  };

  /**
   * superinvestor_holdings upsert
   */
  export type superinvestor_holdingsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings
     */
    select?: superinvestor_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings
     */
    omit?: superinvestor_holdingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdingsInclude<ExtArgs> | null;
    /**
     * The filter to search for the superinvestor_holdings to update in case it exists.
     */
    where: superinvestor_holdingsWhereUniqueInput;
    /**
     * In case the superinvestor_holdings found by the `where` argument doesn't exist, create a new superinvestor_holdings with this data.
     */
    create: XOR<
      superinvestor_holdingsCreateInput,
      superinvestor_holdingsUncheckedCreateInput
    >;
    /**
     * In case the superinvestor_holdings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      superinvestor_holdingsUpdateInput,
      superinvestor_holdingsUncheckedUpdateInput
    >;
  };

  /**
   * superinvestor_holdings delete
   */
  export type superinvestor_holdingsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings
     */
    select?: superinvestor_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings
     */
    omit?: superinvestor_holdingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdingsInclude<ExtArgs> | null;
    /**
     * Filter which superinvestor_holdings to delete.
     */
    where: superinvestor_holdingsWhereUniqueInput;
  };

  /**
   * superinvestor_holdings deleteMany
   */
  export type superinvestor_holdingsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which superinvestor_holdings to delete
     */
    where?: superinvestor_holdingsWhereInput;
    /**
     * Limit how many superinvestor_holdings to delete.
     */
    limit?: number;
  };

  /**
   * superinvestor_holdings.superinvestor_holdings_list
   */
  export type superinvestor_holdings$superinvestor_holdings_listArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings_list
     */
    select?: superinvestor_holdings_listSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings_list
     */
    omit?: superinvestor_holdings_listOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdings_listInclude<ExtArgs> | null;
    where?: superinvestor_holdings_listWhereInput;
    orderBy?:
      | superinvestor_holdings_listOrderByWithRelationInput
      | superinvestor_holdings_listOrderByWithRelationInput[];
    cursor?: superinvestor_holdings_listWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | Superinvestor_holdings_listScalarFieldEnum
      | Superinvestor_holdings_listScalarFieldEnum[];
  };

  /**
   * superinvestor_holdings.superinvestor_sector_analysis
   */
  export type superinvestor_holdings$superinvestor_sector_analysisArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_sector_analysis
     */
    select?: superinvestor_sector_analysisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_sector_analysis
     */
    omit?: superinvestor_sector_analysisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_sector_analysisInclude<ExtArgs> | null;
    where?: superinvestor_sector_analysisWhereInput;
    orderBy?:
      | superinvestor_sector_analysisOrderByWithRelationInput
      | superinvestor_sector_analysisOrderByWithRelationInput[];
    cursor?: superinvestor_sector_analysisWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | Superinvestor_sector_analysisScalarFieldEnum
      | Superinvestor_sector_analysisScalarFieldEnum[];
  };

  /**
   * superinvestor_holdings without action
   */
  export type superinvestor_holdingsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings
     */
    select?: superinvestor_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings
     */
    omit?: superinvestor_holdingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdingsInclude<ExtArgs> | null;
  };

  /**
   * Model superinvestor_holdings_list
   */

  export type AggregateSuperinvestor_holdings_list = {
    _count: Superinvestor_holdings_listCountAggregateOutputType | null;
    _avg: Superinvestor_holdings_listAvgAggregateOutputType | null;
    _sum: Superinvestor_holdings_listSumAggregateOutputType | null;
    _min: Superinvestor_holdings_listMinAggregateOutputType | null;
    _max: Superinvestor_holdings_listMaxAggregateOutputType | null;
  };

  export type Superinvestor_holdings_listAvgAggregateOutputType = {
    id: number | null;
    manager_id: number | null;
    percentage_of_portfolio: Decimal | null;
    share_value: Decimal | null;
    reported_price_value: Decimal | null;
    value: Decimal | null;
  };

  export type Superinvestor_holdings_listSumAggregateOutputType = {
    id: number | null;
    manager_id: number | null;
    percentage_of_portfolio: Decimal | null;
    share_value: Decimal | null;
    reported_price_value: Decimal | null;
    value: Decimal | null;
  };

  export type Superinvestor_holdings_listMinAggregateOutputType = {
    id: number | null;
    manager_id: number | null;
    symbol: string | null;
    percentage_of_portfolio: Decimal | null;
    recent_activity: string | null;
    share_raw: string | null;
    share_value: Decimal | null;
    reported_price_raw: string | null;
    reported_price_value: Decimal | null;
    value_raw: string | null;
    value: Decimal | null;
  };

  export type Superinvestor_holdings_listMaxAggregateOutputType = {
    id: number | null;
    manager_id: number | null;
    symbol: string | null;
    percentage_of_portfolio: Decimal | null;
    recent_activity: string | null;
    share_raw: string | null;
    share_value: Decimal | null;
    reported_price_raw: string | null;
    reported_price_value: Decimal | null;
    value_raw: string | null;
    value: Decimal | null;
  };

  export type Superinvestor_holdings_listCountAggregateOutputType = {
    id: number;
    manager_id: number;
    symbol: number;
    percentage_of_portfolio: number;
    recent_activity: number;
    share_raw: number;
    share_value: number;
    reported_price_raw: number;
    reported_price_value: number;
    value_raw: number;
    value: number;
    _all: number;
  };

  export type Superinvestor_holdings_listAvgAggregateInputType = {
    id?: true;
    manager_id?: true;
    percentage_of_portfolio?: true;
    share_value?: true;
    reported_price_value?: true;
    value?: true;
  };

  export type Superinvestor_holdings_listSumAggregateInputType = {
    id?: true;
    manager_id?: true;
    percentage_of_portfolio?: true;
    share_value?: true;
    reported_price_value?: true;
    value?: true;
  };

  export type Superinvestor_holdings_listMinAggregateInputType = {
    id?: true;
    manager_id?: true;
    symbol?: true;
    percentage_of_portfolio?: true;
    recent_activity?: true;
    share_raw?: true;
    share_value?: true;
    reported_price_raw?: true;
    reported_price_value?: true;
    value_raw?: true;
    value?: true;
  };

  export type Superinvestor_holdings_listMaxAggregateInputType = {
    id?: true;
    manager_id?: true;
    symbol?: true;
    percentage_of_portfolio?: true;
    recent_activity?: true;
    share_raw?: true;
    share_value?: true;
    reported_price_raw?: true;
    reported_price_value?: true;
    value_raw?: true;
    value?: true;
  };

  export type Superinvestor_holdings_listCountAggregateInputType = {
    id?: true;
    manager_id?: true;
    symbol?: true;
    percentage_of_portfolio?: true;
    recent_activity?: true;
    share_raw?: true;
    share_value?: true;
    reported_price_raw?: true;
    reported_price_value?: true;
    value_raw?: true;
    value?: true;
    _all?: true;
  };

  export type Superinvestor_holdings_listAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which superinvestor_holdings_list to aggregate.
     */
    where?: superinvestor_holdings_listWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of superinvestor_holdings_lists to fetch.
     */
    orderBy?:
      | superinvestor_holdings_listOrderByWithRelationInput
      | superinvestor_holdings_listOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: superinvestor_holdings_listWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` superinvestor_holdings_lists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` superinvestor_holdings_lists.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned superinvestor_holdings_lists
     **/
    _count?: true | Superinvestor_holdings_listCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Superinvestor_holdings_listAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Superinvestor_holdings_listSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Superinvestor_holdings_listMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Superinvestor_holdings_listMaxAggregateInputType;
  };

  export type GetSuperinvestor_holdings_listAggregateType<
    T extends Superinvestor_holdings_listAggregateArgs
  > = {
    [P in keyof T & keyof AggregateSuperinvestor_holdings_list]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperinvestor_holdings_list[P]>
      : GetScalarType<T[P], AggregateSuperinvestor_holdings_list[P]>;
  };

  export type superinvestor_holdings_listGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: superinvestor_holdings_listWhereInput;
    orderBy?:
      | superinvestor_holdings_listOrderByWithAggregationInput
      | superinvestor_holdings_listOrderByWithAggregationInput[];
    by:
      | Superinvestor_holdings_listScalarFieldEnum[]
      | Superinvestor_holdings_listScalarFieldEnum;
    having?: superinvestor_holdings_listScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Superinvestor_holdings_listCountAggregateInputType | true;
    _avg?: Superinvestor_holdings_listAvgAggregateInputType;
    _sum?: Superinvestor_holdings_listSumAggregateInputType;
    _min?: Superinvestor_holdings_listMinAggregateInputType;
    _max?: Superinvestor_holdings_listMaxAggregateInputType;
  };

  export type Superinvestor_holdings_listGroupByOutputType = {
    id: number;
    manager_id: number | null;
    symbol: string | null;
    percentage_of_portfolio: Decimal | null;
    recent_activity: string | null;
    share_raw: string | null;
    share_value: Decimal | null;
    reported_price_raw: string | null;
    reported_price_value: Decimal | null;
    value_raw: string | null;
    value: Decimal | null;
    _count: Superinvestor_holdings_listCountAggregateOutputType | null;
    _avg: Superinvestor_holdings_listAvgAggregateOutputType | null;
    _sum: Superinvestor_holdings_listSumAggregateOutputType | null;
    _min: Superinvestor_holdings_listMinAggregateOutputType | null;
    _max: Superinvestor_holdings_listMaxAggregateOutputType | null;
  };

  type GetSuperinvestor_holdings_listGroupByPayload<
    T extends superinvestor_holdings_listGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Superinvestor_holdings_listGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof Superinvestor_holdings_listGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<
                T[P],
                Superinvestor_holdings_listGroupByOutputType[P]
              >
          : GetScalarType<
              T[P],
              Superinvestor_holdings_listGroupByOutputType[P]
            >;
      }
    >
  >;

  export type superinvestor_holdings_listSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      manager_id?: boolean;
      symbol?: boolean;
      percentage_of_portfolio?: boolean;
      recent_activity?: boolean;
      share_raw?: boolean;
      share_value?: boolean;
      reported_price_raw?: boolean;
      reported_price_value?: boolean;
      value_raw?: boolean;
      value?: boolean;
      superinvestor_holdings?:
        | boolean
        | superinvestor_holdings_list$superinvestor_holdingsArgs<ExtArgs>;
    },
    ExtArgs['result']['superinvestor_holdings_list']
  >;

  export type superinvestor_holdings_listSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      manager_id?: boolean;
      symbol?: boolean;
      percentage_of_portfolio?: boolean;
      recent_activity?: boolean;
      share_raw?: boolean;
      share_value?: boolean;
      reported_price_raw?: boolean;
      reported_price_value?: boolean;
      value_raw?: boolean;
      value?: boolean;
      superinvestor_holdings?:
        | boolean
        | superinvestor_holdings_list$superinvestor_holdingsArgs<ExtArgs>;
    },
    ExtArgs['result']['superinvestor_holdings_list']
  >;

  export type superinvestor_holdings_listSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      manager_id?: boolean;
      symbol?: boolean;
      percentage_of_portfolio?: boolean;
      recent_activity?: boolean;
      share_raw?: boolean;
      share_value?: boolean;
      reported_price_raw?: boolean;
      reported_price_value?: boolean;
      value_raw?: boolean;
      value?: boolean;
      superinvestor_holdings?:
        | boolean
        | superinvestor_holdings_list$superinvestor_holdingsArgs<ExtArgs>;
    },
    ExtArgs['result']['superinvestor_holdings_list']
  >;

  export type superinvestor_holdings_listSelectScalar = {
    id?: boolean;
    manager_id?: boolean;
    symbol?: boolean;
    percentage_of_portfolio?: boolean;
    recent_activity?: boolean;
    share_raw?: boolean;
    share_value?: boolean;
    reported_price_raw?: boolean;
    reported_price_value?: boolean;
    value_raw?: boolean;
    value?: boolean;
  };

  export type superinvestor_holdings_listOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'manager_id'
    | 'symbol'
    | 'percentage_of_portfolio'
    | 'recent_activity'
    | 'share_raw'
    | 'share_value'
    | 'reported_price_raw'
    | 'reported_price_value'
    | 'value_raw'
    | 'value',
    ExtArgs['result']['superinvestor_holdings_list']
  >;
  export type superinvestor_holdings_listInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    superinvestor_holdings?:
      | boolean
      | superinvestor_holdings_list$superinvestor_holdingsArgs<ExtArgs>;
  };
  export type superinvestor_holdings_listIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    superinvestor_holdings?:
      | boolean
      | superinvestor_holdings_list$superinvestor_holdingsArgs<ExtArgs>;
  };
  export type superinvestor_holdings_listIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    superinvestor_holdings?:
      | boolean
      | superinvestor_holdings_list$superinvestor_holdingsArgs<ExtArgs>;
  };

  export type $superinvestor_holdings_listPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'superinvestor_holdings_list';
    objects: {
      superinvestor_holdings: Prisma.$superinvestor_holdingsPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        manager_id: number | null;
        symbol: string | null;
        percentage_of_portfolio: Prisma.Decimal | null;
        recent_activity: string | null;
        share_raw: string | null;
        share_value: Prisma.Decimal | null;
        reported_price_raw: string | null;
        reported_price_value: Prisma.Decimal | null;
        value_raw: string | null;
        value: Prisma.Decimal | null;
      },
      ExtArgs['result']['superinvestor_holdings_list']
    >;
    composites: {};
  };

  type superinvestor_holdings_listGetPayload<
    S extends
      | boolean
      | null
      | undefined
      | superinvestor_holdings_listDefaultArgs
  > = $Result.GetResult<Prisma.$superinvestor_holdings_listPayload, S>;

  type superinvestor_holdings_listCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    superinvestor_holdings_listFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Superinvestor_holdings_listCountAggregateInputType | true;
  };

  export interface superinvestor_holdings_listDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['superinvestor_holdings_list'];
      meta: { name: 'superinvestor_holdings_list' };
    };
    /**
     * Find zero or one Superinvestor_holdings_list that matches the filter.
     * @param {superinvestor_holdings_listFindUniqueArgs} args - Arguments to find a Superinvestor_holdings_list
     * @example
     * // Get one Superinvestor_holdings_list
     * const superinvestor_holdings_list = await prisma.superinvestor_holdings_list.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends superinvestor_holdings_listFindUniqueArgs>(
      args: SelectSubset<T, superinvestor_holdings_listFindUniqueArgs<ExtArgs>>
    ): Prisma__superinvestor_holdings_listClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdings_listPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Superinvestor_holdings_list that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {superinvestor_holdings_listFindUniqueOrThrowArgs} args - Arguments to find a Superinvestor_holdings_list
     * @example
     * // Get one Superinvestor_holdings_list
     * const superinvestor_holdings_list = await prisma.superinvestor_holdings_list.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<
      T extends superinvestor_holdings_listFindUniqueOrThrowArgs
    >(
      args: SelectSubset<
        T,
        superinvestor_holdings_listFindUniqueOrThrowArgs<ExtArgs>
      >
    ): Prisma__superinvestor_holdings_listClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdings_listPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Superinvestor_holdings_list that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_holdings_listFindFirstArgs} args - Arguments to find a Superinvestor_holdings_list
     * @example
     * // Get one Superinvestor_holdings_list
     * const superinvestor_holdings_list = await prisma.superinvestor_holdings_list.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends superinvestor_holdings_listFindFirstArgs>(
      args?: SelectSubset<T, superinvestor_holdings_listFindFirstArgs<ExtArgs>>
    ): Prisma__superinvestor_holdings_listClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdings_listPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Superinvestor_holdings_list that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_holdings_listFindFirstOrThrowArgs} args - Arguments to find a Superinvestor_holdings_list
     * @example
     * // Get one Superinvestor_holdings_list
     * const superinvestor_holdings_list = await prisma.superinvestor_holdings_list.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends superinvestor_holdings_listFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        superinvestor_holdings_listFindFirstOrThrowArgs<ExtArgs>
      >
    ): Prisma__superinvestor_holdings_listClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdings_listPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Superinvestor_holdings_lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_holdings_listFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Superinvestor_holdings_lists
     * const superinvestor_holdings_lists = await prisma.superinvestor_holdings_list.findMany()
     *
     * // Get first 10 Superinvestor_holdings_lists
     * const superinvestor_holdings_lists = await prisma.superinvestor_holdings_list.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const superinvestor_holdings_listWithIdOnly = await prisma.superinvestor_holdings_list.findMany({ select: { id: true } })
     *
     */
    findMany<T extends superinvestor_holdings_listFindManyArgs>(
      args?: SelectSubset<T, superinvestor_holdings_listFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$superinvestor_holdings_listPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Superinvestor_holdings_list.
     * @param {superinvestor_holdings_listCreateArgs} args - Arguments to create a Superinvestor_holdings_list.
     * @example
     * // Create one Superinvestor_holdings_list
     * const Superinvestor_holdings_list = await prisma.superinvestor_holdings_list.create({
     *   data: {
     *     // ... data to create a Superinvestor_holdings_list
     *   }
     * })
     *
     */
    create<T extends superinvestor_holdings_listCreateArgs>(
      args: SelectSubset<T, superinvestor_holdings_listCreateArgs<ExtArgs>>
    ): Prisma__superinvestor_holdings_listClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdings_listPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Superinvestor_holdings_lists.
     * @param {superinvestor_holdings_listCreateManyArgs} args - Arguments to create many Superinvestor_holdings_lists.
     * @example
     * // Create many Superinvestor_holdings_lists
     * const superinvestor_holdings_list = await prisma.superinvestor_holdings_list.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends superinvestor_holdings_listCreateManyArgs>(
      args?: SelectSubset<T, superinvestor_holdings_listCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Superinvestor_holdings_lists and returns the data saved in the database.
     * @param {superinvestor_holdings_listCreateManyAndReturnArgs} args - Arguments to create many Superinvestor_holdings_lists.
     * @example
     * // Create many Superinvestor_holdings_lists
     * const superinvestor_holdings_list = await prisma.superinvestor_holdings_list.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Superinvestor_holdings_lists and only return the `id`
     * const superinvestor_holdings_listWithIdOnly = await prisma.superinvestor_holdings_list.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends superinvestor_holdings_listCreateManyAndReturnArgs
    >(
      args?: SelectSubset<
        T,
        superinvestor_holdings_listCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$superinvestor_holdings_listPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Superinvestor_holdings_list.
     * @param {superinvestor_holdings_listDeleteArgs} args - Arguments to delete one Superinvestor_holdings_list.
     * @example
     * // Delete one Superinvestor_holdings_list
     * const Superinvestor_holdings_list = await prisma.superinvestor_holdings_list.delete({
     *   where: {
     *     // ... filter to delete one Superinvestor_holdings_list
     *   }
     * })
     *
     */
    delete<T extends superinvestor_holdings_listDeleteArgs>(
      args: SelectSubset<T, superinvestor_holdings_listDeleteArgs<ExtArgs>>
    ): Prisma__superinvestor_holdings_listClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdings_listPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Superinvestor_holdings_list.
     * @param {superinvestor_holdings_listUpdateArgs} args - Arguments to update one Superinvestor_holdings_list.
     * @example
     * // Update one Superinvestor_holdings_list
     * const superinvestor_holdings_list = await prisma.superinvestor_holdings_list.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends superinvestor_holdings_listUpdateArgs>(
      args: SelectSubset<T, superinvestor_holdings_listUpdateArgs<ExtArgs>>
    ): Prisma__superinvestor_holdings_listClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdings_listPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Superinvestor_holdings_lists.
     * @param {superinvestor_holdings_listDeleteManyArgs} args - Arguments to filter Superinvestor_holdings_lists to delete.
     * @example
     * // Delete a few Superinvestor_holdings_lists
     * const { count } = await prisma.superinvestor_holdings_list.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends superinvestor_holdings_listDeleteManyArgs>(
      args?: SelectSubset<T, superinvestor_holdings_listDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Superinvestor_holdings_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_holdings_listUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Superinvestor_holdings_lists
     * const superinvestor_holdings_list = await prisma.superinvestor_holdings_list.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends superinvestor_holdings_listUpdateManyArgs>(
      args: SelectSubset<T, superinvestor_holdings_listUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Superinvestor_holdings_lists and returns the data updated in the database.
     * @param {superinvestor_holdings_listUpdateManyAndReturnArgs} args - Arguments to update many Superinvestor_holdings_lists.
     * @example
     * // Update many Superinvestor_holdings_lists
     * const superinvestor_holdings_list = await prisma.superinvestor_holdings_list.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Superinvestor_holdings_lists and only return the `id`
     * const superinvestor_holdings_listWithIdOnly = await prisma.superinvestor_holdings_list.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends superinvestor_holdings_listUpdateManyAndReturnArgs
    >(
      args: SelectSubset<
        T,
        superinvestor_holdings_listUpdateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$superinvestor_holdings_listPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Superinvestor_holdings_list.
     * @param {superinvestor_holdings_listUpsertArgs} args - Arguments to update or create a Superinvestor_holdings_list.
     * @example
     * // Update or create a Superinvestor_holdings_list
     * const superinvestor_holdings_list = await prisma.superinvestor_holdings_list.upsert({
     *   create: {
     *     // ... data to create a Superinvestor_holdings_list
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Superinvestor_holdings_list we want to update
     *   }
     * })
     */
    upsert<T extends superinvestor_holdings_listUpsertArgs>(
      args: SelectSubset<T, superinvestor_holdings_listUpsertArgs<ExtArgs>>
    ): Prisma__superinvestor_holdings_listClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdings_listPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Superinvestor_holdings_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_holdings_listCountArgs} args - Arguments to filter Superinvestor_holdings_lists to count.
     * @example
     * // Count the number of Superinvestor_holdings_lists
     * const count = await prisma.superinvestor_holdings_list.count({
     *   where: {
     *     // ... the filter for the Superinvestor_holdings_lists we want to count
     *   }
     * })
     **/
    count<T extends superinvestor_holdings_listCountArgs>(
      args?: Subset<T, superinvestor_holdings_listCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              Superinvestor_holdings_listCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Superinvestor_holdings_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Superinvestor_holdings_listAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Superinvestor_holdings_listAggregateArgs>(
      args: Subset<T, Superinvestor_holdings_listAggregateArgs>
    ): Prisma.PrismaPromise<GetSuperinvestor_holdings_listAggregateType<T>>;

    /**
     * Group by Superinvestor_holdings_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_holdings_listGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends superinvestor_holdings_listGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: superinvestor_holdings_listGroupByArgs['orderBy'] }
        : { orderBy?: superinvestor_holdings_listGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<
        T,
        superinvestor_holdings_listGroupByArgs,
        OrderByArg
      > &
        InputErrors
    ): {} extends InputErrors
      ? GetSuperinvestor_holdings_listGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the superinvestor_holdings_list model
     */
    readonly fields: superinvestor_holdings_listFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for superinvestor_holdings_list.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__superinvestor_holdings_listClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    superinvestor_holdings<
      T extends
        superinvestor_holdings_list$superinvestor_holdingsArgs<ExtArgs> = {}
    >(
      args?: Subset<
        T,
        superinvestor_holdings_list$superinvestor_holdingsArgs<ExtArgs>
      >
    ): Prisma__superinvestor_holdingsClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdingsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the superinvestor_holdings_list model
   */
  interface superinvestor_holdings_listFieldRefs {
    readonly id: FieldRef<'superinvestor_holdings_list', 'Int'>;
    readonly manager_id: FieldRef<'superinvestor_holdings_list', 'Int'>;
    readonly symbol: FieldRef<'superinvestor_holdings_list', 'String'>;
    readonly percentage_of_portfolio: FieldRef<
      'superinvestor_holdings_list',
      'Decimal'
    >;
    readonly recent_activity: FieldRef<'superinvestor_holdings_list', 'String'>;
    readonly share_raw: FieldRef<'superinvestor_holdings_list', 'String'>;
    readonly share_value: FieldRef<'superinvestor_holdings_list', 'Decimal'>;
    readonly reported_price_raw: FieldRef<
      'superinvestor_holdings_list',
      'String'
    >;
    readonly reported_price_value: FieldRef<
      'superinvestor_holdings_list',
      'Decimal'
    >;
    readonly value_raw: FieldRef<'superinvestor_holdings_list', 'String'>;
    readonly value: FieldRef<'superinvestor_holdings_list', 'Decimal'>;
  }

  // Custom InputTypes
  /**
   * superinvestor_holdings_list findUnique
   */
  export type superinvestor_holdings_listFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings_list
     */
    select?: superinvestor_holdings_listSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings_list
     */
    omit?: superinvestor_holdings_listOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdings_listInclude<ExtArgs> | null;
    /**
     * Filter, which superinvestor_holdings_list to fetch.
     */
    where: superinvestor_holdings_listWhereUniqueInput;
  };

  /**
   * superinvestor_holdings_list findUniqueOrThrow
   */
  export type superinvestor_holdings_listFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings_list
     */
    select?: superinvestor_holdings_listSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings_list
     */
    omit?: superinvestor_holdings_listOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdings_listInclude<ExtArgs> | null;
    /**
     * Filter, which superinvestor_holdings_list to fetch.
     */
    where: superinvestor_holdings_listWhereUniqueInput;
  };

  /**
   * superinvestor_holdings_list findFirst
   */
  export type superinvestor_holdings_listFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings_list
     */
    select?: superinvestor_holdings_listSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings_list
     */
    omit?: superinvestor_holdings_listOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdings_listInclude<ExtArgs> | null;
    /**
     * Filter, which superinvestor_holdings_list to fetch.
     */
    where?: superinvestor_holdings_listWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of superinvestor_holdings_lists to fetch.
     */
    orderBy?:
      | superinvestor_holdings_listOrderByWithRelationInput
      | superinvestor_holdings_listOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for superinvestor_holdings_lists.
     */
    cursor?: superinvestor_holdings_listWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` superinvestor_holdings_lists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` superinvestor_holdings_lists.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of superinvestor_holdings_lists.
     */
    distinct?:
      | Superinvestor_holdings_listScalarFieldEnum
      | Superinvestor_holdings_listScalarFieldEnum[];
  };

  /**
   * superinvestor_holdings_list findFirstOrThrow
   */
  export type superinvestor_holdings_listFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings_list
     */
    select?: superinvestor_holdings_listSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings_list
     */
    omit?: superinvestor_holdings_listOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdings_listInclude<ExtArgs> | null;
    /**
     * Filter, which superinvestor_holdings_list to fetch.
     */
    where?: superinvestor_holdings_listWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of superinvestor_holdings_lists to fetch.
     */
    orderBy?:
      | superinvestor_holdings_listOrderByWithRelationInput
      | superinvestor_holdings_listOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for superinvestor_holdings_lists.
     */
    cursor?: superinvestor_holdings_listWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` superinvestor_holdings_lists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` superinvestor_holdings_lists.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of superinvestor_holdings_lists.
     */
    distinct?:
      | Superinvestor_holdings_listScalarFieldEnum
      | Superinvestor_holdings_listScalarFieldEnum[];
  };

  /**
   * superinvestor_holdings_list findMany
   */
  export type superinvestor_holdings_listFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings_list
     */
    select?: superinvestor_holdings_listSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings_list
     */
    omit?: superinvestor_holdings_listOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdings_listInclude<ExtArgs> | null;
    /**
     * Filter, which superinvestor_holdings_lists to fetch.
     */
    where?: superinvestor_holdings_listWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of superinvestor_holdings_lists to fetch.
     */
    orderBy?:
      | superinvestor_holdings_listOrderByWithRelationInput
      | superinvestor_holdings_listOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing superinvestor_holdings_lists.
     */
    cursor?: superinvestor_holdings_listWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` superinvestor_holdings_lists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` superinvestor_holdings_lists.
     */
    skip?: number;
    distinct?:
      | Superinvestor_holdings_listScalarFieldEnum
      | Superinvestor_holdings_listScalarFieldEnum[];
  };

  /**
   * superinvestor_holdings_list create
   */
  export type superinvestor_holdings_listCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings_list
     */
    select?: superinvestor_holdings_listSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings_list
     */
    omit?: superinvestor_holdings_listOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdings_listInclude<ExtArgs> | null;
    /**
     * The data needed to create a superinvestor_holdings_list.
     */
    data?: XOR<
      superinvestor_holdings_listCreateInput,
      superinvestor_holdings_listUncheckedCreateInput
    >;
  };

  /**
   * superinvestor_holdings_list createMany
   */
  export type superinvestor_holdings_listCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many superinvestor_holdings_lists.
     */
    data:
      | superinvestor_holdings_listCreateManyInput
      | superinvestor_holdings_listCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * superinvestor_holdings_list createManyAndReturn
   */
  export type superinvestor_holdings_listCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings_list
     */
    select?: superinvestor_holdings_listSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings_list
     */
    omit?: superinvestor_holdings_listOmit<ExtArgs> | null;
    /**
     * The data used to create many superinvestor_holdings_lists.
     */
    data:
      | superinvestor_holdings_listCreateManyInput
      | superinvestor_holdings_listCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdings_listIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * superinvestor_holdings_list update
   */
  export type superinvestor_holdings_listUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings_list
     */
    select?: superinvestor_holdings_listSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings_list
     */
    omit?: superinvestor_holdings_listOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdings_listInclude<ExtArgs> | null;
    /**
     * The data needed to update a superinvestor_holdings_list.
     */
    data: XOR<
      superinvestor_holdings_listUpdateInput,
      superinvestor_holdings_listUncheckedUpdateInput
    >;
    /**
     * Choose, which superinvestor_holdings_list to update.
     */
    where: superinvestor_holdings_listWhereUniqueInput;
  };

  /**
   * superinvestor_holdings_list updateMany
   */
  export type superinvestor_holdings_listUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update superinvestor_holdings_lists.
     */
    data: XOR<
      superinvestor_holdings_listUpdateManyMutationInput,
      superinvestor_holdings_listUncheckedUpdateManyInput
    >;
    /**
     * Filter which superinvestor_holdings_lists to update
     */
    where?: superinvestor_holdings_listWhereInput;
    /**
     * Limit how many superinvestor_holdings_lists to update.
     */
    limit?: number;
  };

  /**
   * superinvestor_holdings_list updateManyAndReturn
   */
  export type superinvestor_holdings_listUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings_list
     */
    select?: superinvestor_holdings_listSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings_list
     */
    omit?: superinvestor_holdings_listOmit<ExtArgs> | null;
    /**
     * The data used to update superinvestor_holdings_lists.
     */
    data: XOR<
      superinvestor_holdings_listUpdateManyMutationInput,
      superinvestor_holdings_listUncheckedUpdateManyInput
    >;
    /**
     * Filter which superinvestor_holdings_lists to update
     */
    where?: superinvestor_holdings_listWhereInput;
    /**
     * Limit how many superinvestor_holdings_lists to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdings_listIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * superinvestor_holdings_list upsert
   */
  export type superinvestor_holdings_listUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings_list
     */
    select?: superinvestor_holdings_listSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings_list
     */
    omit?: superinvestor_holdings_listOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdings_listInclude<ExtArgs> | null;
    /**
     * The filter to search for the superinvestor_holdings_list to update in case it exists.
     */
    where: superinvestor_holdings_listWhereUniqueInput;
    /**
     * In case the superinvestor_holdings_list found by the `where` argument doesn't exist, create a new superinvestor_holdings_list with this data.
     */
    create: XOR<
      superinvestor_holdings_listCreateInput,
      superinvestor_holdings_listUncheckedCreateInput
    >;
    /**
     * In case the superinvestor_holdings_list was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      superinvestor_holdings_listUpdateInput,
      superinvestor_holdings_listUncheckedUpdateInput
    >;
  };

  /**
   * superinvestor_holdings_list delete
   */
  export type superinvestor_holdings_listDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings_list
     */
    select?: superinvestor_holdings_listSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings_list
     */
    omit?: superinvestor_holdings_listOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdings_listInclude<ExtArgs> | null;
    /**
     * Filter which superinvestor_holdings_list to delete.
     */
    where: superinvestor_holdings_listWhereUniqueInput;
  };

  /**
   * superinvestor_holdings_list deleteMany
   */
  export type superinvestor_holdings_listDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which superinvestor_holdings_lists to delete
     */
    where?: superinvestor_holdings_listWhereInput;
    /**
     * Limit how many superinvestor_holdings_lists to delete.
     */
    limit?: number;
  };

  /**
   * superinvestor_holdings_list.superinvestor_holdings
   */
  export type superinvestor_holdings_list$superinvestor_holdingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings
     */
    select?: superinvestor_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings
     */
    omit?: superinvestor_holdingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdingsInclude<ExtArgs> | null;
    where?: superinvestor_holdingsWhereInput;
  };

  /**
   * superinvestor_holdings_list without action
   */
  export type superinvestor_holdings_listDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings_list
     */
    select?: superinvestor_holdings_listSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings_list
     */
    omit?: superinvestor_holdings_listOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdings_listInclude<ExtArgs> | null;
  };

  /**
   * Model superinvestor_sector_analysis
   */

  export type AggregateSuperinvestor_sector_analysis = {
    _count: Superinvestor_sector_analysisCountAggregateOutputType | null;
    _avg: Superinvestor_sector_analysisAvgAggregateOutputType | null;
    _sum: Superinvestor_sector_analysisSumAggregateOutputType | null;
    _min: Superinvestor_sector_analysisMinAggregateOutputType | null;
    _max: Superinvestor_sector_analysisMaxAggregateOutputType | null;
  };

  export type Superinvestor_sector_analysisAvgAggregateOutputType = {
    id: number | null;
    manager_id: number | null;
    sector_percentage: Decimal | null;
  };

  export type Superinvestor_sector_analysisSumAggregateOutputType = {
    id: number | null;
    manager_id: number | null;
    sector_percentage: Decimal | null;
  };

  export type Superinvestor_sector_analysisMinAggregateOutputType = {
    id: number | null;
    manager_id: number | null;
    sector_name: string | null;
    sector_percentage: Decimal | null;
  };

  export type Superinvestor_sector_analysisMaxAggregateOutputType = {
    id: number | null;
    manager_id: number | null;
    sector_name: string | null;
    sector_percentage: Decimal | null;
  };

  export type Superinvestor_sector_analysisCountAggregateOutputType = {
    id: number;
    manager_id: number;
    sector_name: number;
    sector_percentage: number;
    _all: number;
  };

  export type Superinvestor_sector_analysisAvgAggregateInputType = {
    id?: true;
    manager_id?: true;
    sector_percentage?: true;
  };

  export type Superinvestor_sector_analysisSumAggregateInputType = {
    id?: true;
    manager_id?: true;
    sector_percentage?: true;
  };

  export type Superinvestor_sector_analysisMinAggregateInputType = {
    id?: true;
    manager_id?: true;
    sector_name?: true;
    sector_percentage?: true;
  };

  export type Superinvestor_sector_analysisMaxAggregateInputType = {
    id?: true;
    manager_id?: true;
    sector_name?: true;
    sector_percentage?: true;
  };

  export type Superinvestor_sector_analysisCountAggregateInputType = {
    id?: true;
    manager_id?: true;
    sector_name?: true;
    sector_percentage?: true;
    _all?: true;
  };

  export type Superinvestor_sector_analysisAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which superinvestor_sector_analysis to aggregate.
     */
    where?: superinvestor_sector_analysisWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of superinvestor_sector_analyses to fetch.
     */
    orderBy?:
      | superinvestor_sector_analysisOrderByWithRelationInput
      | superinvestor_sector_analysisOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: superinvestor_sector_analysisWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` superinvestor_sector_analyses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` superinvestor_sector_analyses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned superinvestor_sector_analyses
     **/
    _count?: true | Superinvestor_sector_analysisCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Superinvestor_sector_analysisAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Superinvestor_sector_analysisSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Superinvestor_sector_analysisMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Superinvestor_sector_analysisMaxAggregateInputType;
  };

  export type GetSuperinvestor_sector_analysisAggregateType<
    T extends Superinvestor_sector_analysisAggregateArgs
  > = {
    [P in keyof T & keyof AggregateSuperinvestor_sector_analysis]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperinvestor_sector_analysis[P]>
      : GetScalarType<T[P], AggregateSuperinvestor_sector_analysis[P]>;
  };

  export type superinvestor_sector_analysisGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: superinvestor_sector_analysisWhereInput;
    orderBy?:
      | superinvestor_sector_analysisOrderByWithAggregationInput
      | superinvestor_sector_analysisOrderByWithAggregationInput[];
    by:
      | Superinvestor_sector_analysisScalarFieldEnum[]
      | Superinvestor_sector_analysisScalarFieldEnum;
    having?: superinvestor_sector_analysisScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Superinvestor_sector_analysisCountAggregateInputType | true;
    _avg?: Superinvestor_sector_analysisAvgAggregateInputType;
    _sum?: Superinvestor_sector_analysisSumAggregateInputType;
    _min?: Superinvestor_sector_analysisMinAggregateInputType;
    _max?: Superinvestor_sector_analysisMaxAggregateInputType;
  };

  export type Superinvestor_sector_analysisGroupByOutputType = {
    id: number;
    manager_id: number | null;
    sector_name: string | null;
    sector_percentage: Decimal | null;
    _count: Superinvestor_sector_analysisCountAggregateOutputType | null;
    _avg: Superinvestor_sector_analysisAvgAggregateOutputType | null;
    _sum: Superinvestor_sector_analysisSumAggregateOutputType | null;
    _min: Superinvestor_sector_analysisMinAggregateOutputType | null;
    _max: Superinvestor_sector_analysisMaxAggregateOutputType | null;
  };

  type GetSuperinvestor_sector_analysisGroupByPayload<
    T extends superinvestor_sector_analysisGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<
        Superinvestor_sector_analysisGroupByOutputType,
        T['by']
      > & {
        [P in keyof T &
          keyof Superinvestor_sector_analysisGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<
                T[P],
                Superinvestor_sector_analysisGroupByOutputType[P]
              >
          : GetScalarType<
              T[P],
              Superinvestor_sector_analysisGroupByOutputType[P]
            >;
      }
    >
  >;

  export type superinvestor_sector_analysisSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      manager_id?: boolean;
      sector_name?: boolean;
      sector_percentage?: boolean;
      superinvestor_holdings?:
        | boolean
        | superinvestor_sector_analysis$superinvestor_holdingsArgs<ExtArgs>;
    },
    ExtArgs['result']['superinvestor_sector_analysis']
  >;

  export type superinvestor_sector_analysisSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      manager_id?: boolean;
      sector_name?: boolean;
      sector_percentage?: boolean;
      superinvestor_holdings?:
        | boolean
        | superinvestor_sector_analysis$superinvestor_holdingsArgs<ExtArgs>;
    },
    ExtArgs['result']['superinvestor_sector_analysis']
  >;

  export type superinvestor_sector_analysisSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      manager_id?: boolean;
      sector_name?: boolean;
      sector_percentage?: boolean;
      superinvestor_holdings?:
        | boolean
        | superinvestor_sector_analysis$superinvestor_holdingsArgs<ExtArgs>;
    },
    ExtArgs['result']['superinvestor_sector_analysis']
  >;

  export type superinvestor_sector_analysisSelectScalar = {
    id?: boolean;
    manager_id?: boolean;
    sector_name?: boolean;
    sector_percentage?: boolean;
  };

  export type superinvestor_sector_analysisOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id' | 'manager_id' | 'sector_name' | 'sector_percentage',
    ExtArgs['result']['superinvestor_sector_analysis']
  >;
  export type superinvestor_sector_analysisInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    superinvestor_holdings?:
      | boolean
      | superinvestor_sector_analysis$superinvestor_holdingsArgs<ExtArgs>;
  };
  export type superinvestor_sector_analysisIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    superinvestor_holdings?:
      | boolean
      | superinvestor_sector_analysis$superinvestor_holdingsArgs<ExtArgs>;
  };
  export type superinvestor_sector_analysisIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    superinvestor_holdings?:
      | boolean
      | superinvestor_sector_analysis$superinvestor_holdingsArgs<ExtArgs>;
  };

  export type $superinvestor_sector_analysisPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'superinvestor_sector_analysis';
    objects: {
      superinvestor_holdings: Prisma.$superinvestor_holdingsPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        manager_id: number | null;
        sector_name: string | null;
        sector_percentage: Prisma.Decimal | null;
      },
      ExtArgs['result']['superinvestor_sector_analysis']
    >;
    composites: {};
  };

  type superinvestor_sector_analysisGetPayload<
    S extends
      | boolean
      | null
      | undefined
      | superinvestor_sector_analysisDefaultArgs
  > = $Result.GetResult<Prisma.$superinvestor_sector_analysisPayload, S>;

  type superinvestor_sector_analysisCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    superinvestor_sector_analysisFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Superinvestor_sector_analysisCountAggregateInputType | true;
  };

  export interface superinvestor_sector_analysisDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['superinvestor_sector_analysis'];
      meta: { name: 'superinvestor_sector_analysis' };
    };
    /**
     * Find zero or one Superinvestor_sector_analysis that matches the filter.
     * @param {superinvestor_sector_analysisFindUniqueArgs} args - Arguments to find a Superinvestor_sector_analysis
     * @example
     * // Get one Superinvestor_sector_analysis
     * const superinvestor_sector_analysis = await prisma.superinvestor_sector_analysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends superinvestor_sector_analysisFindUniqueArgs>(
      args: SelectSubset<
        T,
        superinvestor_sector_analysisFindUniqueArgs<ExtArgs>
      >
    ): Prisma__superinvestor_sector_analysisClient<
      $Result.GetResult<
        Prisma.$superinvestor_sector_analysisPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Superinvestor_sector_analysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {superinvestor_sector_analysisFindUniqueOrThrowArgs} args - Arguments to find a Superinvestor_sector_analysis
     * @example
     * // Get one Superinvestor_sector_analysis
     * const superinvestor_sector_analysis = await prisma.superinvestor_sector_analysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<
      T extends superinvestor_sector_analysisFindUniqueOrThrowArgs
    >(
      args: SelectSubset<
        T,
        superinvestor_sector_analysisFindUniqueOrThrowArgs<ExtArgs>
      >
    ): Prisma__superinvestor_sector_analysisClient<
      $Result.GetResult<
        Prisma.$superinvestor_sector_analysisPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Superinvestor_sector_analysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_sector_analysisFindFirstArgs} args - Arguments to find a Superinvestor_sector_analysis
     * @example
     * // Get one Superinvestor_sector_analysis
     * const superinvestor_sector_analysis = await prisma.superinvestor_sector_analysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends superinvestor_sector_analysisFindFirstArgs>(
      args?: SelectSubset<
        T,
        superinvestor_sector_analysisFindFirstArgs<ExtArgs>
      >
    ): Prisma__superinvestor_sector_analysisClient<
      $Result.GetResult<
        Prisma.$superinvestor_sector_analysisPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Superinvestor_sector_analysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_sector_analysisFindFirstOrThrowArgs} args - Arguments to find a Superinvestor_sector_analysis
     * @example
     * // Get one Superinvestor_sector_analysis
     * const superinvestor_sector_analysis = await prisma.superinvestor_sector_analysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<
      T extends superinvestor_sector_analysisFindFirstOrThrowArgs
    >(
      args?: SelectSubset<
        T,
        superinvestor_sector_analysisFindFirstOrThrowArgs<ExtArgs>
      >
    ): Prisma__superinvestor_sector_analysisClient<
      $Result.GetResult<
        Prisma.$superinvestor_sector_analysisPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Superinvestor_sector_analyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_sector_analysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Superinvestor_sector_analyses
     * const superinvestor_sector_analyses = await prisma.superinvestor_sector_analysis.findMany()
     *
     * // Get first 10 Superinvestor_sector_analyses
     * const superinvestor_sector_analyses = await prisma.superinvestor_sector_analysis.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const superinvestor_sector_analysisWithIdOnly = await prisma.superinvestor_sector_analysis.findMany({ select: { id: true } })
     *
     */
    findMany<T extends superinvestor_sector_analysisFindManyArgs>(
      args?: SelectSubset<T, superinvestor_sector_analysisFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$superinvestor_sector_analysisPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Superinvestor_sector_analysis.
     * @param {superinvestor_sector_analysisCreateArgs} args - Arguments to create a Superinvestor_sector_analysis.
     * @example
     * // Create one Superinvestor_sector_analysis
     * const Superinvestor_sector_analysis = await prisma.superinvestor_sector_analysis.create({
     *   data: {
     *     // ... data to create a Superinvestor_sector_analysis
     *   }
     * })
     *
     */
    create<T extends superinvestor_sector_analysisCreateArgs>(
      args: SelectSubset<T, superinvestor_sector_analysisCreateArgs<ExtArgs>>
    ): Prisma__superinvestor_sector_analysisClient<
      $Result.GetResult<
        Prisma.$superinvestor_sector_analysisPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Superinvestor_sector_analyses.
     * @param {superinvestor_sector_analysisCreateManyArgs} args - Arguments to create many Superinvestor_sector_analyses.
     * @example
     * // Create many Superinvestor_sector_analyses
     * const superinvestor_sector_analysis = await prisma.superinvestor_sector_analysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends superinvestor_sector_analysisCreateManyArgs>(
      args?: SelectSubset<
        T,
        superinvestor_sector_analysisCreateManyArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Superinvestor_sector_analyses and returns the data saved in the database.
     * @param {superinvestor_sector_analysisCreateManyAndReturnArgs} args - Arguments to create many Superinvestor_sector_analyses.
     * @example
     * // Create many Superinvestor_sector_analyses
     * const superinvestor_sector_analysis = await prisma.superinvestor_sector_analysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Superinvestor_sector_analyses and only return the `id`
     * const superinvestor_sector_analysisWithIdOnly = await prisma.superinvestor_sector_analysis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends superinvestor_sector_analysisCreateManyAndReturnArgs
    >(
      args?: SelectSubset<
        T,
        superinvestor_sector_analysisCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$superinvestor_sector_analysisPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Superinvestor_sector_analysis.
     * @param {superinvestor_sector_analysisDeleteArgs} args - Arguments to delete one Superinvestor_sector_analysis.
     * @example
     * // Delete one Superinvestor_sector_analysis
     * const Superinvestor_sector_analysis = await prisma.superinvestor_sector_analysis.delete({
     *   where: {
     *     // ... filter to delete one Superinvestor_sector_analysis
     *   }
     * })
     *
     */
    delete<T extends superinvestor_sector_analysisDeleteArgs>(
      args: SelectSubset<T, superinvestor_sector_analysisDeleteArgs<ExtArgs>>
    ): Prisma__superinvestor_sector_analysisClient<
      $Result.GetResult<
        Prisma.$superinvestor_sector_analysisPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Superinvestor_sector_analysis.
     * @param {superinvestor_sector_analysisUpdateArgs} args - Arguments to update one Superinvestor_sector_analysis.
     * @example
     * // Update one Superinvestor_sector_analysis
     * const superinvestor_sector_analysis = await prisma.superinvestor_sector_analysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends superinvestor_sector_analysisUpdateArgs>(
      args: SelectSubset<T, superinvestor_sector_analysisUpdateArgs<ExtArgs>>
    ): Prisma__superinvestor_sector_analysisClient<
      $Result.GetResult<
        Prisma.$superinvestor_sector_analysisPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Superinvestor_sector_analyses.
     * @param {superinvestor_sector_analysisDeleteManyArgs} args - Arguments to filter Superinvestor_sector_analyses to delete.
     * @example
     * // Delete a few Superinvestor_sector_analyses
     * const { count } = await prisma.superinvestor_sector_analysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends superinvestor_sector_analysisDeleteManyArgs>(
      args?: SelectSubset<
        T,
        superinvestor_sector_analysisDeleteManyArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Superinvestor_sector_analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_sector_analysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Superinvestor_sector_analyses
     * const superinvestor_sector_analysis = await prisma.superinvestor_sector_analysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends superinvestor_sector_analysisUpdateManyArgs>(
      args: SelectSubset<
        T,
        superinvestor_sector_analysisUpdateManyArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Superinvestor_sector_analyses and returns the data updated in the database.
     * @param {superinvestor_sector_analysisUpdateManyAndReturnArgs} args - Arguments to update many Superinvestor_sector_analyses.
     * @example
     * // Update many Superinvestor_sector_analyses
     * const superinvestor_sector_analysis = await prisma.superinvestor_sector_analysis.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Superinvestor_sector_analyses and only return the `id`
     * const superinvestor_sector_analysisWithIdOnly = await prisma.superinvestor_sector_analysis.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends superinvestor_sector_analysisUpdateManyAndReturnArgs
    >(
      args: SelectSubset<
        T,
        superinvestor_sector_analysisUpdateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$superinvestor_sector_analysisPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Superinvestor_sector_analysis.
     * @param {superinvestor_sector_analysisUpsertArgs} args - Arguments to update or create a Superinvestor_sector_analysis.
     * @example
     * // Update or create a Superinvestor_sector_analysis
     * const superinvestor_sector_analysis = await prisma.superinvestor_sector_analysis.upsert({
     *   create: {
     *     // ... data to create a Superinvestor_sector_analysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Superinvestor_sector_analysis we want to update
     *   }
     * })
     */
    upsert<T extends superinvestor_sector_analysisUpsertArgs>(
      args: SelectSubset<T, superinvestor_sector_analysisUpsertArgs<ExtArgs>>
    ): Prisma__superinvestor_sector_analysisClient<
      $Result.GetResult<
        Prisma.$superinvestor_sector_analysisPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Superinvestor_sector_analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_sector_analysisCountArgs} args - Arguments to filter Superinvestor_sector_analyses to count.
     * @example
     * // Count the number of Superinvestor_sector_analyses
     * const count = await prisma.superinvestor_sector_analysis.count({
     *   where: {
     *     // ... the filter for the Superinvestor_sector_analyses we want to count
     *   }
     * })
     **/
    count<T extends superinvestor_sector_analysisCountArgs>(
      args?: Subset<T, superinvestor_sector_analysisCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              Superinvestor_sector_analysisCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Superinvestor_sector_analysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Superinvestor_sector_analysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Superinvestor_sector_analysisAggregateArgs>(
      args: Subset<T, Superinvestor_sector_analysisAggregateArgs>
    ): Prisma.PrismaPromise<GetSuperinvestor_sector_analysisAggregateType<T>>;

    /**
     * Group by Superinvestor_sector_analysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superinvestor_sector_analysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends superinvestor_sector_analysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: superinvestor_sector_analysisGroupByArgs['orderBy'] }
        : { orderBy?: superinvestor_sector_analysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<
        T,
        superinvestor_sector_analysisGroupByArgs,
        OrderByArg
      > &
        InputErrors
    ): {} extends InputErrors
      ? GetSuperinvestor_sector_analysisGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the superinvestor_sector_analysis model
     */
    readonly fields: superinvestor_sector_analysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for superinvestor_sector_analysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__superinvestor_sector_analysisClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    superinvestor_holdings<
      T extends
        superinvestor_sector_analysis$superinvestor_holdingsArgs<ExtArgs> = {}
    >(
      args?: Subset<
        T,
        superinvestor_sector_analysis$superinvestor_holdingsArgs<ExtArgs>
      >
    ): Prisma__superinvestor_holdingsClient<
      $Result.GetResult<
        Prisma.$superinvestor_holdingsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the superinvestor_sector_analysis model
   */
  interface superinvestor_sector_analysisFieldRefs {
    readonly id: FieldRef<'superinvestor_sector_analysis', 'Int'>;
    readonly manager_id: FieldRef<'superinvestor_sector_analysis', 'Int'>;
    readonly sector_name: FieldRef<'superinvestor_sector_analysis', 'String'>;
    readonly sector_percentage: FieldRef<
      'superinvestor_sector_analysis',
      'Decimal'
    >;
  }

  // Custom InputTypes
  /**
   * superinvestor_sector_analysis findUnique
   */
  export type superinvestor_sector_analysisFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_sector_analysis
     */
    select?: superinvestor_sector_analysisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_sector_analysis
     */
    omit?: superinvestor_sector_analysisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_sector_analysisInclude<ExtArgs> | null;
    /**
     * Filter, which superinvestor_sector_analysis to fetch.
     */
    where: superinvestor_sector_analysisWhereUniqueInput;
  };

  /**
   * superinvestor_sector_analysis findUniqueOrThrow
   */
  export type superinvestor_sector_analysisFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_sector_analysis
     */
    select?: superinvestor_sector_analysisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_sector_analysis
     */
    omit?: superinvestor_sector_analysisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_sector_analysisInclude<ExtArgs> | null;
    /**
     * Filter, which superinvestor_sector_analysis to fetch.
     */
    where: superinvestor_sector_analysisWhereUniqueInput;
  };

  /**
   * superinvestor_sector_analysis findFirst
   */
  export type superinvestor_sector_analysisFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_sector_analysis
     */
    select?: superinvestor_sector_analysisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_sector_analysis
     */
    omit?: superinvestor_sector_analysisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_sector_analysisInclude<ExtArgs> | null;
    /**
     * Filter, which superinvestor_sector_analysis to fetch.
     */
    where?: superinvestor_sector_analysisWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of superinvestor_sector_analyses to fetch.
     */
    orderBy?:
      | superinvestor_sector_analysisOrderByWithRelationInput
      | superinvestor_sector_analysisOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for superinvestor_sector_analyses.
     */
    cursor?: superinvestor_sector_analysisWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` superinvestor_sector_analyses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` superinvestor_sector_analyses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of superinvestor_sector_analyses.
     */
    distinct?:
      | Superinvestor_sector_analysisScalarFieldEnum
      | Superinvestor_sector_analysisScalarFieldEnum[];
  };

  /**
   * superinvestor_sector_analysis findFirstOrThrow
   */
  export type superinvestor_sector_analysisFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_sector_analysis
     */
    select?: superinvestor_sector_analysisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_sector_analysis
     */
    omit?: superinvestor_sector_analysisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_sector_analysisInclude<ExtArgs> | null;
    /**
     * Filter, which superinvestor_sector_analysis to fetch.
     */
    where?: superinvestor_sector_analysisWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of superinvestor_sector_analyses to fetch.
     */
    orderBy?:
      | superinvestor_sector_analysisOrderByWithRelationInput
      | superinvestor_sector_analysisOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for superinvestor_sector_analyses.
     */
    cursor?: superinvestor_sector_analysisWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` superinvestor_sector_analyses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` superinvestor_sector_analyses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of superinvestor_sector_analyses.
     */
    distinct?:
      | Superinvestor_sector_analysisScalarFieldEnum
      | Superinvestor_sector_analysisScalarFieldEnum[];
  };

  /**
   * superinvestor_sector_analysis findMany
   */
  export type superinvestor_sector_analysisFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_sector_analysis
     */
    select?: superinvestor_sector_analysisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_sector_analysis
     */
    omit?: superinvestor_sector_analysisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_sector_analysisInclude<ExtArgs> | null;
    /**
     * Filter, which superinvestor_sector_analyses to fetch.
     */
    where?: superinvestor_sector_analysisWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of superinvestor_sector_analyses to fetch.
     */
    orderBy?:
      | superinvestor_sector_analysisOrderByWithRelationInput
      | superinvestor_sector_analysisOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing superinvestor_sector_analyses.
     */
    cursor?: superinvestor_sector_analysisWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` superinvestor_sector_analyses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` superinvestor_sector_analyses.
     */
    skip?: number;
    distinct?:
      | Superinvestor_sector_analysisScalarFieldEnum
      | Superinvestor_sector_analysisScalarFieldEnum[];
  };

  /**
   * superinvestor_sector_analysis create
   */
  export type superinvestor_sector_analysisCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_sector_analysis
     */
    select?: superinvestor_sector_analysisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_sector_analysis
     */
    omit?: superinvestor_sector_analysisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_sector_analysisInclude<ExtArgs> | null;
    /**
     * The data needed to create a superinvestor_sector_analysis.
     */
    data?: XOR<
      superinvestor_sector_analysisCreateInput,
      superinvestor_sector_analysisUncheckedCreateInput
    >;
  };

  /**
   * superinvestor_sector_analysis createMany
   */
  export type superinvestor_sector_analysisCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many superinvestor_sector_analyses.
     */
    data:
      | superinvestor_sector_analysisCreateManyInput
      | superinvestor_sector_analysisCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * superinvestor_sector_analysis createManyAndReturn
   */
  export type superinvestor_sector_analysisCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_sector_analysis
     */
    select?: superinvestor_sector_analysisSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_sector_analysis
     */
    omit?: superinvestor_sector_analysisOmit<ExtArgs> | null;
    /**
     * The data used to create many superinvestor_sector_analyses.
     */
    data:
      | superinvestor_sector_analysisCreateManyInput
      | superinvestor_sector_analysisCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_sector_analysisIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * superinvestor_sector_analysis update
   */
  export type superinvestor_sector_analysisUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_sector_analysis
     */
    select?: superinvestor_sector_analysisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_sector_analysis
     */
    omit?: superinvestor_sector_analysisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_sector_analysisInclude<ExtArgs> | null;
    /**
     * The data needed to update a superinvestor_sector_analysis.
     */
    data: XOR<
      superinvestor_sector_analysisUpdateInput,
      superinvestor_sector_analysisUncheckedUpdateInput
    >;
    /**
     * Choose, which superinvestor_sector_analysis to update.
     */
    where: superinvestor_sector_analysisWhereUniqueInput;
  };

  /**
   * superinvestor_sector_analysis updateMany
   */
  export type superinvestor_sector_analysisUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update superinvestor_sector_analyses.
     */
    data: XOR<
      superinvestor_sector_analysisUpdateManyMutationInput,
      superinvestor_sector_analysisUncheckedUpdateManyInput
    >;
    /**
     * Filter which superinvestor_sector_analyses to update
     */
    where?: superinvestor_sector_analysisWhereInput;
    /**
     * Limit how many superinvestor_sector_analyses to update.
     */
    limit?: number;
  };

  /**
   * superinvestor_sector_analysis updateManyAndReturn
   */
  export type superinvestor_sector_analysisUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_sector_analysis
     */
    select?: superinvestor_sector_analysisSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_sector_analysis
     */
    omit?: superinvestor_sector_analysisOmit<ExtArgs> | null;
    /**
     * The data used to update superinvestor_sector_analyses.
     */
    data: XOR<
      superinvestor_sector_analysisUpdateManyMutationInput,
      superinvestor_sector_analysisUncheckedUpdateManyInput
    >;
    /**
     * Filter which superinvestor_sector_analyses to update
     */
    where?: superinvestor_sector_analysisWhereInput;
    /**
     * Limit how many superinvestor_sector_analyses to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_sector_analysisIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * superinvestor_sector_analysis upsert
   */
  export type superinvestor_sector_analysisUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_sector_analysis
     */
    select?: superinvestor_sector_analysisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_sector_analysis
     */
    omit?: superinvestor_sector_analysisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_sector_analysisInclude<ExtArgs> | null;
    /**
     * The filter to search for the superinvestor_sector_analysis to update in case it exists.
     */
    where: superinvestor_sector_analysisWhereUniqueInput;
    /**
     * In case the superinvestor_sector_analysis found by the `where` argument doesn't exist, create a new superinvestor_sector_analysis with this data.
     */
    create: XOR<
      superinvestor_sector_analysisCreateInput,
      superinvestor_sector_analysisUncheckedCreateInput
    >;
    /**
     * In case the superinvestor_sector_analysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      superinvestor_sector_analysisUpdateInput,
      superinvestor_sector_analysisUncheckedUpdateInput
    >;
  };

  /**
   * superinvestor_sector_analysis delete
   */
  export type superinvestor_sector_analysisDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_sector_analysis
     */
    select?: superinvestor_sector_analysisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_sector_analysis
     */
    omit?: superinvestor_sector_analysisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_sector_analysisInclude<ExtArgs> | null;
    /**
     * Filter which superinvestor_sector_analysis to delete.
     */
    where: superinvestor_sector_analysisWhereUniqueInput;
  };

  /**
   * superinvestor_sector_analysis deleteMany
   */
  export type superinvestor_sector_analysisDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which superinvestor_sector_analyses to delete
     */
    where?: superinvestor_sector_analysisWhereInput;
    /**
     * Limit how many superinvestor_sector_analyses to delete.
     */
    limit?: number;
  };

  /**
   * superinvestor_sector_analysis.superinvestor_holdings
   */
  export type superinvestor_sector_analysis$superinvestor_holdingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_holdings
     */
    select?: superinvestor_holdingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_holdings
     */
    omit?: superinvestor_holdingsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_holdingsInclude<ExtArgs> | null;
    where?: superinvestor_holdingsWhereInput;
  };

  /**
   * superinvestor_sector_analysis without action
   */
  export type superinvestor_sector_analysisDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the superinvestor_sector_analysis
     */
    select?: superinvestor_sector_analysisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the superinvestor_sector_analysis
     */
    omit?: superinvestor_sector_analysisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: superinvestor_sector_analysisInclude<ExtArgs> | null;
  };

  /**
   * Model symbol
   */

  export type AggregateSymbol = {
    _count: SymbolCountAggregateOutputType | null;
    _min: SymbolMinAggregateOutputType | null;
    _max: SymbolMaxAggregateOutputType | null;
  };

  export type SymbolMinAggregateOutputType = {
    id: string | null;
    symbol: string | null;
    company_name: string | null;
    exchange_short_name: string | null;
    company_logo: string | null;
    type: string | null;
    created_at: Date | null;
    updated_at: Date | null;
  };

  export type SymbolMaxAggregateOutputType = {
    id: string | null;
    symbol: string | null;
    company_name: string | null;
    exchange_short_name: string | null;
    company_logo: string | null;
    type: string | null;
    created_at: Date | null;
    updated_at: Date | null;
  };

  export type SymbolCountAggregateOutputType = {
    id: number;
    symbol: number;
    company_name: number;
    exchange_short_name: number;
    company_logo: number;
    type: number;
    created_at: number;
    updated_at: number;
    _all: number;
  };

  export type SymbolMinAggregateInputType = {
    id?: true;
    symbol?: true;
    company_name?: true;
    exchange_short_name?: true;
    company_logo?: true;
    type?: true;
    created_at?: true;
    updated_at?: true;
  };

  export type SymbolMaxAggregateInputType = {
    id?: true;
    symbol?: true;
    company_name?: true;
    exchange_short_name?: true;
    company_logo?: true;
    type?: true;
    created_at?: true;
    updated_at?: true;
  };

  export type SymbolCountAggregateInputType = {
    id?: true;
    symbol?: true;
    company_name?: true;
    exchange_short_name?: true;
    company_logo?: true;
    type?: true;
    created_at?: true;
    updated_at?: true;
    _all?: true;
  };

  export type SymbolAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which symbol to aggregate.
     */
    where?: symbolWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of symbols to fetch.
     */
    orderBy?: symbolOrderByWithRelationInput | symbolOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: symbolWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` symbols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` symbols.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned symbols
     **/
    _count?: true | SymbolCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SymbolMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SymbolMaxAggregateInputType;
  };

  export type GetSymbolAggregateType<T extends SymbolAggregateArgs> = {
    [P in keyof T & keyof AggregateSymbol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSymbol[P]>
      : GetScalarType<T[P], AggregateSymbol[P]>;
  };

  export type symbolGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: symbolWhereInput;
    orderBy?:
      | symbolOrderByWithAggregationInput
      | symbolOrderByWithAggregationInput[];
    by: SymbolScalarFieldEnum[] | SymbolScalarFieldEnum;
    having?: symbolScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SymbolCountAggregateInputType | true;
    _min?: SymbolMinAggregateInputType;
    _max?: SymbolMaxAggregateInputType;
  };

  export type SymbolGroupByOutputType = {
    id: string;
    symbol: string;
    company_name: string | null;
    exchange_short_name: string | null;
    company_logo: string | null;
    type: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    _count: SymbolCountAggregateOutputType | null;
    _min: SymbolMinAggregateOutputType | null;
    _max: SymbolMaxAggregateOutputType | null;
  };

  type GetSymbolGroupByPayload<T extends symbolGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SymbolGroupByOutputType, T['by']> & {
          [P in keyof T & keyof SymbolGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SymbolGroupByOutputType[P]>
            : GetScalarType<T[P], SymbolGroupByOutputType[P]>;
        }
      >
    >;

  export type symbolSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      symbol?: boolean;
      company_name?: boolean;
      exchange_short_name?: boolean;
      company_logo?: boolean;
      type?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['symbol']
  >;

  export type symbolSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      symbol?: boolean;
      company_name?: boolean;
      exchange_short_name?: boolean;
      company_logo?: boolean;
      type?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['symbol']
  >;

  export type symbolSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      symbol?: boolean;
      company_name?: boolean;
      exchange_short_name?: boolean;
      company_logo?: boolean;
      type?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
    },
    ExtArgs['result']['symbol']
  >;

  export type symbolSelectScalar = {
    id?: boolean;
    symbol?: boolean;
    company_name?: boolean;
    exchange_short_name?: boolean;
    company_logo?: boolean;
    type?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
  };

  export type symbolOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'symbol'
    | 'company_name'
    | 'exchange_short_name'
    | 'company_logo'
    | 'type'
    | 'created_at'
    | 'updated_at',
    ExtArgs['result']['symbol']
  >;

  export type $symbolPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'symbol';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        symbol: string;
        company_name: string | null;
        exchange_short_name: string | null;
        company_logo: string | null;
        type: string | null;
        created_at: Date | null;
        updated_at: Date | null;
      },
      ExtArgs['result']['symbol']
    >;
    composites: {};
  };

  type symbolGetPayload<
    S extends boolean | null | undefined | symbolDefaultArgs
  > = $Result.GetResult<Prisma.$symbolPayload, S>;

  type symbolCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<symbolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: SymbolCountAggregateInputType | true;
  };

  export interface symbolDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['symbol'];
      meta: { name: 'symbol' };
    };
    /**
     * Find zero or one Symbol that matches the filter.
     * @param {symbolFindUniqueArgs} args - Arguments to find a Symbol
     * @example
     * // Get one Symbol
     * const symbol = await prisma.symbol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends symbolFindUniqueArgs>(
      args: SelectSubset<T, symbolFindUniqueArgs<ExtArgs>>
    ): Prisma__symbolClient<
      $Result.GetResult<
        Prisma.$symbolPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Symbol that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {symbolFindUniqueOrThrowArgs} args - Arguments to find a Symbol
     * @example
     * // Get one Symbol
     * const symbol = await prisma.symbol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends symbolFindUniqueOrThrowArgs>(
      args: SelectSubset<T, symbolFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__symbolClient<
      $Result.GetResult<
        Prisma.$symbolPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Symbol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolFindFirstArgs} args - Arguments to find a Symbol
     * @example
     * // Get one Symbol
     * const symbol = await prisma.symbol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends symbolFindFirstArgs>(
      args?: SelectSubset<T, symbolFindFirstArgs<ExtArgs>>
    ): Prisma__symbolClient<
      $Result.GetResult<
        Prisma.$symbolPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Symbol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolFindFirstOrThrowArgs} args - Arguments to find a Symbol
     * @example
     * // Get one Symbol
     * const symbol = await prisma.symbol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends symbolFindFirstOrThrowArgs>(
      args?: SelectSubset<T, symbolFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__symbolClient<
      $Result.GetResult<
        Prisma.$symbolPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Symbols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Symbols
     * const symbols = await prisma.symbol.findMany()
     *
     * // Get first 10 Symbols
     * const symbols = await prisma.symbol.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const symbolWithIdOnly = await prisma.symbol.findMany({ select: { id: true } })
     *
     */
    findMany<T extends symbolFindManyArgs>(
      args?: SelectSubset<T, symbolFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$symbolPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Symbol.
     * @param {symbolCreateArgs} args - Arguments to create a Symbol.
     * @example
     * // Create one Symbol
     * const Symbol = await prisma.symbol.create({
     *   data: {
     *     // ... data to create a Symbol
     *   }
     * })
     *
     */
    create<T extends symbolCreateArgs>(
      args: SelectSubset<T, symbolCreateArgs<ExtArgs>>
    ): Prisma__symbolClient<
      $Result.GetResult<
        Prisma.$symbolPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Symbols.
     * @param {symbolCreateManyArgs} args - Arguments to create many Symbols.
     * @example
     * // Create many Symbols
     * const symbol = await prisma.symbol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends symbolCreateManyArgs>(
      args?: SelectSubset<T, symbolCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Symbols and returns the data saved in the database.
     * @param {symbolCreateManyAndReturnArgs} args - Arguments to create many Symbols.
     * @example
     * // Create many Symbols
     * const symbol = await prisma.symbol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Symbols and only return the `id`
     * const symbolWithIdOnly = await prisma.symbol.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends symbolCreateManyAndReturnArgs>(
      args?: SelectSubset<T, symbolCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$symbolPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Symbol.
     * @param {symbolDeleteArgs} args - Arguments to delete one Symbol.
     * @example
     * // Delete one Symbol
     * const Symbol = await prisma.symbol.delete({
     *   where: {
     *     // ... filter to delete one Symbol
     *   }
     * })
     *
     */
    delete<T extends symbolDeleteArgs>(
      args: SelectSubset<T, symbolDeleteArgs<ExtArgs>>
    ): Prisma__symbolClient<
      $Result.GetResult<
        Prisma.$symbolPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Symbol.
     * @param {symbolUpdateArgs} args - Arguments to update one Symbol.
     * @example
     * // Update one Symbol
     * const symbol = await prisma.symbol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends symbolUpdateArgs>(
      args: SelectSubset<T, symbolUpdateArgs<ExtArgs>>
    ): Prisma__symbolClient<
      $Result.GetResult<
        Prisma.$symbolPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Symbols.
     * @param {symbolDeleteManyArgs} args - Arguments to filter Symbols to delete.
     * @example
     * // Delete a few Symbols
     * const { count } = await prisma.symbol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends symbolDeleteManyArgs>(
      args?: SelectSubset<T, symbolDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Symbols
     * const symbol = await prisma.symbol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends symbolUpdateManyArgs>(
      args: SelectSubset<T, symbolUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Symbols and returns the data updated in the database.
     * @param {symbolUpdateManyAndReturnArgs} args - Arguments to update many Symbols.
     * @example
     * // Update many Symbols
     * const symbol = await prisma.symbol.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Symbols and only return the `id`
     * const symbolWithIdOnly = await prisma.symbol.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends symbolUpdateManyAndReturnArgs>(
      args: SelectSubset<T, symbolUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$symbolPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Symbol.
     * @param {symbolUpsertArgs} args - Arguments to update or create a Symbol.
     * @example
     * // Update or create a Symbol
     * const symbol = await prisma.symbol.upsert({
     *   create: {
     *     // ... data to create a Symbol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Symbol we want to update
     *   }
     * })
     */
    upsert<T extends symbolUpsertArgs>(
      args: SelectSubset<T, symbolUpsertArgs<ExtArgs>>
    ): Prisma__symbolClient<
      $Result.GetResult<
        Prisma.$symbolPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolCountArgs} args - Arguments to filter Symbols to count.
     * @example
     * // Count the number of Symbols
     * const count = await prisma.symbol.count({
     *   where: {
     *     // ... the filter for the Symbols we want to count
     *   }
     * })
     **/
    count<T extends symbolCountArgs>(
      args?: Subset<T, symbolCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SymbolCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Symbol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SymbolAggregateArgs>(
      args: Subset<T, SymbolAggregateArgs>
    ): Prisma.PrismaPromise<GetSymbolAggregateType<T>>;

    /**
     * Group by Symbol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends symbolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: symbolGroupByArgs['orderBy'] }
        : { orderBy?: symbolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, symbolGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetSymbolGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the symbol model
     */
    readonly fields: symbolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for symbol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__symbolClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the symbol model
   */
  interface symbolFieldRefs {
    readonly id: FieldRef<'symbol', 'String'>;
    readonly symbol: FieldRef<'symbol', 'String'>;
    readonly company_name: FieldRef<'symbol', 'String'>;
    readonly exchange_short_name: FieldRef<'symbol', 'String'>;
    readonly company_logo: FieldRef<'symbol', 'String'>;
    readonly type: FieldRef<'symbol', 'String'>;
    readonly created_at: FieldRef<'symbol', 'DateTime'>;
    readonly updated_at: FieldRef<'symbol', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * symbol findUnique
   */
  export type symbolFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the symbol
     */
    select?: symbolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the symbol
     */
    omit?: symbolOmit<ExtArgs> | null;
    /**
     * Filter, which symbol to fetch.
     */
    where: symbolWhereUniqueInput;
  };

  /**
   * symbol findUniqueOrThrow
   */
  export type symbolFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the symbol
     */
    select?: symbolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the symbol
     */
    omit?: symbolOmit<ExtArgs> | null;
    /**
     * Filter, which symbol to fetch.
     */
    where: symbolWhereUniqueInput;
  };

  /**
   * symbol findFirst
   */
  export type symbolFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the symbol
     */
    select?: symbolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the symbol
     */
    omit?: symbolOmit<ExtArgs> | null;
    /**
     * Filter, which symbol to fetch.
     */
    where?: symbolWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of symbols to fetch.
     */
    orderBy?: symbolOrderByWithRelationInput | symbolOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for symbols.
     */
    cursor?: symbolWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` symbols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` symbols.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of symbols.
     */
    distinct?: SymbolScalarFieldEnum | SymbolScalarFieldEnum[];
  };

  /**
   * symbol findFirstOrThrow
   */
  export type symbolFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the symbol
     */
    select?: symbolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the symbol
     */
    omit?: symbolOmit<ExtArgs> | null;
    /**
     * Filter, which symbol to fetch.
     */
    where?: symbolWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of symbols to fetch.
     */
    orderBy?: symbolOrderByWithRelationInput | symbolOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for symbols.
     */
    cursor?: symbolWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` symbols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` symbols.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of symbols.
     */
    distinct?: SymbolScalarFieldEnum | SymbolScalarFieldEnum[];
  };

  /**
   * symbol findMany
   */
  export type symbolFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the symbol
     */
    select?: symbolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the symbol
     */
    omit?: symbolOmit<ExtArgs> | null;
    /**
     * Filter, which symbols to fetch.
     */
    where?: symbolWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of symbols to fetch.
     */
    orderBy?: symbolOrderByWithRelationInput | symbolOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing symbols.
     */
    cursor?: symbolWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` symbols from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` symbols.
     */
    skip?: number;
    distinct?: SymbolScalarFieldEnum | SymbolScalarFieldEnum[];
  };

  /**
   * symbol create
   */
  export type symbolCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the symbol
     */
    select?: symbolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the symbol
     */
    omit?: symbolOmit<ExtArgs> | null;
    /**
     * The data needed to create a symbol.
     */
    data: XOR<symbolCreateInput, symbolUncheckedCreateInput>;
  };

  /**
   * symbol createMany
   */
  export type symbolCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many symbols.
     */
    data: symbolCreateManyInput | symbolCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * symbol createManyAndReturn
   */
  export type symbolCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the symbol
     */
    select?: symbolSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the symbol
     */
    omit?: symbolOmit<ExtArgs> | null;
    /**
     * The data used to create many symbols.
     */
    data: symbolCreateManyInput | symbolCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * symbol update
   */
  export type symbolUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the symbol
     */
    select?: symbolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the symbol
     */
    omit?: symbolOmit<ExtArgs> | null;
    /**
     * The data needed to update a symbol.
     */
    data: XOR<symbolUpdateInput, symbolUncheckedUpdateInput>;
    /**
     * Choose, which symbol to update.
     */
    where: symbolWhereUniqueInput;
  };

  /**
   * symbol updateMany
   */
  export type symbolUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update symbols.
     */
    data: XOR<symbolUpdateManyMutationInput, symbolUncheckedUpdateManyInput>;
    /**
     * Filter which symbols to update
     */
    where?: symbolWhereInput;
    /**
     * Limit how many symbols to update.
     */
    limit?: number;
  };

  /**
   * symbol updateManyAndReturn
   */
  export type symbolUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the symbol
     */
    select?: symbolSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the symbol
     */
    omit?: symbolOmit<ExtArgs> | null;
    /**
     * The data used to update symbols.
     */
    data: XOR<symbolUpdateManyMutationInput, symbolUncheckedUpdateManyInput>;
    /**
     * Filter which symbols to update
     */
    where?: symbolWhereInput;
    /**
     * Limit how many symbols to update.
     */
    limit?: number;
  };

  /**
   * symbol upsert
   */
  export type symbolUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the symbol
     */
    select?: symbolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the symbol
     */
    omit?: symbolOmit<ExtArgs> | null;
    /**
     * The filter to search for the symbol to update in case it exists.
     */
    where: symbolWhereUniqueInput;
    /**
     * In case the symbol found by the `where` argument doesn't exist, create a new symbol with this data.
     */
    create: XOR<symbolCreateInput, symbolUncheckedCreateInput>;
    /**
     * In case the symbol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<symbolUpdateInput, symbolUncheckedUpdateInput>;
  };

  /**
   * symbol delete
   */
  export type symbolDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the symbol
     */
    select?: symbolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the symbol
     */
    omit?: symbolOmit<ExtArgs> | null;
    /**
     * Filter which symbol to delete.
     */
    where: symbolWhereUniqueInput;
  };

  /**
   * symbol deleteMany
   */
  export type symbolDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which symbols to delete
     */
    where?: symbolWhereInput;
    /**
     * Limit how many symbols to delete.
     */
    limit?: number;
  };

  /**
   * symbol without action
   */
  export type symbolDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the symbol
     */
    select?: symbolSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the symbol
     */
    omit?: symbolOmit<ExtArgs> | null;
  };

  /**
   * Model user_devices
   */

  export type AggregateUser_devices = {
    _count: User_devicesCountAggregateOutputType | null;
    _avg: User_devicesAvgAggregateOutputType | null;
    _sum: User_devicesSumAggregateOutputType | null;
    _min: User_devicesMinAggregateOutputType | null;
    _max: User_devicesMaxAggregateOutputType | null;
  };

  export type User_devicesAvgAggregateOutputType = {
    user_id: number | null;
  };

  export type User_devicesSumAggregateOutputType = {
    user_id: number | null;
  };

  export type User_devicesMinAggregateOutputType = {
    device_id: string | null;
    user_id: number | null;
    platform: string | null;
    device_token: string | null;
    last_active_at: Date | null;
    created_at: Date | null;
    app_version: string | null;
    device_name: string | null;
  };

  export type User_devicesMaxAggregateOutputType = {
    device_id: string | null;
    user_id: number | null;
    platform: string | null;
    device_token: string | null;
    last_active_at: Date | null;
    created_at: Date | null;
    app_version: string | null;
    device_name: string | null;
  };

  export type User_devicesCountAggregateOutputType = {
    device_id: number;
    user_id: number;
    platform: number;
    device_token: number;
    last_active_at: number;
    created_at: number;
    app_version: number;
    device_name: number;
    _all: number;
  };

  export type User_devicesAvgAggregateInputType = {
    user_id?: true;
  };

  export type User_devicesSumAggregateInputType = {
    user_id?: true;
  };

  export type User_devicesMinAggregateInputType = {
    device_id?: true;
    user_id?: true;
    platform?: true;
    device_token?: true;
    last_active_at?: true;
    created_at?: true;
    app_version?: true;
    device_name?: true;
  };

  export type User_devicesMaxAggregateInputType = {
    device_id?: true;
    user_id?: true;
    platform?: true;
    device_token?: true;
    last_active_at?: true;
    created_at?: true;
    app_version?: true;
    device_name?: true;
  };

  export type User_devicesCountAggregateInputType = {
    device_id?: true;
    user_id?: true;
    platform?: true;
    device_token?: true;
    last_active_at?: true;
    created_at?: true;
    app_version?: true;
    device_name?: true;
    _all?: true;
  };

  export type User_devicesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which user_devices to aggregate.
     */
    where?: user_devicesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of user_devices to fetch.
     */
    orderBy?:
      | user_devicesOrderByWithRelationInput
      | user_devicesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: user_devicesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` user_devices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` user_devices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned user_devices
     **/
    _count?: true | User_devicesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: User_devicesAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: User_devicesSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: User_devicesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: User_devicesMaxAggregateInputType;
  };

  export type GetUser_devicesAggregateType<
    T extends User_devicesAggregateArgs
  > = {
    [P in keyof T & keyof AggregateUser_devices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_devices[P]>
      : GetScalarType<T[P], AggregateUser_devices[P]>;
  };

  export type user_devicesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: user_devicesWhereInput;
    orderBy?:
      | user_devicesOrderByWithAggregationInput
      | user_devicesOrderByWithAggregationInput[];
    by: User_devicesScalarFieldEnum[] | User_devicesScalarFieldEnum;
    having?: user_devicesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: User_devicesCountAggregateInputType | true;
    _avg?: User_devicesAvgAggregateInputType;
    _sum?: User_devicesSumAggregateInputType;
    _min?: User_devicesMinAggregateInputType;
    _max?: User_devicesMaxAggregateInputType;
  };

  export type User_devicesGroupByOutputType = {
    device_id: string;
    user_id: number;
    platform: string;
    device_token: string | null;
    last_active_at: Date | null;
    created_at: Date | null;
    app_version: string | null;
    device_name: string | null;
    _count: User_devicesCountAggregateOutputType | null;
    _avg: User_devicesAvgAggregateOutputType | null;
    _sum: User_devicesSumAggregateOutputType | null;
    _min: User_devicesMinAggregateOutputType | null;
    _max: User_devicesMaxAggregateOutputType | null;
  };

  type GetUser_devicesGroupByPayload<T extends user_devicesGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<User_devicesGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof User_devicesGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_devicesGroupByOutputType[P]>
            : GetScalarType<T[P], User_devicesGroupByOutputType[P]>;
        }
      >
    >;

  export type user_devicesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      device_id?: boolean;
      user_id?: boolean;
      platform?: boolean;
      device_token?: boolean;
      last_active_at?: boolean;
      created_at?: boolean;
      app_version?: boolean;
      device_name?: boolean;
    },
    ExtArgs['result']['user_devices']
  >;

  export type user_devicesSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      device_id?: boolean;
      user_id?: boolean;
      platform?: boolean;
      device_token?: boolean;
      last_active_at?: boolean;
      created_at?: boolean;
      app_version?: boolean;
      device_name?: boolean;
    },
    ExtArgs['result']['user_devices']
  >;

  export type user_devicesSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      device_id?: boolean;
      user_id?: boolean;
      platform?: boolean;
      device_token?: boolean;
      last_active_at?: boolean;
      created_at?: boolean;
      app_version?: boolean;
      device_name?: boolean;
    },
    ExtArgs['result']['user_devices']
  >;

  export type user_devicesSelectScalar = {
    device_id?: boolean;
    user_id?: boolean;
    platform?: boolean;
    device_token?: boolean;
    last_active_at?: boolean;
    created_at?: boolean;
    app_version?: boolean;
    device_name?: boolean;
  };

  export type user_devicesOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'device_id'
    | 'user_id'
    | 'platform'
    | 'device_token'
    | 'last_active_at'
    | 'created_at'
    | 'app_version'
    | 'device_name',
    ExtArgs['result']['user_devices']
  >;

  export type $user_devicesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'user_devices';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        device_id: string;
        user_id: number;
        platform: string;
        device_token: string | null;
        last_active_at: Date | null;
        created_at: Date | null;
        app_version: string | null;
        device_name: string | null;
      },
      ExtArgs['result']['user_devices']
    >;
    composites: {};
  };

  type user_devicesGetPayload<
    S extends boolean | null | undefined | user_devicesDefaultArgs
  > = $Result.GetResult<Prisma.$user_devicesPayload, S>;

  type user_devicesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    user_devicesFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: User_devicesCountAggregateInputType | true;
  };

  export interface user_devicesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['user_devices'];
      meta: { name: 'user_devices' };
    };
    /**
     * Find zero or one User_devices that matches the filter.
     * @param {user_devicesFindUniqueArgs} args - Arguments to find a User_devices
     * @example
     * // Get one User_devices
     * const user_devices = await prisma.user_devices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_devicesFindUniqueArgs>(
      args: SelectSubset<T, user_devicesFindUniqueArgs<ExtArgs>>
    ): Prisma__user_devicesClient<
      $Result.GetResult<
        Prisma.$user_devicesPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User_devices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_devicesFindUniqueOrThrowArgs} args - Arguments to find a User_devices
     * @example
     * // Get one User_devices
     * const user_devices = await prisma.user_devices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_devicesFindUniqueOrThrowArgs>(
      args: SelectSubset<T, user_devicesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_devicesClient<
      $Result.GetResult<
        Prisma.$user_devicesPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User_devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesFindFirstArgs} args - Arguments to find a User_devices
     * @example
     * // Get one User_devices
     * const user_devices = await prisma.user_devices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_devicesFindFirstArgs>(
      args?: SelectSubset<T, user_devicesFindFirstArgs<ExtArgs>>
    ): Prisma__user_devicesClient<
      $Result.GetResult<
        Prisma.$user_devicesPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User_devices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesFindFirstOrThrowArgs} args - Arguments to find a User_devices
     * @example
     * // Get one User_devices
     * const user_devices = await prisma.user_devices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_devicesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, user_devicesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_devicesClient<
      $Result.GetResult<
        Prisma.$user_devicesPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more User_devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_devices
     * const user_devices = await prisma.user_devices.findMany()
     *
     * // Get first 10 User_devices
     * const user_devices = await prisma.user_devices.findMany({ take: 10 })
     *
     * // Only select the `device_id`
     * const user_devicesWithDevice_idOnly = await prisma.user_devices.findMany({ select: { device_id: true } })
     *
     */
    findMany<T extends user_devicesFindManyArgs>(
      args?: SelectSubset<T, user_devicesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$user_devicesPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a User_devices.
     * @param {user_devicesCreateArgs} args - Arguments to create a User_devices.
     * @example
     * // Create one User_devices
     * const User_devices = await prisma.user_devices.create({
     *   data: {
     *     // ... data to create a User_devices
     *   }
     * })
     *
     */
    create<T extends user_devicesCreateArgs>(
      args: SelectSubset<T, user_devicesCreateArgs<ExtArgs>>
    ): Prisma__user_devicesClient<
      $Result.GetResult<
        Prisma.$user_devicesPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many User_devices.
     * @param {user_devicesCreateManyArgs} args - Arguments to create many User_devices.
     * @example
     * // Create many User_devices
     * const user_devices = await prisma.user_devices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends user_devicesCreateManyArgs>(
      args?: SelectSubset<T, user_devicesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many User_devices and returns the data saved in the database.
     * @param {user_devicesCreateManyAndReturnArgs} args - Arguments to create many User_devices.
     * @example
     * // Create many User_devices
     * const user_devices = await prisma.user_devices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many User_devices and only return the `device_id`
     * const user_devicesWithDevice_idOnly = await prisma.user_devices.createManyAndReturn({
     *   select: { device_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends user_devicesCreateManyAndReturnArgs>(
      args?: SelectSubset<T, user_devicesCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$user_devicesPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a User_devices.
     * @param {user_devicesDeleteArgs} args - Arguments to delete one User_devices.
     * @example
     * // Delete one User_devices
     * const User_devices = await prisma.user_devices.delete({
     *   where: {
     *     // ... filter to delete one User_devices
     *   }
     * })
     *
     */
    delete<T extends user_devicesDeleteArgs>(
      args: SelectSubset<T, user_devicesDeleteArgs<ExtArgs>>
    ): Prisma__user_devicesClient<
      $Result.GetResult<
        Prisma.$user_devicesPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User_devices.
     * @param {user_devicesUpdateArgs} args - Arguments to update one User_devices.
     * @example
     * // Update one User_devices
     * const user_devices = await prisma.user_devices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends user_devicesUpdateArgs>(
      args: SelectSubset<T, user_devicesUpdateArgs<ExtArgs>>
    ): Prisma__user_devicesClient<
      $Result.GetResult<
        Prisma.$user_devicesPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more User_devices.
     * @param {user_devicesDeleteManyArgs} args - Arguments to filter User_devices to delete.
     * @example
     * // Delete a few User_devices
     * const { count } = await prisma.user_devices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends user_devicesDeleteManyArgs>(
      args?: SelectSubset<T, user_devicesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more User_devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_devices
     * const user_devices = await prisma.user_devices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends user_devicesUpdateManyArgs>(
      args: SelectSubset<T, user_devicesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more User_devices and returns the data updated in the database.
     * @param {user_devicesUpdateManyAndReturnArgs} args - Arguments to update many User_devices.
     * @example
     * // Update many User_devices
     * const user_devices = await prisma.user_devices.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more User_devices and only return the `device_id`
     * const user_devicesWithDevice_idOnly = await prisma.user_devices.updateManyAndReturn({
     *   select: { device_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends user_devicesUpdateManyAndReturnArgs>(
      args: SelectSubset<T, user_devicesUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$user_devicesPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one User_devices.
     * @param {user_devicesUpsertArgs} args - Arguments to update or create a User_devices.
     * @example
     * // Update or create a User_devices
     * const user_devices = await prisma.user_devices.upsert({
     *   create: {
     *     // ... data to create a User_devices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_devices we want to update
     *   }
     * })
     */
    upsert<T extends user_devicesUpsertArgs>(
      args: SelectSubset<T, user_devicesUpsertArgs<ExtArgs>>
    ): Prisma__user_devicesClient<
      $Result.GetResult<
        Prisma.$user_devicesPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of User_devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesCountArgs} args - Arguments to filter User_devices to count.
     * @example
     * // Count the number of User_devices
     * const count = await prisma.user_devices.count({
     *   where: {
     *     // ... the filter for the User_devices we want to count
     *   }
     * })
     **/
    count<T extends user_devicesCountArgs>(
      args?: Subset<T, user_devicesCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_devicesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User_devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_devicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends User_devicesAggregateArgs>(
      args: Subset<T, User_devicesAggregateArgs>
    ): Prisma.PrismaPromise<GetUser_devicesAggregateType<T>>;

    /**
     * Group by User_devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends user_devicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_devicesGroupByArgs['orderBy'] }
        : { orderBy?: user_devicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, user_devicesGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetUser_devicesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the user_devices model
     */
    readonly fields: user_devicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_devices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_devicesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the user_devices model
   */
  interface user_devicesFieldRefs {
    readonly device_id: FieldRef<'user_devices', 'String'>;
    readonly user_id: FieldRef<'user_devices', 'Int'>;
    readonly platform: FieldRef<'user_devices', 'String'>;
    readonly device_token: FieldRef<'user_devices', 'String'>;
    readonly last_active_at: FieldRef<'user_devices', 'DateTime'>;
    readonly created_at: FieldRef<'user_devices', 'DateTime'>;
    readonly app_version: FieldRef<'user_devices', 'String'>;
    readonly device_name: FieldRef<'user_devices', 'String'>;
  }

  // Custom InputTypes
  /**
   * user_devices findUnique
   */
  export type user_devicesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null;
    /**
     * Filter, which user_devices to fetch.
     */
    where: user_devicesWhereUniqueInput;
  };

  /**
   * user_devices findUniqueOrThrow
   */
  export type user_devicesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null;
    /**
     * Filter, which user_devices to fetch.
     */
    where: user_devicesWhereUniqueInput;
  };

  /**
   * user_devices findFirst
   */
  export type user_devicesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null;
    /**
     * Filter, which user_devices to fetch.
     */
    where?: user_devicesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of user_devices to fetch.
     */
    orderBy?:
      | user_devicesOrderByWithRelationInput
      | user_devicesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for user_devices.
     */
    cursor?: user_devicesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` user_devices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` user_devices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of user_devices.
     */
    distinct?: User_devicesScalarFieldEnum | User_devicesScalarFieldEnum[];
  };

  /**
   * user_devices findFirstOrThrow
   */
  export type user_devicesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null;
    /**
     * Filter, which user_devices to fetch.
     */
    where?: user_devicesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of user_devices to fetch.
     */
    orderBy?:
      | user_devicesOrderByWithRelationInput
      | user_devicesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for user_devices.
     */
    cursor?: user_devicesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` user_devices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` user_devices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of user_devices.
     */
    distinct?: User_devicesScalarFieldEnum | User_devicesScalarFieldEnum[];
  };

  /**
   * user_devices findMany
   */
  export type user_devicesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null;
    /**
     * Filter, which user_devices to fetch.
     */
    where?: user_devicesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of user_devices to fetch.
     */
    orderBy?:
      | user_devicesOrderByWithRelationInput
      | user_devicesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing user_devices.
     */
    cursor?: user_devicesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` user_devices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` user_devices.
     */
    skip?: number;
    distinct?: User_devicesScalarFieldEnum | User_devicesScalarFieldEnum[];
  };

  /**
   * user_devices create
   */
  export type user_devicesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null;
    /**
     * The data needed to create a user_devices.
     */
    data: XOR<user_devicesCreateInput, user_devicesUncheckedCreateInput>;
  };

  /**
   * user_devices createMany
   */
  export type user_devicesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many user_devices.
     */
    data: user_devicesCreateManyInput | user_devicesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * user_devices createManyAndReturn
   */
  export type user_devicesCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null;
    /**
     * The data used to create many user_devices.
     */
    data: user_devicesCreateManyInput | user_devicesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * user_devices update
   */
  export type user_devicesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null;
    /**
     * The data needed to update a user_devices.
     */
    data: XOR<user_devicesUpdateInput, user_devicesUncheckedUpdateInput>;
    /**
     * Choose, which user_devices to update.
     */
    where: user_devicesWhereUniqueInput;
  };

  /**
   * user_devices updateMany
   */
  export type user_devicesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update user_devices.
     */
    data: XOR<
      user_devicesUpdateManyMutationInput,
      user_devicesUncheckedUpdateManyInput
    >;
    /**
     * Filter which user_devices to update
     */
    where?: user_devicesWhereInput;
    /**
     * Limit how many user_devices to update.
     */
    limit?: number;
  };

  /**
   * user_devices updateManyAndReturn
   */
  export type user_devicesUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null;
    /**
     * The data used to update user_devices.
     */
    data: XOR<
      user_devicesUpdateManyMutationInput,
      user_devicesUncheckedUpdateManyInput
    >;
    /**
     * Filter which user_devices to update
     */
    where?: user_devicesWhereInput;
    /**
     * Limit how many user_devices to update.
     */
    limit?: number;
  };

  /**
   * user_devices upsert
   */
  export type user_devicesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null;
    /**
     * The filter to search for the user_devices to update in case it exists.
     */
    where: user_devicesWhereUniqueInput;
    /**
     * In case the user_devices found by the `where` argument doesn't exist, create a new user_devices with this data.
     */
    create: XOR<user_devicesCreateInput, user_devicesUncheckedCreateInput>;
    /**
     * In case the user_devices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_devicesUpdateInput, user_devicesUncheckedUpdateInput>;
  };

  /**
   * user_devices delete
   */
  export type user_devicesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null;
    /**
     * Filter which user_devices to delete.
     */
    where: user_devicesWhereUniqueInput;
  };

  /**
   * user_devices deleteMany
   */
  export type user_devicesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which user_devices to delete
     */
    where?: user_devicesWhereInput;
    /**
     * Limit how many user_devices to delete.
     */
    limit?: number;
  };

  /**
   * user_devices without action
   */
  export type user_devicesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null;
  };

  /**
   * Model user_subscriptions
   */

  export type AggregateUser_subscriptions = {
    _count: User_subscriptionsCountAggregateOutputType | null;
    _avg: User_subscriptionsAvgAggregateOutputType | null;
    _sum: User_subscriptionsSumAggregateOutputType | null;
    _min: User_subscriptionsMinAggregateOutputType | null;
    _max: User_subscriptionsMaxAggregateOutputType | null;
  };

  export type User_subscriptionsAvgAggregateOutputType = {
    user_subscription_id: number | null;
    user_id: number | null;
    subscription_id: number | null;
  };

  export type User_subscriptionsSumAggregateOutputType = {
    user_subscription_id: number | null;
    user_id: number | null;
    subscription_id: number | null;
  };

  export type User_subscriptionsMinAggregateOutputType = {
    user_subscription_id: number | null;
    user_id: number | null;
    subscription_id: number | null;
    start_date: Date | null;
    end_date: Date | null;
    is_active: boolean | null;
    stripe_subscription_id: string | null;
    stripe_payment_intent_id: string | null;
    payment_status: string | null;
    last_payment_date: Date | null;
    next_billing_date: Date | null;
    cancellation_date: Date | null;
    trial_end_date: Date | null;
    last_payment_attempt_date: Date | null;
    payment_method_id: string | null;
    redeem_code: string | null;
  };

  export type User_subscriptionsMaxAggregateOutputType = {
    user_subscription_id: number | null;
    user_id: number | null;
    subscription_id: number | null;
    start_date: Date | null;
    end_date: Date | null;
    is_active: boolean | null;
    stripe_subscription_id: string | null;
    stripe_payment_intent_id: string | null;
    payment_status: string | null;
    last_payment_date: Date | null;
    next_billing_date: Date | null;
    cancellation_date: Date | null;
    trial_end_date: Date | null;
    last_payment_attempt_date: Date | null;
    payment_method_id: string | null;
    redeem_code: string | null;
  };

  export type User_subscriptionsCountAggregateOutputType = {
    user_subscription_id: number;
    user_id: number;
    subscription_id: number;
    start_date: number;
    end_date: number;
    is_active: number;
    stripe_subscription_id: number;
    stripe_payment_intent_id: number;
    payment_status: number;
    last_payment_date: number;
    next_billing_date: number;
    cancellation_date: number;
    trial_end_date: number;
    last_payment_attempt_date: number;
    payment_method_id: number;
    redeem_code: number;
    _all: number;
  };

  export type User_subscriptionsAvgAggregateInputType = {
    user_subscription_id?: true;
    user_id?: true;
    subscription_id?: true;
  };

  export type User_subscriptionsSumAggregateInputType = {
    user_subscription_id?: true;
    user_id?: true;
    subscription_id?: true;
  };

  export type User_subscriptionsMinAggregateInputType = {
    user_subscription_id?: true;
    user_id?: true;
    subscription_id?: true;
    start_date?: true;
    end_date?: true;
    is_active?: true;
    stripe_subscription_id?: true;
    stripe_payment_intent_id?: true;
    payment_status?: true;
    last_payment_date?: true;
    next_billing_date?: true;
    cancellation_date?: true;
    trial_end_date?: true;
    last_payment_attempt_date?: true;
    payment_method_id?: true;
    redeem_code?: true;
  };

  export type User_subscriptionsMaxAggregateInputType = {
    user_subscription_id?: true;
    user_id?: true;
    subscription_id?: true;
    start_date?: true;
    end_date?: true;
    is_active?: true;
    stripe_subscription_id?: true;
    stripe_payment_intent_id?: true;
    payment_status?: true;
    last_payment_date?: true;
    next_billing_date?: true;
    cancellation_date?: true;
    trial_end_date?: true;
    last_payment_attempt_date?: true;
    payment_method_id?: true;
    redeem_code?: true;
  };

  export type User_subscriptionsCountAggregateInputType = {
    user_subscription_id?: true;
    user_id?: true;
    subscription_id?: true;
    start_date?: true;
    end_date?: true;
    is_active?: true;
    stripe_subscription_id?: true;
    stripe_payment_intent_id?: true;
    payment_status?: true;
    last_payment_date?: true;
    next_billing_date?: true;
    cancellation_date?: true;
    trial_end_date?: true;
    last_payment_attempt_date?: true;
    payment_method_id?: true;
    redeem_code?: true;
    _all?: true;
  };

  export type User_subscriptionsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which user_subscriptions to aggregate.
     */
    where?: user_subscriptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of user_subscriptions to fetch.
     */
    orderBy?:
      | user_subscriptionsOrderByWithRelationInput
      | user_subscriptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: user_subscriptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` user_subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` user_subscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned user_subscriptions
     **/
    _count?: true | User_subscriptionsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: User_subscriptionsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: User_subscriptionsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: User_subscriptionsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: User_subscriptionsMaxAggregateInputType;
  };

  export type GetUser_subscriptionsAggregateType<
    T extends User_subscriptionsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateUser_subscriptions]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_subscriptions[P]>
      : GetScalarType<T[P], AggregateUser_subscriptions[P]>;
  };

  export type user_subscriptionsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: user_subscriptionsWhereInput;
    orderBy?:
      | user_subscriptionsOrderByWithAggregationInput
      | user_subscriptionsOrderByWithAggregationInput[];
    by: User_subscriptionsScalarFieldEnum[] | User_subscriptionsScalarFieldEnum;
    having?: user_subscriptionsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: User_subscriptionsCountAggregateInputType | true;
    _avg?: User_subscriptionsAvgAggregateInputType;
    _sum?: User_subscriptionsSumAggregateInputType;
    _min?: User_subscriptionsMinAggregateInputType;
    _max?: User_subscriptionsMaxAggregateInputType;
  };

  export type User_subscriptionsGroupByOutputType = {
    user_subscription_id: number;
    user_id: number | null;
    subscription_id: number | null;
    start_date: Date | null;
    end_date: Date | null;
    is_active: boolean | null;
    stripe_subscription_id: string | null;
    stripe_payment_intent_id: string | null;
    payment_status: string | null;
    last_payment_date: Date | null;
    next_billing_date: Date | null;
    cancellation_date: Date | null;
    trial_end_date: Date | null;
    last_payment_attempt_date: Date | null;
    payment_method_id: string | null;
    redeem_code: string | null;
    _count: User_subscriptionsCountAggregateOutputType | null;
    _avg: User_subscriptionsAvgAggregateOutputType | null;
    _sum: User_subscriptionsSumAggregateOutputType | null;
    _min: User_subscriptionsMinAggregateOutputType | null;
    _max: User_subscriptionsMaxAggregateOutputType | null;
  };

  type GetUser_subscriptionsGroupByPayload<
    T extends user_subscriptionsGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_subscriptionsGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof User_subscriptionsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], User_subscriptionsGroupByOutputType[P]>
          : GetScalarType<T[P], User_subscriptionsGroupByOutputType[P]>;
      }
    >
  >;

  export type user_subscriptionsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      user_subscription_id?: boolean;
      user_id?: boolean;
      subscription_id?: boolean;
      start_date?: boolean;
      end_date?: boolean;
      is_active?: boolean;
      stripe_subscription_id?: boolean;
      stripe_payment_intent_id?: boolean;
      payment_status?: boolean;
      last_payment_date?: boolean;
      next_billing_date?: boolean;
      cancellation_date?: boolean;
      trial_end_date?: boolean;
      last_payment_attempt_date?: boolean;
      payment_method_id?: boolean;
      redeem_code?: boolean;
      subscriptions?: boolean | user_subscriptions$subscriptionsArgs<ExtArgs>;
    },
    ExtArgs['result']['user_subscriptions']
  >;

  export type user_subscriptionsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      user_subscription_id?: boolean;
      user_id?: boolean;
      subscription_id?: boolean;
      start_date?: boolean;
      end_date?: boolean;
      is_active?: boolean;
      stripe_subscription_id?: boolean;
      stripe_payment_intent_id?: boolean;
      payment_status?: boolean;
      last_payment_date?: boolean;
      next_billing_date?: boolean;
      cancellation_date?: boolean;
      trial_end_date?: boolean;
      last_payment_attempt_date?: boolean;
      payment_method_id?: boolean;
      redeem_code?: boolean;
      subscriptions?: boolean | user_subscriptions$subscriptionsArgs<ExtArgs>;
    },
    ExtArgs['result']['user_subscriptions']
  >;

  export type user_subscriptionsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      user_subscription_id?: boolean;
      user_id?: boolean;
      subscription_id?: boolean;
      start_date?: boolean;
      end_date?: boolean;
      is_active?: boolean;
      stripe_subscription_id?: boolean;
      stripe_payment_intent_id?: boolean;
      payment_status?: boolean;
      last_payment_date?: boolean;
      next_billing_date?: boolean;
      cancellation_date?: boolean;
      trial_end_date?: boolean;
      last_payment_attempt_date?: boolean;
      payment_method_id?: boolean;
      redeem_code?: boolean;
      subscriptions?: boolean | user_subscriptions$subscriptionsArgs<ExtArgs>;
    },
    ExtArgs['result']['user_subscriptions']
  >;

  export type user_subscriptionsSelectScalar = {
    user_subscription_id?: boolean;
    user_id?: boolean;
    subscription_id?: boolean;
    start_date?: boolean;
    end_date?: boolean;
    is_active?: boolean;
    stripe_subscription_id?: boolean;
    stripe_payment_intent_id?: boolean;
    payment_status?: boolean;
    last_payment_date?: boolean;
    next_billing_date?: boolean;
    cancellation_date?: boolean;
    trial_end_date?: boolean;
    last_payment_attempt_date?: boolean;
    payment_method_id?: boolean;
    redeem_code?: boolean;
  };

  export type user_subscriptionsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'user_subscription_id'
    | 'user_id'
    | 'subscription_id'
    | 'start_date'
    | 'end_date'
    | 'is_active'
    | 'stripe_subscription_id'
    | 'stripe_payment_intent_id'
    | 'payment_status'
    | 'last_payment_date'
    | 'next_billing_date'
    | 'cancellation_date'
    | 'trial_end_date'
    | 'last_payment_attempt_date'
    | 'payment_method_id'
    | 'redeem_code',
    ExtArgs['result']['user_subscriptions']
  >;
  export type user_subscriptionsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    subscriptions?: boolean | user_subscriptions$subscriptionsArgs<ExtArgs>;
  };
  export type user_subscriptionsIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    subscriptions?: boolean | user_subscriptions$subscriptionsArgs<ExtArgs>;
  };
  export type user_subscriptionsIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    subscriptions?: boolean | user_subscriptions$subscriptionsArgs<ExtArgs>;
  };

  export type $user_subscriptionsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'user_subscriptions';
    objects: {
      subscriptions: Prisma.$subscriptionsPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        user_subscription_id: number;
        user_id: number | null;
        subscription_id: number | null;
        start_date: Date | null;
        end_date: Date | null;
        is_active: boolean | null;
        stripe_subscription_id: string | null;
        stripe_payment_intent_id: string | null;
        payment_status: string | null;
        last_payment_date: Date | null;
        next_billing_date: Date | null;
        cancellation_date: Date | null;
        trial_end_date: Date | null;
        last_payment_attempt_date: Date | null;
        payment_method_id: string | null;
        redeem_code: string | null;
      },
      ExtArgs['result']['user_subscriptions']
    >;
    composites: {};
  };

  type user_subscriptionsGetPayload<
    S extends boolean | null | undefined | user_subscriptionsDefaultArgs
  > = $Result.GetResult<Prisma.$user_subscriptionsPayload, S>;

  type user_subscriptionsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    user_subscriptionsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: User_subscriptionsCountAggregateInputType | true;
  };

  export interface user_subscriptionsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['user_subscriptions'];
      meta: { name: 'user_subscriptions' };
    };
    /**
     * Find zero or one User_subscriptions that matches the filter.
     * @param {user_subscriptionsFindUniqueArgs} args - Arguments to find a User_subscriptions
     * @example
     * // Get one User_subscriptions
     * const user_subscriptions = await prisma.user_subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_subscriptionsFindUniqueArgs>(
      args: SelectSubset<T, user_subscriptionsFindUniqueArgs<ExtArgs>>
    ): Prisma__user_subscriptionsClient<
      $Result.GetResult<
        Prisma.$user_subscriptionsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User_subscriptions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_subscriptionsFindUniqueOrThrowArgs} args - Arguments to find a User_subscriptions
     * @example
     * // Get one User_subscriptions
     * const user_subscriptions = await prisma.user_subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_subscriptionsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, user_subscriptionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_subscriptionsClient<
      $Result.GetResult<
        Prisma.$user_subscriptionsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User_subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_subscriptionsFindFirstArgs} args - Arguments to find a User_subscriptions
     * @example
     * // Get one User_subscriptions
     * const user_subscriptions = await prisma.user_subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_subscriptionsFindFirstArgs>(
      args?: SelectSubset<T, user_subscriptionsFindFirstArgs<ExtArgs>>
    ): Prisma__user_subscriptionsClient<
      $Result.GetResult<
        Prisma.$user_subscriptionsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User_subscriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_subscriptionsFindFirstOrThrowArgs} args - Arguments to find a User_subscriptions
     * @example
     * // Get one User_subscriptions
     * const user_subscriptions = await prisma.user_subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_subscriptionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, user_subscriptionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_subscriptionsClient<
      $Result.GetResult<
        Prisma.$user_subscriptionsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more User_subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_subscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_subscriptions
     * const user_subscriptions = await prisma.user_subscriptions.findMany()
     *
     * // Get first 10 User_subscriptions
     * const user_subscriptions = await prisma.user_subscriptions.findMany({ take: 10 })
     *
     * // Only select the `user_subscription_id`
     * const user_subscriptionsWithUser_subscription_idOnly = await prisma.user_subscriptions.findMany({ select: { user_subscription_id: true } })
     *
     */
    findMany<T extends user_subscriptionsFindManyArgs>(
      args?: SelectSubset<T, user_subscriptionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$user_subscriptionsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a User_subscriptions.
     * @param {user_subscriptionsCreateArgs} args - Arguments to create a User_subscriptions.
     * @example
     * // Create one User_subscriptions
     * const User_subscriptions = await prisma.user_subscriptions.create({
     *   data: {
     *     // ... data to create a User_subscriptions
     *   }
     * })
     *
     */
    create<T extends user_subscriptionsCreateArgs>(
      args: SelectSubset<T, user_subscriptionsCreateArgs<ExtArgs>>
    ): Prisma__user_subscriptionsClient<
      $Result.GetResult<
        Prisma.$user_subscriptionsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many User_subscriptions.
     * @param {user_subscriptionsCreateManyArgs} args - Arguments to create many User_subscriptions.
     * @example
     * // Create many User_subscriptions
     * const user_subscriptions = await prisma.user_subscriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends user_subscriptionsCreateManyArgs>(
      args?: SelectSubset<T, user_subscriptionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many User_subscriptions and returns the data saved in the database.
     * @param {user_subscriptionsCreateManyAndReturnArgs} args - Arguments to create many User_subscriptions.
     * @example
     * // Create many User_subscriptions
     * const user_subscriptions = await prisma.user_subscriptions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many User_subscriptions and only return the `user_subscription_id`
     * const user_subscriptionsWithUser_subscription_idOnly = await prisma.user_subscriptions.createManyAndReturn({
     *   select: { user_subscription_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends user_subscriptionsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, user_subscriptionsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$user_subscriptionsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a User_subscriptions.
     * @param {user_subscriptionsDeleteArgs} args - Arguments to delete one User_subscriptions.
     * @example
     * // Delete one User_subscriptions
     * const User_subscriptions = await prisma.user_subscriptions.delete({
     *   where: {
     *     // ... filter to delete one User_subscriptions
     *   }
     * })
     *
     */
    delete<T extends user_subscriptionsDeleteArgs>(
      args: SelectSubset<T, user_subscriptionsDeleteArgs<ExtArgs>>
    ): Prisma__user_subscriptionsClient<
      $Result.GetResult<
        Prisma.$user_subscriptionsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User_subscriptions.
     * @param {user_subscriptionsUpdateArgs} args - Arguments to update one User_subscriptions.
     * @example
     * // Update one User_subscriptions
     * const user_subscriptions = await prisma.user_subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends user_subscriptionsUpdateArgs>(
      args: SelectSubset<T, user_subscriptionsUpdateArgs<ExtArgs>>
    ): Prisma__user_subscriptionsClient<
      $Result.GetResult<
        Prisma.$user_subscriptionsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more User_subscriptions.
     * @param {user_subscriptionsDeleteManyArgs} args - Arguments to filter User_subscriptions to delete.
     * @example
     * // Delete a few User_subscriptions
     * const { count } = await prisma.user_subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends user_subscriptionsDeleteManyArgs>(
      args?: SelectSubset<T, user_subscriptionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more User_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_subscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_subscriptions
     * const user_subscriptions = await prisma.user_subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends user_subscriptionsUpdateManyArgs>(
      args: SelectSubset<T, user_subscriptionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more User_subscriptions and returns the data updated in the database.
     * @param {user_subscriptionsUpdateManyAndReturnArgs} args - Arguments to update many User_subscriptions.
     * @example
     * // Update many User_subscriptions
     * const user_subscriptions = await prisma.user_subscriptions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more User_subscriptions and only return the `user_subscription_id`
     * const user_subscriptionsWithUser_subscription_idOnly = await prisma.user_subscriptions.updateManyAndReturn({
     *   select: { user_subscription_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends user_subscriptionsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, user_subscriptionsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$user_subscriptionsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one User_subscriptions.
     * @param {user_subscriptionsUpsertArgs} args - Arguments to update or create a User_subscriptions.
     * @example
     * // Update or create a User_subscriptions
     * const user_subscriptions = await prisma.user_subscriptions.upsert({
     *   create: {
     *     // ... data to create a User_subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_subscriptions we want to update
     *   }
     * })
     */
    upsert<T extends user_subscriptionsUpsertArgs>(
      args: SelectSubset<T, user_subscriptionsUpsertArgs<ExtArgs>>
    ): Prisma__user_subscriptionsClient<
      $Result.GetResult<
        Prisma.$user_subscriptionsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of User_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_subscriptionsCountArgs} args - Arguments to filter User_subscriptions to count.
     * @example
     * // Count the number of User_subscriptions
     * const count = await prisma.user_subscriptions.count({
     *   where: {
     *     // ... the filter for the User_subscriptions we want to count
     *   }
     * })
     **/
    count<T extends user_subscriptionsCountArgs>(
      args?: Subset<T, user_subscriptionsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              User_subscriptionsCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_subscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends User_subscriptionsAggregateArgs>(
      args: Subset<T, User_subscriptionsAggregateArgs>
    ): Prisma.PrismaPromise<GetUser_subscriptionsAggregateType<T>>;

    /**
     * Group by User_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_subscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends user_subscriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_subscriptionsGroupByArgs['orderBy'] }
        : { orderBy?: user_subscriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, user_subscriptionsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetUser_subscriptionsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the user_subscriptions model
     */
    readonly fields: user_subscriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_subscriptionsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    subscriptions<T extends user_subscriptions$subscriptionsArgs<ExtArgs> = {}>(
      args?: Subset<T, user_subscriptions$subscriptionsArgs<ExtArgs>>
    ): Prisma__subscriptionsClient<
      $Result.GetResult<
        Prisma.$subscriptionsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the user_subscriptions model
   */
  interface user_subscriptionsFieldRefs {
    readonly user_subscription_id: FieldRef<'user_subscriptions', 'Int'>;
    readonly user_id: FieldRef<'user_subscriptions', 'Int'>;
    readonly subscription_id: FieldRef<'user_subscriptions', 'Int'>;
    readonly start_date: FieldRef<'user_subscriptions', 'DateTime'>;
    readonly end_date: FieldRef<'user_subscriptions', 'DateTime'>;
    readonly is_active: FieldRef<'user_subscriptions', 'Boolean'>;
    readonly stripe_subscription_id: FieldRef<'user_subscriptions', 'String'>;
    readonly stripe_payment_intent_id: FieldRef<'user_subscriptions', 'String'>;
    readonly payment_status: FieldRef<'user_subscriptions', 'String'>;
    readonly last_payment_date: FieldRef<'user_subscriptions', 'DateTime'>;
    readonly next_billing_date: FieldRef<'user_subscriptions', 'DateTime'>;
    readonly cancellation_date: FieldRef<'user_subscriptions', 'DateTime'>;
    readonly trial_end_date: FieldRef<'user_subscriptions', 'DateTime'>;
    readonly last_payment_attempt_date: FieldRef<
      'user_subscriptions',
      'DateTime'
    >;
    readonly payment_method_id: FieldRef<'user_subscriptions', 'String'>;
    readonly redeem_code: FieldRef<'user_subscriptions', 'String'>;
  }

  // Custom InputTypes
  /**
   * user_subscriptions findUnique
   */
  export type user_subscriptionsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_subscriptions
     */
    select?: user_subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_subscriptions
     */
    omit?: user_subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_subscriptionsInclude<ExtArgs> | null;
    /**
     * Filter, which user_subscriptions to fetch.
     */
    where: user_subscriptionsWhereUniqueInput;
  };

  /**
   * user_subscriptions findUniqueOrThrow
   */
  export type user_subscriptionsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_subscriptions
     */
    select?: user_subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_subscriptions
     */
    omit?: user_subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_subscriptionsInclude<ExtArgs> | null;
    /**
     * Filter, which user_subscriptions to fetch.
     */
    where: user_subscriptionsWhereUniqueInput;
  };

  /**
   * user_subscriptions findFirst
   */
  export type user_subscriptionsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_subscriptions
     */
    select?: user_subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_subscriptions
     */
    omit?: user_subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_subscriptionsInclude<ExtArgs> | null;
    /**
     * Filter, which user_subscriptions to fetch.
     */
    where?: user_subscriptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of user_subscriptions to fetch.
     */
    orderBy?:
      | user_subscriptionsOrderByWithRelationInput
      | user_subscriptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for user_subscriptions.
     */
    cursor?: user_subscriptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` user_subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` user_subscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of user_subscriptions.
     */
    distinct?:
      | User_subscriptionsScalarFieldEnum
      | User_subscriptionsScalarFieldEnum[];
  };

  /**
   * user_subscriptions findFirstOrThrow
   */
  export type user_subscriptionsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_subscriptions
     */
    select?: user_subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_subscriptions
     */
    omit?: user_subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_subscriptionsInclude<ExtArgs> | null;
    /**
     * Filter, which user_subscriptions to fetch.
     */
    where?: user_subscriptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of user_subscriptions to fetch.
     */
    orderBy?:
      | user_subscriptionsOrderByWithRelationInput
      | user_subscriptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for user_subscriptions.
     */
    cursor?: user_subscriptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` user_subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` user_subscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of user_subscriptions.
     */
    distinct?:
      | User_subscriptionsScalarFieldEnum
      | User_subscriptionsScalarFieldEnum[];
  };

  /**
   * user_subscriptions findMany
   */
  export type user_subscriptionsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_subscriptions
     */
    select?: user_subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_subscriptions
     */
    omit?: user_subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_subscriptionsInclude<ExtArgs> | null;
    /**
     * Filter, which user_subscriptions to fetch.
     */
    where?: user_subscriptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of user_subscriptions to fetch.
     */
    orderBy?:
      | user_subscriptionsOrderByWithRelationInput
      | user_subscriptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing user_subscriptions.
     */
    cursor?: user_subscriptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` user_subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` user_subscriptions.
     */
    skip?: number;
    distinct?:
      | User_subscriptionsScalarFieldEnum
      | User_subscriptionsScalarFieldEnum[];
  };

  /**
   * user_subscriptions create
   */
  export type user_subscriptionsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_subscriptions
     */
    select?: user_subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_subscriptions
     */
    omit?: user_subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_subscriptionsInclude<ExtArgs> | null;
    /**
     * The data needed to create a user_subscriptions.
     */
    data?: XOR<
      user_subscriptionsCreateInput,
      user_subscriptionsUncheckedCreateInput
    >;
  };

  /**
   * user_subscriptions createMany
   */
  export type user_subscriptionsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many user_subscriptions.
     */
    data:
      | user_subscriptionsCreateManyInput
      | user_subscriptionsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * user_subscriptions createManyAndReturn
   */
  export type user_subscriptionsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_subscriptions
     */
    select?: user_subscriptionsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the user_subscriptions
     */
    omit?: user_subscriptionsOmit<ExtArgs> | null;
    /**
     * The data used to create many user_subscriptions.
     */
    data:
      | user_subscriptionsCreateManyInput
      | user_subscriptionsCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_subscriptionsIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * user_subscriptions update
   */
  export type user_subscriptionsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_subscriptions
     */
    select?: user_subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_subscriptions
     */
    omit?: user_subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_subscriptionsInclude<ExtArgs> | null;
    /**
     * The data needed to update a user_subscriptions.
     */
    data: XOR<
      user_subscriptionsUpdateInput,
      user_subscriptionsUncheckedUpdateInput
    >;
    /**
     * Choose, which user_subscriptions to update.
     */
    where: user_subscriptionsWhereUniqueInput;
  };

  /**
   * user_subscriptions updateMany
   */
  export type user_subscriptionsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update user_subscriptions.
     */
    data: XOR<
      user_subscriptionsUpdateManyMutationInput,
      user_subscriptionsUncheckedUpdateManyInput
    >;
    /**
     * Filter which user_subscriptions to update
     */
    where?: user_subscriptionsWhereInput;
    /**
     * Limit how many user_subscriptions to update.
     */
    limit?: number;
  };

  /**
   * user_subscriptions updateManyAndReturn
   */
  export type user_subscriptionsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_subscriptions
     */
    select?: user_subscriptionsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the user_subscriptions
     */
    omit?: user_subscriptionsOmit<ExtArgs> | null;
    /**
     * The data used to update user_subscriptions.
     */
    data: XOR<
      user_subscriptionsUpdateManyMutationInput,
      user_subscriptionsUncheckedUpdateManyInput
    >;
    /**
     * Filter which user_subscriptions to update
     */
    where?: user_subscriptionsWhereInput;
    /**
     * Limit how many user_subscriptions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_subscriptionsIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * user_subscriptions upsert
   */
  export type user_subscriptionsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_subscriptions
     */
    select?: user_subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_subscriptions
     */
    omit?: user_subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_subscriptionsInclude<ExtArgs> | null;
    /**
     * The filter to search for the user_subscriptions to update in case it exists.
     */
    where: user_subscriptionsWhereUniqueInput;
    /**
     * In case the user_subscriptions found by the `where` argument doesn't exist, create a new user_subscriptions with this data.
     */
    create: XOR<
      user_subscriptionsCreateInput,
      user_subscriptionsUncheckedCreateInput
    >;
    /**
     * In case the user_subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      user_subscriptionsUpdateInput,
      user_subscriptionsUncheckedUpdateInput
    >;
  };

  /**
   * user_subscriptions delete
   */
  export type user_subscriptionsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_subscriptions
     */
    select?: user_subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_subscriptions
     */
    omit?: user_subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_subscriptionsInclude<ExtArgs> | null;
    /**
     * Filter which user_subscriptions to delete.
     */
    where: user_subscriptionsWhereUniqueInput;
  };

  /**
   * user_subscriptions deleteMany
   */
  export type user_subscriptionsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which user_subscriptions to delete
     */
    where?: user_subscriptionsWhereInput;
    /**
     * Limit how many user_subscriptions to delete.
     */
    limit?: number;
  };

  /**
   * user_subscriptions.subscriptions
   */
  export type user_subscriptions$subscriptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null;
    where?: subscriptionsWhereInput;
  };

  /**
   * user_subscriptions without action
   */
  export type user_subscriptionsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the user_subscriptions
     */
    select?: user_subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the user_subscriptions
     */
    omit?: user_subscriptionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_subscriptionsInclude<ExtArgs> | null;
  };

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null;
    _avg: UsersAvgAggregateOutputType | null;
    _sum: UsersSumAggregateOutputType | null;
    _min: UsersMinAggregateOutputType | null;
    _max: UsersMaxAggregateOutputType | null;
  };

  export type UsersAvgAggregateOutputType = {
    user_id: number | null;
    active_watchlist_id: number | null;
  };

  export type UsersSumAggregateOutputType = {
    user_id: number | null;
    active_watchlist_id: number | null;
  };

  export type UsersMinAggregateOutputType = {
    user_id: number | null;
    google_id: string | null;
    email: string | null;
    name: string | null;
    profile_pic: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    stripe_customer_id: string | null;
    refresh_token: string | null;
    has_used_trial: boolean | null;
    trial_used_at: Date | null;
    bio: string | null;
    is_verified: boolean | null;
    status_message: string | null;
    last_login_at: Date | null;
    birthdate: Date | null;
    language_preference: string | null;
    theme_preference: string | null;
    onboarding_completed: boolean | null;
    account_status: string | null;
    active_watchlist_id: number | null;
    username: string | null;
    is_private: boolean | null;
    apple_id: string | null;
  };

  export type UsersMaxAggregateOutputType = {
    user_id: number | null;
    google_id: string | null;
    email: string | null;
    name: string | null;
    profile_pic: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    stripe_customer_id: string | null;
    refresh_token: string | null;
    has_used_trial: boolean | null;
    trial_used_at: Date | null;
    bio: string | null;
    is_verified: boolean | null;
    status_message: string | null;
    last_login_at: Date | null;
    birthdate: Date | null;
    language_preference: string | null;
    theme_preference: string | null;
    onboarding_completed: boolean | null;
    account_status: string | null;
    active_watchlist_id: number | null;
    username: string | null;
    is_private: boolean | null;
    apple_id: string | null;
  };

  export type UsersCountAggregateOutputType = {
    user_id: number;
    google_id: number;
    email: number;
    name: number;
    profile_pic: number;
    created_at: number;
    updated_at: number;
    stripe_customer_id: number;
    refresh_token: number;
    has_used_trial: number;
    trial_used_at: number;
    bio: number;
    is_verified: number;
    status_message: number;
    last_login_at: number;
    birthdate: number;
    language_preference: number;
    theme_preference: number;
    onboarding_completed: number;
    account_status: number;
    active_watchlist_id: number;
    username: number;
    is_private: number;
    apple_id: number;
    _all: number;
  };

  export type UsersAvgAggregateInputType = {
    user_id?: true;
    active_watchlist_id?: true;
  };

  export type UsersSumAggregateInputType = {
    user_id?: true;
    active_watchlist_id?: true;
  };

  export type UsersMinAggregateInputType = {
    user_id?: true;
    google_id?: true;
    email?: true;
    name?: true;
    profile_pic?: true;
    created_at?: true;
    updated_at?: true;
    stripe_customer_id?: true;
    refresh_token?: true;
    has_used_trial?: true;
    trial_used_at?: true;
    bio?: true;
    is_verified?: true;
    status_message?: true;
    last_login_at?: true;
    birthdate?: true;
    language_preference?: true;
    theme_preference?: true;
    onboarding_completed?: true;
    account_status?: true;
    active_watchlist_id?: true;
    username?: true;
    is_private?: true;
    apple_id?: true;
  };

  export type UsersMaxAggregateInputType = {
    user_id?: true;
    google_id?: true;
    email?: true;
    name?: true;
    profile_pic?: true;
    created_at?: true;
    updated_at?: true;
    stripe_customer_id?: true;
    refresh_token?: true;
    has_used_trial?: true;
    trial_used_at?: true;
    bio?: true;
    is_verified?: true;
    status_message?: true;
    last_login_at?: true;
    birthdate?: true;
    language_preference?: true;
    theme_preference?: true;
    onboarding_completed?: true;
    account_status?: true;
    active_watchlist_id?: true;
    username?: true;
    is_private?: true;
    apple_id?: true;
  };

  export type UsersCountAggregateInputType = {
    user_id?: true;
    google_id?: true;
    email?: true;
    name?: true;
    profile_pic?: true;
    created_at?: true;
    updated_at?: true;
    stripe_customer_id?: true;
    refresh_token?: true;
    has_used_trial?: true;
    trial_used_at?: true;
    bio?: true;
    is_verified?: true;
    status_message?: true;
    last_login_at?: true;
    birthdate?: true;
    language_preference?: true;
    theme_preference?: true;
    onboarding_completed?: true;
    account_status?: true;
    active_watchlist_id?: true;
    username?: true;
    is_private?: true;
    apple_id?: true;
    _all?: true;
  };

  export type UsersAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned users
     **/
    _count?: true | UsersCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UsersAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UsersSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UsersMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UsersMaxAggregateInputType;
  };

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
    [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>;
  };

  export type usersGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: usersWhereInput;
    orderBy?:
      | usersOrderByWithAggregationInput
      | usersOrderByWithAggregationInput[];
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum;
    having?: usersScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UsersCountAggregateInputType | true;
    _avg?: UsersAvgAggregateInputType;
    _sum?: UsersSumAggregateInputType;
    _min?: UsersMinAggregateInputType;
    _max?: UsersMaxAggregateInputType;
  };

  export type UsersGroupByOutputType = {
    user_id: number;
    google_id: string | null;
    email: string | null;
    name: string;
    profile_pic: string | null;
    created_at: Date | null;
    updated_at: Date | null;
    stripe_customer_id: string | null;
    refresh_token: string | null;
    has_used_trial: boolean;
    trial_used_at: Date | null;
    bio: string | null;
    is_verified: boolean;
    status_message: string | null;
    last_login_at: Date | null;
    birthdate: Date | null;
    language_preference: string;
    theme_preference: string | null;
    onboarding_completed: boolean;
    account_status: string | null;
    active_watchlist_id: number | null;
    username: string;
    is_private: boolean;
    apple_id: string | null;
    _count: UsersCountAggregateOutputType | null;
    _avg: UsersAvgAggregateOutputType | null;
    _sum: UsersSumAggregateOutputType | null;
    _min: UsersMinAggregateOutputType | null;
    _max: UsersMaxAggregateOutputType | null;
  };

  type GetUsersGroupByPayload<T extends usersGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UsersGroupByOutputType, T['by']> & {
          [P in keyof T & keyof UsersGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>;
        }
      >
    >;

  export type usersSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      user_id?: boolean;
      google_id?: boolean;
      email?: boolean;
      name?: boolean;
      profile_pic?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      stripe_customer_id?: boolean;
      refresh_token?: boolean;
      has_used_trial?: boolean;
      trial_used_at?: boolean;
      bio?: boolean;
      is_verified?: boolean;
      status_message?: boolean;
      last_login_at?: boolean;
      birthdate?: boolean;
      language_preference?: boolean;
      theme_preference?: boolean;
      onboarding_completed?: boolean;
      account_status?: boolean;
      active_watchlist_id?: boolean;
      username?: boolean;
      is_private?: boolean;
      apple_id?: boolean;
    },
    ExtArgs['result']['users']
  >;

  export type usersSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      user_id?: boolean;
      google_id?: boolean;
      email?: boolean;
      name?: boolean;
      profile_pic?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      stripe_customer_id?: boolean;
      refresh_token?: boolean;
      has_used_trial?: boolean;
      trial_used_at?: boolean;
      bio?: boolean;
      is_verified?: boolean;
      status_message?: boolean;
      last_login_at?: boolean;
      birthdate?: boolean;
      language_preference?: boolean;
      theme_preference?: boolean;
      onboarding_completed?: boolean;
      account_status?: boolean;
      active_watchlist_id?: boolean;
      username?: boolean;
      is_private?: boolean;
      apple_id?: boolean;
    },
    ExtArgs['result']['users']
  >;

  export type usersSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      user_id?: boolean;
      google_id?: boolean;
      email?: boolean;
      name?: boolean;
      profile_pic?: boolean;
      created_at?: boolean;
      updated_at?: boolean;
      stripe_customer_id?: boolean;
      refresh_token?: boolean;
      has_used_trial?: boolean;
      trial_used_at?: boolean;
      bio?: boolean;
      is_verified?: boolean;
      status_message?: boolean;
      last_login_at?: boolean;
      birthdate?: boolean;
      language_preference?: boolean;
      theme_preference?: boolean;
      onboarding_completed?: boolean;
      account_status?: boolean;
      active_watchlist_id?: boolean;
      username?: boolean;
      is_private?: boolean;
      apple_id?: boolean;
    },
    ExtArgs['result']['users']
  >;

  export type usersSelectScalar = {
    user_id?: boolean;
    google_id?: boolean;
    email?: boolean;
    name?: boolean;
    profile_pic?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    stripe_customer_id?: boolean;
    refresh_token?: boolean;
    has_used_trial?: boolean;
    trial_used_at?: boolean;
    bio?: boolean;
    is_verified?: boolean;
    status_message?: boolean;
    last_login_at?: boolean;
    birthdate?: boolean;
    language_preference?: boolean;
    theme_preference?: boolean;
    onboarding_completed?: boolean;
    account_status?: boolean;
    active_watchlist_id?: boolean;
    username?: boolean;
    is_private?: boolean;
    apple_id?: boolean;
  };

  export type usersOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'user_id'
    | 'google_id'
    | 'email'
    | 'name'
    | 'profile_pic'
    | 'created_at'
    | 'updated_at'
    | 'stripe_customer_id'
    | 'refresh_token'
    | 'has_used_trial'
    | 'trial_used_at'
    | 'bio'
    | 'is_verified'
    | 'status_message'
    | 'last_login_at'
    | 'birthdate'
    | 'language_preference'
    | 'theme_preference'
    | 'onboarding_completed'
    | 'account_status'
    | 'active_watchlist_id'
    | 'username'
    | 'is_private'
    | 'apple_id',
    ExtArgs['result']['users']
  >;

  export type $usersPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'users';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        user_id: number;
        google_id: string | null;
        email: string | null;
        name: string;
        profile_pic: string | null;
        created_at: Date | null;
        updated_at: Date | null;
        stripe_customer_id: string | null;
        refresh_token: string | null;
        has_used_trial: boolean;
        trial_used_at: Date | null;
        bio: string | null;
        is_verified: boolean;
        status_message: string | null;
        last_login_at: Date | null;
        birthdate: Date | null;
        language_preference: string;
        theme_preference: string | null;
        onboarding_completed: boolean;
        account_status: string | null;
        active_watchlist_id: number | null;
        username: string;
        is_private: boolean;
        apple_id: string | null;
      },
      ExtArgs['result']['users']
    >;
    composites: {};
  };

  type usersGetPayload<
    S extends boolean | null | undefined | usersDefaultArgs
  > = $Result.GetResult<Prisma.$usersPayload, S>;

  type usersCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UsersCountAggregateInputType | true;
  };

  export interface usersDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['users'];
      meta: { name: 'users' };
    };
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(
      args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(
      args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(
      args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     *
     * // Only select the `user_id`
     * const usersWithUser_idOnly = await prisma.users.findMany({ select: { user_id: true } })
     *
     */
    findMany<T extends usersFindManyArgs>(
      args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     *
     */
    create<T extends usersCreateArgs>(
      args: SelectSubset<T, usersCreateArgs<ExtArgs>>
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends usersCreateManyArgs>(
      args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `user_id`
     * const usersWithUser_idOnly = await prisma.users.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(
      args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     *
     */
    delete<T extends usersDeleteArgs>(
      args: SelectSubset<T, usersDeleteArgs<ExtArgs>>
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends usersUpdateArgs>(
      args: SelectSubset<T, usersUpdateArgs<ExtArgs>>
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends usersDeleteManyArgs>(
      args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends usersUpdateManyArgs>(
      args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `user_id`
     * const usersWithUser_idOnly = await prisma.users.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(
      args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(
      args: SelectSubset<T, usersUpsertArgs<ExtArgs>>
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UsersAggregateArgs>(
      args: Subset<T, UsersAggregateArgs>
    ): Prisma.PrismaPromise<GetUsersAggregateType<T>>;

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetUsersGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the users model
     */
    readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly user_id: FieldRef<'users', 'Int'>;
    readonly google_id: FieldRef<'users', 'String'>;
    readonly email: FieldRef<'users', 'String'>;
    readonly name: FieldRef<'users', 'String'>;
    readonly profile_pic: FieldRef<'users', 'String'>;
    readonly created_at: FieldRef<'users', 'DateTime'>;
    readonly updated_at: FieldRef<'users', 'DateTime'>;
    readonly stripe_customer_id: FieldRef<'users', 'String'>;
    readonly refresh_token: FieldRef<'users', 'String'>;
    readonly has_used_trial: FieldRef<'users', 'Boolean'>;
    readonly trial_used_at: FieldRef<'users', 'DateTime'>;
    readonly bio: FieldRef<'users', 'String'>;
    readonly is_verified: FieldRef<'users', 'Boolean'>;
    readonly status_message: FieldRef<'users', 'String'>;
    readonly last_login_at: FieldRef<'users', 'DateTime'>;
    readonly birthdate: FieldRef<'users', 'DateTime'>;
    readonly language_preference: FieldRef<'users', 'String'>;
    readonly theme_preference: FieldRef<'users', 'String'>;
    readonly onboarding_completed: FieldRef<'users', 'Boolean'>;
    readonly account_status: FieldRef<'users', 'String'>;
    readonly active_watchlist_id: FieldRef<'users', 'Int'>;
    readonly username: FieldRef<'users', 'String'>;
    readonly is_private: FieldRef<'users', 'Boolean'>;
    readonly apple_id: FieldRef<'users', 'String'>;
  }

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput;
  };

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput;
  };

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[];
  };

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[];
  };

  /**
   * users findMany
   */
  export type usersFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` users.
     */
    skip?: number;
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[];
  };

  /**
   * users create
   */
  export type usersCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>;
  };

  /**
   * users createMany
   */
  export type usersCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * users update
   */
  export type usersUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>;
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput;
  };

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>;
    /**
     * Filter which users to update
     */
    where?: usersWhereInput;
    /**
     * Limit how many users to update.
     */
    limit?: number;
  };

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>;
    /**
     * Filter which users to update
     */
    where?: usersWhereInput;
    /**
     * Limit how many users to update.
     */
    limit?: number;
  };

  /**
   * users upsert
   */
  export type usersUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput;
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>;
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>;
  };

  /**
   * users delete
   */
  export type usersDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput;
  };

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput;
    /**
     * Limit how many users to delete.
     */
    limit?: number;
  };

  /**
   * users without action
   */
  export type usersDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
  };

  /**
   * Model watchlist_items
   */

  export type AggregateWatchlist_items = {
    _count: Watchlist_itemsCountAggregateOutputType | null;
    _avg: Watchlist_itemsAvgAggregateOutputType | null;
    _sum: Watchlist_itemsSumAggregateOutputType | null;
    _min: Watchlist_itemsMinAggregateOutputType | null;
    _max: Watchlist_itemsMaxAggregateOutputType | null;
  };

  export type Watchlist_itemsAvgAggregateOutputType = {
    watchlist_item_id: number | null;
    watchlist_id: number | null;
    sequence: number | null;
  };

  export type Watchlist_itemsSumAggregateOutputType = {
    watchlist_item_id: number | null;
    watchlist_id: number | null;
    sequence: number | null;
  };

  export type Watchlist_itemsMinAggregateOutputType = {
    watchlist_item_id: number | null;
    watchlist_id: number | null;
    symbol: string | null;
    name: string | null;
    type: string | null;
    added_at: Date | null;
    sequence: number | null;
  };

  export type Watchlist_itemsMaxAggregateOutputType = {
    watchlist_item_id: number | null;
    watchlist_id: number | null;
    symbol: string | null;
    name: string | null;
    type: string | null;
    added_at: Date | null;
    sequence: number | null;
  };

  export type Watchlist_itemsCountAggregateOutputType = {
    watchlist_item_id: number;
    watchlist_id: number;
    symbol: number;
    name: number;
    type: number;
    added_at: number;
    sequence: number;
    _all: number;
  };

  export type Watchlist_itemsAvgAggregateInputType = {
    watchlist_item_id?: true;
    watchlist_id?: true;
    sequence?: true;
  };

  export type Watchlist_itemsSumAggregateInputType = {
    watchlist_item_id?: true;
    watchlist_id?: true;
    sequence?: true;
  };

  export type Watchlist_itemsMinAggregateInputType = {
    watchlist_item_id?: true;
    watchlist_id?: true;
    symbol?: true;
    name?: true;
    type?: true;
    added_at?: true;
    sequence?: true;
  };

  export type Watchlist_itemsMaxAggregateInputType = {
    watchlist_item_id?: true;
    watchlist_id?: true;
    symbol?: true;
    name?: true;
    type?: true;
    added_at?: true;
    sequence?: true;
  };

  export type Watchlist_itemsCountAggregateInputType = {
    watchlist_item_id?: true;
    watchlist_id?: true;
    symbol?: true;
    name?: true;
    type?: true;
    added_at?: true;
    sequence?: true;
    _all?: true;
  };

  export type Watchlist_itemsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which watchlist_items to aggregate.
     */
    where?: watchlist_itemsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of watchlist_items to fetch.
     */
    orderBy?:
      | watchlist_itemsOrderByWithRelationInput
      | watchlist_itemsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: watchlist_itemsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` watchlist_items from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` watchlist_items.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned watchlist_items
     **/
    _count?: true | Watchlist_itemsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Watchlist_itemsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Watchlist_itemsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Watchlist_itemsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Watchlist_itemsMaxAggregateInputType;
  };

  export type GetWatchlist_itemsAggregateType<
    T extends Watchlist_itemsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateWatchlist_items]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchlist_items[P]>
      : GetScalarType<T[P], AggregateWatchlist_items[P]>;
  };

  export type watchlist_itemsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: watchlist_itemsWhereInput;
    orderBy?:
      | watchlist_itemsOrderByWithAggregationInput
      | watchlist_itemsOrderByWithAggregationInput[];
    by: Watchlist_itemsScalarFieldEnum[] | Watchlist_itemsScalarFieldEnum;
    having?: watchlist_itemsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Watchlist_itemsCountAggregateInputType | true;
    _avg?: Watchlist_itemsAvgAggregateInputType;
    _sum?: Watchlist_itemsSumAggregateInputType;
    _min?: Watchlist_itemsMinAggregateInputType;
    _max?: Watchlist_itemsMaxAggregateInputType;
  };

  export type Watchlist_itemsGroupByOutputType = {
    watchlist_item_id: number;
    watchlist_id: number | null;
    symbol: string | null;
    name: string | null;
    type: string | null;
    added_at: Date | null;
    sequence: number | null;
    _count: Watchlist_itemsCountAggregateOutputType | null;
    _avg: Watchlist_itemsAvgAggregateOutputType | null;
    _sum: Watchlist_itemsSumAggregateOutputType | null;
    _min: Watchlist_itemsMinAggregateOutputType | null;
    _max: Watchlist_itemsMaxAggregateOutputType | null;
  };

  type GetWatchlist_itemsGroupByPayload<T extends watchlist_itemsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<Watchlist_itemsGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof Watchlist_itemsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Watchlist_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Watchlist_itemsGroupByOutputType[P]>;
        }
      >
    >;

  export type watchlist_itemsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      watchlist_item_id?: boolean;
      watchlist_id?: boolean;
      symbol?: boolean;
      name?: boolean;
      type?: boolean;
      added_at?: boolean;
      sequence?: boolean;
    },
    ExtArgs['result']['watchlist_items']
  >;

  export type watchlist_itemsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      watchlist_item_id?: boolean;
      watchlist_id?: boolean;
      symbol?: boolean;
      name?: boolean;
      type?: boolean;
      added_at?: boolean;
      sequence?: boolean;
    },
    ExtArgs['result']['watchlist_items']
  >;

  export type watchlist_itemsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      watchlist_item_id?: boolean;
      watchlist_id?: boolean;
      symbol?: boolean;
      name?: boolean;
      type?: boolean;
      added_at?: boolean;
      sequence?: boolean;
    },
    ExtArgs['result']['watchlist_items']
  >;

  export type watchlist_itemsSelectScalar = {
    watchlist_item_id?: boolean;
    watchlist_id?: boolean;
    symbol?: boolean;
    name?: boolean;
    type?: boolean;
    added_at?: boolean;
    sequence?: boolean;
  };

  export type watchlist_itemsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'watchlist_item_id'
    | 'watchlist_id'
    | 'symbol'
    | 'name'
    | 'type'
    | 'added_at'
    | 'sequence',
    ExtArgs['result']['watchlist_items']
  >;

  export type $watchlist_itemsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'watchlist_items';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        watchlist_item_id: number;
        watchlist_id: number | null;
        symbol: string | null;
        name: string | null;
        type: string | null;
        added_at: Date | null;
        sequence: number | null;
      },
      ExtArgs['result']['watchlist_items']
    >;
    composites: {};
  };

  type watchlist_itemsGetPayload<
    S extends boolean | null | undefined | watchlist_itemsDefaultArgs
  > = $Result.GetResult<Prisma.$watchlist_itemsPayload, S>;

  type watchlist_itemsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    watchlist_itemsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Watchlist_itemsCountAggregateInputType | true;
  };

  export interface watchlist_itemsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['watchlist_items'];
      meta: { name: 'watchlist_items' };
    };
    /**
     * Find zero or one Watchlist_items that matches the filter.
     * @param {watchlist_itemsFindUniqueArgs} args - Arguments to find a Watchlist_items
     * @example
     * // Get one Watchlist_items
     * const watchlist_items = await prisma.watchlist_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends watchlist_itemsFindUniqueArgs>(
      args: SelectSubset<T, watchlist_itemsFindUniqueArgs<ExtArgs>>
    ): Prisma__watchlist_itemsClient<
      $Result.GetResult<
        Prisma.$watchlist_itemsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Watchlist_items that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {watchlist_itemsFindUniqueOrThrowArgs} args - Arguments to find a Watchlist_items
     * @example
     * // Get one Watchlist_items
     * const watchlist_items = await prisma.watchlist_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends watchlist_itemsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, watchlist_itemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__watchlist_itemsClient<
      $Result.GetResult<
        Prisma.$watchlist_itemsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Watchlist_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {watchlist_itemsFindFirstArgs} args - Arguments to find a Watchlist_items
     * @example
     * // Get one Watchlist_items
     * const watchlist_items = await prisma.watchlist_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends watchlist_itemsFindFirstArgs>(
      args?: SelectSubset<T, watchlist_itemsFindFirstArgs<ExtArgs>>
    ): Prisma__watchlist_itemsClient<
      $Result.GetResult<
        Prisma.$watchlist_itemsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Watchlist_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {watchlist_itemsFindFirstOrThrowArgs} args - Arguments to find a Watchlist_items
     * @example
     * // Get one Watchlist_items
     * const watchlist_items = await prisma.watchlist_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends watchlist_itemsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, watchlist_itemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__watchlist_itemsClient<
      $Result.GetResult<
        Prisma.$watchlist_itemsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Watchlist_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {watchlist_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Watchlist_items
     * const watchlist_items = await prisma.watchlist_items.findMany()
     *
     * // Get first 10 Watchlist_items
     * const watchlist_items = await prisma.watchlist_items.findMany({ take: 10 })
     *
     * // Only select the `watchlist_item_id`
     * const watchlist_itemsWithWatchlist_item_idOnly = await prisma.watchlist_items.findMany({ select: { watchlist_item_id: true } })
     *
     */
    findMany<T extends watchlist_itemsFindManyArgs>(
      args?: SelectSubset<T, watchlist_itemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$watchlist_itemsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Watchlist_items.
     * @param {watchlist_itemsCreateArgs} args - Arguments to create a Watchlist_items.
     * @example
     * // Create one Watchlist_items
     * const Watchlist_items = await prisma.watchlist_items.create({
     *   data: {
     *     // ... data to create a Watchlist_items
     *   }
     * })
     *
     */
    create<T extends watchlist_itemsCreateArgs>(
      args: SelectSubset<T, watchlist_itemsCreateArgs<ExtArgs>>
    ): Prisma__watchlist_itemsClient<
      $Result.GetResult<
        Prisma.$watchlist_itemsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Watchlist_items.
     * @param {watchlist_itemsCreateManyArgs} args - Arguments to create many Watchlist_items.
     * @example
     * // Create many Watchlist_items
     * const watchlist_items = await prisma.watchlist_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends watchlist_itemsCreateManyArgs>(
      args?: SelectSubset<T, watchlist_itemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Watchlist_items and returns the data saved in the database.
     * @param {watchlist_itemsCreateManyAndReturnArgs} args - Arguments to create many Watchlist_items.
     * @example
     * // Create many Watchlist_items
     * const watchlist_items = await prisma.watchlist_items.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Watchlist_items and only return the `watchlist_item_id`
     * const watchlist_itemsWithWatchlist_item_idOnly = await prisma.watchlist_items.createManyAndReturn({
     *   select: { watchlist_item_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends watchlist_itemsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, watchlist_itemsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$watchlist_itemsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Watchlist_items.
     * @param {watchlist_itemsDeleteArgs} args - Arguments to delete one Watchlist_items.
     * @example
     * // Delete one Watchlist_items
     * const Watchlist_items = await prisma.watchlist_items.delete({
     *   where: {
     *     // ... filter to delete one Watchlist_items
     *   }
     * })
     *
     */
    delete<T extends watchlist_itemsDeleteArgs>(
      args: SelectSubset<T, watchlist_itemsDeleteArgs<ExtArgs>>
    ): Prisma__watchlist_itemsClient<
      $Result.GetResult<
        Prisma.$watchlist_itemsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Watchlist_items.
     * @param {watchlist_itemsUpdateArgs} args - Arguments to update one Watchlist_items.
     * @example
     * // Update one Watchlist_items
     * const watchlist_items = await prisma.watchlist_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends watchlist_itemsUpdateArgs>(
      args: SelectSubset<T, watchlist_itemsUpdateArgs<ExtArgs>>
    ): Prisma__watchlist_itemsClient<
      $Result.GetResult<
        Prisma.$watchlist_itemsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Watchlist_items.
     * @param {watchlist_itemsDeleteManyArgs} args - Arguments to filter Watchlist_items to delete.
     * @example
     * // Delete a few Watchlist_items
     * const { count } = await prisma.watchlist_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends watchlist_itemsDeleteManyArgs>(
      args?: SelectSubset<T, watchlist_itemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Watchlist_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {watchlist_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Watchlist_items
     * const watchlist_items = await prisma.watchlist_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends watchlist_itemsUpdateManyArgs>(
      args: SelectSubset<T, watchlist_itemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Watchlist_items and returns the data updated in the database.
     * @param {watchlist_itemsUpdateManyAndReturnArgs} args - Arguments to update many Watchlist_items.
     * @example
     * // Update many Watchlist_items
     * const watchlist_items = await prisma.watchlist_items.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Watchlist_items and only return the `watchlist_item_id`
     * const watchlist_itemsWithWatchlist_item_idOnly = await prisma.watchlist_items.updateManyAndReturn({
     *   select: { watchlist_item_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends watchlist_itemsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, watchlist_itemsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$watchlist_itemsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Watchlist_items.
     * @param {watchlist_itemsUpsertArgs} args - Arguments to update or create a Watchlist_items.
     * @example
     * // Update or create a Watchlist_items
     * const watchlist_items = await prisma.watchlist_items.upsert({
     *   create: {
     *     // ... data to create a Watchlist_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Watchlist_items we want to update
     *   }
     * })
     */
    upsert<T extends watchlist_itemsUpsertArgs>(
      args: SelectSubset<T, watchlist_itemsUpsertArgs<ExtArgs>>
    ): Prisma__watchlist_itemsClient<
      $Result.GetResult<
        Prisma.$watchlist_itemsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Watchlist_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {watchlist_itemsCountArgs} args - Arguments to filter Watchlist_items to count.
     * @example
     * // Count the number of Watchlist_items
     * const count = await prisma.watchlist_items.count({
     *   where: {
     *     // ... the filter for the Watchlist_items we want to count
     *   }
     * })
     **/
    count<T extends watchlist_itemsCountArgs>(
      args?: Subset<T, watchlist_itemsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Watchlist_itemsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Watchlist_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Watchlist_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Watchlist_itemsAggregateArgs>(
      args: Subset<T, Watchlist_itemsAggregateArgs>
    ): Prisma.PrismaPromise<GetWatchlist_itemsAggregateType<T>>;

    /**
     * Group by Watchlist_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {watchlist_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends watchlist_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: watchlist_itemsGroupByArgs['orderBy'] }
        : { orderBy?: watchlist_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, watchlist_itemsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetWatchlist_itemsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the watchlist_items model
     */
    readonly fields: watchlist_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for watchlist_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__watchlist_itemsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the watchlist_items model
   */
  interface watchlist_itemsFieldRefs {
    readonly watchlist_item_id: FieldRef<'watchlist_items', 'Int'>;
    readonly watchlist_id: FieldRef<'watchlist_items', 'Int'>;
    readonly symbol: FieldRef<'watchlist_items', 'String'>;
    readonly name: FieldRef<'watchlist_items', 'String'>;
    readonly type: FieldRef<'watchlist_items', 'String'>;
    readonly added_at: FieldRef<'watchlist_items', 'DateTime'>;
    readonly sequence: FieldRef<'watchlist_items', 'Int'>;
  }

  // Custom InputTypes
  /**
   * watchlist_items findUnique
   */
  export type watchlist_itemsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlist_items
     */
    select?: watchlist_itemsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlist_items
     */
    omit?: watchlist_itemsOmit<ExtArgs> | null;
    /**
     * Filter, which watchlist_items to fetch.
     */
    where: watchlist_itemsWhereUniqueInput;
  };

  /**
   * watchlist_items findUniqueOrThrow
   */
  export type watchlist_itemsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlist_items
     */
    select?: watchlist_itemsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlist_items
     */
    omit?: watchlist_itemsOmit<ExtArgs> | null;
    /**
     * Filter, which watchlist_items to fetch.
     */
    where: watchlist_itemsWhereUniqueInput;
  };

  /**
   * watchlist_items findFirst
   */
  export type watchlist_itemsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlist_items
     */
    select?: watchlist_itemsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlist_items
     */
    omit?: watchlist_itemsOmit<ExtArgs> | null;
    /**
     * Filter, which watchlist_items to fetch.
     */
    where?: watchlist_itemsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of watchlist_items to fetch.
     */
    orderBy?:
      | watchlist_itemsOrderByWithRelationInput
      | watchlist_itemsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for watchlist_items.
     */
    cursor?: watchlist_itemsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` watchlist_items from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` watchlist_items.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of watchlist_items.
     */
    distinct?:
      | Watchlist_itemsScalarFieldEnum
      | Watchlist_itemsScalarFieldEnum[];
  };

  /**
   * watchlist_items findFirstOrThrow
   */
  export type watchlist_itemsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlist_items
     */
    select?: watchlist_itemsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlist_items
     */
    omit?: watchlist_itemsOmit<ExtArgs> | null;
    /**
     * Filter, which watchlist_items to fetch.
     */
    where?: watchlist_itemsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of watchlist_items to fetch.
     */
    orderBy?:
      | watchlist_itemsOrderByWithRelationInput
      | watchlist_itemsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for watchlist_items.
     */
    cursor?: watchlist_itemsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` watchlist_items from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` watchlist_items.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of watchlist_items.
     */
    distinct?:
      | Watchlist_itemsScalarFieldEnum
      | Watchlist_itemsScalarFieldEnum[];
  };

  /**
   * watchlist_items findMany
   */
  export type watchlist_itemsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlist_items
     */
    select?: watchlist_itemsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlist_items
     */
    omit?: watchlist_itemsOmit<ExtArgs> | null;
    /**
     * Filter, which watchlist_items to fetch.
     */
    where?: watchlist_itemsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of watchlist_items to fetch.
     */
    orderBy?:
      | watchlist_itemsOrderByWithRelationInput
      | watchlist_itemsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing watchlist_items.
     */
    cursor?: watchlist_itemsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` watchlist_items from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` watchlist_items.
     */
    skip?: number;
    distinct?:
      | Watchlist_itemsScalarFieldEnum
      | Watchlist_itemsScalarFieldEnum[];
  };

  /**
   * watchlist_items create
   */
  export type watchlist_itemsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlist_items
     */
    select?: watchlist_itemsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlist_items
     */
    omit?: watchlist_itemsOmit<ExtArgs> | null;
    /**
     * The data needed to create a watchlist_items.
     */
    data?: XOR<watchlist_itemsCreateInput, watchlist_itemsUncheckedCreateInput>;
  };

  /**
   * watchlist_items createMany
   */
  export type watchlist_itemsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many watchlist_items.
     */
    data: watchlist_itemsCreateManyInput | watchlist_itemsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * watchlist_items createManyAndReturn
   */
  export type watchlist_itemsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlist_items
     */
    select?: watchlist_itemsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlist_items
     */
    omit?: watchlist_itemsOmit<ExtArgs> | null;
    /**
     * The data used to create many watchlist_items.
     */
    data: watchlist_itemsCreateManyInput | watchlist_itemsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * watchlist_items update
   */
  export type watchlist_itemsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlist_items
     */
    select?: watchlist_itemsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlist_items
     */
    omit?: watchlist_itemsOmit<ExtArgs> | null;
    /**
     * The data needed to update a watchlist_items.
     */
    data: XOR<watchlist_itemsUpdateInput, watchlist_itemsUncheckedUpdateInput>;
    /**
     * Choose, which watchlist_items to update.
     */
    where: watchlist_itemsWhereUniqueInput;
  };

  /**
   * watchlist_items updateMany
   */
  export type watchlist_itemsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update watchlist_items.
     */
    data: XOR<
      watchlist_itemsUpdateManyMutationInput,
      watchlist_itemsUncheckedUpdateManyInput
    >;
    /**
     * Filter which watchlist_items to update
     */
    where?: watchlist_itemsWhereInput;
    /**
     * Limit how many watchlist_items to update.
     */
    limit?: number;
  };

  /**
   * watchlist_items updateManyAndReturn
   */
  export type watchlist_itemsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlist_items
     */
    select?: watchlist_itemsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlist_items
     */
    omit?: watchlist_itemsOmit<ExtArgs> | null;
    /**
     * The data used to update watchlist_items.
     */
    data: XOR<
      watchlist_itemsUpdateManyMutationInput,
      watchlist_itemsUncheckedUpdateManyInput
    >;
    /**
     * Filter which watchlist_items to update
     */
    where?: watchlist_itemsWhereInput;
    /**
     * Limit how many watchlist_items to update.
     */
    limit?: number;
  };

  /**
   * watchlist_items upsert
   */
  export type watchlist_itemsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlist_items
     */
    select?: watchlist_itemsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlist_items
     */
    omit?: watchlist_itemsOmit<ExtArgs> | null;
    /**
     * The filter to search for the watchlist_items to update in case it exists.
     */
    where: watchlist_itemsWhereUniqueInput;
    /**
     * In case the watchlist_items found by the `where` argument doesn't exist, create a new watchlist_items with this data.
     */
    create: XOR<
      watchlist_itemsCreateInput,
      watchlist_itemsUncheckedCreateInput
    >;
    /**
     * In case the watchlist_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      watchlist_itemsUpdateInput,
      watchlist_itemsUncheckedUpdateInput
    >;
  };

  /**
   * watchlist_items delete
   */
  export type watchlist_itemsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlist_items
     */
    select?: watchlist_itemsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlist_items
     */
    omit?: watchlist_itemsOmit<ExtArgs> | null;
    /**
     * Filter which watchlist_items to delete.
     */
    where: watchlist_itemsWhereUniqueInput;
  };

  /**
   * watchlist_items deleteMany
   */
  export type watchlist_itemsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which watchlist_items to delete
     */
    where?: watchlist_itemsWhereInput;
    /**
     * Limit how many watchlist_items to delete.
     */
    limit?: number;
  };

  /**
   * watchlist_items without action
   */
  export type watchlist_itemsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlist_items
     */
    select?: watchlist_itemsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlist_items
     */
    omit?: watchlist_itemsOmit<ExtArgs> | null;
  };

  /**
   * Model watchlists
   */

  export type AggregateWatchlists = {
    _count: WatchlistsCountAggregateOutputType | null;
    _avg: WatchlistsAvgAggregateOutputType | null;
    _sum: WatchlistsSumAggregateOutputType | null;
    _min: WatchlistsMinAggregateOutputType | null;
    _max: WatchlistsMaxAggregateOutputType | null;
  };

  export type WatchlistsAvgAggregateOutputType = {
    watchlist_id: number | null;
    user_id: number | null;
  };

  export type WatchlistsSumAggregateOutputType = {
    watchlist_id: number | null;
    user_id: number | null;
  };

  export type WatchlistsMinAggregateOutputType = {
    watchlist_id: number | null;
    user_id: number | null;
    name: string | null;
    created_at: Date | null;
  };

  export type WatchlistsMaxAggregateOutputType = {
    watchlist_id: number | null;
    user_id: number | null;
    name: string | null;
    created_at: Date | null;
  };

  export type WatchlistsCountAggregateOutputType = {
    watchlist_id: number;
    user_id: number;
    name: number;
    created_at: number;
    _all: number;
  };

  export type WatchlistsAvgAggregateInputType = {
    watchlist_id?: true;
    user_id?: true;
  };

  export type WatchlistsSumAggregateInputType = {
    watchlist_id?: true;
    user_id?: true;
  };

  export type WatchlistsMinAggregateInputType = {
    watchlist_id?: true;
    user_id?: true;
    name?: true;
    created_at?: true;
  };

  export type WatchlistsMaxAggregateInputType = {
    watchlist_id?: true;
    user_id?: true;
    name?: true;
    created_at?: true;
  };

  export type WatchlistsCountAggregateInputType = {
    watchlist_id?: true;
    user_id?: true;
    name?: true;
    created_at?: true;
    _all?: true;
  };

  export type WatchlistsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which watchlists to aggregate.
     */
    where?: watchlistsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of watchlists to fetch.
     */
    orderBy?:
      | watchlistsOrderByWithRelationInput
      | watchlistsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: watchlistsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` watchlists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` watchlists.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned watchlists
     **/
    _count?: true | WatchlistsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: WatchlistsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: WatchlistsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: WatchlistsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: WatchlistsMaxAggregateInputType;
  };

  export type GetWatchlistsAggregateType<T extends WatchlistsAggregateArgs> = {
    [P in keyof T & keyof AggregateWatchlists]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchlists[P]>
      : GetScalarType<T[P], AggregateWatchlists[P]>;
  };

  export type watchlistsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: watchlistsWhereInput;
    orderBy?:
      | watchlistsOrderByWithAggregationInput
      | watchlistsOrderByWithAggregationInput[];
    by: WatchlistsScalarFieldEnum[] | WatchlistsScalarFieldEnum;
    having?: watchlistsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: WatchlistsCountAggregateInputType | true;
    _avg?: WatchlistsAvgAggregateInputType;
    _sum?: WatchlistsSumAggregateInputType;
    _min?: WatchlistsMinAggregateInputType;
    _max?: WatchlistsMaxAggregateInputType;
  };

  export type WatchlistsGroupByOutputType = {
    watchlist_id: number;
    user_id: number | null;
    name: string | null;
    created_at: Date | null;
    _count: WatchlistsCountAggregateOutputType | null;
    _avg: WatchlistsAvgAggregateOutputType | null;
    _sum: WatchlistsSumAggregateOutputType | null;
    _min: WatchlistsMinAggregateOutputType | null;
    _max: WatchlistsMaxAggregateOutputType | null;
  };

  type GetWatchlistsGroupByPayload<T extends watchlistsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<WatchlistsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof WatchlistsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchlistsGroupByOutputType[P]>
            : GetScalarType<T[P], WatchlistsGroupByOutputType[P]>;
        }
      >
    >;

  export type watchlistsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      watchlist_id?: boolean;
      user_id?: boolean;
      name?: boolean;
      created_at?: boolean;
    },
    ExtArgs['result']['watchlists']
  >;

  export type watchlistsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      watchlist_id?: boolean;
      user_id?: boolean;
      name?: boolean;
      created_at?: boolean;
    },
    ExtArgs['result']['watchlists']
  >;

  export type watchlistsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      watchlist_id?: boolean;
      user_id?: boolean;
      name?: boolean;
      created_at?: boolean;
    },
    ExtArgs['result']['watchlists']
  >;

  export type watchlistsSelectScalar = {
    watchlist_id?: boolean;
    user_id?: boolean;
    name?: boolean;
    created_at?: boolean;
  };

  export type watchlistsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'watchlist_id' | 'user_id' | 'name' | 'created_at',
    ExtArgs['result']['watchlists']
  >;

  export type $watchlistsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'watchlists';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        watchlist_id: number;
        user_id: number | null;
        name: string | null;
        created_at: Date | null;
      },
      ExtArgs['result']['watchlists']
    >;
    composites: {};
  };

  type watchlistsGetPayload<
    S extends boolean | null | undefined | watchlistsDefaultArgs
  > = $Result.GetResult<Prisma.$watchlistsPayload, S>;

  type watchlistsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    watchlistsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: WatchlistsCountAggregateInputType | true;
  };

  export interface watchlistsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['watchlists'];
      meta: { name: 'watchlists' };
    };
    /**
     * Find zero or one Watchlists that matches the filter.
     * @param {watchlistsFindUniqueArgs} args - Arguments to find a Watchlists
     * @example
     * // Get one Watchlists
     * const watchlists = await prisma.watchlists.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends watchlistsFindUniqueArgs>(
      args: SelectSubset<T, watchlistsFindUniqueArgs<ExtArgs>>
    ): Prisma__watchlistsClient<
      $Result.GetResult<
        Prisma.$watchlistsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Watchlists that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {watchlistsFindUniqueOrThrowArgs} args - Arguments to find a Watchlists
     * @example
     * // Get one Watchlists
     * const watchlists = await prisma.watchlists.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends watchlistsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, watchlistsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__watchlistsClient<
      $Result.GetResult<
        Prisma.$watchlistsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Watchlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {watchlistsFindFirstArgs} args - Arguments to find a Watchlists
     * @example
     * // Get one Watchlists
     * const watchlists = await prisma.watchlists.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends watchlistsFindFirstArgs>(
      args?: SelectSubset<T, watchlistsFindFirstArgs<ExtArgs>>
    ): Prisma__watchlistsClient<
      $Result.GetResult<
        Prisma.$watchlistsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Watchlists that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {watchlistsFindFirstOrThrowArgs} args - Arguments to find a Watchlists
     * @example
     * // Get one Watchlists
     * const watchlists = await prisma.watchlists.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends watchlistsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, watchlistsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__watchlistsClient<
      $Result.GetResult<
        Prisma.$watchlistsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Watchlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {watchlistsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Watchlists
     * const watchlists = await prisma.watchlists.findMany()
     *
     * // Get first 10 Watchlists
     * const watchlists = await prisma.watchlists.findMany({ take: 10 })
     *
     * // Only select the `watchlist_id`
     * const watchlistsWithWatchlist_idOnly = await prisma.watchlists.findMany({ select: { watchlist_id: true } })
     *
     */
    findMany<T extends watchlistsFindManyArgs>(
      args?: SelectSubset<T, watchlistsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$watchlistsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Watchlists.
     * @param {watchlistsCreateArgs} args - Arguments to create a Watchlists.
     * @example
     * // Create one Watchlists
     * const Watchlists = await prisma.watchlists.create({
     *   data: {
     *     // ... data to create a Watchlists
     *   }
     * })
     *
     */
    create<T extends watchlistsCreateArgs>(
      args: SelectSubset<T, watchlistsCreateArgs<ExtArgs>>
    ): Prisma__watchlistsClient<
      $Result.GetResult<
        Prisma.$watchlistsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Watchlists.
     * @param {watchlistsCreateManyArgs} args - Arguments to create many Watchlists.
     * @example
     * // Create many Watchlists
     * const watchlists = await prisma.watchlists.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends watchlistsCreateManyArgs>(
      args?: SelectSubset<T, watchlistsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Watchlists and returns the data saved in the database.
     * @param {watchlistsCreateManyAndReturnArgs} args - Arguments to create many Watchlists.
     * @example
     * // Create many Watchlists
     * const watchlists = await prisma.watchlists.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Watchlists and only return the `watchlist_id`
     * const watchlistsWithWatchlist_idOnly = await prisma.watchlists.createManyAndReturn({
     *   select: { watchlist_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends watchlistsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, watchlistsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$watchlistsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Watchlists.
     * @param {watchlistsDeleteArgs} args - Arguments to delete one Watchlists.
     * @example
     * // Delete one Watchlists
     * const Watchlists = await prisma.watchlists.delete({
     *   where: {
     *     // ... filter to delete one Watchlists
     *   }
     * })
     *
     */
    delete<T extends watchlistsDeleteArgs>(
      args: SelectSubset<T, watchlistsDeleteArgs<ExtArgs>>
    ): Prisma__watchlistsClient<
      $Result.GetResult<
        Prisma.$watchlistsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Watchlists.
     * @param {watchlistsUpdateArgs} args - Arguments to update one Watchlists.
     * @example
     * // Update one Watchlists
     * const watchlists = await prisma.watchlists.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends watchlistsUpdateArgs>(
      args: SelectSubset<T, watchlistsUpdateArgs<ExtArgs>>
    ): Prisma__watchlistsClient<
      $Result.GetResult<
        Prisma.$watchlistsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Watchlists.
     * @param {watchlistsDeleteManyArgs} args - Arguments to filter Watchlists to delete.
     * @example
     * // Delete a few Watchlists
     * const { count } = await prisma.watchlists.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends watchlistsDeleteManyArgs>(
      args?: SelectSubset<T, watchlistsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Watchlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {watchlistsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Watchlists
     * const watchlists = await prisma.watchlists.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends watchlistsUpdateManyArgs>(
      args: SelectSubset<T, watchlistsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Watchlists and returns the data updated in the database.
     * @param {watchlistsUpdateManyAndReturnArgs} args - Arguments to update many Watchlists.
     * @example
     * // Update many Watchlists
     * const watchlists = await prisma.watchlists.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Watchlists and only return the `watchlist_id`
     * const watchlistsWithWatchlist_idOnly = await prisma.watchlists.updateManyAndReturn({
     *   select: { watchlist_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends watchlistsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, watchlistsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$watchlistsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Watchlists.
     * @param {watchlistsUpsertArgs} args - Arguments to update or create a Watchlists.
     * @example
     * // Update or create a Watchlists
     * const watchlists = await prisma.watchlists.upsert({
     *   create: {
     *     // ... data to create a Watchlists
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Watchlists we want to update
     *   }
     * })
     */
    upsert<T extends watchlistsUpsertArgs>(
      args: SelectSubset<T, watchlistsUpsertArgs<ExtArgs>>
    ): Prisma__watchlistsClient<
      $Result.GetResult<
        Prisma.$watchlistsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Watchlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {watchlistsCountArgs} args - Arguments to filter Watchlists to count.
     * @example
     * // Count the number of Watchlists
     * const count = await prisma.watchlists.count({
     *   where: {
     *     // ... the filter for the Watchlists we want to count
     *   }
     * })
     **/
    count<T extends watchlistsCountArgs>(
      args?: Subset<T, watchlistsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchlistsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Watchlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends WatchlistsAggregateArgs>(
      args: Subset<T, WatchlistsAggregateArgs>
    ): Prisma.PrismaPromise<GetWatchlistsAggregateType<T>>;

    /**
     * Group by Watchlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {watchlistsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends watchlistsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: watchlistsGroupByArgs['orderBy'] }
        : { orderBy?: watchlistsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, watchlistsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetWatchlistsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the watchlists model
     */
    readonly fields: watchlistsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for watchlists.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__watchlistsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the watchlists model
   */
  interface watchlistsFieldRefs {
    readonly watchlist_id: FieldRef<'watchlists', 'Int'>;
    readonly user_id: FieldRef<'watchlists', 'Int'>;
    readonly name: FieldRef<'watchlists', 'String'>;
    readonly created_at: FieldRef<'watchlists', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * watchlists findUnique
   */
  export type watchlistsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlists
     */
    select?: watchlistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlists
     */
    omit?: watchlistsOmit<ExtArgs> | null;
    /**
     * Filter, which watchlists to fetch.
     */
    where: watchlistsWhereUniqueInput;
  };

  /**
   * watchlists findUniqueOrThrow
   */
  export type watchlistsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlists
     */
    select?: watchlistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlists
     */
    omit?: watchlistsOmit<ExtArgs> | null;
    /**
     * Filter, which watchlists to fetch.
     */
    where: watchlistsWhereUniqueInput;
  };

  /**
   * watchlists findFirst
   */
  export type watchlistsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlists
     */
    select?: watchlistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlists
     */
    omit?: watchlistsOmit<ExtArgs> | null;
    /**
     * Filter, which watchlists to fetch.
     */
    where?: watchlistsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of watchlists to fetch.
     */
    orderBy?:
      | watchlistsOrderByWithRelationInput
      | watchlistsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for watchlists.
     */
    cursor?: watchlistsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` watchlists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` watchlists.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of watchlists.
     */
    distinct?: WatchlistsScalarFieldEnum | WatchlistsScalarFieldEnum[];
  };

  /**
   * watchlists findFirstOrThrow
   */
  export type watchlistsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlists
     */
    select?: watchlistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlists
     */
    omit?: watchlistsOmit<ExtArgs> | null;
    /**
     * Filter, which watchlists to fetch.
     */
    where?: watchlistsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of watchlists to fetch.
     */
    orderBy?:
      | watchlistsOrderByWithRelationInput
      | watchlistsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for watchlists.
     */
    cursor?: watchlistsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` watchlists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` watchlists.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of watchlists.
     */
    distinct?: WatchlistsScalarFieldEnum | WatchlistsScalarFieldEnum[];
  };

  /**
   * watchlists findMany
   */
  export type watchlistsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlists
     */
    select?: watchlistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlists
     */
    omit?: watchlistsOmit<ExtArgs> | null;
    /**
     * Filter, which watchlists to fetch.
     */
    where?: watchlistsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of watchlists to fetch.
     */
    orderBy?:
      | watchlistsOrderByWithRelationInput
      | watchlistsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing watchlists.
     */
    cursor?: watchlistsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` watchlists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` watchlists.
     */
    skip?: number;
    distinct?: WatchlistsScalarFieldEnum | WatchlistsScalarFieldEnum[];
  };

  /**
   * watchlists create
   */
  export type watchlistsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlists
     */
    select?: watchlistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlists
     */
    omit?: watchlistsOmit<ExtArgs> | null;
    /**
     * The data needed to create a watchlists.
     */
    data?: XOR<watchlistsCreateInput, watchlistsUncheckedCreateInput>;
  };

  /**
   * watchlists createMany
   */
  export type watchlistsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many watchlists.
     */
    data: watchlistsCreateManyInput | watchlistsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * watchlists createManyAndReturn
   */
  export type watchlistsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlists
     */
    select?: watchlistsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlists
     */
    omit?: watchlistsOmit<ExtArgs> | null;
    /**
     * The data used to create many watchlists.
     */
    data: watchlistsCreateManyInput | watchlistsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * watchlists update
   */
  export type watchlistsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlists
     */
    select?: watchlistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlists
     */
    omit?: watchlistsOmit<ExtArgs> | null;
    /**
     * The data needed to update a watchlists.
     */
    data: XOR<watchlistsUpdateInput, watchlistsUncheckedUpdateInput>;
    /**
     * Choose, which watchlists to update.
     */
    where: watchlistsWhereUniqueInput;
  };

  /**
   * watchlists updateMany
   */
  export type watchlistsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update watchlists.
     */
    data: XOR<
      watchlistsUpdateManyMutationInput,
      watchlistsUncheckedUpdateManyInput
    >;
    /**
     * Filter which watchlists to update
     */
    where?: watchlistsWhereInput;
    /**
     * Limit how many watchlists to update.
     */
    limit?: number;
  };

  /**
   * watchlists updateManyAndReturn
   */
  export type watchlistsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlists
     */
    select?: watchlistsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlists
     */
    omit?: watchlistsOmit<ExtArgs> | null;
    /**
     * The data used to update watchlists.
     */
    data: XOR<
      watchlistsUpdateManyMutationInput,
      watchlistsUncheckedUpdateManyInput
    >;
    /**
     * Filter which watchlists to update
     */
    where?: watchlistsWhereInput;
    /**
     * Limit how many watchlists to update.
     */
    limit?: number;
  };

  /**
   * watchlists upsert
   */
  export type watchlistsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlists
     */
    select?: watchlistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlists
     */
    omit?: watchlistsOmit<ExtArgs> | null;
    /**
     * The filter to search for the watchlists to update in case it exists.
     */
    where: watchlistsWhereUniqueInput;
    /**
     * In case the watchlists found by the `where` argument doesn't exist, create a new watchlists with this data.
     */
    create: XOR<watchlistsCreateInput, watchlistsUncheckedCreateInput>;
    /**
     * In case the watchlists was found with the provided `where` argument, update it with this data.
     */
    update: XOR<watchlistsUpdateInput, watchlistsUncheckedUpdateInput>;
  };

  /**
   * watchlists delete
   */
  export type watchlistsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlists
     */
    select?: watchlistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlists
     */
    omit?: watchlistsOmit<ExtArgs> | null;
    /**
     * Filter which watchlists to delete.
     */
    where: watchlistsWhereUniqueInput;
  };

  /**
   * watchlists deleteMany
   */
  export type watchlistsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which watchlists to delete
     */
    where?: watchlistsWhereInput;
    /**
     * Limit how many watchlists to delete.
     */
    limit?: number;
  };

  /**
   * watchlists without action
   */
  export type watchlistsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the watchlists
     */
    select?: watchlistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the watchlists
     */
    omit?: watchlistsOmit<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const App_problem_reportScalarFieldEnum: {
    id: 'id';
    topic: 'topic';
    details: 'details';
    status: 'status';
    updated_at: 'updated_at';
    created_at: 'created_at';
  };

  export type App_problem_reportScalarFieldEnum =
    (typeof App_problem_reportScalarFieldEnum)[keyof typeof App_problem_reportScalarFieldEnum];

  export const App_version_supportScalarFieldEnum: {
    id: 'id';
    version: 'version';
    platform: 'platform';
    build_number: 'build_number';
    status: 'status';
    min_supported_version: 'min_supported_version';
    is_active: 'is_active';
    critical_update: 'critical_update';
    force_update_message: 'force_update_message';
    release_notes: 'release_notes';
    download_url: 'download_url';
    release_date: 'release_date';
    deprecation_date: 'deprecation_date';
    end_of_support_date: 'end_of_support_date';
    metadata: 'metadata';
    created_at: 'created_at';
    updated_at: 'updated_at';
  };

  export type App_version_supportScalarFieldEnum =
    (typeof App_version_supportScalarFieldEnum)[keyof typeof App_version_supportScalarFieldEnum];

  export const CommentsScalarFieldEnum: {
    id: 'id';
    symbol: 'symbol';
    content: 'content';
    user_id: 'user_id';
    parent_id: 'parent_id';
    likes: 'likes';
    created_at: 'created_at';
    updated_at: 'updated_at';
  };

  export type CommentsScalarFieldEnum =
    (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum];

  export const In_app_announcementsScalarFieldEnum: {
    id: 'id';
    type: 'type';
    display_type: 'display_type';
    title_en: 'title_en';
    title_th: 'title_th';
    message_en: 'message_en';
    message_th: 'message_th';
    button_text_en: 'button_text_en';
    button_text_th: 'button_text_th';
    action_type: 'action_type';
    action_value: 'action_value';
    platform: 'platform';
    min_app_version: 'min_app_version';
    max_app_version: 'max_app_version';
    start_at: 'start_at';
    end_at: 'end_at';
    priority: 'priority';
    is_active: 'is_active';
    dismissible: 'dismissible';
    created_at: 'created_at';
    updated_at: 'updated_at';
  };

  export type In_app_announcementsScalarFieldEnum =
    (typeof In_app_announcementsScalarFieldEnum)[keyof typeof In_app_announcementsScalarFieldEnum];

  export const Investment_insightsScalarFieldEnum: {
    id: 'id';
    symbol: 'symbol';
    name: 'name';
    type: 'type';
    reason: 'reason';
    recommendation: 'recommendation';
    analysis: 'analysis';
    created_at: 'created_at';
    reason_th: 'reason_th';
    analysis_th: 'analysis_th';
    thesis_en: 'thesis_en';
    takeaway_en: 'takeaway_en';
    thesis_th: 'thesis_th';
    takeaway_th: 'takeaway_th';
  };

  export type Investment_insightsScalarFieldEnum =
    (typeof Investment_insightsScalarFieldEnum)[keyof typeof Investment_insightsScalarFieldEnum];

  export const Market_recapScalarFieldEnum: {
    stock_market_recap_en: 'stock_market_recap_en';
    stock_market_recap_th: 'stock_market_recap_th';
    sector_performance_en: 'sector_performance_en';
    sector_performance_th: 'sector_performance_th';
    economic_data_and_potential_concerns_en: 'economic_data_and_potential_concerns_en';
    economic_data_and_potential_concerns_th: 'economic_data_and_potential_concerns_th';
    other_market_activity_en: 'other_market_activity_en';
    other_market_activity_th: 'other_market_activity_th';
    summary_en: 'summary_en';
    summary_th: 'summary_th';
    id: 'id';
    created_at: 'created_at';
    updated_at: 'updated_at';
  };

  export type Market_recapScalarFieldEnum =
    (typeof Market_recapScalarFieldEnum)[keyof typeof Market_recapScalarFieldEnum];

  export const News_commentsScalarFieldEnum: {
    id: 'id';
    news_id: 'news_id';
    parent_comment_id: 'parent_comment_id';
    content: 'content';
    like_count: 'like_count';
    reply_count: 'reply_count';
    is_active: 'is_active';
    created_at: 'created_at';
    updated_at: 'updated_at';
    user_id: 'user_id';
  };

  export type News_commentsScalarFieldEnum =
    (typeof News_commentsScalarFieldEnum)[keyof typeof News_commentsScalarFieldEnum];

  export const News_configScalarFieldEnum: {
    name: 'name';
    value: 'value';
  };

  export type News_configScalarFieldEnum =
    (typeof News_configScalarFieldEnum)[keyof typeof News_configScalarFieldEnum];

  export const Payment_historyScalarFieldEnum: {
    payment_id: 'payment_id';
    user_subscription_id: 'user_subscription_id';
    amount: 'amount';
    currency: 'currency';
    payment_status: 'payment_status';
    stripe_payment_intent_id: 'stripe_payment_intent_id';
    payment_method_id: 'payment_method_id';
    payment_date: 'payment_date';
    billing_period_start: 'billing_period_start';
    billing_period_end: 'billing_period_end';
    invoice_url: 'invoice_url';
    error_message: 'error_message';
    stripe_invoice_id: 'stripe_invoice_id';
  };

  export type Payment_historyScalarFieldEnum =
    (typeof Payment_historyScalarFieldEnum)[keyof typeof Payment_historyScalarFieldEnum];

  export const PermissionsScalarFieldEnum: {
    permission_id: 'permission_id';
    subscription_id: 'subscription_id';
    feature: 'feature';
    is_enabled: 'is_enabled';
    limit_access: 'limit_access';
  };

  export type PermissionsScalarFieldEnum =
    (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum];

  export const PortfolioScalarFieldEnum: {
    portfolio_id: 'portfolio_id';
    user_id: 'user_id';
    total_value: 'total_value';
    updated_at: 'updated_at';
  };

  export type PortfolioScalarFieldEnum =
    (typeof PortfolioScalarFieldEnum)[keyof typeof PortfolioScalarFieldEnum];

  export const Portfolio_holdingsScalarFieldEnum: {
    id: 'id';
    portfolio_id: 'portfolio_id';
    symbol: 'symbol';
    total_quantity: 'total_quantity';
    average_price: 'average_price';
    total_invested: 'total_invested';
    updated_at: 'updated_at';
  };

  export type Portfolio_holdingsScalarFieldEnum =
    (typeof Portfolio_holdingsScalarFieldEnum)[keyof typeof Portfolio_holdingsScalarFieldEnum];

  export const Portfolio_stocksScalarFieldEnum: {
    id: 'id';
    portfolio_id: 'portfolio_id';
    symbol: 'symbol';
    type: 'type';
    quantity: 'quantity';
    price: 'price';
    total_amount: 'total_amount';
    transaction_date: 'transaction_date';
    created_at: 'created_at';
    updated_at: 'updated_at';
    currency: 'currency';
  };

  export type Portfolio_stocksScalarFieldEnum =
    (typeof Portfolio_stocksScalarFieldEnum)[keyof typeof Portfolio_stocksScalarFieldEnum];

  export const Price_alertsScalarFieldEnum: {
    id: 'id';
    user_id: 'user_id';
    symbol: 'symbol';
    asset_type: 'asset_type';
    target_price: 'target_price';
    alert_type: 'alert_type';
    status: 'status';
    created_at: 'created_at';
    updated_at: 'updated_at';
    triggered_at: 'triggered_at';
    expires_at: 'expires_at';
  };

  export type Price_alertsScalarFieldEnum =
    (typeof Price_alertsScalarFieldEnum)[keyof typeof Price_alertsScalarFieldEnum];

  export const Promotion_articlesScalarFieldEnum: {
    image_banner_dark: 'image_banner_dark';
    image_banner_white: 'image_banner_white';
    title_th: 'title_th';
    title_en: 'title_en';
    description_th: 'description_th';
    description_en: 'description_en';
    content_th: 'content_th';
    content_en: 'content_en';
    button_text_th: 'button_text_th';
    button_text_en: 'button_text_en';
    path: 'path';
    type: 'type';
    id: 'id';
  };

  export type Promotion_articlesScalarFieldEnum =
    (typeof Promotion_articlesScalarFieldEnum)[keyof typeof Promotion_articlesScalarFieldEnum];

  export const Stock_newsScalarFieldEnum: {
    id: 'id';
    symbol: 'symbol';
    exchange: 'exchange';
    title: 'title';
    content: 'content';
    summary: 'summary';
    image_url: 'image_url';
    source_url: 'source_url';
    publisher: 'publisher';
    published_date: 'published_date';
    language: 'language';
    view_count: 'view_count';
    is_featured: 'is_featured';
    is_hot: 'is_hot';
    tags: 'tags';
    metadata: 'metadata';
    like_count: 'like_count';
    share_count: 'share_count';
    is_active: 'is_active';
    created_at: 'created_at';
    updated_at: 'updated_at';
    categories: 'categories';
  };

  export type Stock_newsScalarFieldEnum =
    (typeof Stock_newsScalarFieldEnum)[keyof typeof Stock_newsScalarFieldEnum];

  export const Stock_news_read_historyScalarFieldEnum: {
    id: 'id';
    news_id: 'news_id';
    user_id: 'user_id';
    session_id: 'session_id';
    read_at: 'read_at';
    language_read: 'language_read';
    read_duration: 'read_duration';
    metadata: 'metadata';
  };

  export type Stock_news_read_historyScalarFieldEnum =
    (typeof Stock_news_read_historyScalarFieldEnum)[keyof typeof Stock_news_read_historyScalarFieldEnum];

  export const Stock_news_related_symbolsScalarFieldEnum: {
    id: 'id';
    news_id: 'news_id';
    related_symbol: 'related_symbol';
    related_exchange: 'related_exchange';
    is_primary: 'is_primary';
  };

  export type Stock_news_related_symbolsScalarFieldEnum =
    (typeof Stock_news_related_symbolsScalarFieldEnum)[keyof typeof Stock_news_related_symbolsScalarFieldEnum];

  export const Stock_news_translationScalarFieldEnum: {
    id: 'id';
    news_id: 'news_id';
    language: 'language';
    title: 'title';
    content: 'content';
    summary: 'summary';
    created_at: 'created_at';
    updated_at: 'updated_at';
  };

  export type Stock_news_translationScalarFieldEnum =
    (typeof Stock_news_translationScalarFieldEnum)[keyof typeof Stock_news_translationScalarFieldEnum];

  export const SubscriptionsScalarFieldEnum: {
    subscription_id: 'subscription_id';
    name: 'name';
    price: 'price';
    features: 'features';
    created_at: 'created_at';
    updated_at: 'updated_at';
    stripe_price_id: 'stripe_price_id';
    price_amount: 'price_amount';
    currency: 'currency';
    billing_interval: 'billing_interval';
    is_active: 'is_active';
    trial_days: 'trial_days';
  };

  export type SubscriptionsScalarFieldEnum =
    (typeof SubscriptionsScalarFieldEnum)[keyof typeof SubscriptionsScalarFieldEnum];

  export const Superinvestor_holdingsScalarFieldEnum: {
    id: 'id';
    manager_name: 'manager_name';
    portfolio_value_raw: 'portfolio_value_raw';
    number_of_stocks: 'number_of_stocks';
    manager_link: 'manager_link';
    image: 'image';
    information_en: 'information_en';
    information_th: 'information_th';
    created_at: 'created_at';
    updated_at: 'updated_at';
    portfolio_value: 'portfolio_value';
  };

  export type Superinvestor_holdingsScalarFieldEnum =
    (typeof Superinvestor_holdingsScalarFieldEnum)[keyof typeof Superinvestor_holdingsScalarFieldEnum];

  export const Superinvestor_holdings_listScalarFieldEnum: {
    id: 'id';
    manager_id: 'manager_id';
    symbol: 'symbol';
    percentage_of_portfolio: 'percentage_of_portfolio';
    recent_activity: 'recent_activity';
    share_raw: 'share_raw';
    share_value: 'share_value';
    reported_price_raw: 'reported_price_raw';
    reported_price_value: 'reported_price_value';
    value_raw: 'value_raw';
    value: 'value';
  };

  export type Superinvestor_holdings_listScalarFieldEnum =
    (typeof Superinvestor_holdings_listScalarFieldEnum)[keyof typeof Superinvestor_holdings_listScalarFieldEnum];

  export const Superinvestor_sector_analysisScalarFieldEnum: {
    id: 'id';
    manager_id: 'manager_id';
    sector_name: 'sector_name';
    sector_percentage: 'sector_percentage';
  };

  export type Superinvestor_sector_analysisScalarFieldEnum =
    (typeof Superinvestor_sector_analysisScalarFieldEnum)[keyof typeof Superinvestor_sector_analysisScalarFieldEnum];

  export const SymbolScalarFieldEnum: {
    id: 'id';
    symbol: 'symbol';
    company_name: 'company_name';
    exchange_short_name: 'exchange_short_name';
    company_logo: 'company_logo';
    type: 'type';
    created_at: 'created_at';
    updated_at: 'updated_at';
  };

  export type SymbolScalarFieldEnum =
    (typeof SymbolScalarFieldEnum)[keyof typeof SymbolScalarFieldEnum];

  export const User_devicesScalarFieldEnum: {
    device_id: 'device_id';
    user_id: 'user_id';
    platform: 'platform';
    device_token: 'device_token';
    last_active_at: 'last_active_at';
    created_at: 'created_at';
    app_version: 'app_version';
    device_name: 'device_name';
  };

  export type User_devicesScalarFieldEnum =
    (typeof User_devicesScalarFieldEnum)[keyof typeof User_devicesScalarFieldEnum];

  export const User_subscriptionsScalarFieldEnum: {
    user_subscription_id: 'user_subscription_id';
    user_id: 'user_id';
    subscription_id: 'subscription_id';
    start_date: 'start_date';
    end_date: 'end_date';
    is_active: 'is_active';
    stripe_subscription_id: 'stripe_subscription_id';
    stripe_payment_intent_id: 'stripe_payment_intent_id';
    payment_status: 'payment_status';
    last_payment_date: 'last_payment_date';
    next_billing_date: 'next_billing_date';
    cancellation_date: 'cancellation_date';
    trial_end_date: 'trial_end_date';
    last_payment_attempt_date: 'last_payment_attempt_date';
    payment_method_id: 'payment_method_id';
    redeem_code: 'redeem_code';
  };

  export type User_subscriptionsScalarFieldEnum =
    (typeof User_subscriptionsScalarFieldEnum)[keyof typeof User_subscriptionsScalarFieldEnum];

  export const UsersScalarFieldEnum: {
    user_id: 'user_id';
    google_id: 'google_id';
    email: 'email';
    name: 'name';
    profile_pic: 'profile_pic';
    created_at: 'created_at';
    updated_at: 'updated_at';
    stripe_customer_id: 'stripe_customer_id';
    refresh_token: 'refresh_token';
    has_used_trial: 'has_used_trial';
    trial_used_at: 'trial_used_at';
    bio: 'bio';
    is_verified: 'is_verified';
    status_message: 'status_message';
    last_login_at: 'last_login_at';
    birthdate: 'birthdate';
    language_preference: 'language_preference';
    theme_preference: 'theme_preference';
    onboarding_completed: 'onboarding_completed';
    account_status: 'account_status';
    active_watchlist_id: 'active_watchlist_id';
    username: 'username';
    is_private: 'is_private';
    apple_id: 'apple_id';
  };

  export type UsersScalarFieldEnum =
    (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum];

  export const Watchlist_itemsScalarFieldEnum: {
    watchlist_item_id: 'watchlist_item_id';
    watchlist_id: 'watchlist_id';
    symbol: 'symbol';
    name: 'name';
    type: 'type';
    added_at: 'added_at';
    sequence: 'sequence';
  };

  export type Watchlist_itemsScalarFieldEnum =
    (typeof Watchlist_itemsScalarFieldEnum)[keyof typeof Watchlist_itemsScalarFieldEnum];

  export const WatchlistsScalarFieldEnum: {
    watchlist_id: 'watchlist_id';
    user_id: 'user_id';
    name: 'name';
    created_at: 'created_at';
  };

  export type WatchlistsScalarFieldEnum =
    (typeof WatchlistsScalarFieldEnum)[keyof typeof WatchlistsScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull;
  };

  export type JsonNullValueInput =
    (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter =
    (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String'
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String[]'
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime'
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int'
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int[]'
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Boolean'
  >;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Json'
  >;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'QueryMode'
  >;

  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Decimal'
  >;

  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Decimal[]'
  >;

  /**
   * Reference to a field of type 'asset_type'
   */
  export type Enumasset_typeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'asset_type'
  >;

  /**
   * Reference to a field of type 'asset_type[]'
   */
  export type ListEnumasset_typeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'asset_type[]'
  >;

  /**
   * Reference to a field of type 'alert_type'
   */
  export type Enumalert_typeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'alert_type'
  >;

  /**
   * Reference to a field of type 'alert_type[]'
   */
  export type ListEnumalert_typeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'alert_type[]'
  >;

  /**
   * Reference to a field of type 'alert_status'
   */
  export type Enumalert_statusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'alert_status'
  >;

  /**
   * Reference to a field of type 'alert_status[]'
   */
  export type ListEnumalert_statusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'alert_status[]'>;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float'
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float[]'
  >;

  /**
   * Deep Input Types
   */

  export type app_problem_reportWhereInput = {
    AND?: app_problem_reportWhereInput | app_problem_reportWhereInput[];
    OR?: app_problem_reportWhereInput[];
    NOT?: app_problem_reportWhereInput | app_problem_reportWhereInput[];
    id?: UuidFilter<'app_problem_report'> | string;
    topic?: StringNullableFilter<'app_problem_report'> | string | null;
    details?: StringNullableFilter<'app_problem_report'> | string | null;
    status?: StringNullableFilter<'app_problem_report'> | string | null;
    updated_at?:
      | DateTimeNullableFilter<'app_problem_report'>
      | Date
      | string
      | null;
    created_at?:
      | DateTimeNullableFilter<'app_problem_report'>
      | Date
      | string
      | null;
  };

  export type app_problem_reportOrderByWithRelationInput = {
    id?: SortOrder;
    topic?: SortOrderInput | SortOrder;
    details?: SortOrderInput | SortOrder;
    status?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
  };

  export type app_problem_reportWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: app_problem_reportWhereInput | app_problem_reportWhereInput[];
      OR?: app_problem_reportWhereInput[];
      NOT?: app_problem_reportWhereInput | app_problem_reportWhereInput[];
      topic?: StringNullableFilter<'app_problem_report'> | string | null;
      details?: StringNullableFilter<'app_problem_report'> | string | null;
      status?: StringNullableFilter<'app_problem_report'> | string | null;
      updated_at?:
        | DateTimeNullableFilter<'app_problem_report'>
        | Date
        | string
        | null;
      created_at?:
        | DateTimeNullableFilter<'app_problem_report'>
        | Date
        | string
        | null;
    },
    'id'
  >;

  export type app_problem_reportOrderByWithAggregationInput = {
    id?: SortOrder;
    topic?: SortOrderInput | SortOrder;
    details?: SortOrderInput | SortOrder;
    status?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    _count?: app_problem_reportCountOrderByAggregateInput;
    _max?: app_problem_reportMaxOrderByAggregateInput;
    _min?: app_problem_reportMinOrderByAggregateInput;
  };

  export type app_problem_reportScalarWhereWithAggregatesInput = {
    AND?:
      | app_problem_reportScalarWhereWithAggregatesInput
      | app_problem_reportScalarWhereWithAggregatesInput[];
    OR?: app_problem_reportScalarWhereWithAggregatesInput[];
    NOT?:
      | app_problem_reportScalarWhereWithAggregatesInput
      | app_problem_reportScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'app_problem_report'> | string;
    topic?:
      | StringNullableWithAggregatesFilter<'app_problem_report'>
      | string
      | null;
    details?:
      | StringNullableWithAggregatesFilter<'app_problem_report'>
      | string
      | null;
    status?:
      | StringNullableWithAggregatesFilter<'app_problem_report'>
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'app_problem_report'>
      | Date
      | string
      | null;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'app_problem_report'>
      | Date
      | string
      | null;
  };

  export type app_version_supportWhereInput = {
    AND?: app_version_supportWhereInput | app_version_supportWhereInput[];
    OR?: app_version_supportWhereInput[];
    NOT?: app_version_supportWhereInput | app_version_supportWhereInput[];
    id?: IntFilter<'app_version_support'> | number;
    version?: StringFilter<'app_version_support'> | string;
    platform?: StringFilter<'app_version_support'> | string;
    build_number?: IntNullableFilter<'app_version_support'> | number | null;
    status?: StringFilter<'app_version_support'> | string;
    min_supported_version?:
      | StringNullableFilter<'app_version_support'>
      | string
      | null;
    is_active?: BoolNullableFilter<'app_version_support'> | boolean | null;
    critical_update?:
      | BoolNullableFilter<'app_version_support'>
      | boolean
      | null;
    force_update_message?:
      | StringNullableFilter<'app_version_support'>
      | string
      | null;
    release_notes?: StringNullableFilter<'app_version_support'> | string | null;
    download_url?: StringNullableFilter<'app_version_support'> | string | null;
    release_date?:
      | DateTimeNullableFilter<'app_version_support'>
      | Date
      | string
      | null;
    deprecation_date?:
      | DateTimeNullableFilter<'app_version_support'>
      | Date
      | string
      | null;
    end_of_support_date?:
      | DateTimeNullableFilter<'app_version_support'>
      | Date
      | string
      | null;
    metadata?: JsonNullableFilter<'app_version_support'>;
    created_at?:
      | DateTimeNullableFilter<'app_version_support'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableFilter<'app_version_support'>
      | Date
      | string
      | null;
  };

  export type app_version_supportOrderByWithRelationInput = {
    id?: SortOrder;
    version?: SortOrder;
    platform?: SortOrder;
    build_number?: SortOrderInput | SortOrder;
    status?: SortOrder;
    min_supported_version?: SortOrderInput | SortOrder;
    is_active?: SortOrderInput | SortOrder;
    critical_update?: SortOrderInput | SortOrder;
    force_update_message?: SortOrderInput | SortOrder;
    release_notes?: SortOrderInput | SortOrder;
    download_url?: SortOrderInput | SortOrder;
    release_date?: SortOrderInput | SortOrder;
    deprecation_date?: SortOrderInput | SortOrder;
    end_of_support_date?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
  };

  export type app_version_supportWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      version_platform?: app_version_supportVersionPlatformCompoundUniqueInput;
      AND?: app_version_supportWhereInput | app_version_supportWhereInput[];
      OR?: app_version_supportWhereInput[];
      NOT?: app_version_supportWhereInput | app_version_supportWhereInput[];
      version?: StringFilter<'app_version_support'> | string;
      platform?: StringFilter<'app_version_support'> | string;
      build_number?: IntNullableFilter<'app_version_support'> | number | null;
      status?: StringFilter<'app_version_support'> | string;
      min_supported_version?:
        | StringNullableFilter<'app_version_support'>
        | string
        | null;
      is_active?: BoolNullableFilter<'app_version_support'> | boolean | null;
      critical_update?:
        | BoolNullableFilter<'app_version_support'>
        | boolean
        | null;
      force_update_message?:
        | StringNullableFilter<'app_version_support'>
        | string
        | null;
      release_notes?:
        | StringNullableFilter<'app_version_support'>
        | string
        | null;
      download_url?:
        | StringNullableFilter<'app_version_support'>
        | string
        | null;
      release_date?:
        | DateTimeNullableFilter<'app_version_support'>
        | Date
        | string
        | null;
      deprecation_date?:
        | DateTimeNullableFilter<'app_version_support'>
        | Date
        | string
        | null;
      end_of_support_date?:
        | DateTimeNullableFilter<'app_version_support'>
        | Date
        | string
        | null;
      metadata?: JsonNullableFilter<'app_version_support'>;
      created_at?:
        | DateTimeNullableFilter<'app_version_support'>
        | Date
        | string
        | null;
      updated_at?:
        | DateTimeNullableFilter<'app_version_support'>
        | Date
        | string
        | null;
    },
    'id' | 'version_platform'
  >;

  export type app_version_supportOrderByWithAggregationInput = {
    id?: SortOrder;
    version?: SortOrder;
    platform?: SortOrder;
    build_number?: SortOrderInput | SortOrder;
    status?: SortOrder;
    min_supported_version?: SortOrderInput | SortOrder;
    is_active?: SortOrderInput | SortOrder;
    critical_update?: SortOrderInput | SortOrder;
    force_update_message?: SortOrderInput | SortOrder;
    release_notes?: SortOrderInput | SortOrder;
    download_url?: SortOrderInput | SortOrder;
    release_date?: SortOrderInput | SortOrder;
    deprecation_date?: SortOrderInput | SortOrder;
    end_of_support_date?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    _count?: app_version_supportCountOrderByAggregateInput;
    _avg?: app_version_supportAvgOrderByAggregateInput;
    _max?: app_version_supportMaxOrderByAggregateInput;
    _min?: app_version_supportMinOrderByAggregateInput;
    _sum?: app_version_supportSumOrderByAggregateInput;
  };

  export type app_version_supportScalarWhereWithAggregatesInput = {
    AND?:
      | app_version_supportScalarWhereWithAggregatesInput
      | app_version_supportScalarWhereWithAggregatesInput[];
    OR?: app_version_supportScalarWhereWithAggregatesInput[];
    NOT?:
      | app_version_supportScalarWhereWithAggregatesInput
      | app_version_supportScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'app_version_support'> | number;
    version?: StringWithAggregatesFilter<'app_version_support'> | string;
    platform?: StringWithAggregatesFilter<'app_version_support'> | string;
    build_number?:
      | IntNullableWithAggregatesFilter<'app_version_support'>
      | number
      | null;
    status?: StringWithAggregatesFilter<'app_version_support'> | string;
    min_supported_version?:
      | StringNullableWithAggregatesFilter<'app_version_support'>
      | string
      | null;
    is_active?:
      | BoolNullableWithAggregatesFilter<'app_version_support'>
      | boolean
      | null;
    critical_update?:
      | BoolNullableWithAggregatesFilter<'app_version_support'>
      | boolean
      | null;
    force_update_message?:
      | StringNullableWithAggregatesFilter<'app_version_support'>
      | string
      | null;
    release_notes?:
      | StringNullableWithAggregatesFilter<'app_version_support'>
      | string
      | null;
    download_url?:
      | StringNullableWithAggregatesFilter<'app_version_support'>
      | string
      | null;
    release_date?:
      | DateTimeNullableWithAggregatesFilter<'app_version_support'>
      | Date
      | string
      | null;
    deprecation_date?:
      | DateTimeNullableWithAggregatesFilter<'app_version_support'>
      | Date
      | string
      | null;
    end_of_support_date?:
      | DateTimeNullableWithAggregatesFilter<'app_version_support'>
      | Date
      | string
      | null;
    metadata?: JsonNullableWithAggregatesFilter<'app_version_support'>;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'app_version_support'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'app_version_support'>
      | Date
      | string
      | null;
  };

  export type commentsWhereInput = {
    AND?: commentsWhereInput | commentsWhereInput[];
    OR?: commentsWhereInput[];
    NOT?: commentsWhereInput | commentsWhereInput[];
    id?: IntFilter<'comments'> | number;
    symbol?: StringFilter<'comments'> | string;
    content?: StringFilter<'comments'> | string;
    user_id?: IntFilter<'comments'> | number;
    parent_id?: IntNullableFilter<'comments'> | number | null;
    likes?: IntNullableFilter<'comments'> | number | null;
    created_at?: DateTimeNullableFilter<'comments'> | Date | string | null;
    updated_at?: DateTimeNullableFilter<'comments'> | Date | string | null;
    comments?: XOR<
      CommentsNullableScalarRelationFilter,
      commentsWhereInput
    > | null;
    other_comments?: CommentsListRelationFilter;
  };

  export type commentsOrderByWithRelationInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    content?: SortOrder;
    user_id?: SortOrder;
    parent_id?: SortOrderInput | SortOrder;
    likes?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    comments?: commentsOrderByWithRelationInput;
    other_comments?: commentsOrderByRelationAggregateInput;
  };

  export type commentsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: commentsWhereInput | commentsWhereInput[];
      OR?: commentsWhereInput[];
      NOT?: commentsWhereInput | commentsWhereInput[];
      symbol?: StringFilter<'comments'> | string;
      content?: StringFilter<'comments'> | string;
      user_id?: IntFilter<'comments'> | number;
      parent_id?: IntNullableFilter<'comments'> | number | null;
      likes?: IntNullableFilter<'comments'> | number | null;
      created_at?: DateTimeNullableFilter<'comments'> | Date | string | null;
      updated_at?: DateTimeNullableFilter<'comments'> | Date | string | null;
      comments?: XOR<
        CommentsNullableScalarRelationFilter,
        commentsWhereInput
      > | null;
      other_comments?: CommentsListRelationFilter;
    },
    'id'
  >;

  export type commentsOrderByWithAggregationInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    content?: SortOrder;
    user_id?: SortOrder;
    parent_id?: SortOrderInput | SortOrder;
    likes?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    _count?: commentsCountOrderByAggregateInput;
    _avg?: commentsAvgOrderByAggregateInput;
    _max?: commentsMaxOrderByAggregateInput;
    _min?: commentsMinOrderByAggregateInput;
    _sum?: commentsSumOrderByAggregateInput;
  };

  export type commentsScalarWhereWithAggregatesInput = {
    AND?:
      | commentsScalarWhereWithAggregatesInput
      | commentsScalarWhereWithAggregatesInput[];
    OR?: commentsScalarWhereWithAggregatesInput[];
    NOT?:
      | commentsScalarWhereWithAggregatesInput
      | commentsScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'comments'> | number;
    symbol?: StringWithAggregatesFilter<'comments'> | string;
    content?: StringWithAggregatesFilter<'comments'> | string;
    user_id?: IntWithAggregatesFilter<'comments'> | number;
    parent_id?: IntNullableWithAggregatesFilter<'comments'> | number | null;
    likes?: IntNullableWithAggregatesFilter<'comments'> | number | null;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'comments'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'comments'>
      | Date
      | string
      | null;
  };

  export type in_app_announcementsWhereInput = {
    AND?: in_app_announcementsWhereInput | in_app_announcementsWhereInput[];
    OR?: in_app_announcementsWhereInput[];
    NOT?: in_app_announcementsWhereInput | in_app_announcementsWhereInput[];
    id?: IntFilter<'in_app_announcements'> | number;
    type?: StringFilter<'in_app_announcements'> | string;
    display_type?: StringFilter<'in_app_announcements'> | string;
    title_en?: StringFilter<'in_app_announcements'> | string;
    title_th?: StringFilter<'in_app_announcements'> | string;
    message_en?: StringFilter<'in_app_announcements'> | string;
    message_th?: StringFilter<'in_app_announcements'> | string;
    button_text_en?:
      | StringNullableFilter<'in_app_announcements'>
      | string
      | null;
    button_text_th?:
      | StringNullableFilter<'in_app_announcements'>
      | string
      | null;
    action_type?: StringNullableFilter<'in_app_announcements'> | string | null;
    action_value?: StringNullableFilter<'in_app_announcements'> | string | null;
    platform?: StringNullableFilter<'in_app_announcements'> | string | null;
    min_app_version?:
      | StringNullableFilter<'in_app_announcements'>
      | string
      | null;
    max_app_version?:
      | StringNullableFilter<'in_app_announcements'>
      | string
      | null;
    start_at?:
      | DateTimeNullableFilter<'in_app_announcements'>
      | Date
      | string
      | null;
    end_at?:
      | DateTimeNullableFilter<'in_app_announcements'>
      | Date
      | string
      | null;
    priority?: IntNullableFilter<'in_app_announcements'> | number | null;
    is_active?: BoolNullableFilter<'in_app_announcements'> | boolean | null;
    dismissible?: BoolNullableFilter<'in_app_announcements'> | boolean | null;
    created_at?:
      | DateTimeNullableFilter<'in_app_announcements'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableFilter<'in_app_announcements'>
      | Date
      | string
      | null;
  };

  export type in_app_announcementsOrderByWithRelationInput = {
    id?: SortOrder;
    type?: SortOrder;
    display_type?: SortOrder;
    title_en?: SortOrder;
    title_th?: SortOrder;
    message_en?: SortOrder;
    message_th?: SortOrder;
    button_text_en?: SortOrderInput | SortOrder;
    button_text_th?: SortOrderInput | SortOrder;
    action_type?: SortOrderInput | SortOrder;
    action_value?: SortOrderInput | SortOrder;
    platform?: SortOrderInput | SortOrder;
    min_app_version?: SortOrderInput | SortOrder;
    max_app_version?: SortOrderInput | SortOrder;
    start_at?: SortOrderInput | SortOrder;
    end_at?: SortOrderInput | SortOrder;
    priority?: SortOrderInput | SortOrder;
    is_active?: SortOrderInput | SortOrder;
    dismissible?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
  };

  export type in_app_announcementsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: in_app_announcementsWhereInput | in_app_announcementsWhereInput[];
      OR?: in_app_announcementsWhereInput[];
      NOT?: in_app_announcementsWhereInput | in_app_announcementsWhereInput[];
      type?: StringFilter<'in_app_announcements'> | string;
      display_type?: StringFilter<'in_app_announcements'> | string;
      title_en?: StringFilter<'in_app_announcements'> | string;
      title_th?: StringFilter<'in_app_announcements'> | string;
      message_en?: StringFilter<'in_app_announcements'> | string;
      message_th?: StringFilter<'in_app_announcements'> | string;
      button_text_en?:
        | StringNullableFilter<'in_app_announcements'>
        | string
        | null;
      button_text_th?:
        | StringNullableFilter<'in_app_announcements'>
        | string
        | null;
      action_type?:
        | StringNullableFilter<'in_app_announcements'>
        | string
        | null;
      action_value?:
        | StringNullableFilter<'in_app_announcements'>
        | string
        | null;
      platform?: StringNullableFilter<'in_app_announcements'> | string | null;
      min_app_version?:
        | StringNullableFilter<'in_app_announcements'>
        | string
        | null;
      max_app_version?:
        | StringNullableFilter<'in_app_announcements'>
        | string
        | null;
      start_at?:
        | DateTimeNullableFilter<'in_app_announcements'>
        | Date
        | string
        | null;
      end_at?:
        | DateTimeNullableFilter<'in_app_announcements'>
        | Date
        | string
        | null;
      priority?: IntNullableFilter<'in_app_announcements'> | number | null;
      is_active?: BoolNullableFilter<'in_app_announcements'> | boolean | null;
      dismissible?: BoolNullableFilter<'in_app_announcements'> | boolean | null;
      created_at?:
        | DateTimeNullableFilter<'in_app_announcements'>
        | Date
        | string
        | null;
      updated_at?:
        | DateTimeNullableFilter<'in_app_announcements'>
        | Date
        | string
        | null;
    },
    'id'
  >;

  export type in_app_announcementsOrderByWithAggregationInput = {
    id?: SortOrder;
    type?: SortOrder;
    display_type?: SortOrder;
    title_en?: SortOrder;
    title_th?: SortOrder;
    message_en?: SortOrder;
    message_th?: SortOrder;
    button_text_en?: SortOrderInput | SortOrder;
    button_text_th?: SortOrderInput | SortOrder;
    action_type?: SortOrderInput | SortOrder;
    action_value?: SortOrderInput | SortOrder;
    platform?: SortOrderInput | SortOrder;
    min_app_version?: SortOrderInput | SortOrder;
    max_app_version?: SortOrderInput | SortOrder;
    start_at?: SortOrderInput | SortOrder;
    end_at?: SortOrderInput | SortOrder;
    priority?: SortOrderInput | SortOrder;
    is_active?: SortOrderInput | SortOrder;
    dismissible?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    _count?: in_app_announcementsCountOrderByAggregateInput;
    _avg?: in_app_announcementsAvgOrderByAggregateInput;
    _max?: in_app_announcementsMaxOrderByAggregateInput;
    _min?: in_app_announcementsMinOrderByAggregateInput;
    _sum?: in_app_announcementsSumOrderByAggregateInput;
  };

  export type in_app_announcementsScalarWhereWithAggregatesInput = {
    AND?:
      | in_app_announcementsScalarWhereWithAggregatesInput
      | in_app_announcementsScalarWhereWithAggregatesInput[];
    OR?: in_app_announcementsScalarWhereWithAggregatesInput[];
    NOT?:
      | in_app_announcementsScalarWhereWithAggregatesInput
      | in_app_announcementsScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'in_app_announcements'> | number;
    type?: StringWithAggregatesFilter<'in_app_announcements'> | string;
    display_type?: StringWithAggregatesFilter<'in_app_announcements'> | string;
    title_en?: StringWithAggregatesFilter<'in_app_announcements'> | string;
    title_th?: StringWithAggregatesFilter<'in_app_announcements'> | string;
    message_en?: StringWithAggregatesFilter<'in_app_announcements'> | string;
    message_th?: StringWithAggregatesFilter<'in_app_announcements'> | string;
    button_text_en?:
      | StringNullableWithAggregatesFilter<'in_app_announcements'>
      | string
      | null;
    button_text_th?:
      | StringNullableWithAggregatesFilter<'in_app_announcements'>
      | string
      | null;
    action_type?:
      | StringNullableWithAggregatesFilter<'in_app_announcements'>
      | string
      | null;
    action_value?:
      | StringNullableWithAggregatesFilter<'in_app_announcements'>
      | string
      | null;
    platform?:
      | StringNullableWithAggregatesFilter<'in_app_announcements'>
      | string
      | null;
    min_app_version?:
      | StringNullableWithAggregatesFilter<'in_app_announcements'>
      | string
      | null;
    max_app_version?:
      | StringNullableWithAggregatesFilter<'in_app_announcements'>
      | string
      | null;
    start_at?:
      | DateTimeNullableWithAggregatesFilter<'in_app_announcements'>
      | Date
      | string
      | null;
    end_at?:
      | DateTimeNullableWithAggregatesFilter<'in_app_announcements'>
      | Date
      | string
      | null;
    priority?:
      | IntNullableWithAggregatesFilter<'in_app_announcements'>
      | number
      | null;
    is_active?:
      | BoolNullableWithAggregatesFilter<'in_app_announcements'>
      | boolean
      | null;
    dismissible?:
      | BoolNullableWithAggregatesFilter<'in_app_announcements'>
      | boolean
      | null;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'in_app_announcements'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'in_app_announcements'>
      | Date
      | string
      | null;
  };

  export type investment_insightsWhereInput = {
    AND?: investment_insightsWhereInput | investment_insightsWhereInput[];
    OR?: investment_insightsWhereInput[];
    NOT?: investment_insightsWhereInput | investment_insightsWhereInput[];
    id?: IntFilter<'investment_insights'> | number;
    symbol?: StringFilter<'investment_insights'> | string;
    name?: StringFilter<'investment_insights'> | string;
    type?: StringFilter<'investment_insights'> | string;
    reason?: StringFilter<'investment_insights'> | string;
    recommendation?: StringFilter<'investment_insights'> | string;
    analysis?: StringFilter<'investment_insights'> | string;
    created_at?:
      | DateTimeNullableFilter<'investment_insights'>
      | Date
      | string
      | null;
    reason_th?: StringNullableFilter<'investment_insights'> | string | null;
    analysis_th?: StringNullableFilter<'investment_insights'> | string | null;
    thesis_en?: StringNullableFilter<'investment_insights'> | string | null;
    takeaway_en?: StringNullableFilter<'investment_insights'> | string | null;
    thesis_th?: StringNullableFilter<'investment_insights'> | string | null;
    takeaway_th?: StringNullableFilter<'investment_insights'> | string | null;
  };

  export type investment_insightsOrderByWithRelationInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    reason?: SortOrder;
    recommendation?: SortOrder;
    analysis?: SortOrder;
    created_at?: SortOrderInput | SortOrder;
    reason_th?: SortOrderInput | SortOrder;
    analysis_th?: SortOrderInput | SortOrder;
    thesis_en?: SortOrderInput | SortOrder;
    takeaway_en?: SortOrderInput | SortOrder;
    thesis_th?: SortOrderInput | SortOrder;
    takeaway_th?: SortOrderInput | SortOrder;
  };

  export type investment_insightsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: investment_insightsWhereInput | investment_insightsWhereInput[];
      OR?: investment_insightsWhereInput[];
      NOT?: investment_insightsWhereInput | investment_insightsWhereInput[];
      symbol?: StringFilter<'investment_insights'> | string;
      name?: StringFilter<'investment_insights'> | string;
      type?: StringFilter<'investment_insights'> | string;
      reason?: StringFilter<'investment_insights'> | string;
      recommendation?: StringFilter<'investment_insights'> | string;
      analysis?: StringFilter<'investment_insights'> | string;
      created_at?:
        | DateTimeNullableFilter<'investment_insights'>
        | Date
        | string
        | null;
      reason_th?: StringNullableFilter<'investment_insights'> | string | null;
      analysis_th?: StringNullableFilter<'investment_insights'> | string | null;
      thesis_en?: StringNullableFilter<'investment_insights'> | string | null;
      takeaway_en?: StringNullableFilter<'investment_insights'> | string | null;
      thesis_th?: StringNullableFilter<'investment_insights'> | string | null;
      takeaway_th?: StringNullableFilter<'investment_insights'> | string | null;
    },
    'id'
  >;

  export type investment_insightsOrderByWithAggregationInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    reason?: SortOrder;
    recommendation?: SortOrder;
    analysis?: SortOrder;
    created_at?: SortOrderInput | SortOrder;
    reason_th?: SortOrderInput | SortOrder;
    analysis_th?: SortOrderInput | SortOrder;
    thesis_en?: SortOrderInput | SortOrder;
    takeaway_en?: SortOrderInput | SortOrder;
    thesis_th?: SortOrderInput | SortOrder;
    takeaway_th?: SortOrderInput | SortOrder;
    _count?: investment_insightsCountOrderByAggregateInput;
    _avg?: investment_insightsAvgOrderByAggregateInput;
    _max?: investment_insightsMaxOrderByAggregateInput;
    _min?: investment_insightsMinOrderByAggregateInput;
    _sum?: investment_insightsSumOrderByAggregateInput;
  };

  export type investment_insightsScalarWhereWithAggregatesInput = {
    AND?:
      | investment_insightsScalarWhereWithAggregatesInput
      | investment_insightsScalarWhereWithAggregatesInput[];
    OR?: investment_insightsScalarWhereWithAggregatesInput[];
    NOT?:
      | investment_insightsScalarWhereWithAggregatesInput
      | investment_insightsScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'investment_insights'> | number;
    symbol?: StringWithAggregatesFilter<'investment_insights'> | string;
    name?: StringWithAggregatesFilter<'investment_insights'> | string;
    type?: StringWithAggregatesFilter<'investment_insights'> | string;
    reason?: StringWithAggregatesFilter<'investment_insights'> | string;
    recommendation?: StringWithAggregatesFilter<'investment_insights'> | string;
    analysis?: StringWithAggregatesFilter<'investment_insights'> | string;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'investment_insights'>
      | Date
      | string
      | null;
    reason_th?:
      | StringNullableWithAggregatesFilter<'investment_insights'>
      | string
      | null;
    analysis_th?:
      | StringNullableWithAggregatesFilter<'investment_insights'>
      | string
      | null;
    thesis_en?:
      | StringNullableWithAggregatesFilter<'investment_insights'>
      | string
      | null;
    takeaway_en?:
      | StringNullableWithAggregatesFilter<'investment_insights'>
      | string
      | null;
    thesis_th?:
      | StringNullableWithAggregatesFilter<'investment_insights'>
      | string
      | null;
    takeaway_th?:
      | StringNullableWithAggregatesFilter<'investment_insights'>
      | string
      | null;
  };

  export type market_recapWhereInput = {
    AND?: market_recapWhereInput | market_recapWhereInput[];
    OR?: market_recapWhereInput[];
    NOT?: market_recapWhereInput | market_recapWhereInput[];
    stock_market_recap_en?:
      | StringNullableFilter<'market_recap'>
      | string
      | null;
    stock_market_recap_th?:
      | StringNullableFilter<'market_recap'>
      | string
      | null;
    sector_performance_en?:
      | StringNullableFilter<'market_recap'>
      | string
      | null;
    sector_performance_th?:
      | StringNullableFilter<'market_recap'>
      | string
      | null;
    economic_data_and_potential_concerns_en?:
      | StringNullableFilter<'market_recap'>
      | string
      | null;
    economic_data_and_potential_concerns_th?:
      | StringNullableFilter<'market_recap'>
      | string
      | null;
    other_market_activity_en?:
      | StringNullableFilter<'market_recap'>
      | string
      | null;
    other_market_activity_th?:
      | StringNullableFilter<'market_recap'>
      | string
      | null;
    summary_en?: StringNullableFilter<'market_recap'> | string | null;
    summary_th?: StringNullableFilter<'market_recap'> | string | null;
    id?: IntFilter<'market_recap'> | number;
    created_at?: DateTimeNullableFilter<'market_recap'> | Date | string | null;
    updated_at?: DateTimeNullableFilter<'market_recap'> | Date | string | null;
  };

  export type market_recapOrderByWithRelationInput = {
    stock_market_recap_en?: SortOrderInput | SortOrder;
    stock_market_recap_th?: SortOrderInput | SortOrder;
    sector_performance_en?: SortOrderInput | SortOrder;
    sector_performance_th?: SortOrderInput | SortOrder;
    economic_data_and_potential_concerns_en?: SortOrderInput | SortOrder;
    economic_data_and_potential_concerns_th?: SortOrderInput | SortOrder;
    other_market_activity_en?: SortOrderInput | SortOrder;
    other_market_activity_th?: SortOrderInput | SortOrder;
    summary_en?: SortOrderInput | SortOrder;
    summary_th?: SortOrderInput | SortOrder;
    id?: SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
  };

  export type market_recapWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: market_recapWhereInput | market_recapWhereInput[];
      OR?: market_recapWhereInput[];
      NOT?: market_recapWhereInput | market_recapWhereInput[];
      stock_market_recap_en?:
        | StringNullableFilter<'market_recap'>
        | string
        | null;
      stock_market_recap_th?:
        | StringNullableFilter<'market_recap'>
        | string
        | null;
      sector_performance_en?:
        | StringNullableFilter<'market_recap'>
        | string
        | null;
      sector_performance_th?:
        | StringNullableFilter<'market_recap'>
        | string
        | null;
      economic_data_and_potential_concerns_en?:
        | StringNullableFilter<'market_recap'>
        | string
        | null;
      economic_data_and_potential_concerns_th?:
        | StringNullableFilter<'market_recap'>
        | string
        | null;
      other_market_activity_en?:
        | StringNullableFilter<'market_recap'>
        | string
        | null;
      other_market_activity_th?:
        | StringNullableFilter<'market_recap'>
        | string
        | null;
      summary_en?: StringNullableFilter<'market_recap'> | string | null;
      summary_th?: StringNullableFilter<'market_recap'> | string | null;
      created_at?:
        | DateTimeNullableFilter<'market_recap'>
        | Date
        | string
        | null;
      updated_at?:
        | DateTimeNullableFilter<'market_recap'>
        | Date
        | string
        | null;
    },
    'id'
  >;

  export type market_recapOrderByWithAggregationInput = {
    stock_market_recap_en?: SortOrderInput | SortOrder;
    stock_market_recap_th?: SortOrderInput | SortOrder;
    sector_performance_en?: SortOrderInput | SortOrder;
    sector_performance_th?: SortOrderInput | SortOrder;
    economic_data_and_potential_concerns_en?: SortOrderInput | SortOrder;
    economic_data_and_potential_concerns_th?: SortOrderInput | SortOrder;
    other_market_activity_en?: SortOrderInput | SortOrder;
    other_market_activity_th?: SortOrderInput | SortOrder;
    summary_en?: SortOrderInput | SortOrder;
    summary_th?: SortOrderInput | SortOrder;
    id?: SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    _count?: market_recapCountOrderByAggregateInput;
    _avg?: market_recapAvgOrderByAggregateInput;
    _max?: market_recapMaxOrderByAggregateInput;
    _min?: market_recapMinOrderByAggregateInput;
    _sum?: market_recapSumOrderByAggregateInput;
  };

  export type market_recapScalarWhereWithAggregatesInput = {
    AND?:
      | market_recapScalarWhereWithAggregatesInput
      | market_recapScalarWhereWithAggregatesInput[];
    OR?: market_recapScalarWhereWithAggregatesInput[];
    NOT?:
      | market_recapScalarWhereWithAggregatesInput
      | market_recapScalarWhereWithAggregatesInput[];
    stock_market_recap_en?:
      | StringNullableWithAggregatesFilter<'market_recap'>
      | string
      | null;
    stock_market_recap_th?:
      | StringNullableWithAggregatesFilter<'market_recap'>
      | string
      | null;
    sector_performance_en?:
      | StringNullableWithAggregatesFilter<'market_recap'>
      | string
      | null;
    sector_performance_th?:
      | StringNullableWithAggregatesFilter<'market_recap'>
      | string
      | null;
    economic_data_and_potential_concerns_en?:
      | StringNullableWithAggregatesFilter<'market_recap'>
      | string
      | null;
    economic_data_and_potential_concerns_th?:
      | StringNullableWithAggregatesFilter<'market_recap'>
      | string
      | null;
    other_market_activity_en?:
      | StringNullableWithAggregatesFilter<'market_recap'>
      | string
      | null;
    other_market_activity_th?:
      | StringNullableWithAggregatesFilter<'market_recap'>
      | string
      | null;
    summary_en?:
      | StringNullableWithAggregatesFilter<'market_recap'>
      | string
      | null;
    summary_th?:
      | StringNullableWithAggregatesFilter<'market_recap'>
      | string
      | null;
    id?: IntWithAggregatesFilter<'market_recap'> | number;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'market_recap'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'market_recap'>
      | Date
      | string
      | null;
  };

  export type news_commentsWhereInput = {
    AND?: news_commentsWhereInput | news_commentsWhereInput[];
    OR?: news_commentsWhereInput[];
    NOT?: news_commentsWhereInput | news_commentsWhereInput[];
    id?: IntFilter<'news_comments'> | number;
    news_id?: UuidFilter<'news_comments'> | string;
    parent_comment_id?: IntNullableFilter<'news_comments'> | number | null;
    content?: StringFilter<'news_comments'> | string;
    like_count?: IntNullableFilter<'news_comments'> | number | null;
    reply_count?: IntNullableFilter<'news_comments'> | number | null;
    is_active?: BoolNullableFilter<'news_comments'> | boolean | null;
    created_at?: DateTimeNullableFilter<'news_comments'> | Date | string | null;
    updated_at?: DateTimeNullableFilter<'news_comments'> | Date | string | null;
    user_id?: IntFilter<'news_comments'> | number;
    stock_news?: XOR<Stock_newsScalarRelationFilter, stock_newsWhereInput>;
    news_comments?: XOR<
      News_commentsNullableScalarRelationFilter,
      news_commentsWhereInput
    > | null;
    other_news_comments?: News_commentsListRelationFilter;
  };

  export type news_commentsOrderByWithRelationInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    parent_comment_id?: SortOrderInput | SortOrder;
    content?: SortOrder;
    like_count?: SortOrderInput | SortOrder;
    reply_count?: SortOrderInput | SortOrder;
    is_active?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    user_id?: SortOrder;
    stock_news?: stock_newsOrderByWithRelationInput;
    news_comments?: news_commentsOrderByWithRelationInput;
    other_news_comments?: news_commentsOrderByRelationAggregateInput;
  };

  export type news_commentsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: news_commentsWhereInput | news_commentsWhereInput[];
      OR?: news_commentsWhereInput[];
      NOT?: news_commentsWhereInput | news_commentsWhereInput[];
      news_id?: UuidFilter<'news_comments'> | string;
      parent_comment_id?: IntNullableFilter<'news_comments'> | number | null;
      content?: StringFilter<'news_comments'> | string;
      like_count?: IntNullableFilter<'news_comments'> | number | null;
      reply_count?: IntNullableFilter<'news_comments'> | number | null;
      is_active?: BoolNullableFilter<'news_comments'> | boolean | null;
      created_at?:
        | DateTimeNullableFilter<'news_comments'>
        | Date
        | string
        | null;
      updated_at?:
        | DateTimeNullableFilter<'news_comments'>
        | Date
        | string
        | null;
      user_id?: IntFilter<'news_comments'> | number;
      stock_news?: XOR<Stock_newsScalarRelationFilter, stock_newsWhereInput>;
      news_comments?: XOR<
        News_commentsNullableScalarRelationFilter,
        news_commentsWhereInput
      > | null;
      other_news_comments?: News_commentsListRelationFilter;
    },
    'id'
  >;

  export type news_commentsOrderByWithAggregationInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    parent_comment_id?: SortOrderInput | SortOrder;
    content?: SortOrder;
    like_count?: SortOrderInput | SortOrder;
    reply_count?: SortOrderInput | SortOrder;
    is_active?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    user_id?: SortOrder;
    _count?: news_commentsCountOrderByAggregateInput;
    _avg?: news_commentsAvgOrderByAggregateInput;
    _max?: news_commentsMaxOrderByAggregateInput;
    _min?: news_commentsMinOrderByAggregateInput;
    _sum?: news_commentsSumOrderByAggregateInput;
  };

  export type news_commentsScalarWhereWithAggregatesInput = {
    AND?:
      | news_commentsScalarWhereWithAggregatesInput
      | news_commentsScalarWhereWithAggregatesInput[];
    OR?: news_commentsScalarWhereWithAggregatesInput[];
    NOT?:
      | news_commentsScalarWhereWithAggregatesInput
      | news_commentsScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'news_comments'> | number;
    news_id?: UuidWithAggregatesFilter<'news_comments'> | string;
    parent_comment_id?:
      | IntNullableWithAggregatesFilter<'news_comments'>
      | number
      | null;
    content?: StringWithAggregatesFilter<'news_comments'> | string;
    like_count?:
      | IntNullableWithAggregatesFilter<'news_comments'>
      | number
      | null;
    reply_count?:
      | IntNullableWithAggregatesFilter<'news_comments'>
      | number
      | null;
    is_active?:
      | BoolNullableWithAggregatesFilter<'news_comments'>
      | boolean
      | null;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'news_comments'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'news_comments'>
      | Date
      | string
      | null;
    user_id?: IntWithAggregatesFilter<'news_comments'> | number;
  };

  export type news_configWhereInput = {
    AND?: news_configWhereInput | news_configWhereInput[];
    OR?: news_configWhereInput[];
    NOT?: news_configWhereInput | news_configWhereInput[];
    name?: StringFilter<'news_config'> | string;
    value?: JsonFilter<'news_config'>;
  };

  export type news_configOrderByWithRelationInput = {
    name?: SortOrder;
    value?: SortOrder;
  };

  export type news_configWhereUniqueInput = Prisma.AtLeast<
    {
      name?: string;
      AND?: news_configWhereInput | news_configWhereInput[];
      OR?: news_configWhereInput[];
      NOT?: news_configWhereInput | news_configWhereInput[];
      value?: JsonFilter<'news_config'>;
    },
    'name'
  >;

  export type news_configOrderByWithAggregationInput = {
    name?: SortOrder;
    value?: SortOrder;
    _count?: news_configCountOrderByAggregateInput;
    _max?: news_configMaxOrderByAggregateInput;
    _min?: news_configMinOrderByAggregateInput;
  };

  export type news_configScalarWhereWithAggregatesInput = {
    AND?:
      | news_configScalarWhereWithAggregatesInput
      | news_configScalarWhereWithAggregatesInput[];
    OR?: news_configScalarWhereWithAggregatesInput[];
    NOT?:
      | news_configScalarWhereWithAggregatesInput
      | news_configScalarWhereWithAggregatesInput[];
    name?: StringWithAggregatesFilter<'news_config'> | string;
    value?: JsonWithAggregatesFilter<'news_config'>;
  };

  export type payment_historyWhereInput = {
    AND?: payment_historyWhereInput | payment_historyWhereInput[];
    OR?: payment_historyWhereInput[];
    NOT?: payment_historyWhereInput | payment_historyWhereInput[];
    payment_id?: IntFilter<'payment_history'> | number;
    user_subscription_id?: IntNullableFilter<'payment_history'> | number | null;
    amount?:
      | DecimalFilter<'payment_history'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    currency?: StringNullableFilter<'payment_history'> | string | null;
    payment_status?: StringFilter<'payment_history'> | string;
    stripe_payment_intent_id?:
      | StringNullableFilter<'payment_history'>
      | string
      | null;
    payment_method_id?: StringNullableFilter<'payment_history'> | string | null;
    payment_date?:
      | DateTimeNullableFilter<'payment_history'>
      | Date
      | string
      | null;
    billing_period_start?:
      | DateTimeNullableFilter<'payment_history'>
      | Date
      | string
      | null;
    billing_period_end?:
      | DateTimeNullableFilter<'payment_history'>
      | Date
      | string
      | null;
    invoice_url?: StringNullableFilter<'payment_history'> | string | null;
    error_message?: StringNullableFilter<'payment_history'> | string | null;
    stripe_invoice_id?: StringNullableFilter<'payment_history'> | string | null;
  };

  export type payment_historyOrderByWithRelationInput = {
    payment_id?: SortOrder;
    user_subscription_id?: SortOrderInput | SortOrder;
    amount?: SortOrder;
    currency?: SortOrderInput | SortOrder;
    payment_status?: SortOrder;
    stripe_payment_intent_id?: SortOrderInput | SortOrder;
    payment_method_id?: SortOrderInput | SortOrder;
    payment_date?: SortOrderInput | SortOrder;
    billing_period_start?: SortOrderInput | SortOrder;
    billing_period_end?: SortOrderInput | SortOrder;
    invoice_url?: SortOrderInput | SortOrder;
    error_message?: SortOrderInput | SortOrder;
    stripe_invoice_id?: SortOrderInput | SortOrder;
  };

  export type payment_historyWhereUniqueInput = Prisma.AtLeast<
    {
      payment_id?: number;
      AND?: payment_historyWhereInput | payment_historyWhereInput[];
      OR?: payment_historyWhereInput[];
      NOT?: payment_historyWhereInput | payment_historyWhereInput[];
      user_subscription_id?:
        | IntNullableFilter<'payment_history'>
        | number
        | null;
      amount?:
        | DecimalFilter<'payment_history'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      currency?: StringNullableFilter<'payment_history'> | string | null;
      payment_status?: StringFilter<'payment_history'> | string;
      stripe_payment_intent_id?:
        | StringNullableFilter<'payment_history'>
        | string
        | null;
      payment_method_id?:
        | StringNullableFilter<'payment_history'>
        | string
        | null;
      payment_date?:
        | DateTimeNullableFilter<'payment_history'>
        | Date
        | string
        | null;
      billing_period_start?:
        | DateTimeNullableFilter<'payment_history'>
        | Date
        | string
        | null;
      billing_period_end?:
        | DateTimeNullableFilter<'payment_history'>
        | Date
        | string
        | null;
      invoice_url?: StringNullableFilter<'payment_history'> | string | null;
      error_message?: StringNullableFilter<'payment_history'> | string | null;
      stripe_invoice_id?:
        | StringNullableFilter<'payment_history'>
        | string
        | null;
    },
    'payment_id'
  >;

  export type payment_historyOrderByWithAggregationInput = {
    payment_id?: SortOrder;
    user_subscription_id?: SortOrderInput | SortOrder;
    amount?: SortOrder;
    currency?: SortOrderInput | SortOrder;
    payment_status?: SortOrder;
    stripe_payment_intent_id?: SortOrderInput | SortOrder;
    payment_method_id?: SortOrderInput | SortOrder;
    payment_date?: SortOrderInput | SortOrder;
    billing_period_start?: SortOrderInput | SortOrder;
    billing_period_end?: SortOrderInput | SortOrder;
    invoice_url?: SortOrderInput | SortOrder;
    error_message?: SortOrderInput | SortOrder;
    stripe_invoice_id?: SortOrderInput | SortOrder;
    _count?: payment_historyCountOrderByAggregateInput;
    _avg?: payment_historyAvgOrderByAggregateInput;
    _max?: payment_historyMaxOrderByAggregateInput;
    _min?: payment_historyMinOrderByAggregateInput;
    _sum?: payment_historySumOrderByAggregateInput;
  };

  export type payment_historyScalarWhereWithAggregatesInput = {
    AND?:
      | payment_historyScalarWhereWithAggregatesInput
      | payment_historyScalarWhereWithAggregatesInput[];
    OR?: payment_historyScalarWhereWithAggregatesInput[];
    NOT?:
      | payment_historyScalarWhereWithAggregatesInput
      | payment_historyScalarWhereWithAggregatesInput[];
    payment_id?: IntWithAggregatesFilter<'payment_history'> | number;
    user_subscription_id?:
      | IntNullableWithAggregatesFilter<'payment_history'>
      | number
      | null;
    amount?:
      | DecimalWithAggregatesFilter<'payment_history'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    currency?:
      | StringNullableWithAggregatesFilter<'payment_history'>
      | string
      | null;
    payment_status?: StringWithAggregatesFilter<'payment_history'> | string;
    stripe_payment_intent_id?:
      | StringNullableWithAggregatesFilter<'payment_history'>
      | string
      | null;
    payment_method_id?:
      | StringNullableWithAggregatesFilter<'payment_history'>
      | string
      | null;
    payment_date?:
      | DateTimeNullableWithAggregatesFilter<'payment_history'>
      | Date
      | string
      | null;
    billing_period_start?:
      | DateTimeNullableWithAggregatesFilter<'payment_history'>
      | Date
      | string
      | null;
    billing_period_end?:
      | DateTimeNullableWithAggregatesFilter<'payment_history'>
      | Date
      | string
      | null;
    invoice_url?:
      | StringNullableWithAggregatesFilter<'payment_history'>
      | string
      | null;
    error_message?:
      | StringNullableWithAggregatesFilter<'payment_history'>
      | string
      | null;
    stripe_invoice_id?:
      | StringNullableWithAggregatesFilter<'payment_history'>
      | string
      | null;
  };

  export type permissionsWhereInput = {
    AND?: permissionsWhereInput | permissionsWhereInput[];
    OR?: permissionsWhereInput[];
    NOT?: permissionsWhereInput | permissionsWhereInput[];
    permission_id?: IntFilter<'permissions'> | number;
    subscription_id?: IntNullableFilter<'permissions'> | number | null;
    feature?: StringNullableFilter<'permissions'> | string | null;
    is_enabled?: BoolNullableFilter<'permissions'> | boolean | null;
    limit_access?: StringNullableFilter<'permissions'> | string | null;
    subscriptions?: XOR<
      SubscriptionsNullableScalarRelationFilter,
      subscriptionsWhereInput
    > | null;
  };

  export type permissionsOrderByWithRelationInput = {
    permission_id?: SortOrder;
    subscription_id?: SortOrderInput | SortOrder;
    feature?: SortOrderInput | SortOrder;
    is_enabled?: SortOrderInput | SortOrder;
    limit_access?: SortOrderInput | SortOrder;
    subscriptions?: subscriptionsOrderByWithRelationInput;
  };

  export type permissionsWhereUniqueInput = Prisma.AtLeast<
    {
      permission_id?: number;
      AND?: permissionsWhereInput | permissionsWhereInput[];
      OR?: permissionsWhereInput[];
      NOT?: permissionsWhereInput | permissionsWhereInput[];
      subscription_id?: IntNullableFilter<'permissions'> | number | null;
      feature?: StringNullableFilter<'permissions'> | string | null;
      is_enabled?: BoolNullableFilter<'permissions'> | boolean | null;
      limit_access?: StringNullableFilter<'permissions'> | string | null;
      subscriptions?: XOR<
        SubscriptionsNullableScalarRelationFilter,
        subscriptionsWhereInput
      > | null;
    },
    'permission_id'
  >;

  export type permissionsOrderByWithAggregationInput = {
    permission_id?: SortOrder;
    subscription_id?: SortOrderInput | SortOrder;
    feature?: SortOrderInput | SortOrder;
    is_enabled?: SortOrderInput | SortOrder;
    limit_access?: SortOrderInput | SortOrder;
    _count?: permissionsCountOrderByAggregateInput;
    _avg?: permissionsAvgOrderByAggregateInput;
    _max?: permissionsMaxOrderByAggregateInput;
    _min?: permissionsMinOrderByAggregateInput;
    _sum?: permissionsSumOrderByAggregateInput;
  };

  export type permissionsScalarWhereWithAggregatesInput = {
    AND?:
      | permissionsScalarWhereWithAggregatesInput
      | permissionsScalarWhereWithAggregatesInput[];
    OR?: permissionsScalarWhereWithAggregatesInput[];
    NOT?:
      | permissionsScalarWhereWithAggregatesInput
      | permissionsScalarWhereWithAggregatesInput[];
    permission_id?: IntWithAggregatesFilter<'permissions'> | number;
    subscription_id?:
      | IntNullableWithAggregatesFilter<'permissions'>
      | number
      | null;
    feature?: StringNullableWithAggregatesFilter<'permissions'> | string | null;
    is_enabled?:
      | BoolNullableWithAggregatesFilter<'permissions'>
      | boolean
      | null;
    limit_access?:
      | StringNullableWithAggregatesFilter<'permissions'>
      | string
      | null;
  };

  export type portfolioWhereInput = {
    AND?: portfolioWhereInput | portfolioWhereInput[];
    OR?: portfolioWhereInput[];
    NOT?: portfolioWhereInput | portfolioWhereInput[];
    portfolio_id?: IntFilter<'portfolio'> | number;
    user_id?: IntFilter<'portfolio'> | number;
    total_value?:
      | DecimalNullableFilter<'portfolio'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    updated_at?: DateTimeNullableFilter<'portfolio'> | Date | string | null;
  };

  export type portfolioOrderByWithRelationInput = {
    portfolio_id?: SortOrder;
    user_id?: SortOrder;
    total_value?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
  };

  export type portfolioWhereUniqueInput = Prisma.AtLeast<
    {
      portfolio_id?: number;
      user_id?: number;
      AND?: portfolioWhereInput | portfolioWhereInput[];
      OR?: portfolioWhereInput[];
      NOT?: portfolioWhereInput | portfolioWhereInput[];
      total_value?:
        | DecimalNullableFilter<'portfolio'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      updated_at?: DateTimeNullableFilter<'portfolio'> | Date | string | null;
    },
    'portfolio_id' | 'user_id'
  >;

  export type portfolioOrderByWithAggregationInput = {
    portfolio_id?: SortOrder;
    user_id?: SortOrder;
    total_value?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    _count?: portfolioCountOrderByAggregateInput;
    _avg?: portfolioAvgOrderByAggregateInput;
    _max?: portfolioMaxOrderByAggregateInput;
    _min?: portfolioMinOrderByAggregateInput;
    _sum?: portfolioSumOrderByAggregateInput;
  };

  export type portfolioScalarWhereWithAggregatesInput = {
    AND?:
      | portfolioScalarWhereWithAggregatesInput
      | portfolioScalarWhereWithAggregatesInput[];
    OR?: portfolioScalarWhereWithAggregatesInput[];
    NOT?:
      | portfolioScalarWhereWithAggregatesInput
      | portfolioScalarWhereWithAggregatesInput[];
    portfolio_id?: IntWithAggregatesFilter<'portfolio'> | number;
    user_id?: IntWithAggregatesFilter<'portfolio'> | number;
    total_value?:
      | DecimalNullableWithAggregatesFilter<'portfolio'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'portfolio'>
      | Date
      | string
      | null;
  };

  export type portfolio_holdingsWhereInput = {
    AND?: portfolio_holdingsWhereInput | portfolio_holdingsWhereInput[];
    OR?: portfolio_holdingsWhereInput[];
    NOT?: portfolio_holdingsWhereInput | portfolio_holdingsWhereInput[];
    id?: IntFilter<'portfolio_holdings'> | number;
    portfolio_id?: IntFilter<'portfolio_holdings'> | number;
    symbol?: StringFilter<'portfolio_holdings'> | string;
    total_quantity?:
      | DecimalNullableFilter<'portfolio_holdings'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    average_price?:
      | DecimalNullableFilter<'portfolio_holdings'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    total_invested?:
      | DecimalNullableFilter<'portfolio_holdings'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    updated_at?:
      | DateTimeNullableFilter<'portfolio_holdings'>
      | Date
      | string
      | null;
  };

  export type portfolio_holdingsOrderByWithRelationInput = {
    id?: SortOrder;
    portfolio_id?: SortOrder;
    symbol?: SortOrder;
    total_quantity?: SortOrderInput | SortOrder;
    average_price?: SortOrderInput | SortOrder;
    total_invested?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
  };

  export type portfolio_holdingsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      portfolio_id_symbol?: portfolio_holdingsPortfolio_idSymbolCompoundUniqueInput;
      AND?: portfolio_holdingsWhereInput | portfolio_holdingsWhereInput[];
      OR?: portfolio_holdingsWhereInput[];
      NOT?: portfolio_holdingsWhereInput | portfolio_holdingsWhereInput[];
      portfolio_id?: IntFilter<'portfolio_holdings'> | number;
      symbol?: StringFilter<'portfolio_holdings'> | string;
      total_quantity?:
        | DecimalNullableFilter<'portfolio_holdings'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      average_price?:
        | DecimalNullableFilter<'portfolio_holdings'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      total_invested?:
        | DecimalNullableFilter<'portfolio_holdings'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      updated_at?:
        | DateTimeNullableFilter<'portfolio_holdings'>
        | Date
        | string
        | null;
    },
    'id' | 'portfolio_id_symbol'
  >;

  export type portfolio_holdingsOrderByWithAggregationInput = {
    id?: SortOrder;
    portfolio_id?: SortOrder;
    symbol?: SortOrder;
    total_quantity?: SortOrderInput | SortOrder;
    average_price?: SortOrderInput | SortOrder;
    total_invested?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    _count?: portfolio_holdingsCountOrderByAggregateInput;
    _avg?: portfolio_holdingsAvgOrderByAggregateInput;
    _max?: portfolio_holdingsMaxOrderByAggregateInput;
    _min?: portfolio_holdingsMinOrderByAggregateInput;
    _sum?: portfolio_holdingsSumOrderByAggregateInput;
  };

  export type portfolio_holdingsScalarWhereWithAggregatesInput = {
    AND?:
      | portfolio_holdingsScalarWhereWithAggregatesInput
      | portfolio_holdingsScalarWhereWithAggregatesInput[];
    OR?: portfolio_holdingsScalarWhereWithAggregatesInput[];
    NOT?:
      | portfolio_holdingsScalarWhereWithAggregatesInput
      | portfolio_holdingsScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'portfolio_holdings'> | number;
    portfolio_id?: IntWithAggregatesFilter<'portfolio_holdings'> | number;
    symbol?: StringWithAggregatesFilter<'portfolio_holdings'> | string;
    total_quantity?:
      | DecimalNullableWithAggregatesFilter<'portfolio_holdings'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    average_price?:
      | DecimalNullableWithAggregatesFilter<'portfolio_holdings'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    total_invested?:
      | DecimalNullableWithAggregatesFilter<'portfolio_holdings'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'portfolio_holdings'>
      | Date
      | string
      | null;
  };

  export type portfolio_stocksWhereInput = {
    AND?: portfolio_stocksWhereInput | portfolio_stocksWhereInput[];
    OR?: portfolio_stocksWhereInput[];
    NOT?: portfolio_stocksWhereInput | portfolio_stocksWhereInput[];
    id?: IntFilter<'portfolio_stocks'> | number;
    portfolio_id?: IntFilter<'portfolio_stocks'> | number;
    symbol?: StringFilter<'portfolio_stocks'> | string;
    type?: StringFilter<'portfolio_stocks'> | string;
    quantity?:
      | DecimalFilter<'portfolio_stocks'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    price?:
      | DecimalFilter<'portfolio_stocks'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    total_amount?:
      | DecimalFilter<'portfolio_stocks'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    transaction_date?:
      | DateTimeNullableFilter<'portfolio_stocks'>
      | Date
      | string
      | null;
    created_at?:
      | DateTimeNullableFilter<'portfolio_stocks'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableFilter<'portfolio_stocks'>
      | Date
      | string
      | null;
    currency?: StringNullableFilter<'portfolio_stocks'> | string | null;
  };

  export type portfolio_stocksOrderByWithRelationInput = {
    id?: SortOrder;
    portfolio_id?: SortOrder;
    symbol?: SortOrder;
    type?: SortOrder;
    quantity?: SortOrder;
    price?: SortOrder;
    total_amount?: SortOrder;
    transaction_date?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    currency?: SortOrderInput | SortOrder;
  };

  export type portfolio_stocksWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: portfolio_stocksWhereInput | portfolio_stocksWhereInput[];
      OR?: portfolio_stocksWhereInput[];
      NOT?: portfolio_stocksWhereInput | portfolio_stocksWhereInput[];
      portfolio_id?: IntFilter<'portfolio_stocks'> | number;
      symbol?: StringFilter<'portfolio_stocks'> | string;
      type?: StringFilter<'portfolio_stocks'> | string;
      quantity?:
        | DecimalFilter<'portfolio_stocks'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      price?:
        | DecimalFilter<'portfolio_stocks'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      total_amount?:
        | DecimalFilter<'portfolio_stocks'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      transaction_date?:
        | DateTimeNullableFilter<'portfolio_stocks'>
        | Date
        | string
        | null;
      created_at?:
        | DateTimeNullableFilter<'portfolio_stocks'>
        | Date
        | string
        | null;
      updated_at?:
        | DateTimeNullableFilter<'portfolio_stocks'>
        | Date
        | string
        | null;
      currency?: StringNullableFilter<'portfolio_stocks'> | string | null;
    },
    'id'
  >;

  export type portfolio_stocksOrderByWithAggregationInput = {
    id?: SortOrder;
    portfolio_id?: SortOrder;
    symbol?: SortOrder;
    type?: SortOrder;
    quantity?: SortOrder;
    price?: SortOrder;
    total_amount?: SortOrder;
    transaction_date?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    currency?: SortOrderInput | SortOrder;
    _count?: portfolio_stocksCountOrderByAggregateInput;
    _avg?: portfolio_stocksAvgOrderByAggregateInput;
    _max?: portfolio_stocksMaxOrderByAggregateInput;
    _min?: portfolio_stocksMinOrderByAggregateInput;
    _sum?: portfolio_stocksSumOrderByAggregateInput;
  };

  export type portfolio_stocksScalarWhereWithAggregatesInput = {
    AND?:
      | portfolio_stocksScalarWhereWithAggregatesInput
      | portfolio_stocksScalarWhereWithAggregatesInput[];
    OR?: portfolio_stocksScalarWhereWithAggregatesInput[];
    NOT?:
      | portfolio_stocksScalarWhereWithAggregatesInput
      | portfolio_stocksScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'portfolio_stocks'> | number;
    portfolio_id?: IntWithAggregatesFilter<'portfolio_stocks'> | number;
    symbol?: StringWithAggregatesFilter<'portfolio_stocks'> | string;
    type?: StringWithAggregatesFilter<'portfolio_stocks'> | string;
    quantity?:
      | DecimalWithAggregatesFilter<'portfolio_stocks'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    price?:
      | DecimalWithAggregatesFilter<'portfolio_stocks'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    total_amount?:
      | DecimalWithAggregatesFilter<'portfolio_stocks'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    transaction_date?:
      | DateTimeNullableWithAggregatesFilter<'portfolio_stocks'>
      | Date
      | string
      | null;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'portfolio_stocks'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'portfolio_stocks'>
      | Date
      | string
      | null;
    currency?:
      | StringNullableWithAggregatesFilter<'portfolio_stocks'>
      | string
      | null;
  };

  export type price_alertsWhereInput = {
    AND?: price_alertsWhereInput | price_alertsWhereInput[];
    OR?: price_alertsWhereInput[];
    NOT?: price_alertsWhereInput | price_alertsWhereInput[];
    id?: UuidFilter<'price_alerts'> | string;
    user_id?: IntFilter<'price_alerts'> | number;
    symbol?: StringFilter<'price_alerts'> | string;
    asset_type?: Enumasset_typeFilter<'price_alerts'> | $Enums.asset_type;
    target_price?:
      | DecimalFilter<'price_alerts'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    alert_type?: Enumalert_typeFilter<'price_alerts'> | $Enums.alert_type;
    status?: Enumalert_statusFilter<'price_alerts'> | $Enums.alert_status;
    created_at?: DateTimeNullableFilter<'price_alerts'> | Date | string | null;
    updated_at?: DateTimeNullableFilter<'price_alerts'> | Date | string | null;
    triggered_at?:
      | DateTimeNullableFilter<'price_alerts'>
      | Date
      | string
      | null;
    expires_at?: DateTimeNullableFilter<'price_alerts'> | Date | string | null;
  };

  export type price_alertsOrderByWithRelationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    symbol?: SortOrder;
    asset_type?: SortOrder;
    target_price?: SortOrder;
    alert_type?: SortOrder;
    status?: SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    triggered_at?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
  };

  export type price_alertsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: price_alertsWhereInput | price_alertsWhereInput[];
      OR?: price_alertsWhereInput[];
      NOT?: price_alertsWhereInput | price_alertsWhereInput[];
      user_id?: IntFilter<'price_alerts'> | number;
      symbol?: StringFilter<'price_alerts'> | string;
      asset_type?: Enumasset_typeFilter<'price_alerts'> | $Enums.asset_type;
      target_price?:
        | DecimalFilter<'price_alerts'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      alert_type?: Enumalert_typeFilter<'price_alerts'> | $Enums.alert_type;
      status?: Enumalert_statusFilter<'price_alerts'> | $Enums.alert_status;
      created_at?:
        | DateTimeNullableFilter<'price_alerts'>
        | Date
        | string
        | null;
      updated_at?:
        | DateTimeNullableFilter<'price_alerts'>
        | Date
        | string
        | null;
      triggered_at?:
        | DateTimeNullableFilter<'price_alerts'>
        | Date
        | string
        | null;
      expires_at?:
        | DateTimeNullableFilter<'price_alerts'>
        | Date
        | string
        | null;
    },
    'id'
  >;

  export type price_alertsOrderByWithAggregationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    symbol?: SortOrder;
    asset_type?: SortOrder;
    target_price?: SortOrder;
    alert_type?: SortOrder;
    status?: SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    triggered_at?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    _count?: price_alertsCountOrderByAggregateInput;
    _avg?: price_alertsAvgOrderByAggregateInput;
    _max?: price_alertsMaxOrderByAggregateInput;
    _min?: price_alertsMinOrderByAggregateInput;
    _sum?: price_alertsSumOrderByAggregateInput;
  };

  export type price_alertsScalarWhereWithAggregatesInput = {
    AND?:
      | price_alertsScalarWhereWithAggregatesInput
      | price_alertsScalarWhereWithAggregatesInput[];
    OR?: price_alertsScalarWhereWithAggregatesInput[];
    NOT?:
      | price_alertsScalarWhereWithAggregatesInput
      | price_alertsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'price_alerts'> | string;
    user_id?: IntWithAggregatesFilter<'price_alerts'> | number;
    symbol?: StringWithAggregatesFilter<'price_alerts'> | string;
    asset_type?:
      | Enumasset_typeWithAggregatesFilter<'price_alerts'>
      | $Enums.asset_type;
    target_price?:
      | DecimalWithAggregatesFilter<'price_alerts'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    alert_type?:
      | Enumalert_typeWithAggregatesFilter<'price_alerts'>
      | $Enums.alert_type;
    status?:
      | Enumalert_statusWithAggregatesFilter<'price_alerts'>
      | $Enums.alert_status;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'price_alerts'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'price_alerts'>
      | Date
      | string
      | null;
    triggered_at?:
      | DateTimeNullableWithAggregatesFilter<'price_alerts'>
      | Date
      | string
      | null;
    expires_at?:
      | DateTimeNullableWithAggregatesFilter<'price_alerts'>
      | Date
      | string
      | null;
  };

  export type promotion_articlesWhereInput = {
    AND?: promotion_articlesWhereInput | promotion_articlesWhereInput[];
    OR?: promotion_articlesWhereInput[];
    NOT?: promotion_articlesWhereInput | promotion_articlesWhereInput[];
    image_banner_dark?:
      | StringNullableFilter<'promotion_articles'>
      | string
      | null;
    image_banner_white?:
      | StringNullableFilter<'promotion_articles'>
      | string
      | null;
    title_th?: StringNullableFilter<'promotion_articles'> | string | null;
    title_en?: StringNullableFilter<'promotion_articles'> | string | null;
    description_th?: StringNullableFilter<'promotion_articles'> | string | null;
    description_en?: StringNullableFilter<'promotion_articles'> | string | null;
    content_th?: StringNullableFilter<'promotion_articles'> | string | null;
    content_en?: StringNullableFilter<'promotion_articles'> | string | null;
    button_text_th?: StringNullableFilter<'promotion_articles'> | string | null;
    button_text_en?: StringNullableFilter<'promotion_articles'> | string | null;
    path?: StringNullableFilter<'promotion_articles'> | string | null;
    type?: StringNullableFilter<'promotion_articles'> | string | null;
    id?: IntFilter<'promotion_articles'> | number;
  };

  export type promotion_articlesOrderByWithRelationInput = {
    image_banner_dark?: SortOrderInput | SortOrder;
    image_banner_white?: SortOrderInput | SortOrder;
    title_th?: SortOrderInput | SortOrder;
    title_en?: SortOrderInput | SortOrder;
    description_th?: SortOrderInput | SortOrder;
    description_en?: SortOrderInput | SortOrder;
    content_th?: SortOrderInput | SortOrder;
    content_en?: SortOrderInput | SortOrder;
    button_text_th?: SortOrderInput | SortOrder;
    button_text_en?: SortOrderInput | SortOrder;
    path?: SortOrderInput | SortOrder;
    type?: SortOrderInput | SortOrder;
    id?: SortOrder;
  };

  export type promotion_articlesWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: promotion_articlesWhereInput | promotion_articlesWhereInput[];
      OR?: promotion_articlesWhereInput[];
      NOT?: promotion_articlesWhereInput | promotion_articlesWhereInput[];
      image_banner_dark?:
        | StringNullableFilter<'promotion_articles'>
        | string
        | null;
      image_banner_white?:
        | StringNullableFilter<'promotion_articles'>
        | string
        | null;
      title_th?: StringNullableFilter<'promotion_articles'> | string | null;
      title_en?: StringNullableFilter<'promotion_articles'> | string | null;
      description_th?:
        | StringNullableFilter<'promotion_articles'>
        | string
        | null;
      description_en?:
        | StringNullableFilter<'promotion_articles'>
        | string
        | null;
      content_th?: StringNullableFilter<'promotion_articles'> | string | null;
      content_en?: StringNullableFilter<'promotion_articles'> | string | null;
      button_text_th?:
        | StringNullableFilter<'promotion_articles'>
        | string
        | null;
      button_text_en?:
        | StringNullableFilter<'promotion_articles'>
        | string
        | null;
      path?: StringNullableFilter<'promotion_articles'> | string | null;
      type?: StringNullableFilter<'promotion_articles'> | string | null;
    },
    'id'
  >;

  export type promotion_articlesOrderByWithAggregationInput = {
    image_banner_dark?: SortOrderInput | SortOrder;
    image_banner_white?: SortOrderInput | SortOrder;
    title_th?: SortOrderInput | SortOrder;
    title_en?: SortOrderInput | SortOrder;
    description_th?: SortOrderInput | SortOrder;
    description_en?: SortOrderInput | SortOrder;
    content_th?: SortOrderInput | SortOrder;
    content_en?: SortOrderInput | SortOrder;
    button_text_th?: SortOrderInput | SortOrder;
    button_text_en?: SortOrderInput | SortOrder;
    path?: SortOrderInput | SortOrder;
    type?: SortOrderInput | SortOrder;
    id?: SortOrder;
    _count?: promotion_articlesCountOrderByAggregateInput;
    _avg?: promotion_articlesAvgOrderByAggregateInput;
    _max?: promotion_articlesMaxOrderByAggregateInput;
    _min?: promotion_articlesMinOrderByAggregateInput;
    _sum?: promotion_articlesSumOrderByAggregateInput;
  };

  export type promotion_articlesScalarWhereWithAggregatesInput = {
    AND?:
      | promotion_articlesScalarWhereWithAggregatesInput
      | promotion_articlesScalarWhereWithAggregatesInput[];
    OR?: promotion_articlesScalarWhereWithAggregatesInput[];
    NOT?:
      | promotion_articlesScalarWhereWithAggregatesInput
      | promotion_articlesScalarWhereWithAggregatesInput[];
    image_banner_dark?:
      | StringNullableWithAggregatesFilter<'promotion_articles'>
      | string
      | null;
    image_banner_white?:
      | StringNullableWithAggregatesFilter<'promotion_articles'>
      | string
      | null;
    title_th?:
      | StringNullableWithAggregatesFilter<'promotion_articles'>
      | string
      | null;
    title_en?:
      | StringNullableWithAggregatesFilter<'promotion_articles'>
      | string
      | null;
    description_th?:
      | StringNullableWithAggregatesFilter<'promotion_articles'>
      | string
      | null;
    description_en?:
      | StringNullableWithAggregatesFilter<'promotion_articles'>
      | string
      | null;
    content_th?:
      | StringNullableWithAggregatesFilter<'promotion_articles'>
      | string
      | null;
    content_en?:
      | StringNullableWithAggregatesFilter<'promotion_articles'>
      | string
      | null;
    button_text_th?:
      | StringNullableWithAggregatesFilter<'promotion_articles'>
      | string
      | null;
    button_text_en?:
      | StringNullableWithAggregatesFilter<'promotion_articles'>
      | string
      | null;
    path?:
      | StringNullableWithAggregatesFilter<'promotion_articles'>
      | string
      | null;
    type?:
      | StringNullableWithAggregatesFilter<'promotion_articles'>
      | string
      | null;
    id?: IntWithAggregatesFilter<'promotion_articles'> | number;
  };

  export type stock_newsWhereInput = {
    AND?: stock_newsWhereInput | stock_newsWhereInput[];
    OR?: stock_newsWhereInput[];
    NOT?: stock_newsWhereInput | stock_newsWhereInput[];
    id?: UuidFilter<'stock_news'> | string;
    symbol?: StringFilter<'stock_news'> | string;
    exchange?: StringNullableFilter<'stock_news'> | string | null;
    title?: StringFilter<'stock_news'> | string;
    content?: StringNullableFilter<'stock_news'> | string | null;
    summary?: StringNullableFilter<'stock_news'> | string | null;
    image_url?: StringNullableFilter<'stock_news'> | string | null;
    source_url?: StringNullableFilter<'stock_news'> | string | null;
    publisher?: StringNullableFilter<'stock_news'> | string | null;
    published_date?: DateTimeFilter<'stock_news'> | Date | string;
    language?: StringNullableFilter<'stock_news'> | string | null;
    view_count?: IntNullableFilter<'stock_news'> | number | null;
    is_featured?: BoolNullableFilter<'stock_news'> | boolean | null;
    is_hot?: BoolNullableFilter<'stock_news'> | boolean | null;
    tags?: StringNullableListFilter<'stock_news'>;
    metadata?: JsonNullableFilter<'stock_news'>;
    like_count?: IntNullableFilter<'stock_news'> | number | null;
    share_count?: IntNullableFilter<'stock_news'> | number | null;
    is_active?: BoolNullableFilter<'stock_news'> | boolean | null;
    created_at?: DateTimeNullableFilter<'stock_news'> | Date | string | null;
    updated_at?: DateTimeNullableFilter<'stock_news'> | Date | string | null;
    categories?: JsonNullableFilter<'stock_news'>;
    news_comments?: News_commentsListRelationFilter;
    stock_news_read_history?: Stock_news_read_historyListRelationFilter;
    stock_news_related_symbols?: Stock_news_related_symbolsListRelationFilter;
    stock_news_translation?: Stock_news_translationListRelationFilter;
  };

  export type stock_newsOrderByWithRelationInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    exchange?: SortOrderInput | SortOrder;
    title?: SortOrder;
    content?: SortOrderInput | SortOrder;
    summary?: SortOrderInput | SortOrder;
    image_url?: SortOrderInput | SortOrder;
    source_url?: SortOrderInput | SortOrder;
    publisher?: SortOrderInput | SortOrder;
    published_date?: SortOrder;
    language?: SortOrderInput | SortOrder;
    view_count?: SortOrderInput | SortOrder;
    is_featured?: SortOrderInput | SortOrder;
    is_hot?: SortOrderInput | SortOrder;
    tags?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    like_count?: SortOrderInput | SortOrder;
    share_count?: SortOrderInput | SortOrder;
    is_active?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    categories?: SortOrderInput | SortOrder;
    news_comments?: news_commentsOrderByRelationAggregateInput;
    stock_news_read_history?: stock_news_read_historyOrderByRelationAggregateInput;
    stock_news_related_symbols?: stock_news_related_symbolsOrderByRelationAggregateInput;
    stock_news_translation?: stock_news_translationOrderByRelationAggregateInput;
  };

  export type stock_newsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: stock_newsWhereInput | stock_newsWhereInput[];
      OR?: stock_newsWhereInput[];
      NOT?: stock_newsWhereInput | stock_newsWhereInput[];
      symbol?: StringFilter<'stock_news'> | string;
      exchange?: StringNullableFilter<'stock_news'> | string | null;
      title?: StringFilter<'stock_news'> | string;
      content?: StringNullableFilter<'stock_news'> | string | null;
      summary?: StringNullableFilter<'stock_news'> | string | null;
      image_url?: StringNullableFilter<'stock_news'> | string | null;
      source_url?: StringNullableFilter<'stock_news'> | string | null;
      publisher?: StringNullableFilter<'stock_news'> | string | null;
      published_date?: DateTimeFilter<'stock_news'> | Date | string;
      language?: StringNullableFilter<'stock_news'> | string | null;
      view_count?: IntNullableFilter<'stock_news'> | number | null;
      is_featured?: BoolNullableFilter<'stock_news'> | boolean | null;
      is_hot?: BoolNullableFilter<'stock_news'> | boolean | null;
      tags?: StringNullableListFilter<'stock_news'>;
      metadata?: JsonNullableFilter<'stock_news'>;
      like_count?: IntNullableFilter<'stock_news'> | number | null;
      share_count?: IntNullableFilter<'stock_news'> | number | null;
      is_active?: BoolNullableFilter<'stock_news'> | boolean | null;
      created_at?: DateTimeNullableFilter<'stock_news'> | Date | string | null;
      updated_at?: DateTimeNullableFilter<'stock_news'> | Date | string | null;
      categories?: JsonNullableFilter<'stock_news'>;
      news_comments?: News_commentsListRelationFilter;
      stock_news_read_history?: Stock_news_read_historyListRelationFilter;
      stock_news_related_symbols?: Stock_news_related_symbolsListRelationFilter;
      stock_news_translation?: Stock_news_translationListRelationFilter;
    },
    'id'
  >;

  export type stock_newsOrderByWithAggregationInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    exchange?: SortOrderInput | SortOrder;
    title?: SortOrder;
    content?: SortOrderInput | SortOrder;
    summary?: SortOrderInput | SortOrder;
    image_url?: SortOrderInput | SortOrder;
    source_url?: SortOrderInput | SortOrder;
    publisher?: SortOrderInput | SortOrder;
    published_date?: SortOrder;
    language?: SortOrderInput | SortOrder;
    view_count?: SortOrderInput | SortOrder;
    is_featured?: SortOrderInput | SortOrder;
    is_hot?: SortOrderInput | SortOrder;
    tags?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    like_count?: SortOrderInput | SortOrder;
    share_count?: SortOrderInput | SortOrder;
    is_active?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    categories?: SortOrderInput | SortOrder;
    _count?: stock_newsCountOrderByAggregateInput;
    _avg?: stock_newsAvgOrderByAggregateInput;
    _max?: stock_newsMaxOrderByAggregateInput;
    _min?: stock_newsMinOrderByAggregateInput;
    _sum?: stock_newsSumOrderByAggregateInput;
  };

  export type stock_newsScalarWhereWithAggregatesInput = {
    AND?:
      | stock_newsScalarWhereWithAggregatesInput
      | stock_newsScalarWhereWithAggregatesInput[];
    OR?: stock_newsScalarWhereWithAggregatesInput[];
    NOT?:
      | stock_newsScalarWhereWithAggregatesInput
      | stock_newsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'stock_news'> | string;
    symbol?: StringWithAggregatesFilter<'stock_news'> | string;
    exchange?: StringNullableWithAggregatesFilter<'stock_news'> | string | null;
    title?: StringWithAggregatesFilter<'stock_news'> | string;
    content?: StringNullableWithAggregatesFilter<'stock_news'> | string | null;
    summary?: StringNullableWithAggregatesFilter<'stock_news'> | string | null;
    image_url?:
      | StringNullableWithAggregatesFilter<'stock_news'>
      | string
      | null;
    source_url?:
      | StringNullableWithAggregatesFilter<'stock_news'>
      | string
      | null;
    publisher?:
      | StringNullableWithAggregatesFilter<'stock_news'>
      | string
      | null;
    published_date?: DateTimeWithAggregatesFilter<'stock_news'> | Date | string;
    language?: StringNullableWithAggregatesFilter<'stock_news'> | string | null;
    view_count?: IntNullableWithAggregatesFilter<'stock_news'> | number | null;
    is_featured?:
      | BoolNullableWithAggregatesFilter<'stock_news'>
      | boolean
      | null;
    is_hot?: BoolNullableWithAggregatesFilter<'stock_news'> | boolean | null;
    tags?: StringNullableListFilter<'stock_news'>;
    metadata?: JsonNullableWithAggregatesFilter<'stock_news'>;
    like_count?: IntNullableWithAggregatesFilter<'stock_news'> | number | null;
    share_count?: IntNullableWithAggregatesFilter<'stock_news'> | number | null;
    is_active?: BoolNullableWithAggregatesFilter<'stock_news'> | boolean | null;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'stock_news'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'stock_news'>
      | Date
      | string
      | null;
    categories?: JsonNullableWithAggregatesFilter<'stock_news'>;
  };

  export type stock_news_read_historyWhereInput = {
    AND?:
      | stock_news_read_historyWhereInput
      | stock_news_read_historyWhereInput[];
    OR?: stock_news_read_historyWhereInput[];
    NOT?:
      | stock_news_read_historyWhereInput
      | stock_news_read_historyWhereInput[];
    id?: UuidFilter<'stock_news_read_history'> | string;
    news_id?: UuidFilter<'stock_news_read_history'> | string;
    user_id?: StringNullableFilter<'stock_news_read_history'> | string | null;
    session_id?:
      | StringNullableFilter<'stock_news_read_history'>
      | string
      | null;
    read_at?:
      | DateTimeNullableFilter<'stock_news_read_history'>
      | Date
      | string
      | null;
    language_read?:
      | StringNullableFilter<'stock_news_read_history'>
      | string
      | null;
    read_duration?:
      | IntNullableFilter<'stock_news_read_history'>
      | number
      | null;
    metadata?: JsonNullableFilter<'stock_news_read_history'>;
    stock_news?: XOR<Stock_newsScalarRelationFilter, stock_newsWhereInput>;
  };

  export type stock_news_read_historyOrderByWithRelationInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    user_id?: SortOrderInput | SortOrder;
    session_id?: SortOrderInput | SortOrder;
    read_at?: SortOrderInput | SortOrder;
    language_read?: SortOrderInput | SortOrder;
    read_duration?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    stock_news?: stock_newsOrderByWithRelationInput;
  };

  export type stock_news_read_historyWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?:
        | stock_news_read_historyWhereInput
        | stock_news_read_historyWhereInput[];
      OR?: stock_news_read_historyWhereInput[];
      NOT?:
        | stock_news_read_historyWhereInput
        | stock_news_read_historyWhereInput[];
      news_id?: UuidFilter<'stock_news_read_history'> | string;
      user_id?: StringNullableFilter<'stock_news_read_history'> | string | null;
      session_id?:
        | StringNullableFilter<'stock_news_read_history'>
        | string
        | null;
      read_at?:
        | DateTimeNullableFilter<'stock_news_read_history'>
        | Date
        | string
        | null;
      language_read?:
        | StringNullableFilter<'stock_news_read_history'>
        | string
        | null;
      read_duration?:
        | IntNullableFilter<'stock_news_read_history'>
        | number
        | null;
      metadata?: JsonNullableFilter<'stock_news_read_history'>;
      stock_news?: XOR<Stock_newsScalarRelationFilter, stock_newsWhereInput>;
    },
    'id'
  >;

  export type stock_news_read_historyOrderByWithAggregationInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    user_id?: SortOrderInput | SortOrder;
    session_id?: SortOrderInput | SortOrder;
    read_at?: SortOrderInput | SortOrder;
    language_read?: SortOrderInput | SortOrder;
    read_duration?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    _count?: stock_news_read_historyCountOrderByAggregateInput;
    _avg?: stock_news_read_historyAvgOrderByAggregateInput;
    _max?: stock_news_read_historyMaxOrderByAggregateInput;
    _min?: stock_news_read_historyMinOrderByAggregateInput;
    _sum?: stock_news_read_historySumOrderByAggregateInput;
  };

  export type stock_news_read_historyScalarWhereWithAggregatesInput = {
    AND?:
      | stock_news_read_historyScalarWhereWithAggregatesInput
      | stock_news_read_historyScalarWhereWithAggregatesInput[];
    OR?: stock_news_read_historyScalarWhereWithAggregatesInput[];
    NOT?:
      | stock_news_read_historyScalarWhereWithAggregatesInput
      | stock_news_read_historyScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'stock_news_read_history'> | string;
    news_id?: UuidWithAggregatesFilter<'stock_news_read_history'> | string;
    user_id?:
      | StringNullableWithAggregatesFilter<'stock_news_read_history'>
      | string
      | null;
    session_id?:
      | StringNullableWithAggregatesFilter<'stock_news_read_history'>
      | string
      | null;
    read_at?:
      | DateTimeNullableWithAggregatesFilter<'stock_news_read_history'>
      | Date
      | string
      | null;
    language_read?:
      | StringNullableWithAggregatesFilter<'stock_news_read_history'>
      | string
      | null;
    read_duration?:
      | IntNullableWithAggregatesFilter<'stock_news_read_history'>
      | number
      | null;
    metadata?: JsonNullableWithAggregatesFilter<'stock_news_read_history'>;
  };

  export type stock_news_related_symbolsWhereInput = {
    AND?:
      | stock_news_related_symbolsWhereInput
      | stock_news_related_symbolsWhereInput[];
    OR?: stock_news_related_symbolsWhereInput[];
    NOT?:
      | stock_news_related_symbolsWhereInput
      | stock_news_related_symbolsWhereInput[];
    id?: UuidFilter<'stock_news_related_symbols'> | string;
    news_id?: UuidFilter<'stock_news_related_symbols'> | string;
    related_symbol?: StringFilter<'stock_news_related_symbols'> | string;
    related_exchange?:
      | StringNullableFilter<'stock_news_related_symbols'>
      | string
      | null;
    is_primary?:
      | BoolNullableFilter<'stock_news_related_symbols'>
      | boolean
      | null;
    stock_news?: XOR<Stock_newsScalarRelationFilter, stock_newsWhereInput>;
  };

  export type stock_news_related_symbolsOrderByWithRelationInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    related_symbol?: SortOrder;
    related_exchange?: SortOrderInput | SortOrder;
    is_primary?: SortOrderInput | SortOrder;
    stock_news?: stock_newsOrderByWithRelationInput;
  };

  export type stock_news_related_symbolsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?:
        | stock_news_related_symbolsWhereInput
        | stock_news_related_symbolsWhereInput[];
      OR?: stock_news_related_symbolsWhereInput[];
      NOT?:
        | stock_news_related_symbolsWhereInput
        | stock_news_related_symbolsWhereInput[];
      news_id?: UuidFilter<'stock_news_related_symbols'> | string;
      related_symbol?: StringFilter<'stock_news_related_symbols'> | string;
      related_exchange?:
        | StringNullableFilter<'stock_news_related_symbols'>
        | string
        | null;
      is_primary?:
        | BoolNullableFilter<'stock_news_related_symbols'>
        | boolean
        | null;
      stock_news?: XOR<Stock_newsScalarRelationFilter, stock_newsWhereInput>;
    },
    'id'
  >;

  export type stock_news_related_symbolsOrderByWithAggregationInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    related_symbol?: SortOrder;
    related_exchange?: SortOrderInput | SortOrder;
    is_primary?: SortOrderInput | SortOrder;
    _count?: stock_news_related_symbolsCountOrderByAggregateInput;
    _max?: stock_news_related_symbolsMaxOrderByAggregateInput;
    _min?: stock_news_related_symbolsMinOrderByAggregateInput;
  };

  export type stock_news_related_symbolsScalarWhereWithAggregatesInput = {
    AND?:
      | stock_news_related_symbolsScalarWhereWithAggregatesInput
      | stock_news_related_symbolsScalarWhereWithAggregatesInput[];
    OR?: stock_news_related_symbolsScalarWhereWithAggregatesInput[];
    NOT?:
      | stock_news_related_symbolsScalarWhereWithAggregatesInput
      | stock_news_related_symbolsScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'stock_news_related_symbols'> | string;
    news_id?: UuidWithAggregatesFilter<'stock_news_related_symbols'> | string;
    related_symbol?:
      | StringWithAggregatesFilter<'stock_news_related_symbols'>
      | string;
    related_exchange?:
      | StringNullableWithAggregatesFilter<'stock_news_related_symbols'>
      | string
      | null;
    is_primary?:
      | BoolNullableWithAggregatesFilter<'stock_news_related_symbols'>
      | boolean
      | null;
  };

  export type stock_news_translationWhereInput = {
    AND?: stock_news_translationWhereInput | stock_news_translationWhereInput[];
    OR?: stock_news_translationWhereInput[];
    NOT?: stock_news_translationWhereInput | stock_news_translationWhereInput[];
    id?: UuidFilter<'stock_news_translation'> | string;
    news_id?: UuidFilter<'stock_news_translation'> | string;
    language?: StringFilter<'stock_news_translation'> | string;
    title?: StringFilter<'stock_news_translation'> | string;
    content?: StringNullableFilter<'stock_news_translation'> | string | null;
    summary?: StringNullableFilter<'stock_news_translation'> | string | null;
    created_at?:
      | DateTimeNullableFilter<'stock_news_translation'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableFilter<'stock_news_translation'>
      | Date
      | string
      | null;
    stock_news?: XOR<Stock_newsScalarRelationFilter, stock_newsWhereInput>;
  };

  export type stock_news_translationOrderByWithRelationInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    language?: SortOrder;
    title?: SortOrder;
    content?: SortOrderInput | SortOrder;
    summary?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    stock_news?: stock_newsOrderByWithRelationInput;
  };

  export type stock_news_translationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?:
        | stock_news_translationWhereInput
        | stock_news_translationWhereInput[];
      OR?: stock_news_translationWhereInput[];
      NOT?:
        | stock_news_translationWhereInput
        | stock_news_translationWhereInput[];
      news_id?: UuidFilter<'stock_news_translation'> | string;
      language?: StringFilter<'stock_news_translation'> | string;
      title?: StringFilter<'stock_news_translation'> | string;
      content?: StringNullableFilter<'stock_news_translation'> | string | null;
      summary?: StringNullableFilter<'stock_news_translation'> | string | null;
      created_at?:
        | DateTimeNullableFilter<'stock_news_translation'>
        | Date
        | string
        | null;
      updated_at?:
        | DateTimeNullableFilter<'stock_news_translation'>
        | Date
        | string
        | null;
      stock_news?: XOR<Stock_newsScalarRelationFilter, stock_newsWhereInput>;
    },
    'id'
  >;

  export type stock_news_translationOrderByWithAggregationInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    language?: SortOrder;
    title?: SortOrder;
    content?: SortOrderInput | SortOrder;
    summary?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    _count?: stock_news_translationCountOrderByAggregateInput;
    _max?: stock_news_translationMaxOrderByAggregateInput;
    _min?: stock_news_translationMinOrderByAggregateInput;
  };

  export type stock_news_translationScalarWhereWithAggregatesInput = {
    AND?:
      | stock_news_translationScalarWhereWithAggregatesInput
      | stock_news_translationScalarWhereWithAggregatesInput[];
    OR?: stock_news_translationScalarWhereWithAggregatesInput[];
    NOT?:
      | stock_news_translationScalarWhereWithAggregatesInput
      | stock_news_translationScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'stock_news_translation'> | string;
    news_id?: UuidWithAggregatesFilter<'stock_news_translation'> | string;
    language?: StringWithAggregatesFilter<'stock_news_translation'> | string;
    title?: StringWithAggregatesFilter<'stock_news_translation'> | string;
    content?:
      | StringNullableWithAggregatesFilter<'stock_news_translation'>
      | string
      | null;
    summary?:
      | StringNullableWithAggregatesFilter<'stock_news_translation'>
      | string
      | null;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'stock_news_translation'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'stock_news_translation'>
      | Date
      | string
      | null;
  };

  export type subscriptionsWhereInput = {
    AND?: subscriptionsWhereInput | subscriptionsWhereInput[];
    OR?: subscriptionsWhereInput[];
    NOT?: subscriptionsWhereInput | subscriptionsWhereInput[];
    subscription_id?: IntFilter<'subscriptions'> | number;
    name?: StringNullableFilter<'subscriptions'> | string | null;
    price?:
      | DecimalNullableFilter<'subscriptions'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    features?: JsonNullableFilter<'subscriptions'>;
    created_at?: DateTimeNullableFilter<'subscriptions'> | Date | string | null;
    updated_at?: DateTimeNullableFilter<'subscriptions'> | Date | string | null;
    stripe_price_id?: StringNullableFilter<'subscriptions'> | string | null;
    price_amount?: StringNullableFilter<'subscriptions'> | string | null;
    currency?: StringNullableFilter<'subscriptions'> | string | null;
    billing_interval?: StringNullableFilter<'subscriptions'> | string | null;
    is_active?: BoolNullableFilter<'subscriptions'> | boolean | null;
    trial_days?: IntNullableFilter<'subscriptions'> | number | null;
    permissions?: PermissionsListRelationFilter;
    user_subscriptions?: User_subscriptionsListRelationFilter;
  };

  export type subscriptionsOrderByWithRelationInput = {
    subscription_id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    price?: SortOrderInput | SortOrder;
    features?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    stripe_price_id?: SortOrderInput | SortOrder;
    price_amount?: SortOrderInput | SortOrder;
    currency?: SortOrderInput | SortOrder;
    billing_interval?: SortOrderInput | SortOrder;
    is_active?: SortOrderInput | SortOrder;
    trial_days?: SortOrderInput | SortOrder;
    permissions?: permissionsOrderByRelationAggregateInput;
    user_subscriptions?: user_subscriptionsOrderByRelationAggregateInput;
  };

  export type subscriptionsWhereUniqueInput = Prisma.AtLeast<
    {
      subscription_id?: number;
      AND?: subscriptionsWhereInput | subscriptionsWhereInput[];
      OR?: subscriptionsWhereInput[];
      NOT?: subscriptionsWhereInput | subscriptionsWhereInput[];
      name?: StringNullableFilter<'subscriptions'> | string | null;
      price?:
        | DecimalNullableFilter<'subscriptions'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      features?: JsonNullableFilter<'subscriptions'>;
      created_at?:
        | DateTimeNullableFilter<'subscriptions'>
        | Date
        | string
        | null;
      updated_at?:
        | DateTimeNullableFilter<'subscriptions'>
        | Date
        | string
        | null;
      stripe_price_id?: StringNullableFilter<'subscriptions'> | string | null;
      price_amount?: StringNullableFilter<'subscriptions'> | string | null;
      currency?: StringNullableFilter<'subscriptions'> | string | null;
      billing_interval?: StringNullableFilter<'subscriptions'> | string | null;
      is_active?: BoolNullableFilter<'subscriptions'> | boolean | null;
      trial_days?: IntNullableFilter<'subscriptions'> | number | null;
      permissions?: PermissionsListRelationFilter;
      user_subscriptions?: User_subscriptionsListRelationFilter;
    },
    'subscription_id'
  >;

  export type subscriptionsOrderByWithAggregationInput = {
    subscription_id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    price?: SortOrderInput | SortOrder;
    features?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    stripe_price_id?: SortOrderInput | SortOrder;
    price_amount?: SortOrderInput | SortOrder;
    currency?: SortOrderInput | SortOrder;
    billing_interval?: SortOrderInput | SortOrder;
    is_active?: SortOrderInput | SortOrder;
    trial_days?: SortOrderInput | SortOrder;
    _count?: subscriptionsCountOrderByAggregateInput;
    _avg?: subscriptionsAvgOrderByAggregateInput;
    _max?: subscriptionsMaxOrderByAggregateInput;
    _min?: subscriptionsMinOrderByAggregateInput;
    _sum?: subscriptionsSumOrderByAggregateInput;
  };

  export type subscriptionsScalarWhereWithAggregatesInput = {
    AND?:
      | subscriptionsScalarWhereWithAggregatesInput
      | subscriptionsScalarWhereWithAggregatesInput[];
    OR?: subscriptionsScalarWhereWithAggregatesInput[];
    NOT?:
      | subscriptionsScalarWhereWithAggregatesInput
      | subscriptionsScalarWhereWithAggregatesInput[];
    subscription_id?: IntWithAggregatesFilter<'subscriptions'> | number;
    name?: StringNullableWithAggregatesFilter<'subscriptions'> | string | null;
    price?:
      | DecimalNullableWithAggregatesFilter<'subscriptions'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    features?: JsonNullableWithAggregatesFilter<'subscriptions'>;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'subscriptions'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'subscriptions'>
      | Date
      | string
      | null;
    stripe_price_id?:
      | StringNullableWithAggregatesFilter<'subscriptions'>
      | string
      | null;
    price_amount?:
      | StringNullableWithAggregatesFilter<'subscriptions'>
      | string
      | null;
    currency?:
      | StringNullableWithAggregatesFilter<'subscriptions'>
      | string
      | null;
    billing_interval?:
      | StringNullableWithAggregatesFilter<'subscriptions'>
      | string
      | null;
    is_active?:
      | BoolNullableWithAggregatesFilter<'subscriptions'>
      | boolean
      | null;
    trial_days?:
      | IntNullableWithAggregatesFilter<'subscriptions'>
      | number
      | null;
  };

  export type superinvestor_holdingsWhereInput = {
    AND?: superinvestor_holdingsWhereInput | superinvestor_holdingsWhereInput[];
    OR?: superinvestor_holdingsWhereInput[];
    NOT?: superinvestor_holdingsWhereInput | superinvestor_holdingsWhereInput[];
    id?: IntFilter<'superinvestor_holdings'> | number;
    manager_name?:
      | StringNullableFilter<'superinvestor_holdings'>
      | string
      | null;
    portfolio_value_raw?:
      | StringNullableFilter<'superinvestor_holdings'>
      | string
      | null;
    number_of_stocks?:
      | IntNullableFilter<'superinvestor_holdings'>
      | number
      | null;
    manager_link?:
      | StringNullableFilter<'superinvestor_holdings'>
      | string
      | null;
    image?: StringNullableFilter<'superinvestor_holdings'> | string | null;
    information_en?:
      | StringNullableFilter<'superinvestor_holdings'>
      | string
      | null;
    information_th?:
      | StringNullableFilter<'superinvestor_holdings'>
      | string
      | null;
    created_at?:
      | DateTimeNullableFilter<'superinvestor_holdings'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableFilter<'superinvestor_holdings'>
      | Date
      | string
      | null;
    portfolio_value?:
      | DecimalNullableFilter<'superinvestor_holdings'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    superinvestor_holdings_list?: Superinvestor_holdings_listListRelationFilter;
    superinvestor_sector_analysis?: Superinvestor_sector_analysisListRelationFilter;
  };

  export type superinvestor_holdingsOrderByWithRelationInput = {
    id?: SortOrder;
    manager_name?: SortOrderInput | SortOrder;
    portfolio_value_raw?: SortOrderInput | SortOrder;
    number_of_stocks?: SortOrderInput | SortOrder;
    manager_link?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    information_en?: SortOrderInput | SortOrder;
    information_th?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    portfolio_value?: SortOrderInput | SortOrder;
    superinvestor_holdings_list?: superinvestor_holdings_listOrderByRelationAggregateInput;
    superinvestor_sector_analysis?: superinvestor_sector_analysisOrderByRelationAggregateInput;
  };

  export type superinvestor_holdingsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      manager_link?: string;
      AND?:
        | superinvestor_holdingsWhereInput
        | superinvestor_holdingsWhereInput[];
      OR?: superinvestor_holdingsWhereInput[];
      NOT?:
        | superinvestor_holdingsWhereInput
        | superinvestor_holdingsWhereInput[];
      manager_name?:
        | StringNullableFilter<'superinvestor_holdings'>
        | string
        | null;
      portfolio_value_raw?:
        | StringNullableFilter<'superinvestor_holdings'>
        | string
        | null;
      number_of_stocks?:
        | IntNullableFilter<'superinvestor_holdings'>
        | number
        | null;
      image?: StringNullableFilter<'superinvestor_holdings'> | string | null;
      information_en?:
        | StringNullableFilter<'superinvestor_holdings'>
        | string
        | null;
      information_th?:
        | StringNullableFilter<'superinvestor_holdings'>
        | string
        | null;
      created_at?:
        | DateTimeNullableFilter<'superinvestor_holdings'>
        | Date
        | string
        | null;
      updated_at?:
        | DateTimeNullableFilter<'superinvestor_holdings'>
        | Date
        | string
        | null;
      portfolio_value?:
        | DecimalNullableFilter<'superinvestor_holdings'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      superinvestor_holdings_list?: Superinvestor_holdings_listListRelationFilter;
      superinvestor_sector_analysis?: Superinvestor_sector_analysisListRelationFilter;
    },
    'id' | 'manager_link'
  >;

  export type superinvestor_holdingsOrderByWithAggregationInput = {
    id?: SortOrder;
    manager_name?: SortOrderInput | SortOrder;
    portfolio_value_raw?: SortOrderInput | SortOrder;
    number_of_stocks?: SortOrderInput | SortOrder;
    manager_link?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    information_en?: SortOrderInput | SortOrder;
    information_th?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    portfolio_value?: SortOrderInput | SortOrder;
    _count?: superinvestor_holdingsCountOrderByAggregateInput;
    _avg?: superinvestor_holdingsAvgOrderByAggregateInput;
    _max?: superinvestor_holdingsMaxOrderByAggregateInput;
    _min?: superinvestor_holdingsMinOrderByAggregateInput;
    _sum?: superinvestor_holdingsSumOrderByAggregateInput;
  };

  export type superinvestor_holdingsScalarWhereWithAggregatesInput = {
    AND?:
      | superinvestor_holdingsScalarWhereWithAggregatesInput
      | superinvestor_holdingsScalarWhereWithAggregatesInput[];
    OR?: superinvestor_holdingsScalarWhereWithAggregatesInput[];
    NOT?:
      | superinvestor_holdingsScalarWhereWithAggregatesInput
      | superinvestor_holdingsScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'superinvestor_holdings'> | number;
    manager_name?:
      | StringNullableWithAggregatesFilter<'superinvestor_holdings'>
      | string
      | null;
    portfolio_value_raw?:
      | StringNullableWithAggregatesFilter<'superinvestor_holdings'>
      | string
      | null;
    number_of_stocks?:
      | IntNullableWithAggregatesFilter<'superinvestor_holdings'>
      | number
      | null;
    manager_link?:
      | StringNullableWithAggregatesFilter<'superinvestor_holdings'>
      | string
      | null;
    image?:
      | StringNullableWithAggregatesFilter<'superinvestor_holdings'>
      | string
      | null;
    information_en?:
      | StringNullableWithAggregatesFilter<'superinvestor_holdings'>
      | string
      | null;
    information_th?:
      | StringNullableWithAggregatesFilter<'superinvestor_holdings'>
      | string
      | null;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'superinvestor_holdings'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'superinvestor_holdings'>
      | Date
      | string
      | null;
    portfolio_value?:
      | DecimalNullableWithAggregatesFilter<'superinvestor_holdings'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type superinvestor_holdings_listWhereInput = {
    AND?:
      | superinvestor_holdings_listWhereInput
      | superinvestor_holdings_listWhereInput[];
    OR?: superinvestor_holdings_listWhereInput[];
    NOT?:
      | superinvestor_holdings_listWhereInput
      | superinvestor_holdings_listWhereInput[];
    id?: IntFilter<'superinvestor_holdings_list'> | number;
    manager_id?:
      | IntNullableFilter<'superinvestor_holdings_list'>
      | number
      | null;
    symbol?:
      | StringNullableFilter<'superinvestor_holdings_list'>
      | string
      | null;
    percentage_of_portfolio?:
      | DecimalNullableFilter<'superinvestor_holdings_list'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    recent_activity?:
      | StringNullableFilter<'superinvestor_holdings_list'>
      | string
      | null;
    share_raw?:
      | StringNullableFilter<'superinvestor_holdings_list'>
      | string
      | null;
    share_value?:
      | DecimalNullableFilter<'superinvestor_holdings_list'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    reported_price_raw?:
      | StringNullableFilter<'superinvestor_holdings_list'>
      | string
      | null;
    reported_price_value?:
      | DecimalNullableFilter<'superinvestor_holdings_list'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    value_raw?:
      | StringNullableFilter<'superinvestor_holdings_list'>
      | string
      | null;
    value?:
      | DecimalNullableFilter<'superinvestor_holdings_list'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    superinvestor_holdings?: XOR<
      Superinvestor_holdingsNullableScalarRelationFilter,
      superinvestor_holdingsWhereInput
    > | null;
  };

  export type superinvestor_holdings_listOrderByWithRelationInput = {
    id?: SortOrder;
    manager_id?: SortOrderInput | SortOrder;
    symbol?: SortOrderInput | SortOrder;
    percentage_of_portfolio?: SortOrderInput | SortOrder;
    recent_activity?: SortOrderInput | SortOrder;
    share_raw?: SortOrderInput | SortOrder;
    share_value?: SortOrderInput | SortOrder;
    reported_price_raw?: SortOrderInput | SortOrder;
    reported_price_value?: SortOrderInput | SortOrder;
    value_raw?: SortOrderInput | SortOrder;
    value?: SortOrderInput | SortOrder;
    superinvestor_holdings?: superinvestor_holdingsOrderByWithRelationInput;
  };

  export type superinvestor_holdings_listWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?:
        | superinvestor_holdings_listWhereInput
        | superinvestor_holdings_listWhereInput[];
      OR?: superinvestor_holdings_listWhereInput[];
      NOT?:
        | superinvestor_holdings_listWhereInput
        | superinvestor_holdings_listWhereInput[];
      manager_id?:
        | IntNullableFilter<'superinvestor_holdings_list'>
        | number
        | null;
      symbol?:
        | StringNullableFilter<'superinvestor_holdings_list'>
        | string
        | null;
      percentage_of_portfolio?:
        | DecimalNullableFilter<'superinvestor_holdings_list'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      recent_activity?:
        | StringNullableFilter<'superinvestor_holdings_list'>
        | string
        | null;
      share_raw?:
        | StringNullableFilter<'superinvestor_holdings_list'>
        | string
        | null;
      share_value?:
        | DecimalNullableFilter<'superinvestor_holdings_list'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      reported_price_raw?:
        | StringNullableFilter<'superinvestor_holdings_list'>
        | string
        | null;
      reported_price_value?:
        | DecimalNullableFilter<'superinvestor_holdings_list'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      value_raw?:
        | StringNullableFilter<'superinvestor_holdings_list'>
        | string
        | null;
      value?:
        | DecimalNullableFilter<'superinvestor_holdings_list'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      superinvestor_holdings?: XOR<
        Superinvestor_holdingsNullableScalarRelationFilter,
        superinvestor_holdingsWhereInput
      > | null;
    },
    'id'
  >;

  export type superinvestor_holdings_listOrderByWithAggregationInput = {
    id?: SortOrder;
    manager_id?: SortOrderInput | SortOrder;
    symbol?: SortOrderInput | SortOrder;
    percentage_of_portfolio?: SortOrderInput | SortOrder;
    recent_activity?: SortOrderInput | SortOrder;
    share_raw?: SortOrderInput | SortOrder;
    share_value?: SortOrderInput | SortOrder;
    reported_price_raw?: SortOrderInput | SortOrder;
    reported_price_value?: SortOrderInput | SortOrder;
    value_raw?: SortOrderInput | SortOrder;
    value?: SortOrderInput | SortOrder;
    _count?: superinvestor_holdings_listCountOrderByAggregateInput;
    _avg?: superinvestor_holdings_listAvgOrderByAggregateInput;
    _max?: superinvestor_holdings_listMaxOrderByAggregateInput;
    _min?: superinvestor_holdings_listMinOrderByAggregateInput;
    _sum?: superinvestor_holdings_listSumOrderByAggregateInput;
  };

  export type superinvestor_holdings_listScalarWhereWithAggregatesInput = {
    AND?:
      | superinvestor_holdings_listScalarWhereWithAggregatesInput
      | superinvestor_holdings_listScalarWhereWithAggregatesInput[];
    OR?: superinvestor_holdings_listScalarWhereWithAggregatesInput[];
    NOT?:
      | superinvestor_holdings_listScalarWhereWithAggregatesInput
      | superinvestor_holdings_listScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'superinvestor_holdings_list'> | number;
    manager_id?:
      | IntNullableWithAggregatesFilter<'superinvestor_holdings_list'>
      | number
      | null;
    symbol?:
      | StringNullableWithAggregatesFilter<'superinvestor_holdings_list'>
      | string
      | null;
    percentage_of_portfolio?:
      | DecimalNullableWithAggregatesFilter<'superinvestor_holdings_list'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    recent_activity?:
      | StringNullableWithAggregatesFilter<'superinvestor_holdings_list'>
      | string
      | null;
    share_raw?:
      | StringNullableWithAggregatesFilter<'superinvestor_holdings_list'>
      | string
      | null;
    share_value?:
      | DecimalNullableWithAggregatesFilter<'superinvestor_holdings_list'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    reported_price_raw?:
      | StringNullableWithAggregatesFilter<'superinvestor_holdings_list'>
      | string
      | null;
    reported_price_value?:
      | DecimalNullableWithAggregatesFilter<'superinvestor_holdings_list'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    value_raw?:
      | StringNullableWithAggregatesFilter<'superinvestor_holdings_list'>
      | string
      | null;
    value?:
      | DecimalNullableWithAggregatesFilter<'superinvestor_holdings_list'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type superinvestor_sector_analysisWhereInput = {
    AND?:
      | superinvestor_sector_analysisWhereInput
      | superinvestor_sector_analysisWhereInput[];
    OR?: superinvestor_sector_analysisWhereInput[];
    NOT?:
      | superinvestor_sector_analysisWhereInput
      | superinvestor_sector_analysisWhereInput[];
    id?: IntFilter<'superinvestor_sector_analysis'> | number;
    manager_id?:
      | IntNullableFilter<'superinvestor_sector_analysis'>
      | number
      | null;
    sector_name?:
      | StringNullableFilter<'superinvestor_sector_analysis'>
      | string
      | null;
    sector_percentage?:
      | DecimalNullableFilter<'superinvestor_sector_analysis'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    superinvestor_holdings?: XOR<
      Superinvestor_holdingsNullableScalarRelationFilter,
      superinvestor_holdingsWhereInput
    > | null;
  };

  export type superinvestor_sector_analysisOrderByWithRelationInput = {
    id?: SortOrder;
    manager_id?: SortOrderInput | SortOrder;
    sector_name?: SortOrderInput | SortOrder;
    sector_percentage?: SortOrderInput | SortOrder;
    superinvestor_holdings?: superinvestor_holdingsOrderByWithRelationInput;
  };

  export type superinvestor_sector_analysisWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?:
        | superinvestor_sector_analysisWhereInput
        | superinvestor_sector_analysisWhereInput[];
      OR?: superinvestor_sector_analysisWhereInput[];
      NOT?:
        | superinvestor_sector_analysisWhereInput
        | superinvestor_sector_analysisWhereInput[];
      manager_id?:
        | IntNullableFilter<'superinvestor_sector_analysis'>
        | number
        | null;
      sector_name?:
        | StringNullableFilter<'superinvestor_sector_analysis'>
        | string
        | null;
      sector_percentage?:
        | DecimalNullableFilter<'superinvestor_sector_analysis'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      superinvestor_holdings?: XOR<
        Superinvestor_holdingsNullableScalarRelationFilter,
        superinvestor_holdingsWhereInput
      > | null;
    },
    'id'
  >;

  export type superinvestor_sector_analysisOrderByWithAggregationInput = {
    id?: SortOrder;
    manager_id?: SortOrderInput | SortOrder;
    sector_name?: SortOrderInput | SortOrder;
    sector_percentage?: SortOrderInput | SortOrder;
    _count?: superinvestor_sector_analysisCountOrderByAggregateInput;
    _avg?: superinvestor_sector_analysisAvgOrderByAggregateInput;
    _max?: superinvestor_sector_analysisMaxOrderByAggregateInput;
    _min?: superinvestor_sector_analysisMinOrderByAggregateInput;
    _sum?: superinvestor_sector_analysisSumOrderByAggregateInput;
  };

  export type superinvestor_sector_analysisScalarWhereWithAggregatesInput = {
    AND?:
      | superinvestor_sector_analysisScalarWhereWithAggregatesInput
      | superinvestor_sector_analysisScalarWhereWithAggregatesInput[];
    OR?: superinvestor_sector_analysisScalarWhereWithAggregatesInput[];
    NOT?:
      | superinvestor_sector_analysisScalarWhereWithAggregatesInput
      | superinvestor_sector_analysisScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<'superinvestor_sector_analysis'> | number;
    manager_id?:
      | IntNullableWithAggregatesFilter<'superinvestor_sector_analysis'>
      | number
      | null;
    sector_name?:
      | StringNullableWithAggregatesFilter<'superinvestor_sector_analysis'>
      | string
      | null;
    sector_percentage?:
      | DecimalNullableWithAggregatesFilter<'superinvestor_sector_analysis'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type symbolWhereInput = {
    AND?: symbolWhereInput | symbolWhereInput[];
    OR?: symbolWhereInput[];
    NOT?: symbolWhereInput | symbolWhereInput[];
    id?: UuidFilter<'symbol'> | string;
    symbol?: StringFilter<'symbol'> | string;
    company_name?: StringNullableFilter<'symbol'> | string | null;
    exchange_short_name?: StringNullableFilter<'symbol'> | string | null;
    company_logo?: StringNullableFilter<'symbol'> | string | null;
    type?: StringNullableFilter<'symbol'> | string | null;
    created_at?: DateTimeNullableFilter<'symbol'> | Date | string | null;
    updated_at?: DateTimeNullableFilter<'symbol'> | Date | string | null;
  };

  export type symbolOrderByWithRelationInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    company_name?: SortOrderInput | SortOrder;
    exchange_short_name?: SortOrderInput | SortOrder;
    company_logo?: SortOrderInput | SortOrder;
    type?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
  };

  export type symbolWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: symbolWhereInput | symbolWhereInput[];
      OR?: symbolWhereInput[];
      NOT?: symbolWhereInput | symbolWhereInput[];
      symbol?: StringFilter<'symbol'> | string;
      company_name?: StringNullableFilter<'symbol'> | string | null;
      exchange_short_name?: StringNullableFilter<'symbol'> | string | null;
      company_logo?: StringNullableFilter<'symbol'> | string | null;
      type?: StringNullableFilter<'symbol'> | string | null;
      created_at?: DateTimeNullableFilter<'symbol'> | Date | string | null;
      updated_at?: DateTimeNullableFilter<'symbol'> | Date | string | null;
    },
    'id'
  >;

  export type symbolOrderByWithAggregationInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    company_name?: SortOrderInput | SortOrder;
    exchange_short_name?: SortOrderInput | SortOrder;
    company_logo?: SortOrderInput | SortOrder;
    type?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    _count?: symbolCountOrderByAggregateInput;
    _max?: symbolMaxOrderByAggregateInput;
    _min?: symbolMinOrderByAggregateInput;
  };

  export type symbolScalarWhereWithAggregatesInput = {
    AND?:
      | symbolScalarWhereWithAggregatesInput
      | symbolScalarWhereWithAggregatesInput[];
    OR?: symbolScalarWhereWithAggregatesInput[];
    NOT?:
      | symbolScalarWhereWithAggregatesInput
      | symbolScalarWhereWithAggregatesInput[];
    id?: UuidWithAggregatesFilter<'symbol'> | string;
    symbol?: StringWithAggregatesFilter<'symbol'> | string;
    company_name?: StringNullableWithAggregatesFilter<'symbol'> | string | null;
    exchange_short_name?:
      | StringNullableWithAggregatesFilter<'symbol'>
      | string
      | null;
    company_logo?: StringNullableWithAggregatesFilter<'symbol'> | string | null;
    type?: StringNullableWithAggregatesFilter<'symbol'> | string | null;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'symbol'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'symbol'>
      | Date
      | string
      | null;
  };

  export type user_devicesWhereInput = {
    AND?: user_devicesWhereInput | user_devicesWhereInput[];
    OR?: user_devicesWhereInput[];
    NOT?: user_devicesWhereInput | user_devicesWhereInput[];
    device_id?: UuidFilter<'user_devices'> | string;
    user_id?: IntFilter<'user_devices'> | number;
    platform?: StringFilter<'user_devices'> | string;
    device_token?: StringNullableFilter<'user_devices'> | string | null;
    last_active_at?:
      | DateTimeNullableFilter<'user_devices'>
      | Date
      | string
      | null;
    created_at?: DateTimeNullableFilter<'user_devices'> | Date | string | null;
    app_version?: StringNullableFilter<'user_devices'> | string | null;
    device_name?: StringNullableFilter<'user_devices'> | string | null;
  };

  export type user_devicesOrderByWithRelationInput = {
    device_id?: SortOrder;
    user_id?: SortOrder;
    platform?: SortOrder;
    device_token?: SortOrderInput | SortOrder;
    last_active_at?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    app_version?: SortOrderInput | SortOrder;
    device_name?: SortOrderInput | SortOrder;
  };

  export type user_devicesWhereUniqueInput = Prisma.AtLeast<
    {
      device_id?: string;
      AND?: user_devicesWhereInput | user_devicesWhereInput[];
      OR?: user_devicesWhereInput[];
      NOT?: user_devicesWhereInput | user_devicesWhereInput[];
      user_id?: IntFilter<'user_devices'> | number;
      platform?: StringFilter<'user_devices'> | string;
      device_token?: StringNullableFilter<'user_devices'> | string | null;
      last_active_at?:
        | DateTimeNullableFilter<'user_devices'>
        | Date
        | string
        | null;
      created_at?:
        | DateTimeNullableFilter<'user_devices'>
        | Date
        | string
        | null;
      app_version?: StringNullableFilter<'user_devices'> | string | null;
      device_name?: StringNullableFilter<'user_devices'> | string | null;
    },
    'device_id'
  >;

  export type user_devicesOrderByWithAggregationInput = {
    device_id?: SortOrder;
    user_id?: SortOrder;
    platform?: SortOrder;
    device_token?: SortOrderInput | SortOrder;
    last_active_at?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    app_version?: SortOrderInput | SortOrder;
    device_name?: SortOrderInput | SortOrder;
    _count?: user_devicesCountOrderByAggregateInput;
    _avg?: user_devicesAvgOrderByAggregateInput;
    _max?: user_devicesMaxOrderByAggregateInput;
    _min?: user_devicesMinOrderByAggregateInput;
    _sum?: user_devicesSumOrderByAggregateInput;
  };

  export type user_devicesScalarWhereWithAggregatesInput = {
    AND?:
      | user_devicesScalarWhereWithAggregatesInput
      | user_devicesScalarWhereWithAggregatesInput[];
    OR?: user_devicesScalarWhereWithAggregatesInput[];
    NOT?:
      | user_devicesScalarWhereWithAggregatesInput
      | user_devicesScalarWhereWithAggregatesInput[];
    device_id?: UuidWithAggregatesFilter<'user_devices'> | string;
    user_id?: IntWithAggregatesFilter<'user_devices'> | number;
    platform?: StringWithAggregatesFilter<'user_devices'> | string;
    device_token?:
      | StringNullableWithAggregatesFilter<'user_devices'>
      | string
      | null;
    last_active_at?:
      | DateTimeNullableWithAggregatesFilter<'user_devices'>
      | Date
      | string
      | null;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'user_devices'>
      | Date
      | string
      | null;
    app_version?:
      | StringNullableWithAggregatesFilter<'user_devices'>
      | string
      | null;
    device_name?:
      | StringNullableWithAggregatesFilter<'user_devices'>
      | string
      | null;
  };

  export type user_subscriptionsWhereInput = {
    AND?: user_subscriptionsWhereInput | user_subscriptionsWhereInput[];
    OR?: user_subscriptionsWhereInput[];
    NOT?: user_subscriptionsWhereInput | user_subscriptionsWhereInput[];
    user_subscription_id?: IntFilter<'user_subscriptions'> | number;
    user_id?: IntNullableFilter<'user_subscriptions'> | number | null;
    subscription_id?: IntNullableFilter<'user_subscriptions'> | number | null;
    start_date?:
      | DateTimeNullableFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    end_date?:
      | DateTimeNullableFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    is_active?: BoolNullableFilter<'user_subscriptions'> | boolean | null;
    stripe_subscription_id?:
      | StringNullableFilter<'user_subscriptions'>
      | string
      | null;
    stripe_payment_intent_id?:
      | StringNullableFilter<'user_subscriptions'>
      | string
      | null;
    payment_status?: StringNullableFilter<'user_subscriptions'> | string | null;
    last_payment_date?:
      | DateTimeNullableFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    next_billing_date?:
      | DateTimeNullableFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    cancellation_date?:
      | DateTimeNullableFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    trial_end_date?:
      | DateTimeNullableFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    last_payment_attempt_date?:
      | DateTimeNullableFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    payment_method_id?:
      | StringNullableFilter<'user_subscriptions'>
      | string
      | null;
    redeem_code?: StringNullableFilter<'user_subscriptions'> | string | null;
    subscriptions?: XOR<
      SubscriptionsNullableScalarRelationFilter,
      subscriptionsWhereInput
    > | null;
  };

  export type user_subscriptionsOrderByWithRelationInput = {
    user_subscription_id?: SortOrder;
    user_id?: SortOrderInput | SortOrder;
    subscription_id?: SortOrderInput | SortOrder;
    start_date?: SortOrderInput | SortOrder;
    end_date?: SortOrderInput | SortOrder;
    is_active?: SortOrderInput | SortOrder;
    stripe_subscription_id?: SortOrderInput | SortOrder;
    stripe_payment_intent_id?: SortOrderInput | SortOrder;
    payment_status?: SortOrderInput | SortOrder;
    last_payment_date?: SortOrderInput | SortOrder;
    next_billing_date?: SortOrderInput | SortOrder;
    cancellation_date?: SortOrderInput | SortOrder;
    trial_end_date?: SortOrderInput | SortOrder;
    last_payment_attempt_date?: SortOrderInput | SortOrder;
    payment_method_id?: SortOrderInput | SortOrder;
    redeem_code?: SortOrderInput | SortOrder;
    subscriptions?: subscriptionsOrderByWithRelationInput;
  };

  export type user_subscriptionsWhereUniqueInput = Prisma.AtLeast<
    {
      user_subscription_id?: number;
      AND?: user_subscriptionsWhereInput | user_subscriptionsWhereInput[];
      OR?: user_subscriptionsWhereInput[];
      NOT?: user_subscriptionsWhereInput | user_subscriptionsWhereInput[];
      user_id?: IntNullableFilter<'user_subscriptions'> | number | null;
      subscription_id?: IntNullableFilter<'user_subscriptions'> | number | null;
      start_date?:
        | DateTimeNullableFilter<'user_subscriptions'>
        | Date
        | string
        | null;
      end_date?:
        | DateTimeNullableFilter<'user_subscriptions'>
        | Date
        | string
        | null;
      is_active?: BoolNullableFilter<'user_subscriptions'> | boolean | null;
      stripe_subscription_id?:
        | StringNullableFilter<'user_subscriptions'>
        | string
        | null;
      stripe_payment_intent_id?:
        | StringNullableFilter<'user_subscriptions'>
        | string
        | null;
      payment_status?:
        | StringNullableFilter<'user_subscriptions'>
        | string
        | null;
      last_payment_date?:
        | DateTimeNullableFilter<'user_subscriptions'>
        | Date
        | string
        | null;
      next_billing_date?:
        | DateTimeNullableFilter<'user_subscriptions'>
        | Date
        | string
        | null;
      cancellation_date?:
        | DateTimeNullableFilter<'user_subscriptions'>
        | Date
        | string
        | null;
      trial_end_date?:
        | DateTimeNullableFilter<'user_subscriptions'>
        | Date
        | string
        | null;
      last_payment_attempt_date?:
        | DateTimeNullableFilter<'user_subscriptions'>
        | Date
        | string
        | null;
      payment_method_id?:
        | StringNullableFilter<'user_subscriptions'>
        | string
        | null;
      redeem_code?: StringNullableFilter<'user_subscriptions'> | string | null;
      subscriptions?: XOR<
        SubscriptionsNullableScalarRelationFilter,
        subscriptionsWhereInput
      > | null;
    },
    'user_subscription_id'
  >;

  export type user_subscriptionsOrderByWithAggregationInput = {
    user_subscription_id?: SortOrder;
    user_id?: SortOrderInput | SortOrder;
    subscription_id?: SortOrderInput | SortOrder;
    start_date?: SortOrderInput | SortOrder;
    end_date?: SortOrderInput | SortOrder;
    is_active?: SortOrderInput | SortOrder;
    stripe_subscription_id?: SortOrderInput | SortOrder;
    stripe_payment_intent_id?: SortOrderInput | SortOrder;
    payment_status?: SortOrderInput | SortOrder;
    last_payment_date?: SortOrderInput | SortOrder;
    next_billing_date?: SortOrderInput | SortOrder;
    cancellation_date?: SortOrderInput | SortOrder;
    trial_end_date?: SortOrderInput | SortOrder;
    last_payment_attempt_date?: SortOrderInput | SortOrder;
    payment_method_id?: SortOrderInput | SortOrder;
    redeem_code?: SortOrderInput | SortOrder;
    _count?: user_subscriptionsCountOrderByAggregateInput;
    _avg?: user_subscriptionsAvgOrderByAggregateInput;
    _max?: user_subscriptionsMaxOrderByAggregateInput;
    _min?: user_subscriptionsMinOrderByAggregateInput;
    _sum?: user_subscriptionsSumOrderByAggregateInput;
  };

  export type user_subscriptionsScalarWhereWithAggregatesInput = {
    AND?:
      | user_subscriptionsScalarWhereWithAggregatesInput
      | user_subscriptionsScalarWhereWithAggregatesInput[];
    OR?: user_subscriptionsScalarWhereWithAggregatesInput[];
    NOT?:
      | user_subscriptionsScalarWhereWithAggregatesInput
      | user_subscriptionsScalarWhereWithAggregatesInput[];
    user_subscription_id?:
      | IntWithAggregatesFilter<'user_subscriptions'>
      | number;
    user_id?:
      | IntNullableWithAggregatesFilter<'user_subscriptions'>
      | number
      | null;
    subscription_id?:
      | IntNullableWithAggregatesFilter<'user_subscriptions'>
      | number
      | null;
    start_date?:
      | DateTimeNullableWithAggregatesFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    end_date?:
      | DateTimeNullableWithAggregatesFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    is_active?:
      | BoolNullableWithAggregatesFilter<'user_subscriptions'>
      | boolean
      | null;
    stripe_subscription_id?:
      | StringNullableWithAggregatesFilter<'user_subscriptions'>
      | string
      | null;
    stripe_payment_intent_id?:
      | StringNullableWithAggregatesFilter<'user_subscriptions'>
      | string
      | null;
    payment_status?:
      | StringNullableWithAggregatesFilter<'user_subscriptions'>
      | string
      | null;
    last_payment_date?:
      | DateTimeNullableWithAggregatesFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    next_billing_date?:
      | DateTimeNullableWithAggregatesFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    cancellation_date?:
      | DateTimeNullableWithAggregatesFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    trial_end_date?:
      | DateTimeNullableWithAggregatesFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    last_payment_attempt_date?:
      | DateTimeNullableWithAggregatesFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    payment_method_id?:
      | StringNullableWithAggregatesFilter<'user_subscriptions'>
      | string
      | null;
    redeem_code?:
      | StringNullableWithAggregatesFilter<'user_subscriptions'>
      | string
      | null;
  };

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[];
    OR?: usersWhereInput[];
    NOT?: usersWhereInput | usersWhereInput[];
    user_id?: IntFilter<'users'> | number;
    google_id?: StringNullableFilter<'users'> | string | null;
    email?: StringNullableFilter<'users'> | string | null;
    name?: StringFilter<'users'> | string;
    profile_pic?: StringNullableFilter<'users'> | string | null;
    created_at?: DateTimeNullableFilter<'users'> | Date | string | null;
    updated_at?: DateTimeNullableFilter<'users'> | Date | string | null;
    stripe_customer_id?: StringNullableFilter<'users'> | string | null;
    refresh_token?: StringNullableFilter<'users'> | string | null;
    has_used_trial?: BoolFilter<'users'> | boolean;
    trial_used_at?: DateTimeNullableFilter<'users'> | Date | string | null;
    bio?: StringNullableFilter<'users'> | string | null;
    is_verified?: BoolFilter<'users'> | boolean;
    status_message?: StringNullableFilter<'users'> | string | null;
    last_login_at?: DateTimeNullableFilter<'users'> | Date | string | null;
    birthdate?: DateTimeNullableFilter<'users'> | Date | string | null;
    language_preference?: StringFilter<'users'> | string;
    theme_preference?: StringNullableFilter<'users'> | string | null;
    onboarding_completed?: BoolFilter<'users'> | boolean;
    account_status?: StringNullableFilter<'users'> | string | null;
    active_watchlist_id?: IntNullableFilter<'users'> | number | null;
    username?: StringFilter<'users'> | string;
    is_private?: BoolFilter<'users'> | boolean;
    apple_id?: StringNullableFilter<'users'> | string | null;
  };

  export type usersOrderByWithRelationInput = {
    user_id?: SortOrder;
    google_id?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    name?: SortOrder;
    profile_pic?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    stripe_customer_id?: SortOrderInput | SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    has_used_trial?: SortOrder;
    trial_used_at?: SortOrderInput | SortOrder;
    bio?: SortOrderInput | SortOrder;
    is_verified?: SortOrder;
    status_message?: SortOrderInput | SortOrder;
    last_login_at?: SortOrderInput | SortOrder;
    birthdate?: SortOrderInput | SortOrder;
    language_preference?: SortOrder;
    theme_preference?: SortOrderInput | SortOrder;
    onboarding_completed?: SortOrder;
    account_status?: SortOrderInput | SortOrder;
    active_watchlist_id?: SortOrderInput | SortOrder;
    username?: SortOrder;
    is_private?: SortOrder;
    apple_id?: SortOrderInput | SortOrder;
  };

  export type usersWhereUniqueInput = Prisma.AtLeast<
    {
      user_id?: number;
      email?: string;
      AND?: usersWhereInput | usersWhereInput[];
      OR?: usersWhereInput[];
      NOT?: usersWhereInput | usersWhereInput[];
      google_id?: StringNullableFilter<'users'> | string | null;
      name?: StringFilter<'users'> | string;
      profile_pic?: StringNullableFilter<'users'> | string | null;
      created_at?: DateTimeNullableFilter<'users'> | Date | string | null;
      updated_at?: DateTimeNullableFilter<'users'> | Date | string | null;
      stripe_customer_id?: StringNullableFilter<'users'> | string | null;
      refresh_token?: StringNullableFilter<'users'> | string | null;
      has_used_trial?: BoolFilter<'users'> | boolean;
      trial_used_at?: DateTimeNullableFilter<'users'> | Date | string | null;
      bio?: StringNullableFilter<'users'> | string | null;
      is_verified?: BoolFilter<'users'> | boolean;
      status_message?: StringNullableFilter<'users'> | string | null;
      last_login_at?: DateTimeNullableFilter<'users'> | Date | string | null;
      birthdate?: DateTimeNullableFilter<'users'> | Date | string | null;
      language_preference?: StringFilter<'users'> | string;
      theme_preference?: StringNullableFilter<'users'> | string | null;
      onboarding_completed?: BoolFilter<'users'> | boolean;
      account_status?: StringNullableFilter<'users'> | string | null;
      active_watchlist_id?: IntNullableFilter<'users'> | number | null;
      username?: StringFilter<'users'> | string;
      is_private?: BoolFilter<'users'> | boolean;
      apple_id?: StringNullableFilter<'users'> | string | null;
    },
    'user_id' | 'email'
  >;

  export type usersOrderByWithAggregationInput = {
    user_id?: SortOrder;
    google_id?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    name?: SortOrder;
    profile_pic?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    updated_at?: SortOrderInput | SortOrder;
    stripe_customer_id?: SortOrderInput | SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    has_used_trial?: SortOrder;
    trial_used_at?: SortOrderInput | SortOrder;
    bio?: SortOrderInput | SortOrder;
    is_verified?: SortOrder;
    status_message?: SortOrderInput | SortOrder;
    last_login_at?: SortOrderInput | SortOrder;
    birthdate?: SortOrderInput | SortOrder;
    language_preference?: SortOrder;
    theme_preference?: SortOrderInput | SortOrder;
    onboarding_completed?: SortOrder;
    account_status?: SortOrderInput | SortOrder;
    active_watchlist_id?: SortOrderInput | SortOrder;
    username?: SortOrder;
    is_private?: SortOrder;
    apple_id?: SortOrderInput | SortOrder;
    _count?: usersCountOrderByAggregateInput;
    _avg?: usersAvgOrderByAggregateInput;
    _max?: usersMaxOrderByAggregateInput;
    _min?: usersMinOrderByAggregateInput;
    _sum?: usersSumOrderByAggregateInput;
  };

  export type usersScalarWhereWithAggregatesInput = {
    AND?:
      | usersScalarWhereWithAggregatesInput
      | usersScalarWhereWithAggregatesInput[];
    OR?: usersScalarWhereWithAggregatesInput[];
    NOT?:
      | usersScalarWhereWithAggregatesInput
      | usersScalarWhereWithAggregatesInput[];
    user_id?: IntWithAggregatesFilter<'users'> | number;
    google_id?: StringNullableWithAggregatesFilter<'users'> | string | null;
    email?: StringNullableWithAggregatesFilter<'users'> | string | null;
    name?: StringWithAggregatesFilter<'users'> | string;
    profile_pic?: StringNullableWithAggregatesFilter<'users'> | string | null;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'users'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableWithAggregatesFilter<'users'>
      | Date
      | string
      | null;
    stripe_customer_id?:
      | StringNullableWithAggregatesFilter<'users'>
      | string
      | null;
    refresh_token?: StringNullableWithAggregatesFilter<'users'> | string | null;
    has_used_trial?: BoolWithAggregatesFilter<'users'> | boolean;
    trial_used_at?:
      | DateTimeNullableWithAggregatesFilter<'users'>
      | Date
      | string
      | null;
    bio?: StringNullableWithAggregatesFilter<'users'> | string | null;
    is_verified?: BoolWithAggregatesFilter<'users'> | boolean;
    status_message?:
      | StringNullableWithAggregatesFilter<'users'>
      | string
      | null;
    last_login_at?:
      | DateTimeNullableWithAggregatesFilter<'users'>
      | Date
      | string
      | null;
    birthdate?:
      | DateTimeNullableWithAggregatesFilter<'users'>
      | Date
      | string
      | null;
    language_preference?: StringWithAggregatesFilter<'users'> | string;
    theme_preference?:
      | StringNullableWithAggregatesFilter<'users'>
      | string
      | null;
    onboarding_completed?: BoolWithAggregatesFilter<'users'> | boolean;
    account_status?:
      | StringNullableWithAggregatesFilter<'users'>
      | string
      | null;
    active_watchlist_id?:
      | IntNullableWithAggregatesFilter<'users'>
      | number
      | null;
    username?: StringWithAggregatesFilter<'users'> | string;
    is_private?: BoolWithAggregatesFilter<'users'> | boolean;
    apple_id?: StringNullableWithAggregatesFilter<'users'> | string | null;
  };

  export type watchlist_itemsWhereInput = {
    AND?: watchlist_itemsWhereInput | watchlist_itemsWhereInput[];
    OR?: watchlist_itemsWhereInput[];
    NOT?: watchlist_itemsWhereInput | watchlist_itemsWhereInput[];
    watchlist_item_id?: IntFilter<'watchlist_items'> | number;
    watchlist_id?: IntNullableFilter<'watchlist_items'> | number | null;
    symbol?: StringNullableFilter<'watchlist_items'> | string | null;
    name?: StringNullableFilter<'watchlist_items'> | string | null;
    type?: StringNullableFilter<'watchlist_items'> | string | null;
    added_at?: DateTimeNullableFilter<'watchlist_items'> | Date | string | null;
    sequence?: IntNullableFilter<'watchlist_items'> | number | null;
  };

  export type watchlist_itemsOrderByWithRelationInput = {
    watchlist_item_id?: SortOrder;
    watchlist_id?: SortOrderInput | SortOrder;
    symbol?: SortOrderInput | SortOrder;
    name?: SortOrderInput | SortOrder;
    type?: SortOrderInput | SortOrder;
    added_at?: SortOrderInput | SortOrder;
    sequence?: SortOrderInput | SortOrder;
  };

  export type watchlist_itemsWhereUniqueInput = Prisma.AtLeast<
    {
      watchlist_item_id?: number;
      AND?: watchlist_itemsWhereInput | watchlist_itemsWhereInput[];
      OR?: watchlist_itemsWhereInput[];
      NOT?: watchlist_itemsWhereInput | watchlist_itemsWhereInput[];
      watchlist_id?: IntNullableFilter<'watchlist_items'> | number | null;
      symbol?: StringNullableFilter<'watchlist_items'> | string | null;
      name?: StringNullableFilter<'watchlist_items'> | string | null;
      type?: StringNullableFilter<'watchlist_items'> | string | null;
      added_at?:
        | DateTimeNullableFilter<'watchlist_items'>
        | Date
        | string
        | null;
      sequence?: IntNullableFilter<'watchlist_items'> | number | null;
    },
    'watchlist_item_id'
  >;

  export type watchlist_itemsOrderByWithAggregationInput = {
    watchlist_item_id?: SortOrder;
    watchlist_id?: SortOrderInput | SortOrder;
    symbol?: SortOrderInput | SortOrder;
    name?: SortOrderInput | SortOrder;
    type?: SortOrderInput | SortOrder;
    added_at?: SortOrderInput | SortOrder;
    sequence?: SortOrderInput | SortOrder;
    _count?: watchlist_itemsCountOrderByAggregateInput;
    _avg?: watchlist_itemsAvgOrderByAggregateInput;
    _max?: watchlist_itemsMaxOrderByAggregateInput;
    _min?: watchlist_itemsMinOrderByAggregateInput;
    _sum?: watchlist_itemsSumOrderByAggregateInput;
  };

  export type watchlist_itemsScalarWhereWithAggregatesInput = {
    AND?:
      | watchlist_itemsScalarWhereWithAggregatesInput
      | watchlist_itemsScalarWhereWithAggregatesInput[];
    OR?: watchlist_itemsScalarWhereWithAggregatesInput[];
    NOT?:
      | watchlist_itemsScalarWhereWithAggregatesInput
      | watchlist_itemsScalarWhereWithAggregatesInput[];
    watchlist_item_id?: IntWithAggregatesFilter<'watchlist_items'> | number;
    watchlist_id?:
      | IntNullableWithAggregatesFilter<'watchlist_items'>
      | number
      | null;
    symbol?:
      | StringNullableWithAggregatesFilter<'watchlist_items'>
      | string
      | null;
    name?:
      | StringNullableWithAggregatesFilter<'watchlist_items'>
      | string
      | null;
    type?:
      | StringNullableWithAggregatesFilter<'watchlist_items'>
      | string
      | null;
    added_at?:
      | DateTimeNullableWithAggregatesFilter<'watchlist_items'>
      | Date
      | string
      | null;
    sequence?:
      | IntNullableWithAggregatesFilter<'watchlist_items'>
      | number
      | null;
  };

  export type watchlistsWhereInput = {
    AND?: watchlistsWhereInput | watchlistsWhereInput[];
    OR?: watchlistsWhereInput[];
    NOT?: watchlistsWhereInput | watchlistsWhereInput[];
    watchlist_id?: IntFilter<'watchlists'> | number;
    user_id?: IntNullableFilter<'watchlists'> | number | null;
    name?: StringNullableFilter<'watchlists'> | string | null;
    created_at?: DateTimeNullableFilter<'watchlists'> | Date | string | null;
  };

  export type watchlistsOrderByWithRelationInput = {
    watchlist_id?: SortOrder;
    user_id?: SortOrderInput | SortOrder;
    name?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
  };

  export type watchlistsWhereUniqueInput = Prisma.AtLeast<
    {
      watchlist_id?: number;
      AND?: watchlistsWhereInput | watchlistsWhereInput[];
      OR?: watchlistsWhereInput[];
      NOT?: watchlistsWhereInput | watchlistsWhereInput[];
      user_id?: IntNullableFilter<'watchlists'> | number | null;
      name?: StringNullableFilter<'watchlists'> | string | null;
      created_at?: DateTimeNullableFilter<'watchlists'> | Date | string | null;
    },
    'watchlist_id'
  >;

  export type watchlistsOrderByWithAggregationInput = {
    watchlist_id?: SortOrder;
    user_id?: SortOrderInput | SortOrder;
    name?: SortOrderInput | SortOrder;
    created_at?: SortOrderInput | SortOrder;
    _count?: watchlistsCountOrderByAggregateInput;
    _avg?: watchlistsAvgOrderByAggregateInput;
    _max?: watchlistsMaxOrderByAggregateInput;
    _min?: watchlistsMinOrderByAggregateInput;
    _sum?: watchlistsSumOrderByAggregateInput;
  };

  export type watchlistsScalarWhereWithAggregatesInput = {
    AND?:
      | watchlistsScalarWhereWithAggregatesInput
      | watchlistsScalarWhereWithAggregatesInput[];
    OR?: watchlistsScalarWhereWithAggregatesInput[];
    NOT?:
      | watchlistsScalarWhereWithAggregatesInput
      | watchlistsScalarWhereWithAggregatesInput[];
    watchlist_id?: IntWithAggregatesFilter<'watchlists'> | number;
    user_id?: IntNullableWithAggregatesFilter<'watchlists'> | number | null;
    name?: StringNullableWithAggregatesFilter<'watchlists'> | string | null;
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'watchlists'>
      | Date
      | string
      | null;
  };

  export type app_problem_reportCreateInput = {
    id: string;
    topic?: string | null;
    details?: string | null;
    status?: string | null;
    updated_at?: Date | string | null;
    created_at?: Date | string | null;
  };

  export type app_problem_reportUncheckedCreateInput = {
    id: string;
    topic?: string | null;
    details?: string | null;
    status?: string | null;
    updated_at?: Date | string | null;
    created_at?: Date | string | null;
  };

  export type app_problem_reportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type app_problem_reportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type app_problem_reportCreateManyInput = {
    id: string;
    topic?: string | null;
    details?: string | null;
    status?: string | null;
    updated_at?: Date | string | null;
    created_at?: Date | string | null;
  };

  export type app_problem_reportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type app_problem_reportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type app_version_supportCreateInput = {
    version: string;
    platform: string;
    build_number?: number | null;
    status: string;
    min_supported_version?: string | null;
    is_active?: boolean | null;
    critical_update?: boolean | null;
    force_update_message?: string | null;
    release_notes?: string | null;
    download_url?: string | null;
    release_date?: Date | string | null;
    deprecation_date?: Date | string | null;
    end_of_support_date?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type app_version_supportUncheckedCreateInput = {
    id?: number;
    version: string;
    platform: string;
    build_number?: number | null;
    status: string;
    min_supported_version?: string | null;
    is_active?: boolean | null;
    critical_update?: boolean | null;
    force_update_message?: string | null;
    release_notes?: string | null;
    download_url?: string | null;
    release_date?: Date | string | null;
    deprecation_date?: Date | string | null;
    end_of_support_date?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type app_version_supportUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string;
    platform?: StringFieldUpdateOperationsInput | string;
    build_number?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: StringFieldUpdateOperationsInput | string;
    min_supported_version?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    critical_update?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    force_update_message?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    release_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    download_url?: NullableStringFieldUpdateOperationsInput | string | null;
    release_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    deprecation_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_of_support_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type app_version_supportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    version?: StringFieldUpdateOperationsInput | string;
    platform?: StringFieldUpdateOperationsInput | string;
    build_number?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: StringFieldUpdateOperationsInput | string;
    min_supported_version?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    critical_update?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    force_update_message?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    release_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    download_url?: NullableStringFieldUpdateOperationsInput | string | null;
    release_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    deprecation_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_of_support_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type app_version_supportCreateManyInput = {
    id?: number;
    version: string;
    platform: string;
    build_number?: number | null;
    status: string;
    min_supported_version?: string | null;
    is_active?: boolean | null;
    critical_update?: boolean | null;
    force_update_message?: string | null;
    release_notes?: string | null;
    download_url?: string | null;
    release_date?: Date | string | null;
    deprecation_date?: Date | string | null;
    end_of_support_date?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type app_version_supportUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string;
    platform?: StringFieldUpdateOperationsInput | string;
    build_number?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: StringFieldUpdateOperationsInput | string;
    min_supported_version?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    critical_update?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    force_update_message?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    release_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    download_url?: NullableStringFieldUpdateOperationsInput | string | null;
    release_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    deprecation_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_of_support_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type app_version_supportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    version?: StringFieldUpdateOperationsInput | string;
    platform?: StringFieldUpdateOperationsInput | string;
    build_number?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: StringFieldUpdateOperationsInput | string;
    min_supported_version?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    critical_update?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    force_update_message?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    release_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    download_url?: NullableStringFieldUpdateOperationsInput | string | null;
    release_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    deprecation_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_of_support_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type commentsCreateInput = {
    symbol: string;
    content: string;
    user_id: number;
    likes?: number | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    comments?: commentsCreateNestedOneWithoutOther_commentsInput;
    other_comments?: commentsCreateNestedManyWithoutCommentsInput;
  };

  export type commentsUncheckedCreateInput = {
    id?: number;
    symbol: string;
    content: string;
    user_id: number;
    parent_id?: number | null;
    likes?: number | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    other_comments?: commentsUncheckedCreateNestedManyWithoutCommentsInput;
  };

  export type commentsUpdateInput = {
    symbol?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    likes?: NullableIntFieldUpdateOperationsInput | number | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    comments?: commentsUpdateOneWithoutOther_commentsNestedInput;
    other_comments?: commentsUpdateManyWithoutCommentsNestedInput;
  };

  export type commentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null;
    likes?: NullableIntFieldUpdateOperationsInput | number | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    other_comments?: commentsUncheckedUpdateManyWithoutCommentsNestedInput;
  };

  export type commentsCreateManyInput = {
    id?: number;
    symbol: string;
    content: string;
    user_id: number;
    parent_id?: number | null;
    likes?: number | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type commentsUpdateManyMutationInput = {
    symbol?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    likes?: NullableIntFieldUpdateOperationsInput | number | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type commentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null;
    likes?: NullableIntFieldUpdateOperationsInput | number | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type in_app_announcementsCreateInput = {
    type: string;
    display_type: string;
    title_en: string;
    title_th: string;
    message_en: string;
    message_th: string;
    button_text_en?: string | null;
    button_text_th?: string | null;
    action_type?: string | null;
    action_value?: string | null;
    platform?: string | null;
    min_app_version?: string | null;
    max_app_version?: string | null;
    start_at?: Date | string | null;
    end_at?: Date | string | null;
    priority?: number | null;
    is_active?: boolean | null;
    dismissible?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type in_app_announcementsUncheckedCreateInput = {
    id?: number;
    type: string;
    display_type: string;
    title_en: string;
    title_th: string;
    message_en: string;
    message_th: string;
    button_text_en?: string | null;
    button_text_th?: string | null;
    action_type?: string | null;
    action_value?: string | null;
    platform?: string | null;
    min_app_version?: string | null;
    max_app_version?: string | null;
    start_at?: Date | string | null;
    end_at?: Date | string | null;
    priority?: number | null;
    is_active?: boolean | null;
    dismissible?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type in_app_announcementsUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string;
    display_type?: StringFieldUpdateOperationsInput | string;
    title_en?: StringFieldUpdateOperationsInput | string;
    title_th?: StringFieldUpdateOperationsInput | string;
    message_en?: StringFieldUpdateOperationsInput | string;
    message_th?: StringFieldUpdateOperationsInput | string;
    button_text_en?: NullableStringFieldUpdateOperationsInput | string | null;
    button_text_th?: NullableStringFieldUpdateOperationsInput | string | null;
    action_type?: NullableStringFieldUpdateOperationsInput | string | null;
    action_value?: NullableStringFieldUpdateOperationsInput | string | null;
    platform?: NullableStringFieldUpdateOperationsInput | string | null;
    min_app_version?: NullableStringFieldUpdateOperationsInput | string | null;
    max_app_version?: NullableStringFieldUpdateOperationsInput | string | null;
    start_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    priority?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    dismissible?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type in_app_announcementsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    display_type?: StringFieldUpdateOperationsInput | string;
    title_en?: StringFieldUpdateOperationsInput | string;
    title_th?: StringFieldUpdateOperationsInput | string;
    message_en?: StringFieldUpdateOperationsInput | string;
    message_th?: StringFieldUpdateOperationsInput | string;
    button_text_en?: NullableStringFieldUpdateOperationsInput | string | null;
    button_text_th?: NullableStringFieldUpdateOperationsInput | string | null;
    action_type?: NullableStringFieldUpdateOperationsInput | string | null;
    action_value?: NullableStringFieldUpdateOperationsInput | string | null;
    platform?: NullableStringFieldUpdateOperationsInput | string | null;
    min_app_version?: NullableStringFieldUpdateOperationsInput | string | null;
    max_app_version?: NullableStringFieldUpdateOperationsInput | string | null;
    start_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    priority?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    dismissible?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type in_app_announcementsCreateManyInput = {
    id?: number;
    type: string;
    display_type: string;
    title_en: string;
    title_th: string;
    message_en: string;
    message_th: string;
    button_text_en?: string | null;
    button_text_th?: string | null;
    action_type?: string | null;
    action_value?: string | null;
    platform?: string | null;
    min_app_version?: string | null;
    max_app_version?: string | null;
    start_at?: Date | string | null;
    end_at?: Date | string | null;
    priority?: number | null;
    is_active?: boolean | null;
    dismissible?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type in_app_announcementsUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string;
    display_type?: StringFieldUpdateOperationsInput | string;
    title_en?: StringFieldUpdateOperationsInput | string;
    title_th?: StringFieldUpdateOperationsInput | string;
    message_en?: StringFieldUpdateOperationsInput | string;
    message_th?: StringFieldUpdateOperationsInput | string;
    button_text_en?: NullableStringFieldUpdateOperationsInput | string | null;
    button_text_th?: NullableStringFieldUpdateOperationsInput | string | null;
    action_type?: NullableStringFieldUpdateOperationsInput | string | null;
    action_value?: NullableStringFieldUpdateOperationsInput | string | null;
    platform?: NullableStringFieldUpdateOperationsInput | string | null;
    min_app_version?: NullableStringFieldUpdateOperationsInput | string | null;
    max_app_version?: NullableStringFieldUpdateOperationsInput | string | null;
    start_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    priority?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    dismissible?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type in_app_announcementsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    display_type?: StringFieldUpdateOperationsInput | string;
    title_en?: StringFieldUpdateOperationsInput | string;
    title_th?: StringFieldUpdateOperationsInput | string;
    message_en?: StringFieldUpdateOperationsInput | string;
    message_th?: StringFieldUpdateOperationsInput | string;
    button_text_en?: NullableStringFieldUpdateOperationsInput | string | null;
    button_text_th?: NullableStringFieldUpdateOperationsInput | string | null;
    action_type?: NullableStringFieldUpdateOperationsInput | string | null;
    action_value?: NullableStringFieldUpdateOperationsInput | string | null;
    platform?: NullableStringFieldUpdateOperationsInput | string | null;
    min_app_version?: NullableStringFieldUpdateOperationsInput | string | null;
    max_app_version?: NullableStringFieldUpdateOperationsInput | string | null;
    start_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    priority?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    dismissible?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type investment_insightsCreateInput = {
    symbol: string;
    name: string;
    type: string;
    reason: string;
    recommendation: string;
    analysis: string;
    created_at?: Date | string | null;
    reason_th?: string | null;
    analysis_th?: string | null;
    thesis_en?: string | null;
    takeaway_en?: string | null;
    thesis_th?: string | null;
    takeaway_th?: string | null;
  };

  export type investment_insightsUncheckedCreateInput = {
    id?: number;
    symbol: string;
    name: string;
    type: string;
    reason: string;
    recommendation: string;
    analysis: string;
    created_at?: Date | string | null;
    reason_th?: string | null;
    analysis_th?: string | null;
    thesis_en?: string | null;
    takeaway_en?: string | null;
    thesis_th?: string | null;
    takeaway_th?: string | null;
  };

  export type investment_insightsUpdateInput = {
    symbol?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    recommendation?: StringFieldUpdateOperationsInput | string;
    analysis?: StringFieldUpdateOperationsInput | string;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    reason_th?: NullableStringFieldUpdateOperationsInput | string | null;
    analysis_th?: NullableStringFieldUpdateOperationsInput | string | null;
    thesis_en?: NullableStringFieldUpdateOperationsInput | string | null;
    takeaway_en?: NullableStringFieldUpdateOperationsInput | string | null;
    thesis_th?: NullableStringFieldUpdateOperationsInput | string | null;
    takeaway_th?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type investment_insightsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    recommendation?: StringFieldUpdateOperationsInput | string;
    analysis?: StringFieldUpdateOperationsInput | string;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    reason_th?: NullableStringFieldUpdateOperationsInput | string | null;
    analysis_th?: NullableStringFieldUpdateOperationsInput | string | null;
    thesis_en?: NullableStringFieldUpdateOperationsInput | string | null;
    takeaway_en?: NullableStringFieldUpdateOperationsInput | string | null;
    thesis_th?: NullableStringFieldUpdateOperationsInput | string | null;
    takeaway_th?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type investment_insightsCreateManyInput = {
    id?: number;
    symbol: string;
    name: string;
    type: string;
    reason: string;
    recommendation: string;
    analysis: string;
    created_at?: Date | string | null;
    reason_th?: string | null;
    analysis_th?: string | null;
    thesis_en?: string | null;
    takeaway_en?: string | null;
    thesis_th?: string | null;
    takeaway_th?: string | null;
  };

  export type investment_insightsUpdateManyMutationInput = {
    symbol?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    recommendation?: StringFieldUpdateOperationsInput | string;
    analysis?: StringFieldUpdateOperationsInput | string;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    reason_th?: NullableStringFieldUpdateOperationsInput | string | null;
    analysis_th?: NullableStringFieldUpdateOperationsInput | string | null;
    thesis_en?: NullableStringFieldUpdateOperationsInput | string | null;
    takeaway_en?: NullableStringFieldUpdateOperationsInput | string | null;
    thesis_th?: NullableStringFieldUpdateOperationsInput | string | null;
    takeaway_th?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type investment_insightsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    recommendation?: StringFieldUpdateOperationsInput | string;
    analysis?: StringFieldUpdateOperationsInput | string;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    reason_th?: NullableStringFieldUpdateOperationsInput | string | null;
    analysis_th?: NullableStringFieldUpdateOperationsInput | string | null;
    thesis_en?: NullableStringFieldUpdateOperationsInput | string | null;
    takeaway_en?: NullableStringFieldUpdateOperationsInput | string | null;
    thesis_th?: NullableStringFieldUpdateOperationsInput | string | null;
    takeaway_th?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type market_recapCreateInput = {
    stock_market_recap_en?: string | null;
    stock_market_recap_th?: string | null;
    sector_performance_en?: string | null;
    sector_performance_th?: string | null;
    economic_data_and_potential_concerns_en?: string | null;
    economic_data_and_potential_concerns_th?: string | null;
    other_market_activity_en?: string | null;
    other_market_activity_th?: string | null;
    summary_en?: string | null;
    summary_th?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type market_recapUncheckedCreateInput = {
    stock_market_recap_en?: string | null;
    stock_market_recap_th?: string | null;
    sector_performance_en?: string | null;
    sector_performance_th?: string | null;
    economic_data_and_potential_concerns_en?: string | null;
    economic_data_and_potential_concerns_th?: string | null;
    other_market_activity_en?: string | null;
    other_market_activity_th?: string | null;
    summary_en?: string | null;
    summary_th?: string | null;
    id?: number;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type market_recapUpdateInput = {
    stock_market_recap_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    stock_market_recap_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    sector_performance_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    sector_performance_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    economic_data_and_potential_concerns_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    economic_data_and_potential_concerns_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    other_market_activity_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    other_market_activity_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    summary_en?: NullableStringFieldUpdateOperationsInput | string | null;
    summary_th?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type market_recapUncheckedUpdateInput = {
    stock_market_recap_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    stock_market_recap_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    sector_performance_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    sector_performance_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    economic_data_and_potential_concerns_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    economic_data_and_potential_concerns_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    other_market_activity_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    other_market_activity_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    summary_en?: NullableStringFieldUpdateOperationsInput | string | null;
    summary_th?: NullableStringFieldUpdateOperationsInput | string | null;
    id?: IntFieldUpdateOperationsInput | number;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type market_recapCreateManyInput = {
    stock_market_recap_en?: string | null;
    stock_market_recap_th?: string | null;
    sector_performance_en?: string | null;
    sector_performance_th?: string | null;
    economic_data_and_potential_concerns_en?: string | null;
    economic_data_and_potential_concerns_th?: string | null;
    other_market_activity_en?: string | null;
    other_market_activity_th?: string | null;
    summary_en?: string | null;
    summary_th?: string | null;
    id?: number;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type market_recapUpdateManyMutationInput = {
    stock_market_recap_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    stock_market_recap_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    sector_performance_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    sector_performance_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    economic_data_and_potential_concerns_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    economic_data_and_potential_concerns_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    other_market_activity_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    other_market_activity_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    summary_en?: NullableStringFieldUpdateOperationsInput | string | null;
    summary_th?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type market_recapUncheckedUpdateManyInput = {
    stock_market_recap_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    stock_market_recap_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    sector_performance_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    sector_performance_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    economic_data_and_potential_concerns_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    economic_data_and_potential_concerns_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    other_market_activity_en?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    other_market_activity_th?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    summary_en?: NullableStringFieldUpdateOperationsInput | string | null;
    summary_th?: NullableStringFieldUpdateOperationsInput | string | null;
    id?: IntFieldUpdateOperationsInput | number;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type news_commentsCreateInput = {
    content: string;
    like_count?: number | null;
    reply_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    user_id: number;
    stock_news: stock_newsCreateNestedOneWithoutNews_commentsInput;
    news_comments?: news_commentsCreateNestedOneWithoutOther_news_commentsInput;
    other_news_comments?: news_commentsCreateNestedManyWithoutNews_commentsInput;
  };

  export type news_commentsUncheckedCreateInput = {
    id?: number;
    news_id: string;
    parent_comment_id?: number | null;
    content: string;
    like_count?: number | null;
    reply_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    user_id: number;
    other_news_comments?: news_commentsUncheckedCreateNestedManyWithoutNews_commentsInput;
  };

  export type news_commentsUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    reply_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    user_id?: IntFieldUpdateOperationsInput | number;
    stock_news?: stock_newsUpdateOneRequiredWithoutNews_commentsNestedInput;
    news_comments?: news_commentsUpdateOneWithoutOther_news_commentsNestedInput;
    other_news_comments?: news_commentsUpdateManyWithoutNews_commentsNestedInput;
  };

  export type news_commentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    news_id?: StringFieldUpdateOperationsInput | string;
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null;
    content?: StringFieldUpdateOperationsInput | string;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    reply_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    user_id?: IntFieldUpdateOperationsInput | number;
    other_news_comments?: news_commentsUncheckedUpdateManyWithoutNews_commentsNestedInput;
  };

  export type news_commentsCreateManyInput = {
    id?: number;
    news_id: string;
    parent_comment_id?: number | null;
    content: string;
    like_count?: number | null;
    reply_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    user_id: number;
  };

  export type news_commentsUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    reply_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    user_id?: IntFieldUpdateOperationsInput | number;
  };

  export type news_commentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    news_id?: StringFieldUpdateOperationsInput | string;
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null;
    content?: StringFieldUpdateOperationsInput | string;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    reply_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    user_id?: IntFieldUpdateOperationsInput | number;
  };

  export type news_configCreateInput = {
    name: string;
    value: JsonNullValueInput | InputJsonValue;
  };

  export type news_configUncheckedCreateInput = {
    name: string;
    value: JsonNullValueInput | InputJsonValue;
  };

  export type news_configUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string;
    value?: JsonNullValueInput | InputJsonValue;
  };

  export type news_configUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string;
    value?: JsonNullValueInput | InputJsonValue;
  };

  export type news_configCreateManyInput = {
    name: string;
    value: JsonNullValueInput | InputJsonValue;
  };

  export type news_configUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string;
    value?: JsonNullValueInput | InputJsonValue;
  };

  export type news_configUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string;
    value?: JsonNullValueInput | InputJsonValue;
  };

  export type payment_historyCreateInput = {
    user_subscription_id?: number | null;
    amount: Decimal | DecimalJsLike | number | string;
    currency?: string | null;
    payment_status: string;
    stripe_payment_intent_id?: string | null;
    payment_method_id?: string | null;
    payment_date?: Date | string | null;
    billing_period_start?: Date | string | null;
    billing_period_end?: Date | string | null;
    invoice_url?: string | null;
    error_message?: string | null;
    stripe_invoice_id?: string | null;
  };

  export type payment_historyUncheckedCreateInput = {
    payment_id?: number;
    user_subscription_id?: number | null;
    amount: Decimal | DecimalJsLike | number | string;
    currency?: string | null;
    payment_status: string;
    stripe_payment_intent_id?: string | null;
    payment_method_id?: string | null;
    payment_date?: Date | string | null;
    billing_period_start?: Date | string | null;
    billing_period_end?: Date | string | null;
    invoice_url?: string | null;
    error_message?: string | null;
    stripe_invoice_id?: string | null;
  };

  export type payment_historyUpdateInput = {
    user_subscription_id?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
    payment_status?: StringFieldUpdateOperationsInput | string;
    stripe_payment_intent_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    payment_method_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    payment_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    billing_period_start?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    billing_period_end?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null;
    error_message?: NullableStringFieldUpdateOperationsInput | string | null;
    stripe_invoice_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
  };

  export type payment_historyUncheckedUpdateInput = {
    payment_id?: IntFieldUpdateOperationsInput | number;
    user_subscription_id?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
    payment_status?: StringFieldUpdateOperationsInput | string;
    stripe_payment_intent_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    payment_method_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    payment_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    billing_period_start?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    billing_period_end?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null;
    error_message?: NullableStringFieldUpdateOperationsInput | string | null;
    stripe_invoice_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
  };

  export type payment_historyCreateManyInput = {
    payment_id?: number;
    user_subscription_id?: number | null;
    amount: Decimal | DecimalJsLike | number | string;
    currency?: string | null;
    payment_status: string;
    stripe_payment_intent_id?: string | null;
    payment_method_id?: string | null;
    payment_date?: Date | string | null;
    billing_period_start?: Date | string | null;
    billing_period_end?: Date | string | null;
    invoice_url?: string | null;
    error_message?: string | null;
    stripe_invoice_id?: string | null;
  };

  export type payment_historyUpdateManyMutationInput = {
    user_subscription_id?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
    payment_status?: StringFieldUpdateOperationsInput | string;
    stripe_payment_intent_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    payment_method_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    payment_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    billing_period_start?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    billing_period_end?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null;
    error_message?: NullableStringFieldUpdateOperationsInput | string | null;
    stripe_invoice_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
  };

  export type payment_historyUncheckedUpdateManyInput = {
    payment_id?: IntFieldUpdateOperationsInput | number;
    user_subscription_id?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
    payment_status?: StringFieldUpdateOperationsInput | string;
    stripe_payment_intent_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    payment_method_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    payment_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    billing_period_start?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    billing_period_end?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null;
    error_message?: NullableStringFieldUpdateOperationsInput | string | null;
    stripe_invoice_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
  };

  export type permissionsCreateInput = {
    feature?: string | null;
    is_enabled?: boolean | null;
    limit_access?: string | null;
    subscriptions?: subscriptionsCreateNestedOneWithoutPermissionsInput;
  };

  export type permissionsUncheckedCreateInput = {
    permission_id?: number;
    subscription_id?: number | null;
    feature?: string | null;
    is_enabled?: boolean | null;
    limit_access?: string | null;
  };

  export type permissionsUpdateInput = {
    feature?: NullableStringFieldUpdateOperationsInput | string | null;
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    limit_access?: NullableStringFieldUpdateOperationsInput | string | null;
    subscriptions?: subscriptionsUpdateOneWithoutPermissionsNestedInput;
  };

  export type permissionsUncheckedUpdateInput = {
    permission_id?: IntFieldUpdateOperationsInput | number;
    subscription_id?: NullableIntFieldUpdateOperationsInput | number | null;
    feature?: NullableStringFieldUpdateOperationsInput | string | null;
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    limit_access?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type permissionsCreateManyInput = {
    permission_id?: number;
    subscription_id?: number | null;
    feature?: string | null;
    is_enabled?: boolean | null;
    limit_access?: string | null;
  };

  export type permissionsUpdateManyMutationInput = {
    feature?: NullableStringFieldUpdateOperationsInput | string | null;
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    limit_access?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type permissionsUncheckedUpdateManyInput = {
    permission_id?: IntFieldUpdateOperationsInput | number;
    subscription_id?: NullableIntFieldUpdateOperationsInput | number | null;
    feature?: NullableStringFieldUpdateOperationsInput | string | null;
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    limit_access?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type portfolioCreateInput = {
    user_id: number;
    total_value?: Decimal | DecimalJsLike | number | string | null;
    updated_at?: Date | string | null;
  };

  export type portfolioUncheckedCreateInput = {
    portfolio_id?: number;
    user_id: number;
    total_value?: Decimal | DecimalJsLike | number | string | null;
    updated_at?: Date | string | null;
  };

  export type portfolioUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number;
    total_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type portfolioUncheckedUpdateInput = {
    portfolio_id?: IntFieldUpdateOperationsInput | number;
    user_id?: IntFieldUpdateOperationsInput | number;
    total_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type portfolioCreateManyInput = {
    portfolio_id?: number;
    user_id: number;
    total_value?: Decimal | DecimalJsLike | number | string | null;
    updated_at?: Date | string | null;
  };

  export type portfolioUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number;
    total_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type portfolioUncheckedUpdateManyInput = {
    portfolio_id?: IntFieldUpdateOperationsInput | number;
    user_id?: IntFieldUpdateOperationsInput | number;
    total_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type portfolio_holdingsCreateInput = {
    portfolio_id: number;
    symbol: string;
    total_quantity?: Decimal | DecimalJsLike | number | string | null;
    average_price?: Decimal | DecimalJsLike | number | string | null;
    total_invested?: Decimal | DecimalJsLike | number | string | null;
    updated_at?: Date | string | null;
  };

  export type portfolio_holdingsUncheckedCreateInput = {
    id?: number;
    portfolio_id: number;
    symbol: string;
    total_quantity?: Decimal | DecimalJsLike | number | string | null;
    average_price?: Decimal | DecimalJsLike | number | string | null;
    total_invested?: Decimal | DecimalJsLike | number | string | null;
    updated_at?: Date | string | null;
  };

  export type portfolio_holdingsUpdateInput = {
    portfolio_id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    total_quantity?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    average_price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    total_invested?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type portfolio_holdingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    portfolio_id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    total_quantity?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    average_price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    total_invested?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type portfolio_holdingsCreateManyInput = {
    id?: number;
    portfolio_id: number;
    symbol: string;
    total_quantity?: Decimal | DecimalJsLike | number | string | null;
    average_price?: Decimal | DecimalJsLike | number | string | null;
    total_invested?: Decimal | DecimalJsLike | number | string | null;
    updated_at?: Date | string | null;
  };

  export type portfolio_holdingsUpdateManyMutationInput = {
    portfolio_id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    total_quantity?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    average_price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    total_invested?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type portfolio_holdingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    portfolio_id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    total_quantity?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    average_price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    total_invested?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type portfolio_stocksCreateInput = {
    portfolio_id: number;
    symbol: string;
    type: string;
    quantity: Decimal | DecimalJsLike | number | string;
    price: Decimal | DecimalJsLike | number | string;
    total_amount: Decimal | DecimalJsLike | number | string;
    transaction_date?: Date | string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    currency?: string | null;
  };

  export type portfolio_stocksUncheckedCreateInput = {
    id?: number;
    portfolio_id: number;
    symbol: string;
    type: string;
    quantity: Decimal | DecimalJsLike | number | string;
    price: Decimal | DecimalJsLike | number | string;
    total_amount: Decimal | DecimalJsLike | number | string;
    transaction_date?: Date | string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    currency?: string | null;
  };

  export type portfolio_stocksUpdateInput = {
    portfolio_id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    quantity?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    price?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    total_amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    transaction_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type portfolio_stocksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    portfolio_id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    quantity?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    price?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    total_amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    transaction_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type portfolio_stocksCreateManyInput = {
    id?: number;
    portfolio_id: number;
    symbol: string;
    type: string;
    quantity: Decimal | DecimalJsLike | number | string;
    price: Decimal | DecimalJsLike | number | string;
    total_amount: Decimal | DecimalJsLike | number | string;
    transaction_date?: Date | string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    currency?: string | null;
  };

  export type portfolio_stocksUpdateManyMutationInput = {
    portfolio_id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    quantity?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    price?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    total_amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    transaction_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type portfolio_stocksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    portfolio_id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    quantity?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    price?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    total_amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    transaction_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type price_alertsCreateInput = {
    id?: string;
    user_id: number;
    symbol: string;
    asset_type: $Enums.asset_type;
    target_price: Decimal | DecimalJsLike | number | string;
    alert_type: $Enums.alert_type;
    status?: $Enums.alert_status;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    triggered_at?: Date | string | null;
    expires_at?: Date | string | null;
  };

  export type price_alertsUncheckedCreateInput = {
    id?: string;
    user_id: number;
    symbol: string;
    asset_type: $Enums.asset_type;
    target_price: Decimal | DecimalJsLike | number | string;
    alert_type: $Enums.alert_type;
    status?: $Enums.alert_status;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    triggered_at?: Date | string | null;
    expires_at?: Date | string | null;
  };

  export type price_alertsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    asset_type?: Enumasset_typeFieldUpdateOperationsInput | $Enums.asset_type;
    target_price?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    alert_type?: Enumalert_typeFieldUpdateOperationsInput | $Enums.alert_type;
    status?: Enumalert_statusFieldUpdateOperationsInput | $Enums.alert_status;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    triggered_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expires_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type price_alertsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    asset_type?: Enumasset_typeFieldUpdateOperationsInput | $Enums.asset_type;
    target_price?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    alert_type?: Enumalert_typeFieldUpdateOperationsInput | $Enums.alert_type;
    status?: Enumalert_statusFieldUpdateOperationsInput | $Enums.alert_status;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    triggered_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expires_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type price_alertsCreateManyInput = {
    id?: string;
    user_id: number;
    symbol: string;
    asset_type: $Enums.asset_type;
    target_price: Decimal | DecimalJsLike | number | string;
    alert_type: $Enums.alert_type;
    status?: $Enums.alert_status;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    triggered_at?: Date | string | null;
    expires_at?: Date | string | null;
  };

  export type price_alertsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    asset_type?: Enumasset_typeFieldUpdateOperationsInput | $Enums.asset_type;
    target_price?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    alert_type?: Enumalert_typeFieldUpdateOperationsInput | $Enums.alert_type;
    status?: Enumalert_statusFieldUpdateOperationsInput | $Enums.alert_status;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    triggered_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expires_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type price_alertsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    asset_type?: Enumasset_typeFieldUpdateOperationsInput | $Enums.asset_type;
    target_price?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    alert_type?: Enumalert_typeFieldUpdateOperationsInput | $Enums.alert_type;
    status?: Enumalert_statusFieldUpdateOperationsInput | $Enums.alert_status;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    triggered_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expires_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type promotion_articlesCreateInput = {
    image_banner_dark?: string | null;
    image_banner_white?: string | null;
    title_th?: string | null;
    title_en?: string | null;
    description_th?: string | null;
    description_en?: string | null;
    content_th?: string | null;
    content_en?: string | null;
    button_text_th?: string | null;
    button_text_en?: string | null;
    path?: string | null;
    type?: string | null;
  };

  export type promotion_articlesUncheckedCreateInput = {
    image_banner_dark?: string | null;
    image_banner_white?: string | null;
    title_th?: string | null;
    title_en?: string | null;
    description_th?: string | null;
    description_en?: string | null;
    content_th?: string | null;
    content_en?: string | null;
    button_text_th?: string | null;
    button_text_en?: string | null;
    path?: string | null;
    type?: string | null;
    id?: number;
  };

  export type promotion_articlesUpdateInput = {
    image_banner_dark?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    image_banner_white?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title_th?: NullableStringFieldUpdateOperationsInput | string | null;
    title_en?: NullableStringFieldUpdateOperationsInput | string | null;
    description_th?: NullableStringFieldUpdateOperationsInput | string | null;
    description_en?: NullableStringFieldUpdateOperationsInput | string | null;
    content_th?: NullableStringFieldUpdateOperationsInput | string | null;
    content_en?: NullableStringFieldUpdateOperationsInput | string | null;
    button_text_th?: NullableStringFieldUpdateOperationsInput | string | null;
    button_text_en?: NullableStringFieldUpdateOperationsInput | string | null;
    path?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type promotion_articlesUncheckedUpdateInput = {
    image_banner_dark?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    image_banner_white?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title_th?: NullableStringFieldUpdateOperationsInput | string | null;
    title_en?: NullableStringFieldUpdateOperationsInput | string | null;
    description_th?: NullableStringFieldUpdateOperationsInput | string | null;
    description_en?: NullableStringFieldUpdateOperationsInput | string | null;
    content_th?: NullableStringFieldUpdateOperationsInput | string | null;
    content_en?: NullableStringFieldUpdateOperationsInput | string | null;
    button_text_th?: NullableStringFieldUpdateOperationsInput | string | null;
    button_text_en?: NullableStringFieldUpdateOperationsInput | string | null;
    path?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    id?: IntFieldUpdateOperationsInput | number;
  };

  export type promotion_articlesCreateManyInput = {
    image_banner_dark?: string | null;
    image_banner_white?: string | null;
    title_th?: string | null;
    title_en?: string | null;
    description_th?: string | null;
    description_en?: string | null;
    content_th?: string | null;
    content_en?: string | null;
    button_text_th?: string | null;
    button_text_en?: string | null;
    path?: string | null;
    type?: string | null;
    id?: number;
  };

  export type promotion_articlesUpdateManyMutationInput = {
    image_banner_dark?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    image_banner_white?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title_th?: NullableStringFieldUpdateOperationsInput | string | null;
    title_en?: NullableStringFieldUpdateOperationsInput | string | null;
    description_th?: NullableStringFieldUpdateOperationsInput | string | null;
    description_en?: NullableStringFieldUpdateOperationsInput | string | null;
    content_th?: NullableStringFieldUpdateOperationsInput | string | null;
    content_en?: NullableStringFieldUpdateOperationsInput | string | null;
    button_text_th?: NullableStringFieldUpdateOperationsInput | string | null;
    button_text_en?: NullableStringFieldUpdateOperationsInput | string | null;
    path?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type promotion_articlesUncheckedUpdateManyInput = {
    image_banner_dark?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    image_banner_white?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title_th?: NullableStringFieldUpdateOperationsInput | string | null;
    title_en?: NullableStringFieldUpdateOperationsInput | string | null;
    description_th?: NullableStringFieldUpdateOperationsInput | string | null;
    description_en?: NullableStringFieldUpdateOperationsInput | string | null;
    content_th?: NullableStringFieldUpdateOperationsInput | string | null;
    content_en?: NullableStringFieldUpdateOperationsInput | string | null;
    button_text_th?: NullableStringFieldUpdateOperationsInput | string | null;
    button_text_en?: NullableStringFieldUpdateOperationsInput | string | null;
    path?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    id?: IntFieldUpdateOperationsInput | number;
  };

  export type stock_newsCreateInput = {
    id?: string;
    symbol: string;
    exchange?: string | null;
    title: string;
    content?: string | null;
    summary?: string | null;
    image_url?: string | null;
    source_url?: string | null;
    publisher?: string | null;
    published_date: Date | string;
    language?: string | null;
    view_count?: number | null;
    is_featured?: boolean | null;
    is_hot?: boolean | null;
    tags?: stock_newsCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: number | null;
    share_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    news_comments?: news_commentsCreateNestedManyWithoutStock_newsInput;
    stock_news_read_history?: stock_news_read_historyCreateNestedManyWithoutStock_newsInput;
    stock_news_related_symbols?: stock_news_related_symbolsCreateNestedManyWithoutStock_newsInput;
    stock_news_translation?: stock_news_translationCreateNestedManyWithoutStock_newsInput;
  };

  export type stock_newsUncheckedCreateInput = {
    id?: string;
    symbol: string;
    exchange?: string | null;
    title: string;
    content?: string | null;
    summary?: string | null;
    image_url?: string | null;
    source_url?: string | null;
    publisher?: string | null;
    published_date: Date | string;
    language?: string | null;
    view_count?: number | null;
    is_featured?: boolean | null;
    is_hot?: boolean | null;
    tags?: stock_newsCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: number | null;
    share_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    news_comments?: news_commentsUncheckedCreateNestedManyWithoutStock_newsInput;
    stock_news_read_history?: stock_news_read_historyUncheckedCreateNestedManyWithoutStock_newsInput;
    stock_news_related_symbols?: stock_news_related_symbolsUncheckedCreateNestedManyWithoutStock_newsInput;
    stock_news_translation?: stock_news_translationUncheckedCreateNestedManyWithoutStock_newsInput;
  };

  export type stock_newsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    image_url?: NullableStringFieldUpdateOperationsInput | string | null;
    source_url?: NullableStringFieldUpdateOperationsInput | string | null;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    view_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_featured?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    is_hot?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    tags?: stock_newsUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    share_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    news_comments?: news_commentsUpdateManyWithoutStock_newsNestedInput;
    stock_news_read_history?: stock_news_read_historyUpdateManyWithoutStock_newsNestedInput;
    stock_news_related_symbols?: stock_news_related_symbolsUpdateManyWithoutStock_newsNestedInput;
    stock_news_translation?: stock_news_translationUpdateManyWithoutStock_newsNestedInput;
  };

  export type stock_newsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    image_url?: NullableStringFieldUpdateOperationsInput | string | null;
    source_url?: NullableStringFieldUpdateOperationsInput | string | null;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    view_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_featured?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    is_hot?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    tags?: stock_newsUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    share_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    news_comments?: news_commentsUncheckedUpdateManyWithoutStock_newsNestedInput;
    stock_news_read_history?: stock_news_read_historyUncheckedUpdateManyWithoutStock_newsNestedInput;
    stock_news_related_symbols?: stock_news_related_symbolsUncheckedUpdateManyWithoutStock_newsNestedInput;
    stock_news_translation?: stock_news_translationUncheckedUpdateManyWithoutStock_newsNestedInput;
  };

  export type stock_newsCreateManyInput = {
    id?: string;
    symbol: string;
    exchange?: string | null;
    title: string;
    content?: string | null;
    summary?: string | null;
    image_url?: string | null;
    source_url?: string | null;
    publisher?: string | null;
    published_date: Date | string;
    language?: string | null;
    view_count?: number | null;
    is_featured?: boolean | null;
    is_hot?: boolean | null;
    tags?: stock_newsCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: number | null;
    share_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type stock_newsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    image_url?: NullableStringFieldUpdateOperationsInput | string | null;
    source_url?: NullableStringFieldUpdateOperationsInput | string | null;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    view_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_featured?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    is_hot?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    tags?: stock_newsUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    share_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type stock_newsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    image_url?: NullableStringFieldUpdateOperationsInput | string | null;
    source_url?: NullableStringFieldUpdateOperationsInput | string | null;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    view_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_featured?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    is_hot?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    tags?: stock_newsUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    share_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type stock_news_read_historyCreateInput = {
    id?: string;
    user_id?: string | null;
    session_id?: string | null;
    read_at?: Date | string | null;
    language_read?: string | null;
    read_duration?: number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    stock_news: stock_newsCreateNestedOneWithoutStock_news_read_historyInput;
  };

  export type stock_news_read_historyUncheckedCreateInput = {
    id?: string;
    news_id: string;
    user_id?: string | null;
    session_id?: string | null;
    read_at?: Date | string | null;
    language_read?: string | null;
    read_duration?: number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type stock_news_read_historyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: NullableStringFieldUpdateOperationsInput | string | null;
    session_id?: NullableStringFieldUpdateOperationsInput | string | null;
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    language_read?: NullableStringFieldUpdateOperationsInput | string | null;
    read_duration?: NullableIntFieldUpdateOperationsInput | number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    stock_news?: stock_newsUpdateOneRequiredWithoutStock_news_read_historyNestedInput;
  };

  export type stock_news_read_historyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    news_id?: StringFieldUpdateOperationsInput | string;
    user_id?: NullableStringFieldUpdateOperationsInput | string | null;
    session_id?: NullableStringFieldUpdateOperationsInput | string | null;
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    language_read?: NullableStringFieldUpdateOperationsInput | string | null;
    read_duration?: NullableIntFieldUpdateOperationsInput | number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type stock_news_read_historyCreateManyInput = {
    id?: string;
    news_id: string;
    user_id?: string | null;
    session_id?: string | null;
    read_at?: Date | string | null;
    language_read?: string | null;
    read_duration?: number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type stock_news_read_historyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: NullableStringFieldUpdateOperationsInput | string | null;
    session_id?: NullableStringFieldUpdateOperationsInput | string | null;
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    language_read?: NullableStringFieldUpdateOperationsInput | string | null;
    read_duration?: NullableIntFieldUpdateOperationsInput | number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type stock_news_read_historyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    news_id?: StringFieldUpdateOperationsInput | string;
    user_id?: NullableStringFieldUpdateOperationsInput | string | null;
    session_id?: NullableStringFieldUpdateOperationsInput | string | null;
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    language_read?: NullableStringFieldUpdateOperationsInput | string | null;
    read_duration?: NullableIntFieldUpdateOperationsInput | number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type stock_news_related_symbolsCreateInput = {
    id?: string;
    related_symbol: string;
    related_exchange?: string | null;
    is_primary?: boolean | null;
    stock_news: stock_newsCreateNestedOneWithoutStock_news_related_symbolsInput;
  };

  export type stock_news_related_symbolsUncheckedCreateInput = {
    id?: string;
    news_id: string;
    related_symbol: string;
    related_exchange?: string | null;
    is_primary?: boolean | null;
  };

  export type stock_news_related_symbolsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    related_symbol?: StringFieldUpdateOperationsInput | string;
    related_exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    stock_news?: stock_newsUpdateOneRequiredWithoutStock_news_related_symbolsNestedInput;
  };

  export type stock_news_related_symbolsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    news_id?: StringFieldUpdateOperationsInput | string;
    related_symbol?: StringFieldUpdateOperationsInput | string;
    related_exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null;
  };

  export type stock_news_related_symbolsCreateManyInput = {
    id?: string;
    news_id: string;
    related_symbol: string;
    related_exchange?: string | null;
    is_primary?: boolean | null;
  };

  export type stock_news_related_symbolsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    related_symbol?: StringFieldUpdateOperationsInput | string;
    related_exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null;
  };

  export type stock_news_related_symbolsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    news_id?: StringFieldUpdateOperationsInput | string;
    related_symbol?: StringFieldUpdateOperationsInput | string;
    related_exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null;
  };

  export type stock_news_translationCreateInput = {
    id?: string;
    language: string;
    title: string;
    content?: string | null;
    summary?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    stock_news: stock_newsCreateNestedOneWithoutStock_news_translationInput;
  };

  export type stock_news_translationUncheckedCreateInput = {
    id?: string;
    news_id: string;
    language: string;
    title: string;
    content?: string | null;
    summary?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type stock_news_translationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    stock_news?: stock_newsUpdateOneRequiredWithoutStock_news_translationNestedInput;
  };

  export type stock_news_translationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    news_id?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type stock_news_translationCreateManyInput = {
    id?: string;
    news_id: string;
    language: string;
    title: string;
    content?: string | null;
    summary?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type stock_news_translationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type stock_news_translationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    news_id?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type subscriptionsCreateInput = {
    name?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    features?: NullableJsonNullValueInput | InputJsonValue;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    stripe_price_id?: string | null;
    price_amount?: string | null;
    currency?: string | null;
    billing_interval?: string | null;
    is_active?: boolean | null;
    trial_days?: number | null;
    permissions?: permissionsCreateNestedManyWithoutSubscriptionsInput;
    user_subscriptions?: user_subscriptionsCreateNestedManyWithoutSubscriptionsInput;
  };

  export type subscriptionsUncheckedCreateInput = {
    subscription_id?: number;
    name?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    features?: NullableJsonNullValueInput | InputJsonValue;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    stripe_price_id?: string | null;
    price_amount?: string | null;
    currency?: string | null;
    billing_interval?: string | null;
    is_active?: boolean | null;
    trial_days?: number | null;
    permissions?: permissionsUncheckedCreateNestedManyWithoutSubscriptionsInput;
    user_subscriptions?: user_subscriptionsUncheckedCreateNestedManyWithoutSubscriptionsInput;
  };

  export type subscriptionsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    features?: NullableJsonNullValueInput | InputJsonValue;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    stripe_price_id?: NullableStringFieldUpdateOperationsInput | string | null;
    price_amount?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_interval?: NullableStringFieldUpdateOperationsInput | string | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    trial_days?: NullableIntFieldUpdateOperationsInput | number | null;
    permissions?: permissionsUpdateManyWithoutSubscriptionsNestedInput;
    user_subscriptions?: user_subscriptionsUpdateManyWithoutSubscriptionsNestedInput;
  };

  export type subscriptionsUncheckedUpdateInput = {
    subscription_id?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    features?: NullableJsonNullValueInput | InputJsonValue;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    stripe_price_id?: NullableStringFieldUpdateOperationsInput | string | null;
    price_amount?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_interval?: NullableStringFieldUpdateOperationsInput | string | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    trial_days?: NullableIntFieldUpdateOperationsInput | number | null;
    permissions?: permissionsUncheckedUpdateManyWithoutSubscriptionsNestedInput;
    user_subscriptions?: user_subscriptionsUncheckedUpdateManyWithoutSubscriptionsNestedInput;
  };

  export type subscriptionsCreateManyInput = {
    subscription_id?: number;
    name?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    features?: NullableJsonNullValueInput | InputJsonValue;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    stripe_price_id?: string | null;
    price_amount?: string | null;
    currency?: string | null;
    billing_interval?: string | null;
    is_active?: boolean | null;
    trial_days?: number | null;
  };

  export type subscriptionsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    features?: NullableJsonNullValueInput | InputJsonValue;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    stripe_price_id?: NullableStringFieldUpdateOperationsInput | string | null;
    price_amount?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_interval?: NullableStringFieldUpdateOperationsInput | string | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    trial_days?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type subscriptionsUncheckedUpdateManyInput = {
    subscription_id?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    features?: NullableJsonNullValueInput | InputJsonValue;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    stripe_price_id?: NullableStringFieldUpdateOperationsInput | string | null;
    price_amount?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_interval?: NullableStringFieldUpdateOperationsInput | string | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    trial_days?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type superinvestor_holdingsCreateInput = {
    manager_name?: string | null;
    portfolio_value_raw?: string | null;
    number_of_stocks?: number | null;
    manager_link?: string | null;
    image?: string | null;
    information_en?: string | null;
    information_th?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    portfolio_value?: Decimal | DecimalJsLike | number | string | null;
    superinvestor_holdings_list?: superinvestor_holdings_listCreateNestedManyWithoutSuperinvestor_holdingsInput;
    superinvestor_sector_analysis?: superinvestor_sector_analysisCreateNestedManyWithoutSuperinvestor_holdingsInput;
  };

  export type superinvestor_holdingsUncheckedCreateInput = {
    id?: number;
    manager_name?: string | null;
    portfolio_value_raw?: string | null;
    number_of_stocks?: number | null;
    manager_link?: string | null;
    image?: string | null;
    information_en?: string | null;
    information_th?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    portfolio_value?: Decimal | DecimalJsLike | number | string | null;
    superinvestor_holdings_list?: superinvestor_holdings_listUncheckedCreateNestedManyWithoutSuperinvestor_holdingsInput;
    superinvestor_sector_analysis?: superinvestor_sector_analysisUncheckedCreateNestedManyWithoutSuperinvestor_holdingsInput;
  };

  export type superinvestor_holdingsUpdateInput = {
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null;
    portfolio_value_raw?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    number_of_stocks?: NullableIntFieldUpdateOperationsInput | number | null;
    manager_link?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    information_en?: NullableStringFieldUpdateOperationsInput | string | null;
    information_th?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    portfolio_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    superinvestor_holdings_list?: superinvestor_holdings_listUpdateManyWithoutSuperinvestor_holdingsNestedInput;
    superinvestor_sector_analysis?: superinvestor_sector_analysisUpdateManyWithoutSuperinvestor_holdingsNestedInput;
  };

  export type superinvestor_holdingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null;
    portfolio_value_raw?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    number_of_stocks?: NullableIntFieldUpdateOperationsInput | number | null;
    manager_link?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    information_en?: NullableStringFieldUpdateOperationsInput | string | null;
    information_th?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    portfolio_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    superinvestor_holdings_list?: superinvestor_holdings_listUncheckedUpdateManyWithoutSuperinvestor_holdingsNestedInput;
    superinvestor_sector_analysis?: superinvestor_sector_analysisUncheckedUpdateManyWithoutSuperinvestor_holdingsNestedInput;
  };

  export type superinvestor_holdingsCreateManyInput = {
    id?: number;
    manager_name?: string | null;
    portfolio_value_raw?: string | null;
    number_of_stocks?: number | null;
    manager_link?: string | null;
    image?: string | null;
    information_en?: string | null;
    information_th?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    portfolio_value?: Decimal | DecimalJsLike | number | string | null;
  };

  export type superinvestor_holdingsUpdateManyMutationInput = {
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null;
    portfolio_value_raw?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    number_of_stocks?: NullableIntFieldUpdateOperationsInput | number | null;
    manager_link?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    information_en?: NullableStringFieldUpdateOperationsInput | string | null;
    information_th?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    portfolio_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type superinvestor_holdingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null;
    portfolio_value_raw?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    number_of_stocks?: NullableIntFieldUpdateOperationsInput | number | null;
    manager_link?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    information_en?: NullableStringFieldUpdateOperationsInput | string | null;
    information_th?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    portfolio_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type superinvestor_holdings_listCreateInput = {
    symbol?: string | null;
    percentage_of_portfolio?: Decimal | DecimalJsLike | number | string | null;
    recent_activity?: string | null;
    share_raw?: string | null;
    share_value?: Decimal | DecimalJsLike | number | string | null;
    reported_price_raw?: string | null;
    reported_price_value?: Decimal | DecimalJsLike | number | string | null;
    value_raw?: string | null;
    value?: Decimal | DecimalJsLike | number | string | null;
    superinvestor_holdings?: superinvestor_holdingsCreateNestedOneWithoutSuperinvestor_holdings_listInput;
  };

  export type superinvestor_holdings_listUncheckedCreateInput = {
    id?: number;
    manager_id?: number | null;
    symbol?: string | null;
    percentage_of_portfolio?: Decimal | DecimalJsLike | number | string | null;
    recent_activity?: string | null;
    share_raw?: string | null;
    share_value?: Decimal | DecimalJsLike | number | string | null;
    reported_price_raw?: string | null;
    reported_price_value?: Decimal | DecimalJsLike | number | string | null;
    value_raw?: string | null;
    value?: Decimal | DecimalJsLike | number | string | null;
  };

  export type superinvestor_holdings_listUpdateInput = {
    symbol?: NullableStringFieldUpdateOperationsInput | string | null;
    percentage_of_portfolio?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    recent_activity?: NullableStringFieldUpdateOperationsInput | string | null;
    share_raw?: NullableStringFieldUpdateOperationsInput | string | null;
    share_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    reported_price_raw?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    reported_price_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    value_raw?: NullableStringFieldUpdateOperationsInput | string | null;
    value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    superinvestor_holdings?: superinvestor_holdingsUpdateOneWithoutSuperinvestor_holdings_listNestedInput;
  };

  export type superinvestor_holdings_listUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null;
    symbol?: NullableStringFieldUpdateOperationsInput | string | null;
    percentage_of_portfolio?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    recent_activity?: NullableStringFieldUpdateOperationsInput | string | null;
    share_raw?: NullableStringFieldUpdateOperationsInput | string | null;
    share_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    reported_price_raw?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    reported_price_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    value_raw?: NullableStringFieldUpdateOperationsInput | string | null;
    value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type superinvestor_holdings_listCreateManyInput = {
    id?: number;
    manager_id?: number | null;
    symbol?: string | null;
    percentage_of_portfolio?: Decimal | DecimalJsLike | number | string | null;
    recent_activity?: string | null;
    share_raw?: string | null;
    share_value?: Decimal | DecimalJsLike | number | string | null;
    reported_price_raw?: string | null;
    reported_price_value?: Decimal | DecimalJsLike | number | string | null;
    value_raw?: string | null;
    value?: Decimal | DecimalJsLike | number | string | null;
  };

  export type superinvestor_holdings_listUpdateManyMutationInput = {
    symbol?: NullableStringFieldUpdateOperationsInput | string | null;
    percentage_of_portfolio?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    recent_activity?: NullableStringFieldUpdateOperationsInput | string | null;
    share_raw?: NullableStringFieldUpdateOperationsInput | string | null;
    share_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    reported_price_raw?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    reported_price_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    value_raw?: NullableStringFieldUpdateOperationsInput | string | null;
    value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type superinvestor_holdings_listUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null;
    symbol?: NullableStringFieldUpdateOperationsInput | string | null;
    percentage_of_portfolio?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    recent_activity?: NullableStringFieldUpdateOperationsInput | string | null;
    share_raw?: NullableStringFieldUpdateOperationsInput | string | null;
    share_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    reported_price_raw?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    reported_price_value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    value_raw?: NullableStringFieldUpdateOperationsInput | string | null;
    value?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type superinvestor_sector_analysisCreateInput = {
    sector_name?: string | null;
    sector_percentage?: Decimal | DecimalJsLike | number | string | null;
    superinvestor_holdings?: superinvestor_holdingsCreateNestedOneWithoutSuperinvestor_sector_analysisInput;
  };

  export type superinvestor_sector_analysisUncheckedCreateInput = {
    id?: number;
    manager_id?: number | null;
    sector_name?: string | null;
    sector_percentage?: Decimal | DecimalJsLike | number | string | null;
  };

  export type superinvestor_sector_analysisUpdateInput = {
    sector_name?: NullableStringFieldUpdateOperationsInput | string | null;
    sector_percentage?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    superinvestor_holdings?: superinvestor_holdingsUpdateOneWithoutSuperinvestor_sector_analysisNestedInput;
  };

  export type superinvestor_sector_analysisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null;
    sector_name?: NullableStringFieldUpdateOperationsInput | string | null;
    sector_percentage?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type superinvestor_sector_analysisCreateManyInput = {
    id?: number;
    manager_id?: number | null;
    sector_name?: string | null;
    sector_percentage?: Decimal | DecimalJsLike | number | string | null;
  };

  export type superinvestor_sector_analysisUpdateManyMutationInput = {
    sector_name?: NullableStringFieldUpdateOperationsInput | string | null;
    sector_percentage?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type superinvestor_sector_analysisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null;
    sector_name?: NullableStringFieldUpdateOperationsInput | string | null;
    sector_percentage?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type symbolCreateInput = {
    id?: string;
    symbol: string;
    company_name?: string | null;
    exchange_short_name?: string | null;
    company_logo?: string | null;
    type?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type symbolUncheckedCreateInput = {
    id?: string;
    symbol: string;
    company_name?: string | null;
    exchange_short_name?: string | null;
    company_logo?: string | null;
    type?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type symbolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    exchange_short_name?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    company_logo?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type symbolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    exchange_short_name?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    company_logo?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type symbolCreateManyInput = {
    id?: string;
    symbol: string;
    company_name?: string | null;
    exchange_short_name?: string | null;
    company_logo?: string | null;
    type?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type symbolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    exchange_short_name?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    company_logo?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type symbolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    exchange_short_name?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    company_logo?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type user_devicesCreateInput = {
    device_id?: string;
    user_id: number;
    platform: string;
    device_token?: string | null;
    last_active_at?: Date | string | null;
    created_at?: Date | string | null;
    app_version?: string | null;
    device_name?: string | null;
  };

  export type user_devicesUncheckedCreateInput = {
    device_id?: string;
    user_id: number;
    platform: string;
    device_token?: string | null;
    last_active_at?: Date | string | null;
    created_at?: Date | string | null;
    app_version?: string | null;
    device_name?: string | null;
  };

  export type user_devicesUpdateInput = {
    device_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    platform?: StringFieldUpdateOperationsInput | string;
    device_token?: NullableStringFieldUpdateOperationsInput | string | null;
    last_active_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    app_version?: NullableStringFieldUpdateOperationsInput | string | null;
    device_name?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type user_devicesUncheckedUpdateInput = {
    device_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    platform?: StringFieldUpdateOperationsInput | string;
    device_token?: NullableStringFieldUpdateOperationsInput | string | null;
    last_active_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    app_version?: NullableStringFieldUpdateOperationsInput | string | null;
    device_name?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type user_devicesCreateManyInput = {
    device_id?: string;
    user_id: number;
    platform: string;
    device_token?: string | null;
    last_active_at?: Date | string | null;
    created_at?: Date | string | null;
    app_version?: string | null;
    device_name?: string | null;
  };

  export type user_devicesUpdateManyMutationInput = {
    device_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    platform?: StringFieldUpdateOperationsInput | string;
    device_token?: NullableStringFieldUpdateOperationsInput | string | null;
    last_active_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    app_version?: NullableStringFieldUpdateOperationsInput | string | null;
    device_name?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type user_devicesUncheckedUpdateManyInput = {
    device_id?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    platform?: StringFieldUpdateOperationsInput | string;
    device_token?: NullableStringFieldUpdateOperationsInput | string | null;
    last_active_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    app_version?: NullableStringFieldUpdateOperationsInput | string | null;
    device_name?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type user_subscriptionsCreateInput = {
    user_id?: number | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    is_active?: boolean | null;
    stripe_subscription_id?: string | null;
    stripe_payment_intent_id?: string | null;
    payment_status?: string | null;
    last_payment_date?: Date | string | null;
    next_billing_date?: Date | string | null;
    cancellation_date?: Date | string | null;
    trial_end_date?: Date | string | null;
    last_payment_attempt_date?: Date | string | null;
    payment_method_id?: string | null;
    redeem_code?: string | null;
    subscriptions?: subscriptionsCreateNestedOneWithoutUser_subscriptionsInput;
  };

  export type user_subscriptionsUncheckedCreateInput = {
    user_subscription_id?: number;
    user_id?: number | null;
    subscription_id?: number | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    is_active?: boolean | null;
    stripe_subscription_id?: string | null;
    stripe_payment_intent_id?: string | null;
    payment_status?: string | null;
    last_payment_date?: Date | string | null;
    next_billing_date?: Date | string | null;
    cancellation_date?: Date | string | null;
    trial_end_date?: Date | string | null;
    last_payment_attempt_date?: Date | string | null;
    payment_method_id?: string | null;
    redeem_code?: string | null;
  };

  export type user_subscriptionsUpdateInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    stripe_subscription_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    stripe_payment_intent_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null;
    last_payment_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    next_billing_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cancellation_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    trial_end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    last_payment_attempt_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    payment_method_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    redeem_code?: NullableStringFieldUpdateOperationsInput | string | null;
    subscriptions?: subscriptionsUpdateOneWithoutUser_subscriptionsNestedInput;
  };

  export type user_subscriptionsUncheckedUpdateInput = {
    user_subscription_id?: IntFieldUpdateOperationsInput | number;
    user_id?: NullableIntFieldUpdateOperationsInput | number | null;
    subscription_id?: NullableIntFieldUpdateOperationsInput | number | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    stripe_subscription_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    stripe_payment_intent_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null;
    last_payment_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    next_billing_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cancellation_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    trial_end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    last_payment_attempt_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    payment_method_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    redeem_code?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type user_subscriptionsCreateManyInput = {
    user_subscription_id?: number;
    user_id?: number | null;
    subscription_id?: number | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    is_active?: boolean | null;
    stripe_subscription_id?: string | null;
    stripe_payment_intent_id?: string | null;
    payment_status?: string | null;
    last_payment_date?: Date | string | null;
    next_billing_date?: Date | string | null;
    cancellation_date?: Date | string | null;
    trial_end_date?: Date | string | null;
    last_payment_attempt_date?: Date | string | null;
    payment_method_id?: string | null;
    redeem_code?: string | null;
  };

  export type user_subscriptionsUpdateManyMutationInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    stripe_subscription_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    stripe_payment_intent_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null;
    last_payment_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    next_billing_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cancellation_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    trial_end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    last_payment_attempt_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    payment_method_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    redeem_code?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type user_subscriptionsUncheckedUpdateManyInput = {
    user_subscription_id?: IntFieldUpdateOperationsInput | number;
    user_id?: NullableIntFieldUpdateOperationsInput | number | null;
    subscription_id?: NullableIntFieldUpdateOperationsInput | number | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    stripe_subscription_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    stripe_payment_intent_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null;
    last_payment_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    next_billing_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cancellation_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    trial_end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    last_payment_attempt_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    payment_method_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    redeem_code?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type usersCreateInput = {
    google_id?: string | null;
    email?: string | null;
    name?: string;
    profile_pic?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    stripe_customer_id?: string | null;
    refresh_token?: string | null;
    has_used_trial?: boolean;
    trial_used_at?: Date | string | null;
    bio?: string | null;
    is_verified?: boolean;
    status_message?: string | null;
    last_login_at?: Date | string | null;
    birthdate?: Date | string | null;
    language_preference?: string;
    theme_preference?: string | null;
    onboarding_completed?: boolean;
    account_status?: string | null;
    active_watchlist_id?: number | null;
    username: string;
    is_private?: boolean;
    apple_id?: string | null;
  };

  export type usersUncheckedCreateInput = {
    user_id?: number;
    google_id?: string | null;
    email?: string | null;
    name?: string;
    profile_pic?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    stripe_customer_id?: string | null;
    refresh_token?: string | null;
    has_used_trial?: boolean;
    trial_used_at?: Date | string | null;
    bio?: string | null;
    is_verified?: boolean;
    status_message?: string | null;
    last_login_at?: Date | string | null;
    birthdate?: Date | string | null;
    language_preference?: string;
    theme_preference?: string | null;
    onboarding_completed?: boolean;
    account_status?: string | null;
    active_watchlist_id?: number | null;
    username: string;
    is_private?: boolean;
    apple_id?: string | null;
  };

  export type usersUpdateInput = {
    google_id?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    profile_pic?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    stripe_customer_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    has_used_trial?: BoolFieldUpdateOperationsInput | boolean;
    trial_used_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    is_verified?: BoolFieldUpdateOperationsInput | boolean;
    status_message?: NullableStringFieldUpdateOperationsInput | string | null;
    last_login_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    birthdate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    language_preference?: StringFieldUpdateOperationsInput | string;
    theme_preference?: NullableStringFieldUpdateOperationsInput | string | null;
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean;
    account_status?: NullableStringFieldUpdateOperationsInput | string | null;
    active_watchlist_id?: NullableIntFieldUpdateOperationsInput | number | null;
    username?: StringFieldUpdateOperationsInput | string;
    is_private?: BoolFieldUpdateOperationsInput | boolean;
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type usersUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number;
    google_id?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    profile_pic?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    stripe_customer_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    has_used_trial?: BoolFieldUpdateOperationsInput | boolean;
    trial_used_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    is_verified?: BoolFieldUpdateOperationsInput | boolean;
    status_message?: NullableStringFieldUpdateOperationsInput | string | null;
    last_login_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    birthdate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    language_preference?: StringFieldUpdateOperationsInput | string;
    theme_preference?: NullableStringFieldUpdateOperationsInput | string | null;
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean;
    account_status?: NullableStringFieldUpdateOperationsInput | string | null;
    active_watchlist_id?: NullableIntFieldUpdateOperationsInput | number | null;
    username?: StringFieldUpdateOperationsInput | string;
    is_private?: BoolFieldUpdateOperationsInput | boolean;
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type usersCreateManyInput = {
    user_id?: number;
    google_id?: string | null;
    email?: string | null;
    name?: string;
    profile_pic?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    stripe_customer_id?: string | null;
    refresh_token?: string | null;
    has_used_trial?: boolean;
    trial_used_at?: Date | string | null;
    bio?: string | null;
    is_verified?: boolean;
    status_message?: string | null;
    last_login_at?: Date | string | null;
    birthdate?: Date | string | null;
    language_preference?: string;
    theme_preference?: string | null;
    onboarding_completed?: boolean;
    account_status?: string | null;
    active_watchlist_id?: number | null;
    username: string;
    is_private?: boolean;
    apple_id?: string | null;
  };

  export type usersUpdateManyMutationInput = {
    google_id?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    profile_pic?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    stripe_customer_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    has_used_trial?: BoolFieldUpdateOperationsInput | boolean;
    trial_used_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    is_verified?: BoolFieldUpdateOperationsInput | boolean;
    status_message?: NullableStringFieldUpdateOperationsInput | string | null;
    last_login_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    birthdate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    language_preference?: StringFieldUpdateOperationsInput | string;
    theme_preference?: NullableStringFieldUpdateOperationsInput | string | null;
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean;
    account_status?: NullableStringFieldUpdateOperationsInput | string | null;
    active_watchlist_id?: NullableIntFieldUpdateOperationsInput | number | null;
    username?: StringFieldUpdateOperationsInput | string;
    is_private?: BoolFieldUpdateOperationsInput | boolean;
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type usersUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number;
    google_id?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    profile_pic?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    stripe_customer_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    has_used_trial?: BoolFieldUpdateOperationsInput | boolean;
    trial_used_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    is_verified?: BoolFieldUpdateOperationsInput | boolean;
    status_message?: NullableStringFieldUpdateOperationsInput | string | null;
    last_login_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    birthdate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    language_preference?: StringFieldUpdateOperationsInput | string;
    theme_preference?: NullableStringFieldUpdateOperationsInput | string | null;
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean;
    account_status?: NullableStringFieldUpdateOperationsInput | string | null;
    active_watchlist_id?: NullableIntFieldUpdateOperationsInput | number | null;
    username?: StringFieldUpdateOperationsInput | string;
    is_private?: BoolFieldUpdateOperationsInput | boolean;
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type watchlist_itemsCreateInput = {
    watchlist_id?: number | null;
    symbol?: string | null;
    name?: string | null;
    type?: string | null;
    added_at?: Date | string | null;
    sequence?: number | null;
  };

  export type watchlist_itemsUncheckedCreateInput = {
    watchlist_item_id?: number;
    watchlist_id?: number | null;
    symbol?: string | null;
    name?: string | null;
    type?: string | null;
    added_at?: Date | string | null;
    sequence?: number | null;
  };

  export type watchlist_itemsUpdateInput = {
    watchlist_id?: NullableIntFieldUpdateOperationsInput | number | null;
    symbol?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    added_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    sequence?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type watchlist_itemsUncheckedUpdateInput = {
    watchlist_item_id?: IntFieldUpdateOperationsInput | number;
    watchlist_id?: NullableIntFieldUpdateOperationsInput | number | null;
    symbol?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    added_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    sequence?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type watchlist_itemsCreateManyInput = {
    watchlist_item_id?: number;
    watchlist_id?: number | null;
    symbol?: string | null;
    name?: string | null;
    type?: string | null;
    added_at?: Date | string | null;
    sequence?: number | null;
  };

  export type watchlist_itemsUpdateManyMutationInput = {
    watchlist_id?: NullableIntFieldUpdateOperationsInput | number | null;
    symbol?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    added_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    sequence?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type watchlist_itemsUncheckedUpdateManyInput = {
    watchlist_item_id?: IntFieldUpdateOperationsInput | number;
    watchlist_id?: NullableIntFieldUpdateOperationsInput | number | null;
    symbol?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    added_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    sequence?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type watchlistsCreateInput = {
    user_id?: number | null;
    name?: string | null;
    created_at?: Date | string | null;
  };

  export type watchlistsUncheckedCreateInput = {
    watchlist_id?: number;
    user_id?: number | null;
    name?: string | null;
    created_at?: Date | string | null;
  };

  export type watchlistsUpdateInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type watchlistsUncheckedUpdateInput = {
    watchlist_id?: IntFieldUpdateOperationsInput | number;
    user_id?: NullableIntFieldUpdateOperationsInput | number | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type watchlistsCreateManyInput = {
    watchlist_id?: number;
    user_id?: number | null;
    name?: string | null;
    created_at?: Date | string | null;
  };

  export type watchlistsUpdateManyMutationInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type watchlistsUncheckedUpdateManyInput = {
    watchlist_id?: IntFieldUpdateOperationsInput | number;
    user_id?: NullableIntFieldUpdateOperationsInput | number | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedUuidFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type app_problem_reportCountOrderByAggregateInput = {
    id?: SortOrder;
    topic?: SortOrder;
    details?: SortOrder;
    status?: SortOrder;
    updated_at?: SortOrder;
    created_at?: SortOrder;
  };

  export type app_problem_reportMaxOrderByAggregateInput = {
    id?: SortOrder;
    topic?: SortOrder;
    details?: SortOrder;
    status?: SortOrder;
    updated_at?: SortOrder;
    created_at?: SortOrder;
  };

  export type app_problem_reportMinOrderByAggregateInput = {
    id?: SortOrder;
    topic?: SortOrder;
    details?: SortOrder;
    status?: SortOrder;
    updated_at?: SortOrder;
    created_at?: SortOrder;
  };

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
      >;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type app_version_supportVersionPlatformCompoundUniqueInput = {
    version: string;
    platform: string;
  };

  export type app_version_supportCountOrderByAggregateInput = {
    id?: SortOrder;
    version?: SortOrder;
    platform?: SortOrder;
    build_number?: SortOrder;
    status?: SortOrder;
    min_supported_version?: SortOrder;
    is_active?: SortOrder;
    critical_update?: SortOrder;
    force_update_message?: SortOrder;
    release_notes?: SortOrder;
    download_url?: SortOrder;
    release_date?: SortOrder;
    deprecation_date?: SortOrder;
    end_of_support_date?: SortOrder;
    metadata?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type app_version_supportAvgOrderByAggregateInput = {
    id?: SortOrder;
    build_number?: SortOrder;
  };

  export type app_version_supportMaxOrderByAggregateInput = {
    id?: SortOrder;
    version?: SortOrder;
    platform?: SortOrder;
    build_number?: SortOrder;
    status?: SortOrder;
    min_supported_version?: SortOrder;
    is_active?: SortOrder;
    critical_update?: SortOrder;
    force_update_message?: SortOrder;
    release_notes?: SortOrder;
    download_url?: SortOrder;
    release_date?: SortOrder;
    deprecation_date?: SortOrder;
    end_of_support_date?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type app_version_supportMinOrderByAggregateInput = {
    id?: SortOrder;
    version?: SortOrder;
    platform?: SortOrder;
    build_number?: SortOrder;
    status?: SortOrder;
    min_supported_version?: SortOrder;
    is_active?: SortOrder;
    critical_update?: SortOrder;
    force_update_message?: SortOrder;
    release_notes?: SortOrder;
    download_url?: SortOrder;
    release_date?: SortOrder;
    deprecation_date?: SortOrder;
    end_of_support_date?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type app_version_supportSumOrderByAggregateInput = {
    id?: SortOrder;
    build_number?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedBoolNullableFilter<$PrismaModel>;
    _max?: NestedBoolNullableFilter<$PrismaModel>;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          'path'
        >
      >;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type CommentsNullableScalarRelationFilter = {
    is?: commentsWhereInput | null;
    isNot?: commentsWhereInput | null;
  };

  export type CommentsListRelationFilter = {
    every?: commentsWhereInput;
    some?: commentsWhereInput;
    none?: commentsWhereInput;
  };

  export type commentsOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type commentsCountOrderByAggregateInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    content?: SortOrder;
    user_id?: SortOrder;
    parent_id?: SortOrder;
    likes?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type commentsAvgOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    parent_id?: SortOrder;
    likes?: SortOrder;
  };

  export type commentsMaxOrderByAggregateInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    content?: SortOrder;
    user_id?: SortOrder;
    parent_id?: SortOrder;
    likes?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type commentsMinOrderByAggregateInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    content?: SortOrder;
    user_id?: SortOrder;
    parent_id?: SortOrder;
    likes?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type commentsSumOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    parent_id?: SortOrder;
    likes?: SortOrder;
  };

  export type in_app_announcementsCountOrderByAggregateInput = {
    id?: SortOrder;
    type?: SortOrder;
    display_type?: SortOrder;
    title_en?: SortOrder;
    title_th?: SortOrder;
    message_en?: SortOrder;
    message_th?: SortOrder;
    button_text_en?: SortOrder;
    button_text_th?: SortOrder;
    action_type?: SortOrder;
    action_value?: SortOrder;
    platform?: SortOrder;
    min_app_version?: SortOrder;
    max_app_version?: SortOrder;
    start_at?: SortOrder;
    end_at?: SortOrder;
    priority?: SortOrder;
    is_active?: SortOrder;
    dismissible?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type in_app_announcementsAvgOrderByAggregateInput = {
    id?: SortOrder;
    priority?: SortOrder;
  };

  export type in_app_announcementsMaxOrderByAggregateInput = {
    id?: SortOrder;
    type?: SortOrder;
    display_type?: SortOrder;
    title_en?: SortOrder;
    title_th?: SortOrder;
    message_en?: SortOrder;
    message_th?: SortOrder;
    button_text_en?: SortOrder;
    button_text_th?: SortOrder;
    action_type?: SortOrder;
    action_value?: SortOrder;
    platform?: SortOrder;
    min_app_version?: SortOrder;
    max_app_version?: SortOrder;
    start_at?: SortOrder;
    end_at?: SortOrder;
    priority?: SortOrder;
    is_active?: SortOrder;
    dismissible?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type in_app_announcementsMinOrderByAggregateInput = {
    id?: SortOrder;
    type?: SortOrder;
    display_type?: SortOrder;
    title_en?: SortOrder;
    title_th?: SortOrder;
    message_en?: SortOrder;
    message_th?: SortOrder;
    button_text_en?: SortOrder;
    button_text_th?: SortOrder;
    action_type?: SortOrder;
    action_value?: SortOrder;
    platform?: SortOrder;
    min_app_version?: SortOrder;
    max_app_version?: SortOrder;
    start_at?: SortOrder;
    end_at?: SortOrder;
    priority?: SortOrder;
    is_active?: SortOrder;
    dismissible?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type in_app_announcementsSumOrderByAggregateInput = {
    id?: SortOrder;
    priority?: SortOrder;
  };

  export type investment_insightsCountOrderByAggregateInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    reason?: SortOrder;
    recommendation?: SortOrder;
    analysis?: SortOrder;
    created_at?: SortOrder;
    reason_th?: SortOrder;
    analysis_th?: SortOrder;
    thesis_en?: SortOrder;
    takeaway_en?: SortOrder;
    thesis_th?: SortOrder;
    takeaway_th?: SortOrder;
  };

  export type investment_insightsAvgOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type investment_insightsMaxOrderByAggregateInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    reason?: SortOrder;
    recommendation?: SortOrder;
    analysis?: SortOrder;
    created_at?: SortOrder;
    reason_th?: SortOrder;
    analysis_th?: SortOrder;
    thesis_en?: SortOrder;
    takeaway_en?: SortOrder;
    thesis_th?: SortOrder;
    takeaway_th?: SortOrder;
  };

  export type investment_insightsMinOrderByAggregateInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    reason?: SortOrder;
    recommendation?: SortOrder;
    analysis?: SortOrder;
    created_at?: SortOrder;
    reason_th?: SortOrder;
    analysis_th?: SortOrder;
    thesis_en?: SortOrder;
    takeaway_en?: SortOrder;
    thesis_th?: SortOrder;
    takeaway_th?: SortOrder;
  };

  export type investment_insightsSumOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type market_recapCountOrderByAggregateInput = {
    stock_market_recap_en?: SortOrder;
    stock_market_recap_th?: SortOrder;
    sector_performance_en?: SortOrder;
    sector_performance_th?: SortOrder;
    economic_data_and_potential_concerns_en?: SortOrder;
    economic_data_and_potential_concerns_th?: SortOrder;
    other_market_activity_en?: SortOrder;
    other_market_activity_th?: SortOrder;
    summary_en?: SortOrder;
    summary_th?: SortOrder;
    id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type market_recapAvgOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type market_recapMaxOrderByAggregateInput = {
    stock_market_recap_en?: SortOrder;
    stock_market_recap_th?: SortOrder;
    sector_performance_en?: SortOrder;
    sector_performance_th?: SortOrder;
    economic_data_and_potential_concerns_en?: SortOrder;
    economic_data_and_potential_concerns_th?: SortOrder;
    other_market_activity_en?: SortOrder;
    other_market_activity_th?: SortOrder;
    summary_en?: SortOrder;
    summary_th?: SortOrder;
    id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type market_recapMinOrderByAggregateInput = {
    stock_market_recap_en?: SortOrder;
    stock_market_recap_th?: SortOrder;
    sector_performance_en?: SortOrder;
    sector_performance_th?: SortOrder;
    economic_data_and_potential_concerns_en?: SortOrder;
    economic_data_and_potential_concerns_th?: SortOrder;
    other_market_activity_en?: SortOrder;
    other_market_activity_th?: SortOrder;
    summary_en?: SortOrder;
    summary_th?: SortOrder;
    id?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type market_recapSumOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type Stock_newsScalarRelationFilter = {
    is?: stock_newsWhereInput;
    isNot?: stock_newsWhereInput;
  };

  export type News_commentsNullableScalarRelationFilter = {
    is?: news_commentsWhereInput | null;
    isNot?: news_commentsWhereInput | null;
  };

  export type News_commentsListRelationFilter = {
    every?: news_commentsWhereInput;
    some?: news_commentsWhereInput;
    none?: news_commentsWhereInput;
  };

  export type news_commentsOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type news_commentsCountOrderByAggregateInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    parent_comment_id?: SortOrder;
    content?: SortOrder;
    like_count?: SortOrder;
    reply_count?: SortOrder;
    is_active?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    user_id?: SortOrder;
  };

  export type news_commentsAvgOrderByAggregateInput = {
    id?: SortOrder;
    parent_comment_id?: SortOrder;
    like_count?: SortOrder;
    reply_count?: SortOrder;
    user_id?: SortOrder;
  };

  export type news_commentsMaxOrderByAggregateInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    parent_comment_id?: SortOrder;
    content?: SortOrder;
    like_count?: SortOrder;
    reply_count?: SortOrder;
    is_active?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    user_id?: SortOrder;
  };

  export type news_commentsMinOrderByAggregateInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    parent_comment_id?: SortOrder;
    content?: SortOrder;
    like_count?: SortOrder;
    reply_count?: SortOrder;
    is_active?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    user_id?: SortOrder;
  };

  export type news_commentsSumOrderByAggregateInput = {
    id?: SortOrder;
    parent_comment_id?: SortOrder;
    like_count?: SortOrder;
    reply_count?: SortOrder;
    user_id?: SortOrder;
  };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type news_configCountOrderByAggregateInput = {
    name?: SortOrder;
    value?: SortOrder;
  };

  export type news_configMaxOrderByAggregateInput = {
    name?: SortOrder;
  };

  export type news_configMinOrderByAggregateInput = {
    name?: SortOrder;
  };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>
      >;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type DecimalFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type payment_historyCountOrderByAggregateInput = {
    payment_id?: SortOrder;
    user_subscription_id?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    payment_status?: SortOrder;
    stripe_payment_intent_id?: SortOrder;
    payment_method_id?: SortOrder;
    payment_date?: SortOrder;
    billing_period_start?: SortOrder;
    billing_period_end?: SortOrder;
    invoice_url?: SortOrder;
    error_message?: SortOrder;
    stripe_invoice_id?: SortOrder;
  };

  export type payment_historyAvgOrderByAggregateInput = {
    payment_id?: SortOrder;
    user_subscription_id?: SortOrder;
    amount?: SortOrder;
  };

  export type payment_historyMaxOrderByAggregateInput = {
    payment_id?: SortOrder;
    user_subscription_id?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    payment_status?: SortOrder;
    stripe_payment_intent_id?: SortOrder;
    payment_method_id?: SortOrder;
    payment_date?: SortOrder;
    billing_period_start?: SortOrder;
    billing_period_end?: SortOrder;
    invoice_url?: SortOrder;
    error_message?: SortOrder;
    stripe_invoice_id?: SortOrder;
  };

  export type payment_historyMinOrderByAggregateInput = {
    payment_id?: SortOrder;
    user_subscription_id?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    payment_status?: SortOrder;
    stripe_payment_intent_id?: SortOrder;
    payment_method_id?: SortOrder;
    payment_date?: SortOrder;
    billing_period_start?: SortOrder;
    billing_period_end?: SortOrder;
    invoice_url?: SortOrder;
    error_message?: SortOrder;
    stripe_invoice_id?: SortOrder;
  };

  export type payment_historySumOrderByAggregateInput = {
    payment_id?: SortOrder;
    user_subscription_id?: SortOrder;
    amount?: SortOrder;
  };

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type SubscriptionsNullableScalarRelationFilter = {
    is?: subscriptionsWhereInput | null;
    isNot?: subscriptionsWhereInput | null;
  };

  export type permissionsCountOrderByAggregateInput = {
    permission_id?: SortOrder;
    subscription_id?: SortOrder;
    feature?: SortOrder;
    is_enabled?: SortOrder;
    limit_access?: SortOrder;
  };

  export type permissionsAvgOrderByAggregateInput = {
    permission_id?: SortOrder;
    subscription_id?: SortOrder;
  };

  export type permissionsMaxOrderByAggregateInput = {
    permission_id?: SortOrder;
    subscription_id?: SortOrder;
    feature?: SortOrder;
    is_enabled?: SortOrder;
    limit_access?: SortOrder;
  };

  export type permissionsMinOrderByAggregateInput = {
    permission_id?: SortOrder;
    subscription_id?: SortOrder;
    feature?: SortOrder;
    is_enabled?: SortOrder;
    limit_access?: SortOrder;
  };

  export type permissionsSumOrderByAggregateInput = {
    permission_id?: SortOrder;
    subscription_id?: SortOrder;
  };

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
      | null;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type portfolioCountOrderByAggregateInput = {
    portfolio_id?: SortOrder;
    user_id?: SortOrder;
    total_value?: SortOrder;
    updated_at?: SortOrder;
  };

  export type portfolioAvgOrderByAggregateInput = {
    portfolio_id?: SortOrder;
    user_id?: SortOrder;
    total_value?: SortOrder;
  };

  export type portfolioMaxOrderByAggregateInput = {
    portfolio_id?: SortOrder;
    user_id?: SortOrder;
    total_value?: SortOrder;
    updated_at?: SortOrder;
  };

  export type portfolioMinOrderByAggregateInput = {
    portfolio_id?: SortOrder;
    user_id?: SortOrder;
    total_value?: SortOrder;
    updated_at?: SortOrder;
  };

  export type portfolioSumOrderByAggregateInput = {
    portfolio_id?: SortOrder;
    user_id?: SortOrder;
    total_value?: SortOrder;
  };

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
      | null;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedDecimalNullableFilter<$PrismaModel>;
    _sum?: NestedDecimalNullableFilter<$PrismaModel>;
    _min?: NestedDecimalNullableFilter<$PrismaModel>;
    _max?: NestedDecimalNullableFilter<$PrismaModel>;
  };

  export type portfolio_holdingsPortfolio_idSymbolCompoundUniqueInput = {
    portfolio_id: number;
    symbol: string;
  };

  export type portfolio_holdingsCountOrderByAggregateInput = {
    id?: SortOrder;
    portfolio_id?: SortOrder;
    symbol?: SortOrder;
    total_quantity?: SortOrder;
    average_price?: SortOrder;
    total_invested?: SortOrder;
    updated_at?: SortOrder;
  };

  export type portfolio_holdingsAvgOrderByAggregateInput = {
    id?: SortOrder;
    portfolio_id?: SortOrder;
    total_quantity?: SortOrder;
    average_price?: SortOrder;
    total_invested?: SortOrder;
  };

  export type portfolio_holdingsMaxOrderByAggregateInput = {
    id?: SortOrder;
    portfolio_id?: SortOrder;
    symbol?: SortOrder;
    total_quantity?: SortOrder;
    average_price?: SortOrder;
    total_invested?: SortOrder;
    updated_at?: SortOrder;
  };

  export type portfolio_holdingsMinOrderByAggregateInput = {
    id?: SortOrder;
    portfolio_id?: SortOrder;
    symbol?: SortOrder;
    total_quantity?: SortOrder;
    average_price?: SortOrder;
    total_invested?: SortOrder;
    updated_at?: SortOrder;
  };

  export type portfolio_holdingsSumOrderByAggregateInput = {
    id?: SortOrder;
    portfolio_id?: SortOrder;
    total_quantity?: SortOrder;
    average_price?: SortOrder;
    total_invested?: SortOrder;
  };

  export type portfolio_stocksCountOrderByAggregateInput = {
    id?: SortOrder;
    portfolio_id?: SortOrder;
    symbol?: SortOrder;
    type?: SortOrder;
    quantity?: SortOrder;
    price?: SortOrder;
    total_amount?: SortOrder;
    transaction_date?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    currency?: SortOrder;
  };

  export type portfolio_stocksAvgOrderByAggregateInput = {
    id?: SortOrder;
    portfolio_id?: SortOrder;
    quantity?: SortOrder;
    price?: SortOrder;
    total_amount?: SortOrder;
  };

  export type portfolio_stocksMaxOrderByAggregateInput = {
    id?: SortOrder;
    portfolio_id?: SortOrder;
    symbol?: SortOrder;
    type?: SortOrder;
    quantity?: SortOrder;
    price?: SortOrder;
    total_amount?: SortOrder;
    transaction_date?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    currency?: SortOrder;
  };

  export type portfolio_stocksMinOrderByAggregateInput = {
    id?: SortOrder;
    portfolio_id?: SortOrder;
    symbol?: SortOrder;
    type?: SortOrder;
    quantity?: SortOrder;
    price?: SortOrder;
    total_amount?: SortOrder;
    transaction_date?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    currency?: SortOrder;
  };

  export type portfolio_stocksSumOrderByAggregateInput = {
    id?: SortOrder;
    portfolio_id?: SortOrder;
    quantity?: SortOrder;
    price?: SortOrder;
    total_amount?: SortOrder;
  };

  export type Enumasset_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.asset_type | Enumasset_typeFieldRefInput<$PrismaModel>;
    in?: $Enums.asset_type[] | ListEnumasset_typeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.asset_type[] | ListEnumasset_typeFieldRefInput<$PrismaModel>;
    not?: NestedEnumasset_typeFilter<$PrismaModel> | $Enums.asset_type;
  };

  export type Enumalert_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.alert_type | Enumalert_typeFieldRefInput<$PrismaModel>;
    in?: $Enums.alert_type[] | ListEnumalert_typeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.alert_type[] | ListEnumalert_typeFieldRefInput<$PrismaModel>;
    not?: NestedEnumalert_typeFilter<$PrismaModel> | $Enums.alert_type;
  };

  export type Enumalert_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.alert_status | Enumalert_statusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.alert_status[]
      | ListEnumalert_statusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.alert_status[]
      | ListEnumalert_statusFieldRefInput<$PrismaModel>;
    not?: NestedEnumalert_statusFilter<$PrismaModel> | $Enums.alert_status;
  };

  export type price_alertsCountOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    symbol?: SortOrder;
    asset_type?: SortOrder;
    target_price?: SortOrder;
    alert_type?: SortOrder;
    status?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    triggered_at?: SortOrder;
    expires_at?: SortOrder;
  };

  export type price_alertsAvgOrderByAggregateInput = {
    user_id?: SortOrder;
    target_price?: SortOrder;
  };

  export type price_alertsMaxOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    symbol?: SortOrder;
    asset_type?: SortOrder;
    target_price?: SortOrder;
    alert_type?: SortOrder;
    status?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    triggered_at?: SortOrder;
    expires_at?: SortOrder;
  };

  export type price_alertsMinOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    symbol?: SortOrder;
    asset_type?: SortOrder;
    target_price?: SortOrder;
    alert_type?: SortOrder;
    status?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    triggered_at?: SortOrder;
    expires_at?: SortOrder;
  };

  export type price_alertsSumOrderByAggregateInput = {
    user_id?: SortOrder;
    target_price?: SortOrder;
  };

  export type Enumasset_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.asset_type | Enumasset_typeFieldRefInput<$PrismaModel>;
    in?: $Enums.asset_type[] | ListEnumasset_typeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.asset_type[] | ListEnumasset_typeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumasset_typeWithAggregatesFilter<$PrismaModel>
      | $Enums.asset_type;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumasset_typeFilter<$PrismaModel>;
    _max?: NestedEnumasset_typeFilter<$PrismaModel>;
  };

  export type Enumalert_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.alert_type | Enumalert_typeFieldRefInput<$PrismaModel>;
    in?: $Enums.alert_type[] | ListEnumalert_typeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.alert_type[] | ListEnumalert_typeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumalert_typeWithAggregatesFilter<$PrismaModel>
      | $Enums.alert_type;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumalert_typeFilter<$PrismaModel>;
    _max?: NestedEnumalert_typeFilter<$PrismaModel>;
  };

  export type Enumalert_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.alert_status | Enumalert_statusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.alert_status[]
      | ListEnumalert_statusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.alert_status[]
      | ListEnumalert_statusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumalert_statusWithAggregatesFilter<$PrismaModel>
      | $Enums.alert_status;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumalert_statusFilter<$PrismaModel>;
    _max?: NestedEnumalert_statusFilter<$PrismaModel>;
  };

  export type promotion_articlesCountOrderByAggregateInput = {
    image_banner_dark?: SortOrder;
    image_banner_white?: SortOrder;
    title_th?: SortOrder;
    title_en?: SortOrder;
    description_th?: SortOrder;
    description_en?: SortOrder;
    content_th?: SortOrder;
    content_en?: SortOrder;
    button_text_th?: SortOrder;
    button_text_en?: SortOrder;
    path?: SortOrder;
    type?: SortOrder;
    id?: SortOrder;
  };

  export type promotion_articlesAvgOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type promotion_articlesMaxOrderByAggregateInput = {
    image_banner_dark?: SortOrder;
    image_banner_white?: SortOrder;
    title_th?: SortOrder;
    title_en?: SortOrder;
    description_th?: SortOrder;
    description_en?: SortOrder;
    content_th?: SortOrder;
    content_en?: SortOrder;
    button_text_th?: SortOrder;
    button_text_en?: SortOrder;
    path?: SortOrder;
    type?: SortOrder;
    id?: SortOrder;
  };

  export type promotion_articlesMinOrderByAggregateInput = {
    image_banner_dark?: SortOrder;
    image_banner_white?: SortOrder;
    title_th?: SortOrder;
    title_en?: SortOrder;
    description_th?: SortOrder;
    description_en?: SortOrder;
    content_th?: SortOrder;
    content_en?: SortOrder;
    button_text_th?: SortOrder;
    button_text_en?: SortOrder;
    path?: SortOrder;
    type?: SortOrder;
    id?: SortOrder;
  };

  export type promotion_articlesSumOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    has?: string | StringFieldRefInput<$PrismaModel> | null;
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>;
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type Stock_news_read_historyListRelationFilter = {
    every?: stock_news_read_historyWhereInput;
    some?: stock_news_read_historyWhereInput;
    none?: stock_news_read_historyWhereInput;
  };

  export type Stock_news_related_symbolsListRelationFilter = {
    every?: stock_news_related_symbolsWhereInput;
    some?: stock_news_related_symbolsWhereInput;
    none?: stock_news_related_symbolsWhereInput;
  };

  export type Stock_news_translationListRelationFilter = {
    every?: stock_news_translationWhereInput;
    some?: stock_news_translationWhereInput;
    none?: stock_news_translationWhereInput;
  };

  export type stock_news_read_historyOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type stock_news_related_symbolsOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type stock_news_translationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type stock_newsCountOrderByAggregateInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    exchange?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    summary?: SortOrder;
    image_url?: SortOrder;
    source_url?: SortOrder;
    publisher?: SortOrder;
    published_date?: SortOrder;
    language?: SortOrder;
    view_count?: SortOrder;
    is_featured?: SortOrder;
    is_hot?: SortOrder;
    tags?: SortOrder;
    metadata?: SortOrder;
    like_count?: SortOrder;
    share_count?: SortOrder;
    is_active?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    categories?: SortOrder;
  };

  export type stock_newsAvgOrderByAggregateInput = {
    view_count?: SortOrder;
    like_count?: SortOrder;
    share_count?: SortOrder;
  };

  export type stock_newsMaxOrderByAggregateInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    exchange?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    summary?: SortOrder;
    image_url?: SortOrder;
    source_url?: SortOrder;
    publisher?: SortOrder;
    published_date?: SortOrder;
    language?: SortOrder;
    view_count?: SortOrder;
    is_featured?: SortOrder;
    is_hot?: SortOrder;
    like_count?: SortOrder;
    share_count?: SortOrder;
    is_active?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type stock_newsMinOrderByAggregateInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    exchange?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    summary?: SortOrder;
    image_url?: SortOrder;
    source_url?: SortOrder;
    publisher?: SortOrder;
    published_date?: SortOrder;
    language?: SortOrder;
    view_count?: SortOrder;
    is_featured?: SortOrder;
    is_hot?: SortOrder;
    like_count?: SortOrder;
    share_count?: SortOrder;
    is_active?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type stock_newsSumOrderByAggregateInput = {
    view_count?: SortOrder;
    like_count?: SortOrder;
    share_count?: SortOrder;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type stock_news_read_historyCountOrderByAggregateInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    user_id?: SortOrder;
    session_id?: SortOrder;
    read_at?: SortOrder;
    language_read?: SortOrder;
    read_duration?: SortOrder;
    metadata?: SortOrder;
  };

  export type stock_news_read_historyAvgOrderByAggregateInput = {
    read_duration?: SortOrder;
  };

  export type stock_news_read_historyMaxOrderByAggregateInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    user_id?: SortOrder;
    session_id?: SortOrder;
    read_at?: SortOrder;
    language_read?: SortOrder;
    read_duration?: SortOrder;
  };

  export type stock_news_read_historyMinOrderByAggregateInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    user_id?: SortOrder;
    session_id?: SortOrder;
    read_at?: SortOrder;
    language_read?: SortOrder;
    read_duration?: SortOrder;
  };

  export type stock_news_read_historySumOrderByAggregateInput = {
    read_duration?: SortOrder;
  };

  export type stock_news_related_symbolsCountOrderByAggregateInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    related_symbol?: SortOrder;
    related_exchange?: SortOrder;
    is_primary?: SortOrder;
  };

  export type stock_news_related_symbolsMaxOrderByAggregateInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    related_symbol?: SortOrder;
    related_exchange?: SortOrder;
    is_primary?: SortOrder;
  };

  export type stock_news_related_symbolsMinOrderByAggregateInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    related_symbol?: SortOrder;
    related_exchange?: SortOrder;
    is_primary?: SortOrder;
  };

  export type stock_news_translationCountOrderByAggregateInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    language?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    summary?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type stock_news_translationMaxOrderByAggregateInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    language?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    summary?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type stock_news_translationMinOrderByAggregateInput = {
    id?: SortOrder;
    news_id?: SortOrder;
    language?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    summary?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type PermissionsListRelationFilter = {
    every?: permissionsWhereInput;
    some?: permissionsWhereInput;
    none?: permissionsWhereInput;
  };

  export type User_subscriptionsListRelationFilter = {
    every?: user_subscriptionsWhereInput;
    some?: user_subscriptionsWhereInput;
    none?: user_subscriptionsWhereInput;
  };

  export type permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type user_subscriptionsOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type subscriptionsCountOrderByAggregateInput = {
    subscription_id?: SortOrder;
    name?: SortOrder;
    price?: SortOrder;
    features?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    stripe_price_id?: SortOrder;
    price_amount?: SortOrder;
    currency?: SortOrder;
    billing_interval?: SortOrder;
    is_active?: SortOrder;
    trial_days?: SortOrder;
  };

  export type subscriptionsAvgOrderByAggregateInput = {
    subscription_id?: SortOrder;
    price?: SortOrder;
    trial_days?: SortOrder;
  };

  export type subscriptionsMaxOrderByAggregateInput = {
    subscription_id?: SortOrder;
    name?: SortOrder;
    price?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    stripe_price_id?: SortOrder;
    price_amount?: SortOrder;
    currency?: SortOrder;
    billing_interval?: SortOrder;
    is_active?: SortOrder;
    trial_days?: SortOrder;
  };

  export type subscriptionsMinOrderByAggregateInput = {
    subscription_id?: SortOrder;
    name?: SortOrder;
    price?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    stripe_price_id?: SortOrder;
    price_amount?: SortOrder;
    currency?: SortOrder;
    billing_interval?: SortOrder;
    is_active?: SortOrder;
    trial_days?: SortOrder;
  };

  export type subscriptionsSumOrderByAggregateInput = {
    subscription_id?: SortOrder;
    price?: SortOrder;
    trial_days?: SortOrder;
  };

  export type Superinvestor_holdings_listListRelationFilter = {
    every?: superinvestor_holdings_listWhereInput;
    some?: superinvestor_holdings_listWhereInput;
    none?: superinvestor_holdings_listWhereInput;
  };

  export type Superinvestor_sector_analysisListRelationFilter = {
    every?: superinvestor_sector_analysisWhereInput;
    some?: superinvestor_sector_analysisWhereInput;
    none?: superinvestor_sector_analysisWhereInput;
  };

  export type superinvestor_holdings_listOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type superinvestor_sector_analysisOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type superinvestor_holdingsCountOrderByAggregateInput = {
    id?: SortOrder;
    manager_name?: SortOrder;
    portfolio_value_raw?: SortOrder;
    number_of_stocks?: SortOrder;
    manager_link?: SortOrder;
    image?: SortOrder;
    information_en?: SortOrder;
    information_th?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    portfolio_value?: SortOrder;
  };

  export type superinvestor_holdingsAvgOrderByAggregateInput = {
    id?: SortOrder;
    number_of_stocks?: SortOrder;
    portfolio_value?: SortOrder;
  };

  export type superinvestor_holdingsMaxOrderByAggregateInput = {
    id?: SortOrder;
    manager_name?: SortOrder;
    portfolio_value_raw?: SortOrder;
    number_of_stocks?: SortOrder;
    manager_link?: SortOrder;
    image?: SortOrder;
    information_en?: SortOrder;
    information_th?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    portfolio_value?: SortOrder;
  };

  export type superinvestor_holdingsMinOrderByAggregateInput = {
    id?: SortOrder;
    manager_name?: SortOrder;
    portfolio_value_raw?: SortOrder;
    number_of_stocks?: SortOrder;
    manager_link?: SortOrder;
    image?: SortOrder;
    information_en?: SortOrder;
    information_th?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    portfolio_value?: SortOrder;
  };

  export type superinvestor_holdingsSumOrderByAggregateInput = {
    id?: SortOrder;
    number_of_stocks?: SortOrder;
    portfolio_value?: SortOrder;
  };

  export type Superinvestor_holdingsNullableScalarRelationFilter = {
    is?: superinvestor_holdingsWhereInput | null;
    isNot?: superinvestor_holdingsWhereInput | null;
  };

  export type superinvestor_holdings_listCountOrderByAggregateInput = {
    id?: SortOrder;
    manager_id?: SortOrder;
    symbol?: SortOrder;
    percentage_of_portfolio?: SortOrder;
    recent_activity?: SortOrder;
    share_raw?: SortOrder;
    share_value?: SortOrder;
    reported_price_raw?: SortOrder;
    reported_price_value?: SortOrder;
    value_raw?: SortOrder;
    value?: SortOrder;
  };

  export type superinvestor_holdings_listAvgOrderByAggregateInput = {
    id?: SortOrder;
    manager_id?: SortOrder;
    percentage_of_portfolio?: SortOrder;
    share_value?: SortOrder;
    reported_price_value?: SortOrder;
    value?: SortOrder;
  };

  export type superinvestor_holdings_listMaxOrderByAggregateInput = {
    id?: SortOrder;
    manager_id?: SortOrder;
    symbol?: SortOrder;
    percentage_of_portfolio?: SortOrder;
    recent_activity?: SortOrder;
    share_raw?: SortOrder;
    share_value?: SortOrder;
    reported_price_raw?: SortOrder;
    reported_price_value?: SortOrder;
    value_raw?: SortOrder;
    value?: SortOrder;
  };

  export type superinvestor_holdings_listMinOrderByAggregateInput = {
    id?: SortOrder;
    manager_id?: SortOrder;
    symbol?: SortOrder;
    percentage_of_portfolio?: SortOrder;
    recent_activity?: SortOrder;
    share_raw?: SortOrder;
    share_value?: SortOrder;
    reported_price_raw?: SortOrder;
    reported_price_value?: SortOrder;
    value_raw?: SortOrder;
    value?: SortOrder;
  };

  export type superinvestor_holdings_listSumOrderByAggregateInput = {
    id?: SortOrder;
    manager_id?: SortOrder;
    percentage_of_portfolio?: SortOrder;
    share_value?: SortOrder;
    reported_price_value?: SortOrder;
    value?: SortOrder;
  };

  export type superinvestor_sector_analysisCountOrderByAggregateInput = {
    id?: SortOrder;
    manager_id?: SortOrder;
    sector_name?: SortOrder;
    sector_percentage?: SortOrder;
  };

  export type superinvestor_sector_analysisAvgOrderByAggregateInput = {
    id?: SortOrder;
    manager_id?: SortOrder;
    sector_percentage?: SortOrder;
  };

  export type superinvestor_sector_analysisMaxOrderByAggregateInput = {
    id?: SortOrder;
    manager_id?: SortOrder;
    sector_name?: SortOrder;
    sector_percentage?: SortOrder;
  };

  export type superinvestor_sector_analysisMinOrderByAggregateInput = {
    id?: SortOrder;
    manager_id?: SortOrder;
    sector_name?: SortOrder;
    sector_percentage?: SortOrder;
  };

  export type superinvestor_sector_analysisSumOrderByAggregateInput = {
    id?: SortOrder;
    manager_id?: SortOrder;
    sector_percentage?: SortOrder;
  };

  export type symbolCountOrderByAggregateInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    company_name?: SortOrder;
    exchange_short_name?: SortOrder;
    company_logo?: SortOrder;
    type?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type symbolMaxOrderByAggregateInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    company_name?: SortOrder;
    exchange_short_name?: SortOrder;
    company_logo?: SortOrder;
    type?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type symbolMinOrderByAggregateInput = {
    id?: SortOrder;
    symbol?: SortOrder;
    company_name?: SortOrder;
    exchange_short_name?: SortOrder;
    company_logo?: SortOrder;
    type?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
  };

  export type user_devicesCountOrderByAggregateInput = {
    device_id?: SortOrder;
    user_id?: SortOrder;
    platform?: SortOrder;
    device_token?: SortOrder;
    last_active_at?: SortOrder;
    created_at?: SortOrder;
    app_version?: SortOrder;
    device_name?: SortOrder;
  };

  export type user_devicesAvgOrderByAggregateInput = {
    user_id?: SortOrder;
  };

  export type user_devicesMaxOrderByAggregateInput = {
    device_id?: SortOrder;
    user_id?: SortOrder;
    platform?: SortOrder;
    device_token?: SortOrder;
    last_active_at?: SortOrder;
    created_at?: SortOrder;
    app_version?: SortOrder;
    device_name?: SortOrder;
  };

  export type user_devicesMinOrderByAggregateInput = {
    device_id?: SortOrder;
    user_id?: SortOrder;
    platform?: SortOrder;
    device_token?: SortOrder;
    last_active_at?: SortOrder;
    created_at?: SortOrder;
    app_version?: SortOrder;
    device_name?: SortOrder;
  };

  export type user_devicesSumOrderByAggregateInput = {
    user_id?: SortOrder;
  };

  export type user_subscriptionsCountOrderByAggregateInput = {
    user_subscription_id?: SortOrder;
    user_id?: SortOrder;
    subscription_id?: SortOrder;
    start_date?: SortOrder;
    end_date?: SortOrder;
    is_active?: SortOrder;
    stripe_subscription_id?: SortOrder;
    stripe_payment_intent_id?: SortOrder;
    payment_status?: SortOrder;
    last_payment_date?: SortOrder;
    next_billing_date?: SortOrder;
    cancellation_date?: SortOrder;
    trial_end_date?: SortOrder;
    last_payment_attempt_date?: SortOrder;
    payment_method_id?: SortOrder;
    redeem_code?: SortOrder;
  };

  export type user_subscriptionsAvgOrderByAggregateInput = {
    user_subscription_id?: SortOrder;
    user_id?: SortOrder;
    subscription_id?: SortOrder;
  };

  export type user_subscriptionsMaxOrderByAggregateInput = {
    user_subscription_id?: SortOrder;
    user_id?: SortOrder;
    subscription_id?: SortOrder;
    start_date?: SortOrder;
    end_date?: SortOrder;
    is_active?: SortOrder;
    stripe_subscription_id?: SortOrder;
    stripe_payment_intent_id?: SortOrder;
    payment_status?: SortOrder;
    last_payment_date?: SortOrder;
    next_billing_date?: SortOrder;
    cancellation_date?: SortOrder;
    trial_end_date?: SortOrder;
    last_payment_attempt_date?: SortOrder;
    payment_method_id?: SortOrder;
    redeem_code?: SortOrder;
  };

  export type user_subscriptionsMinOrderByAggregateInput = {
    user_subscription_id?: SortOrder;
    user_id?: SortOrder;
    subscription_id?: SortOrder;
    start_date?: SortOrder;
    end_date?: SortOrder;
    is_active?: SortOrder;
    stripe_subscription_id?: SortOrder;
    stripe_payment_intent_id?: SortOrder;
    payment_status?: SortOrder;
    last_payment_date?: SortOrder;
    next_billing_date?: SortOrder;
    cancellation_date?: SortOrder;
    trial_end_date?: SortOrder;
    last_payment_attempt_date?: SortOrder;
    payment_method_id?: SortOrder;
    redeem_code?: SortOrder;
  };

  export type user_subscriptionsSumOrderByAggregateInput = {
    user_subscription_id?: SortOrder;
    user_id?: SortOrder;
    subscription_id?: SortOrder;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type usersCountOrderByAggregateInput = {
    user_id?: SortOrder;
    google_id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    profile_pic?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    stripe_customer_id?: SortOrder;
    refresh_token?: SortOrder;
    has_used_trial?: SortOrder;
    trial_used_at?: SortOrder;
    bio?: SortOrder;
    is_verified?: SortOrder;
    status_message?: SortOrder;
    last_login_at?: SortOrder;
    birthdate?: SortOrder;
    language_preference?: SortOrder;
    theme_preference?: SortOrder;
    onboarding_completed?: SortOrder;
    account_status?: SortOrder;
    active_watchlist_id?: SortOrder;
    username?: SortOrder;
    is_private?: SortOrder;
    apple_id?: SortOrder;
  };

  export type usersAvgOrderByAggregateInput = {
    user_id?: SortOrder;
    active_watchlist_id?: SortOrder;
  };

  export type usersMaxOrderByAggregateInput = {
    user_id?: SortOrder;
    google_id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    profile_pic?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    stripe_customer_id?: SortOrder;
    refresh_token?: SortOrder;
    has_used_trial?: SortOrder;
    trial_used_at?: SortOrder;
    bio?: SortOrder;
    is_verified?: SortOrder;
    status_message?: SortOrder;
    last_login_at?: SortOrder;
    birthdate?: SortOrder;
    language_preference?: SortOrder;
    theme_preference?: SortOrder;
    onboarding_completed?: SortOrder;
    account_status?: SortOrder;
    active_watchlist_id?: SortOrder;
    username?: SortOrder;
    is_private?: SortOrder;
    apple_id?: SortOrder;
  };

  export type usersMinOrderByAggregateInput = {
    user_id?: SortOrder;
    google_id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    profile_pic?: SortOrder;
    created_at?: SortOrder;
    updated_at?: SortOrder;
    stripe_customer_id?: SortOrder;
    refresh_token?: SortOrder;
    has_used_trial?: SortOrder;
    trial_used_at?: SortOrder;
    bio?: SortOrder;
    is_verified?: SortOrder;
    status_message?: SortOrder;
    last_login_at?: SortOrder;
    birthdate?: SortOrder;
    language_preference?: SortOrder;
    theme_preference?: SortOrder;
    onboarding_completed?: SortOrder;
    account_status?: SortOrder;
    active_watchlist_id?: SortOrder;
    username?: SortOrder;
    is_private?: SortOrder;
    apple_id?: SortOrder;
  };

  export type usersSumOrderByAggregateInput = {
    user_id?: SortOrder;
    active_watchlist_id?: SortOrder;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type watchlist_itemsCountOrderByAggregateInput = {
    watchlist_item_id?: SortOrder;
    watchlist_id?: SortOrder;
    symbol?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    added_at?: SortOrder;
    sequence?: SortOrder;
  };

  export type watchlist_itemsAvgOrderByAggregateInput = {
    watchlist_item_id?: SortOrder;
    watchlist_id?: SortOrder;
    sequence?: SortOrder;
  };

  export type watchlist_itemsMaxOrderByAggregateInput = {
    watchlist_item_id?: SortOrder;
    watchlist_id?: SortOrder;
    symbol?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    added_at?: SortOrder;
    sequence?: SortOrder;
  };

  export type watchlist_itemsMinOrderByAggregateInput = {
    watchlist_item_id?: SortOrder;
    watchlist_id?: SortOrder;
    symbol?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    added_at?: SortOrder;
    sequence?: SortOrder;
  };

  export type watchlist_itemsSumOrderByAggregateInput = {
    watchlist_item_id?: SortOrder;
    watchlist_id?: SortOrder;
    sequence?: SortOrder;
  };

  export type watchlistsCountOrderByAggregateInput = {
    watchlist_id?: SortOrder;
    user_id?: SortOrder;
    name?: SortOrder;
    created_at?: SortOrder;
  };

  export type watchlistsAvgOrderByAggregateInput = {
    watchlist_id?: SortOrder;
    user_id?: SortOrder;
  };

  export type watchlistsMaxOrderByAggregateInput = {
    watchlist_id?: SortOrder;
    user_id?: SortOrder;
    name?: SortOrder;
    created_at?: SortOrder;
  };

  export type watchlistsMinOrderByAggregateInput = {
    watchlist_id?: SortOrder;
    user_id?: SortOrder;
    name?: SortOrder;
    created_at?: SortOrder;
  };

  export type watchlistsSumOrderByAggregateInput = {
    watchlist_id?: SortOrder;
    user_id?: SortOrder;
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type commentsCreateNestedOneWithoutOther_commentsInput = {
    create?: XOR<
      commentsCreateWithoutOther_commentsInput,
      commentsUncheckedCreateWithoutOther_commentsInput
    >;
    connectOrCreate?: commentsCreateOrConnectWithoutOther_commentsInput;
    connect?: commentsWhereUniqueInput;
  };

  export type commentsCreateNestedManyWithoutCommentsInput = {
    create?:
      | XOR<
          commentsCreateWithoutCommentsInput,
          commentsUncheckedCreateWithoutCommentsInput
        >
      | commentsCreateWithoutCommentsInput[]
      | commentsUncheckedCreateWithoutCommentsInput[];
    connectOrCreate?:
      | commentsCreateOrConnectWithoutCommentsInput
      | commentsCreateOrConnectWithoutCommentsInput[];
    createMany?: commentsCreateManyCommentsInputEnvelope;
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[];
  };

  export type commentsUncheckedCreateNestedManyWithoutCommentsInput = {
    create?:
      | XOR<
          commentsCreateWithoutCommentsInput,
          commentsUncheckedCreateWithoutCommentsInput
        >
      | commentsCreateWithoutCommentsInput[]
      | commentsUncheckedCreateWithoutCommentsInput[];
    connectOrCreate?:
      | commentsCreateOrConnectWithoutCommentsInput
      | commentsCreateOrConnectWithoutCommentsInput[];
    createMany?: commentsCreateManyCommentsInputEnvelope;
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[];
  };

  export type commentsUpdateOneWithoutOther_commentsNestedInput = {
    create?: XOR<
      commentsCreateWithoutOther_commentsInput,
      commentsUncheckedCreateWithoutOther_commentsInput
    >;
    connectOrCreate?: commentsCreateOrConnectWithoutOther_commentsInput;
    upsert?: commentsUpsertWithoutOther_commentsInput;
    disconnect?: commentsWhereInput | boolean;
    delete?: commentsWhereInput | boolean;
    connect?: commentsWhereUniqueInput;
    update?: XOR<
      XOR<
        commentsUpdateToOneWithWhereWithoutOther_commentsInput,
        commentsUpdateWithoutOther_commentsInput
      >,
      commentsUncheckedUpdateWithoutOther_commentsInput
    >;
  };

  export type commentsUpdateManyWithoutCommentsNestedInput = {
    create?:
      | XOR<
          commentsCreateWithoutCommentsInput,
          commentsUncheckedCreateWithoutCommentsInput
        >
      | commentsCreateWithoutCommentsInput[]
      | commentsUncheckedCreateWithoutCommentsInput[];
    connectOrCreate?:
      | commentsCreateOrConnectWithoutCommentsInput
      | commentsCreateOrConnectWithoutCommentsInput[];
    upsert?:
      | commentsUpsertWithWhereUniqueWithoutCommentsInput
      | commentsUpsertWithWhereUniqueWithoutCommentsInput[];
    createMany?: commentsCreateManyCommentsInputEnvelope;
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[];
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[];
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[];
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[];
    update?:
      | commentsUpdateWithWhereUniqueWithoutCommentsInput
      | commentsUpdateWithWhereUniqueWithoutCommentsInput[];
    updateMany?:
      | commentsUpdateManyWithWhereWithoutCommentsInput
      | commentsUpdateManyWithWhereWithoutCommentsInput[];
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[];
  };

  export type commentsUncheckedUpdateManyWithoutCommentsNestedInput = {
    create?:
      | XOR<
          commentsCreateWithoutCommentsInput,
          commentsUncheckedCreateWithoutCommentsInput
        >
      | commentsCreateWithoutCommentsInput[]
      | commentsUncheckedCreateWithoutCommentsInput[];
    connectOrCreate?:
      | commentsCreateOrConnectWithoutCommentsInput
      | commentsCreateOrConnectWithoutCommentsInput[];
    upsert?:
      | commentsUpsertWithWhereUniqueWithoutCommentsInput
      | commentsUpsertWithWhereUniqueWithoutCommentsInput[];
    createMany?: commentsCreateManyCommentsInputEnvelope;
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[];
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[];
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[];
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[];
    update?:
      | commentsUpdateWithWhereUniqueWithoutCommentsInput
      | commentsUpdateWithWhereUniqueWithoutCommentsInput[];
    updateMany?:
      | commentsUpdateManyWithWhereWithoutCommentsInput
      | commentsUpdateManyWithWhereWithoutCommentsInput[];
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[];
  };

  export type stock_newsCreateNestedOneWithoutNews_commentsInput = {
    create?: XOR<
      stock_newsCreateWithoutNews_commentsInput,
      stock_newsUncheckedCreateWithoutNews_commentsInput
    >;
    connectOrCreate?: stock_newsCreateOrConnectWithoutNews_commentsInput;
    connect?: stock_newsWhereUniqueInput;
  };

  export type news_commentsCreateNestedOneWithoutOther_news_commentsInput = {
    create?: XOR<
      news_commentsCreateWithoutOther_news_commentsInput,
      news_commentsUncheckedCreateWithoutOther_news_commentsInput
    >;
    connectOrCreate?: news_commentsCreateOrConnectWithoutOther_news_commentsInput;
    connect?: news_commentsWhereUniqueInput;
  };

  export type news_commentsCreateNestedManyWithoutNews_commentsInput = {
    create?:
      | XOR<
          news_commentsCreateWithoutNews_commentsInput,
          news_commentsUncheckedCreateWithoutNews_commentsInput
        >
      | news_commentsCreateWithoutNews_commentsInput[]
      | news_commentsUncheckedCreateWithoutNews_commentsInput[];
    connectOrCreate?:
      | news_commentsCreateOrConnectWithoutNews_commentsInput
      | news_commentsCreateOrConnectWithoutNews_commentsInput[];
    createMany?: news_commentsCreateManyNews_commentsInputEnvelope;
    connect?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
  };

  export type news_commentsUncheckedCreateNestedManyWithoutNews_commentsInput =
    {
      create?:
        | XOR<
            news_commentsCreateWithoutNews_commentsInput,
            news_commentsUncheckedCreateWithoutNews_commentsInput
          >
        | news_commentsCreateWithoutNews_commentsInput[]
        | news_commentsUncheckedCreateWithoutNews_commentsInput[];
      connectOrCreate?:
        | news_commentsCreateOrConnectWithoutNews_commentsInput
        | news_commentsCreateOrConnectWithoutNews_commentsInput[];
      createMany?: news_commentsCreateManyNews_commentsInputEnvelope;
      connect?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
    };

  export type stock_newsUpdateOneRequiredWithoutNews_commentsNestedInput = {
    create?: XOR<
      stock_newsCreateWithoutNews_commentsInput,
      stock_newsUncheckedCreateWithoutNews_commentsInput
    >;
    connectOrCreate?: stock_newsCreateOrConnectWithoutNews_commentsInput;
    upsert?: stock_newsUpsertWithoutNews_commentsInput;
    connect?: stock_newsWhereUniqueInput;
    update?: XOR<
      XOR<
        stock_newsUpdateToOneWithWhereWithoutNews_commentsInput,
        stock_newsUpdateWithoutNews_commentsInput
      >,
      stock_newsUncheckedUpdateWithoutNews_commentsInput
    >;
  };

  export type news_commentsUpdateOneWithoutOther_news_commentsNestedInput = {
    create?: XOR<
      news_commentsCreateWithoutOther_news_commentsInput,
      news_commentsUncheckedCreateWithoutOther_news_commentsInput
    >;
    connectOrCreate?: news_commentsCreateOrConnectWithoutOther_news_commentsInput;
    upsert?: news_commentsUpsertWithoutOther_news_commentsInput;
    disconnect?: news_commentsWhereInput | boolean;
    delete?: news_commentsWhereInput | boolean;
    connect?: news_commentsWhereUniqueInput;
    update?: XOR<
      XOR<
        news_commentsUpdateToOneWithWhereWithoutOther_news_commentsInput,
        news_commentsUpdateWithoutOther_news_commentsInput
      >,
      news_commentsUncheckedUpdateWithoutOther_news_commentsInput
    >;
  };

  export type news_commentsUpdateManyWithoutNews_commentsNestedInput = {
    create?:
      | XOR<
          news_commentsCreateWithoutNews_commentsInput,
          news_commentsUncheckedCreateWithoutNews_commentsInput
        >
      | news_commentsCreateWithoutNews_commentsInput[]
      | news_commentsUncheckedCreateWithoutNews_commentsInput[];
    connectOrCreate?:
      | news_commentsCreateOrConnectWithoutNews_commentsInput
      | news_commentsCreateOrConnectWithoutNews_commentsInput[];
    upsert?:
      | news_commentsUpsertWithWhereUniqueWithoutNews_commentsInput
      | news_commentsUpsertWithWhereUniqueWithoutNews_commentsInput[];
    createMany?: news_commentsCreateManyNews_commentsInputEnvelope;
    set?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
    disconnect?:
      | news_commentsWhereUniqueInput
      | news_commentsWhereUniqueInput[];
    delete?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
    connect?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
    update?:
      | news_commentsUpdateWithWhereUniqueWithoutNews_commentsInput
      | news_commentsUpdateWithWhereUniqueWithoutNews_commentsInput[];
    updateMany?:
      | news_commentsUpdateManyWithWhereWithoutNews_commentsInput
      | news_commentsUpdateManyWithWhereWithoutNews_commentsInput[];
    deleteMany?:
      | news_commentsScalarWhereInput
      | news_commentsScalarWhereInput[];
  };

  export type news_commentsUncheckedUpdateManyWithoutNews_commentsNestedInput =
    {
      create?:
        | XOR<
            news_commentsCreateWithoutNews_commentsInput,
            news_commentsUncheckedCreateWithoutNews_commentsInput
          >
        | news_commentsCreateWithoutNews_commentsInput[]
        | news_commentsUncheckedCreateWithoutNews_commentsInput[];
      connectOrCreate?:
        | news_commentsCreateOrConnectWithoutNews_commentsInput
        | news_commentsCreateOrConnectWithoutNews_commentsInput[];
      upsert?:
        | news_commentsUpsertWithWhereUniqueWithoutNews_commentsInput
        | news_commentsUpsertWithWhereUniqueWithoutNews_commentsInput[];
      createMany?: news_commentsCreateManyNews_commentsInputEnvelope;
      set?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
      disconnect?:
        | news_commentsWhereUniqueInput
        | news_commentsWhereUniqueInput[];
      delete?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
      connect?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
      update?:
        | news_commentsUpdateWithWhereUniqueWithoutNews_commentsInput
        | news_commentsUpdateWithWhereUniqueWithoutNews_commentsInput[];
      updateMany?:
        | news_commentsUpdateManyWithWhereWithoutNews_commentsInput
        | news_commentsUpdateManyWithWhereWithoutNews_commentsInput[];
      deleteMany?:
        | news_commentsScalarWhereInput
        | news_commentsScalarWhereInput[];
    };

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type subscriptionsCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<
      subscriptionsCreateWithoutPermissionsInput,
      subscriptionsUncheckedCreateWithoutPermissionsInput
    >;
    connectOrCreate?: subscriptionsCreateOrConnectWithoutPermissionsInput;
    connect?: subscriptionsWhereUniqueInput;
  };

  export type subscriptionsUpdateOneWithoutPermissionsNestedInput = {
    create?: XOR<
      subscriptionsCreateWithoutPermissionsInput,
      subscriptionsUncheckedCreateWithoutPermissionsInput
    >;
    connectOrCreate?: subscriptionsCreateOrConnectWithoutPermissionsInput;
    upsert?: subscriptionsUpsertWithoutPermissionsInput;
    disconnect?: subscriptionsWhereInput | boolean;
    delete?: subscriptionsWhereInput | boolean;
    connect?: subscriptionsWhereUniqueInput;
    update?: XOR<
      XOR<
        subscriptionsUpdateToOneWithWhereWithoutPermissionsInput,
        subscriptionsUpdateWithoutPermissionsInput
      >,
      subscriptionsUncheckedUpdateWithoutPermissionsInput
    >;
  };

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type Enumasset_typeFieldUpdateOperationsInput = {
    set?: $Enums.asset_type;
  };

  export type Enumalert_typeFieldUpdateOperationsInput = {
    set?: $Enums.alert_type;
  };

  export type Enumalert_statusFieldUpdateOperationsInput = {
    set?: $Enums.alert_status;
  };

  export type stock_newsCreatetagsInput = {
    set: string[];
  };

  export type news_commentsCreateNestedManyWithoutStock_newsInput = {
    create?:
      | XOR<
          news_commentsCreateWithoutStock_newsInput,
          news_commentsUncheckedCreateWithoutStock_newsInput
        >
      | news_commentsCreateWithoutStock_newsInput[]
      | news_commentsUncheckedCreateWithoutStock_newsInput[];
    connectOrCreate?:
      | news_commentsCreateOrConnectWithoutStock_newsInput
      | news_commentsCreateOrConnectWithoutStock_newsInput[];
    createMany?: news_commentsCreateManyStock_newsInputEnvelope;
    connect?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
  };

  export type stock_news_read_historyCreateNestedManyWithoutStock_newsInput = {
    create?:
      | XOR<
          stock_news_read_historyCreateWithoutStock_newsInput,
          stock_news_read_historyUncheckedCreateWithoutStock_newsInput
        >
      | stock_news_read_historyCreateWithoutStock_newsInput[]
      | stock_news_read_historyUncheckedCreateWithoutStock_newsInput[];
    connectOrCreate?:
      | stock_news_read_historyCreateOrConnectWithoutStock_newsInput
      | stock_news_read_historyCreateOrConnectWithoutStock_newsInput[];
    createMany?: stock_news_read_historyCreateManyStock_newsInputEnvelope;
    connect?:
      | stock_news_read_historyWhereUniqueInput
      | stock_news_read_historyWhereUniqueInput[];
  };

  export type stock_news_related_symbolsCreateNestedManyWithoutStock_newsInput =
    {
      create?:
        | XOR<
            stock_news_related_symbolsCreateWithoutStock_newsInput,
            stock_news_related_symbolsUncheckedCreateWithoutStock_newsInput
          >
        | stock_news_related_symbolsCreateWithoutStock_newsInput[]
        | stock_news_related_symbolsUncheckedCreateWithoutStock_newsInput[];
      connectOrCreate?:
        | stock_news_related_symbolsCreateOrConnectWithoutStock_newsInput
        | stock_news_related_symbolsCreateOrConnectWithoutStock_newsInput[];
      createMany?: stock_news_related_symbolsCreateManyStock_newsInputEnvelope;
      connect?:
        | stock_news_related_symbolsWhereUniqueInput
        | stock_news_related_symbolsWhereUniqueInput[];
    };

  export type stock_news_translationCreateNestedManyWithoutStock_newsInput = {
    create?:
      | XOR<
          stock_news_translationCreateWithoutStock_newsInput,
          stock_news_translationUncheckedCreateWithoutStock_newsInput
        >
      | stock_news_translationCreateWithoutStock_newsInput[]
      | stock_news_translationUncheckedCreateWithoutStock_newsInput[];
    connectOrCreate?:
      | stock_news_translationCreateOrConnectWithoutStock_newsInput
      | stock_news_translationCreateOrConnectWithoutStock_newsInput[];
    createMany?: stock_news_translationCreateManyStock_newsInputEnvelope;
    connect?:
      | stock_news_translationWhereUniqueInput
      | stock_news_translationWhereUniqueInput[];
  };

  export type news_commentsUncheckedCreateNestedManyWithoutStock_newsInput = {
    create?:
      | XOR<
          news_commentsCreateWithoutStock_newsInput,
          news_commentsUncheckedCreateWithoutStock_newsInput
        >
      | news_commentsCreateWithoutStock_newsInput[]
      | news_commentsUncheckedCreateWithoutStock_newsInput[];
    connectOrCreate?:
      | news_commentsCreateOrConnectWithoutStock_newsInput
      | news_commentsCreateOrConnectWithoutStock_newsInput[];
    createMany?: news_commentsCreateManyStock_newsInputEnvelope;
    connect?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
  };

  export type stock_news_read_historyUncheckedCreateNestedManyWithoutStock_newsInput =
    {
      create?:
        | XOR<
            stock_news_read_historyCreateWithoutStock_newsInput,
            stock_news_read_historyUncheckedCreateWithoutStock_newsInput
          >
        | stock_news_read_historyCreateWithoutStock_newsInput[]
        | stock_news_read_historyUncheckedCreateWithoutStock_newsInput[];
      connectOrCreate?:
        | stock_news_read_historyCreateOrConnectWithoutStock_newsInput
        | stock_news_read_historyCreateOrConnectWithoutStock_newsInput[];
      createMany?: stock_news_read_historyCreateManyStock_newsInputEnvelope;
      connect?:
        | stock_news_read_historyWhereUniqueInput
        | stock_news_read_historyWhereUniqueInput[];
    };

  export type stock_news_related_symbolsUncheckedCreateNestedManyWithoutStock_newsInput =
    {
      create?:
        | XOR<
            stock_news_related_symbolsCreateWithoutStock_newsInput,
            stock_news_related_symbolsUncheckedCreateWithoutStock_newsInput
          >
        | stock_news_related_symbolsCreateWithoutStock_newsInput[]
        | stock_news_related_symbolsUncheckedCreateWithoutStock_newsInput[];
      connectOrCreate?:
        | stock_news_related_symbolsCreateOrConnectWithoutStock_newsInput
        | stock_news_related_symbolsCreateOrConnectWithoutStock_newsInput[];
      createMany?: stock_news_related_symbolsCreateManyStock_newsInputEnvelope;
      connect?:
        | stock_news_related_symbolsWhereUniqueInput
        | stock_news_related_symbolsWhereUniqueInput[];
    };

  export type stock_news_translationUncheckedCreateNestedManyWithoutStock_newsInput =
    {
      create?:
        | XOR<
            stock_news_translationCreateWithoutStock_newsInput,
            stock_news_translationUncheckedCreateWithoutStock_newsInput
          >
        | stock_news_translationCreateWithoutStock_newsInput[]
        | stock_news_translationUncheckedCreateWithoutStock_newsInput[];
      connectOrCreate?:
        | stock_news_translationCreateOrConnectWithoutStock_newsInput
        | stock_news_translationCreateOrConnectWithoutStock_newsInput[];
      createMany?: stock_news_translationCreateManyStock_newsInputEnvelope;
      connect?:
        | stock_news_translationWhereUniqueInput
        | stock_news_translationWhereUniqueInput[];
    };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type stock_newsUpdatetagsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type news_commentsUpdateManyWithoutStock_newsNestedInput = {
    create?:
      | XOR<
          news_commentsCreateWithoutStock_newsInput,
          news_commentsUncheckedCreateWithoutStock_newsInput
        >
      | news_commentsCreateWithoutStock_newsInput[]
      | news_commentsUncheckedCreateWithoutStock_newsInput[];
    connectOrCreate?:
      | news_commentsCreateOrConnectWithoutStock_newsInput
      | news_commentsCreateOrConnectWithoutStock_newsInput[];
    upsert?:
      | news_commentsUpsertWithWhereUniqueWithoutStock_newsInput
      | news_commentsUpsertWithWhereUniqueWithoutStock_newsInput[];
    createMany?: news_commentsCreateManyStock_newsInputEnvelope;
    set?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
    disconnect?:
      | news_commentsWhereUniqueInput
      | news_commentsWhereUniqueInput[];
    delete?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
    connect?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
    update?:
      | news_commentsUpdateWithWhereUniqueWithoutStock_newsInput
      | news_commentsUpdateWithWhereUniqueWithoutStock_newsInput[];
    updateMany?:
      | news_commentsUpdateManyWithWhereWithoutStock_newsInput
      | news_commentsUpdateManyWithWhereWithoutStock_newsInput[];
    deleteMany?:
      | news_commentsScalarWhereInput
      | news_commentsScalarWhereInput[];
  };

  export type stock_news_read_historyUpdateManyWithoutStock_newsNestedInput = {
    create?:
      | XOR<
          stock_news_read_historyCreateWithoutStock_newsInput,
          stock_news_read_historyUncheckedCreateWithoutStock_newsInput
        >
      | stock_news_read_historyCreateWithoutStock_newsInput[]
      | stock_news_read_historyUncheckedCreateWithoutStock_newsInput[];
    connectOrCreate?:
      | stock_news_read_historyCreateOrConnectWithoutStock_newsInput
      | stock_news_read_historyCreateOrConnectWithoutStock_newsInput[];
    upsert?:
      | stock_news_read_historyUpsertWithWhereUniqueWithoutStock_newsInput
      | stock_news_read_historyUpsertWithWhereUniqueWithoutStock_newsInput[];
    createMany?: stock_news_read_historyCreateManyStock_newsInputEnvelope;
    set?:
      | stock_news_read_historyWhereUniqueInput
      | stock_news_read_historyWhereUniqueInput[];
    disconnect?:
      | stock_news_read_historyWhereUniqueInput
      | stock_news_read_historyWhereUniqueInput[];
    delete?:
      | stock_news_read_historyWhereUniqueInput
      | stock_news_read_historyWhereUniqueInput[];
    connect?:
      | stock_news_read_historyWhereUniqueInput
      | stock_news_read_historyWhereUniqueInput[];
    update?:
      | stock_news_read_historyUpdateWithWhereUniqueWithoutStock_newsInput
      | stock_news_read_historyUpdateWithWhereUniqueWithoutStock_newsInput[];
    updateMany?:
      | stock_news_read_historyUpdateManyWithWhereWithoutStock_newsInput
      | stock_news_read_historyUpdateManyWithWhereWithoutStock_newsInput[];
    deleteMany?:
      | stock_news_read_historyScalarWhereInput
      | stock_news_read_historyScalarWhereInput[];
  };

  export type stock_news_related_symbolsUpdateManyWithoutStock_newsNestedInput =
    {
      create?:
        | XOR<
            stock_news_related_symbolsCreateWithoutStock_newsInput,
            stock_news_related_symbolsUncheckedCreateWithoutStock_newsInput
          >
        | stock_news_related_symbolsCreateWithoutStock_newsInput[]
        | stock_news_related_symbolsUncheckedCreateWithoutStock_newsInput[];
      connectOrCreate?:
        | stock_news_related_symbolsCreateOrConnectWithoutStock_newsInput
        | stock_news_related_symbolsCreateOrConnectWithoutStock_newsInput[];
      upsert?:
        | stock_news_related_symbolsUpsertWithWhereUniqueWithoutStock_newsInput
        | stock_news_related_symbolsUpsertWithWhereUniqueWithoutStock_newsInput[];
      createMany?: stock_news_related_symbolsCreateManyStock_newsInputEnvelope;
      set?:
        | stock_news_related_symbolsWhereUniqueInput
        | stock_news_related_symbolsWhereUniqueInput[];
      disconnect?:
        | stock_news_related_symbolsWhereUniqueInput
        | stock_news_related_symbolsWhereUniqueInput[];
      delete?:
        | stock_news_related_symbolsWhereUniqueInput
        | stock_news_related_symbolsWhereUniqueInput[];
      connect?:
        | stock_news_related_symbolsWhereUniqueInput
        | stock_news_related_symbolsWhereUniqueInput[];
      update?:
        | stock_news_related_symbolsUpdateWithWhereUniqueWithoutStock_newsInput
        | stock_news_related_symbolsUpdateWithWhereUniqueWithoutStock_newsInput[];
      updateMany?:
        | stock_news_related_symbolsUpdateManyWithWhereWithoutStock_newsInput
        | stock_news_related_symbolsUpdateManyWithWhereWithoutStock_newsInput[];
      deleteMany?:
        | stock_news_related_symbolsScalarWhereInput
        | stock_news_related_symbolsScalarWhereInput[];
    };

  export type stock_news_translationUpdateManyWithoutStock_newsNestedInput = {
    create?:
      | XOR<
          stock_news_translationCreateWithoutStock_newsInput,
          stock_news_translationUncheckedCreateWithoutStock_newsInput
        >
      | stock_news_translationCreateWithoutStock_newsInput[]
      | stock_news_translationUncheckedCreateWithoutStock_newsInput[];
    connectOrCreate?:
      | stock_news_translationCreateOrConnectWithoutStock_newsInput
      | stock_news_translationCreateOrConnectWithoutStock_newsInput[];
    upsert?:
      | stock_news_translationUpsertWithWhereUniqueWithoutStock_newsInput
      | stock_news_translationUpsertWithWhereUniqueWithoutStock_newsInput[];
    createMany?: stock_news_translationCreateManyStock_newsInputEnvelope;
    set?:
      | stock_news_translationWhereUniqueInput
      | stock_news_translationWhereUniqueInput[];
    disconnect?:
      | stock_news_translationWhereUniqueInput
      | stock_news_translationWhereUniqueInput[];
    delete?:
      | stock_news_translationWhereUniqueInput
      | stock_news_translationWhereUniqueInput[];
    connect?:
      | stock_news_translationWhereUniqueInput
      | stock_news_translationWhereUniqueInput[];
    update?:
      | stock_news_translationUpdateWithWhereUniqueWithoutStock_newsInput
      | stock_news_translationUpdateWithWhereUniqueWithoutStock_newsInput[];
    updateMany?:
      | stock_news_translationUpdateManyWithWhereWithoutStock_newsInput
      | stock_news_translationUpdateManyWithWhereWithoutStock_newsInput[];
    deleteMany?:
      | stock_news_translationScalarWhereInput
      | stock_news_translationScalarWhereInput[];
  };

  export type news_commentsUncheckedUpdateManyWithoutStock_newsNestedInput = {
    create?:
      | XOR<
          news_commentsCreateWithoutStock_newsInput,
          news_commentsUncheckedCreateWithoutStock_newsInput
        >
      | news_commentsCreateWithoutStock_newsInput[]
      | news_commentsUncheckedCreateWithoutStock_newsInput[];
    connectOrCreate?:
      | news_commentsCreateOrConnectWithoutStock_newsInput
      | news_commentsCreateOrConnectWithoutStock_newsInput[];
    upsert?:
      | news_commentsUpsertWithWhereUniqueWithoutStock_newsInput
      | news_commentsUpsertWithWhereUniqueWithoutStock_newsInput[];
    createMany?: news_commentsCreateManyStock_newsInputEnvelope;
    set?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
    disconnect?:
      | news_commentsWhereUniqueInput
      | news_commentsWhereUniqueInput[];
    delete?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
    connect?: news_commentsWhereUniqueInput | news_commentsWhereUniqueInput[];
    update?:
      | news_commentsUpdateWithWhereUniqueWithoutStock_newsInput
      | news_commentsUpdateWithWhereUniqueWithoutStock_newsInput[];
    updateMany?:
      | news_commentsUpdateManyWithWhereWithoutStock_newsInput
      | news_commentsUpdateManyWithWhereWithoutStock_newsInput[];
    deleteMany?:
      | news_commentsScalarWhereInput
      | news_commentsScalarWhereInput[];
  };

  export type stock_news_read_historyUncheckedUpdateManyWithoutStock_newsNestedInput =
    {
      create?:
        | XOR<
            stock_news_read_historyCreateWithoutStock_newsInput,
            stock_news_read_historyUncheckedCreateWithoutStock_newsInput
          >
        | stock_news_read_historyCreateWithoutStock_newsInput[]
        | stock_news_read_historyUncheckedCreateWithoutStock_newsInput[];
      connectOrCreate?:
        | stock_news_read_historyCreateOrConnectWithoutStock_newsInput
        | stock_news_read_historyCreateOrConnectWithoutStock_newsInput[];
      upsert?:
        | stock_news_read_historyUpsertWithWhereUniqueWithoutStock_newsInput
        | stock_news_read_historyUpsertWithWhereUniqueWithoutStock_newsInput[];
      createMany?: stock_news_read_historyCreateManyStock_newsInputEnvelope;
      set?:
        | stock_news_read_historyWhereUniqueInput
        | stock_news_read_historyWhereUniqueInput[];
      disconnect?:
        | stock_news_read_historyWhereUniqueInput
        | stock_news_read_historyWhereUniqueInput[];
      delete?:
        | stock_news_read_historyWhereUniqueInput
        | stock_news_read_historyWhereUniqueInput[];
      connect?:
        | stock_news_read_historyWhereUniqueInput
        | stock_news_read_historyWhereUniqueInput[];
      update?:
        | stock_news_read_historyUpdateWithWhereUniqueWithoutStock_newsInput
        | stock_news_read_historyUpdateWithWhereUniqueWithoutStock_newsInput[];
      updateMany?:
        | stock_news_read_historyUpdateManyWithWhereWithoutStock_newsInput
        | stock_news_read_historyUpdateManyWithWhereWithoutStock_newsInput[];
      deleteMany?:
        | stock_news_read_historyScalarWhereInput
        | stock_news_read_historyScalarWhereInput[];
    };

  export type stock_news_related_symbolsUncheckedUpdateManyWithoutStock_newsNestedInput =
    {
      create?:
        | XOR<
            stock_news_related_symbolsCreateWithoutStock_newsInput,
            stock_news_related_symbolsUncheckedCreateWithoutStock_newsInput
          >
        | stock_news_related_symbolsCreateWithoutStock_newsInput[]
        | stock_news_related_symbolsUncheckedCreateWithoutStock_newsInput[];
      connectOrCreate?:
        | stock_news_related_symbolsCreateOrConnectWithoutStock_newsInput
        | stock_news_related_symbolsCreateOrConnectWithoutStock_newsInput[];
      upsert?:
        | stock_news_related_symbolsUpsertWithWhereUniqueWithoutStock_newsInput
        | stock_news_related_symbolsUpsertWithWhereUniqueWithoutStock_newsInput[];
      createMany?: stock_news_related_symbolsCreateManyStock_newsInputEnvelope;
      set?:
        | stock_news_related_symbolsWhereUniqueInput
        | stock_news_related_symbolsWhereUniqueInput[];
      disconnect?:
        | stock_news_related_symbolsWhereUniqueInput
        | stock_news_related_symbolsWhereUniqueInput[];
      delete?:
        | stock_news_related_symbolsWhereUniqueInput
        | stock_news_related_symbolsWhereUniqueInput[];
      connect?:
        | stock_news_related_symbolsWhereUniqueInput
        | stock_news_related_symbolsWhereUniqueInput[];
      update?:
        | stock_news_related_symbolsUpdateWithWhereUniqueWithoutStock_newsInput
        | stock_news_related_symbolsUpdateWithWhereUniqueWithoutStock_newsInput[];
      updateMany?:
        | stock_news_related_symbolsUpdateManyWithWhereWithoutStock_newsInput
        | stock_news_related_symbolsUpdateManyWithWhereWithoutStock_newsInput[];
      deleteMany?:
        | stock_news_related_symbolsScalarWhereInput
        | stock_news_related_symbolsScalarWhereInput[];
    };

  export type stock_news_translationUncheckedUpdateManyWithoutStock_newsNestedInput =
    {
      create?:
        | XOR<
            stock_news_translationCreateWithoutStock_newsInput,
            stock_news_translationUncheckedCreateWithoutStock_newsInput
          >
        | stock_news_translationCreateWithoutStock_newsInput[]
        | stock_news_translationUncheckedCreateWithoutStock_newsInput[];
      connectOrCreate?:
        | stock_news_translationCreateOrConnectWithoutStock_newsInput
        | stock_news_translationCreateOrConnectWithoutStock_newsInput[];
      upsert?:
        | stock_news_translationUpsertWithWhereUniqueWithoutStock_newsInput
        | stock_news_translationUpsertWithWhereUniqueWithoutStock_newsInput[];
      createMany?: stock_news_translationCreateManyStock_newsInputEnvelope;
      set?:
        | stock_news_translationWhereUniqueInput
        | stock_news_translationWhereUniqueInput[];
      disconnect?:
        | stock_news_translationWhereUniqueInput
        | stock_news_translationWhereUniqueInput[];
      delete?:
        | stock_news_translationWhereUniqueInput
        | stock_news_translationWhereUniqueInput[];
      connect?:
        | stock_news_translationWhereUniqueInput
        | stock_news_translationWhereUniqueInput[];
      update?:
        | stock_news_translationUpdateWithWhereUniqueWithoutStock_newsInput
        | stock_news_translationUpdateWithWhereUniqueWithoutStock_newsInput[];
      updateMany?:
        | stock_news_translationUpdateManyWithWhereWithoutStock_newsInput
        | stock_news_translationUpdateManyWithWhereWithoutStock_newsInput[];
      deleteMany?:
        | stock_news_translationScalarWhereInput
        | stock_news_translationScalarWhereInput[];
    };

  export type stock_newsCreateNestedOneWithoutStock_news_read_historyInput = {
    create?: XOR<
      stock_newsCreateWithoutStock_news_read_historyInput,
      stock_newsUncheckedCreateWithoutStock_news_read_historyInput
    >;
    connectOrCreate?: stock_newsCreateOrConnectWithoutStock_news_read_historyInput;
    connect?: stock_newsWhereUniqueInput;
  };

  export type stock_newsUpdateOneRequiredWithoutStock_news_read_historyNestedInput =
    {
      create?: XOR<
        stock_newsCreateWithoutStock_news_read_historyInput,
        stock_newsUncheckedCreateWithoutStock_news_read_historyInput
      >;
      connectOrCreate?: stock_newsCreateOrConnectWithoutStock_news_read_historyInput;
      upsert?: stock_newsUpsertWithoutStock_news_read_historyInput;
      connect?: stock_newsWhereUniqueInput;
      update?: XOR<
        XOR<
          stock_newsUpdateToOneWithWhereWithoutStock_news_read_historyInput,
          stock_newsUpdateWithoutStock_news_read_historyInput
        >,
        stock_newsUncheckedUpdateWithoutStock_news_read_historyInput
      >;
    };

  export type stock_newsCreateNestedOneWithoutStock_news_related_symbolsInput =
    {
      create?: XOR<
        stock_newsCreateWithoutStock_news_related_symbolsInput,
        stock_newsUncheckedCreateWithoutStock_news_related_symbolsInput
      >;
      connectOrCreate?: stock_newsCreateOrConnectWithoutStock_news_related_symbolsInput;
      connect?: stock_newsWhereUniqueInput;
    };

  export type stock_newsUpdateOneRequiredWithoutStock_news_related_symbolsNestedInput =
    {
      create?: XOR<
        stock_newsCreateWithoutStock_news_related_symbolsInput,
        stock_newsUncheckedCreateWithoutStock_news_related_symbolsInput
      >;
      connectOrCreate?: stock_newsCreateOrConnectWithoutStock_news_related_symbolsInput;
      upsert?: stock_newsUpsertWithoutStock_news_related_symbolsInput;
      connect?: stock_newsWhereUniqueInput;
      update?: XOR<
        XOR<
          stock_newsUpdateToOneWithWhereWithoutStock_news_related_symbolsInput,
          stock_newsUpdateWithoutStock_news_related_symbolsInput
        >,
        stock_newsUncheckedUpdateWithoutStock_news_related_symbolsInput
      >;
    };

  export type stock_newsCreateNestedOneWithoutStock_news_translationInput = {
    create?: XOR<
      stock_newsCreateWithoutStock_news_translationInput,
      stock_newsUncheckedCreateWithoutStock_news_translationInput
    >;
    connectOrCreate?: stock_newsCreateOrConnectWithoutStock_news_translationInput;
    connect?: stock_newsWhereUniqueInput;
  };

  export type stock_newsUpdateOneRequiredWithoutStock_news_translationNestedInput =
    {
      create?: XOR<
        stock_newsCreateWithoutStock_news_translationInput,
        stock_newsUncheckedCreateWithoutStock_news_translationInput
      >;
      connectOrCreate?: stock_newsCreateOrConnectWithoutStock_news_translationInput;
      upsert?: stock_newsUpsertWithoutStock_news_translationInput;
      connect?: stock_newsWhereUniqueInput;
      update?: XOR<
        XOR<
          stock_newsUpdateToOneWithWhereWithoutStock_news_translationInput,
          stock_newsUpdateWithoutStock_news_translationInput
        >,
        stock_newsUncheckedUpdateWithoutStock_news_translationInput
      >;
    };

  export type permissionsCreateNestedManyWithoutSubscriptionsInput = {
    create?:
      | XOR<
          permissionsCreateWithoutSubscriptionsInput,
          permissionsUncheckedCreateWithoutSubscriptionsInput
        >
      | permissionsCreateWithoutSubscriptionsInput[]
      | permissionsUncheckedCreateWithoutSubscriptionsInput[];
    connectOrCreate?:
      | permissionsCreateOrConnectWithoutSubscriptionsInput
      | permissionsCreateOrConnectWithoutSubscriptionsInput[];
    createMany?: permissionsCreateManySubscriptionsInputEnvelope;
    connect?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[];
  };

  export type user_subscriptionsCreateNestedManyWithoutSubscriptionsInput = {
    create?:
      | XOR<
          user_subscriptionsCreateWithoutSubscriptionsInput,
          user_subscriptionsUncheckedCreateWithoutSubscriptionsInput
        >
      | user_subscriptionsCreateWithoutSubscriptionsInput[]
      | user_subscriptionsUncheckedCreateWithoutSubscriptionsInput[];
    connectOrCreate?:
      | user_subscriptionsCreateOrConnectWithoutSubscriptionsInput
      | user_subscriptionsCreateOrConnectWithoutSubscriptionsInput[];
    createMany?: user_subscriptionsCreateManySubscriptionsInputEnvelope;
    connect?:
      | user_subscriptionsWhereUniqueInput
      | user_subscriptionsWhereUniqueInput[];
  };

  export type permissionsUncheckedCreateNestedManyWithoutSubscriptionsInput = {
    create?:
      | XOR<
          permissionsCreateWithoutSubscriptionsInput,
          permissionsUncheckedCreateWithoutSubscriptionsInput
        >
      | permissionsCreateWithoutSubscriptionsInput[]
      | permissionsUncheckedCreateWithoutSubscriptionsInput[];
    connectOrCreate?:
      | permissionsCreateOrConnectWithoutSubscriptionsInput
      | permissionsCreateOrConnectWithoutSubscriptionsInput[];
    createMany?: permissionsCreateManySubscriptionsInputEnvelope;
    connect?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[];
  };

  export type user_subscriptionsUncheckedCreateNestedManyWithoutSubscriptionsInput =
    {
      create?:
        | XOR<
            user_subscriptionsCreateWithoutSubscriptionsInput,
            user_subscriptionsUncheckedCreateWithoutSubscriptionsInput
          >
        | user_subscriptionsCreateWithoutSubscriptionsInput[]
        | user_subscriptionsUncheckedCreateWithoutSubscriptionsInput[];
      connectOrCreate?:
        | user_subscriptionsCreateOrConnectWithoutSubscriptionsInput
        | user_subscriptionsCreateOrConnectWithoutSubscriptionsInput[];
      createMany?: user_subscriptionsCreateManySubscriptionsInputEnvelope;
      connect?:
        | user_subscriptionsWhereUniqueInput
        | user_subscriptionsWhereUniqueInput[];
    };

  export type permissionsUpdateManyWithoutSubscriptionsNestedInput = {
    create?:
      | XOR<
          permissionsCreateWithoutSubscriptionsInput,
          permissionsUncheckedCreateWithoutSubscriptionsInput
        >
      | permissionsCreateWithoutSubscriptionsInput[]
      | permissionsUncheckedCreateWithoutSubscriptionsInput[];
    connectOrCreate?:
      | permissionsCreateOrConnectWithoutSubscriptionsInput
      | permissionsCreateOrConnectWithoutSubscriptionsInput[];
    upsert?:
      | permissionsUpsertWithWhereUniqueWithoutSubscriptionsInput
      | permissionsUpsertWithWhereUniqueWithoutSubscriptionsInput[];
    createMany?: permissionsCreateManySubscriptionsInputEnvelope;
    set?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[];
    disconnect?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[];
    delete?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[];
    connect?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[];
    update?:
      | permissionsUpdateWithWhereUniqueWithoutSubscriptionsInput
      | permissionsUpdateWithWhereUniqueWithoutSubscriptionsInput[];
    updateMany?:
      | permissionsUpdateManyWithWhereWithoutSubscriptionsInput
      | permissionsUpdateManyWithWhereWithoutSubscriptionsInput[];
    deleteMany?: permissionsScalarWhereInput | permissionsScalarWhereInput[];
  };

  export type user_subscriptionsUpdateManyWithoutSubscriptionsNestedInput = {
    create?:
      | XOR<
          user_subscriptionsCreateWithoutSubscriptionsInput,
          user_subscriptionsUncheckedCreateWithoutSubscriptionsInput
        >
      | user_subscriptionsCreateWithoutSubscriptionsInput[]
      | user_subscriptionsUncheckedCreateWithoutSubscriptionsInput[];
    connectOrCreate?:
      | user_subscriptionsCreateOrConnectWithoutSubscriptionsInput
      | user_subscriptionsCreateOrConnectWithoutSubscriptionsInput[];
    upsert?:
      | user_subscriptionsUpsertWithWhereUniqueWithoutSubscriptionsInput
      | user_subscriptionsUpsertWithWhereUniqueWithoutSubscriptionsInput[];
    createMany?: user_subscriptionsCreateManySubscriptionsInputEnvelope;
    set?:
      | user_subscriptionsWhereUniqueInput
      | user_subscriptionsWhereUniqueInput[];
    disconnect?:
      | user_subscriptionsWhereUniqueInput
      | user_subscriptionsWhereUniqueInput[];
    delete?:
      | user_subscriptionsWhereUniqueInput
      | user_subscriptionsWhereUniqueInput[];
    connect?:
      | user_subscriptionsWhereUniqueInput
      | user_subscriptionsWhereUniqueInput[];
    update?:
      | user_subscriptionsUpdateWithWhereUniqueWithoutSubscriptionsInput
      | user_subscriptionsUpdateWithWhereUniqueWithoutSubscriptionsInput[];
    updateMany?:
      | user_subscriptionsUpdateManyWithWhereWithoutSubscriptionsInput
      | user_subscriptionsUpdateManyWithWhereWithoutSubscriptionsInput[];
    deleteMany?:
      | user_subscriptionsScalarWhereInput
      | user_subscriptionsScalarWhereInput[];
  };

  export type permissionsUncheckedUpdateManyWithoutSubscriptionsNestedInput = {
    create?:
      | XOR<
          permissionsCreateWithoutSubscriptionsInput,
          permissionsUncheckedCreateWithoutSubscriptionsInput
        >
      | permissionsCreateWithoutSubscriptionsInput[]
      | permissionsUncheckedCreateWithoutSubscriptionsInput[];
    connectOrCreate?:
      | permissionsCreateOrConnectWithoutSubscriptionsInput
      | permissionsCreateOrConnectWithoutSubscriptionsInput[];
    upsert?:
      | permissionsUpsertWithWhereUniqueWithoutSubscriptionsInput
      | permissionsUpsertWithWhereUniqueWithoutSubscriptionsInput[];
    createMany?: permissionsCreateManySubscriptionsInputEnvelope;
    set?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[];
    disconnect?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[];
    delete?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[];
    connect?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[];
    update?:
      | permissionsUpdateWithWhereUniqueWithoutSubscriptionsInput
      | permissionsUpdateWithWhereUniqueWithoutSubscriptionsInput[];
    updateMany?:
      | permissionsUpdateManyWithWhereWithoutSubscriptionsInput
      | permissionsUpdateManyWithWhereWithoutSubscriptionsInput[];
    deleteMany?: permissionsScalarWhereInput | permissionsScalarWhereInput[];
  };

  export type user_subscriptionsUncheckedUpdateManyWithoutSubscriptionsNestedInput =
    {
      create?:
        | XOR<
            user_subscriptionsCreateWithoutSubscriptionsInput,
            user_subscriptionsUncheckedCreateWithoutSubscriptionsInput
          >
        | user_subscriptionsCreateWithoutSubscriptionsInput[]
        | user_subscriptionsUncheckedCreateWithoutSubscriptionsInput[];
      connectOrCreate?:
        | user_subscriptionsCreateOrConnectWithoutSubscriptionsInput
        | user_subscriptionsCreateOrConnectWithoutSubscriptionsInput[];
      upsert?:
        | user_subscriptionsUpsertWithWhereUniqueWithoutSubscriptionsInput
        | user_subscriptionsUpsertWithWhereUniqueWithoutSubscriptionsInput[];
      createMany?: user_subscriptionsCreateManySubscriptionsInputEnvelope;
      set?:
        | user_subscriptionsWhereUniqueInput
        | user_subscriptionsWhereUniqueInput[];
      disconnect?:
        | user_subscriptionsWhereUniqueInput
        | user_subscriptionsWhereUniqueInput[];
      delete?:
        | user_subscriptionsWhereUniqueInput
        | user_subscriptionsWhereUniqueInput[];
      connect?:
        | user_subscriptionsWhereUniqueInput
        | user_subscriptionsWhereUniqueInput[];
      update?:
        | user_subscriptionsUpdateWithWhereUniqueWithoutSubscriptionsInput
        | user_subscriptionsUpdateWithWhereUniqueWithoutSubscriptionsInput[];
      updateMany?:
        | user_subscriptionsUpdateManyWithWhereWithoutSubscriptionsInput
        | user_subscriptionsUpdateManyWithWhereWithoutSubscriptionsInput[];
      deleteMany?:
        | user_subscriptionsScalarWhereInput
        | user_subscriptionsScalarWhereInput[];
    };

  export type superinvestor_holdings_listCreateNestedManyWithoutSuperinvestor_holdingsInput =
    {
      create?:
        | XOR<
            superinvestor_holdings_listCreateWithoutSuperinvestor_holdingsInput,
            superinvestor_holdings_listUncheckedCreateWithoutSuperinvestor_holdingsInput
          >
        | superinvestor_holdings_listCreateWithoutSuperinvestor_holdingsInput[]
        | superinvestor_holdings_listUncheckedCreateWithoutSuperinvestor_holdingsInput[];
      connectOrCreate?:
        | superinvestor_holdings_listCreateOrConnectWithoutSuperinvestor_holdingsInput
        | superinvestor_holdings_listCreateOrConnectWithoutSuperinvestor_holdingsInput[];
      createMany?: superinvestor_holdings_listCreateManySuperinvestor_holdingsInputEnvelope;
      connect?:
        | superinvestor_holdings_listWhereUniqueInput
        | superinvestor_holdings_listWhereUniqueInput[];
    };

  export type superinvestor_sector_analysisCreateNestedManyWithoutSuperinvestor_holdingsInput =
    {
      create?:
        | XOR<
            superinvestor_sector_analysisCreateWithoutSuperinvestor_holdingsInput,
            superinvestor_sector_analysisUncheckedCreateWithoutSuperinvestor_holdingsInput
          >
        | superinvestor_sector_analysisCreateWithoutSuperinvestor_holdingsInput[]
        | superinvestor_sector_analysisUncheckedCreateWithoutSuperinvestor_holdingsInput[];
      connectOrCreate?:
        | superinvestor_sector_analysisCreateOrConnectWithoutSuperinvestor_holdingsInput
        | superinvestor_sector_analysisCreateOrConnectWithoutSuperinvestor_holdingsInput[];
      createMany?: superinvestor_sector_analysisCreateManySuperinvestor_holdingsInputEnvelope;
      connect?:
        | superinvestor_sector_analysisWhereUniqueInput
        | superinvestor_sector_analysisWhereUniqueInput[];
    };

  export type superinvestor_holdings_listUncheckedCreateNestedManyWithoutSuperinvestor_holdingsInput =
    {
      create?:
        | XOR<
            superinvestor_holdings_listCreateWithoutSuperinvestor_holdingsInput,
            superinvestor_holdings_listUncheckedCreateWithoutSuperinvestor_holdingsInput
          >
        | superinvestor_holdings_listCreateWithoutSuperinvestor_holdingsInput[]
        | superinvestor_holdings_listUncheckedCreateWithoutSuperinvestor_holdingsInput[];
      connectOrCreate?:
        | superinvestor_holdings_listCreateOrConnectWithoutSuperinvestor_holdingsInput
        | superinvestor_holdings_listCreateOrConnectWithoutSuperinvestor_holdingsInput[];
      createMany?: superinvestor_holdings_listCreateManySuperinvestor_holdingsInputEnvelope;
      connect?:
        | superinvestor_holdings_listWhereUniqueInput
        | superinvestor_holdings_listWhereUniqueInput[];
    };

  export type superinvestor_sector_analysisUncheckedCreateNestedManyWithoutSuperinvestor_holdingsInput =
    {
      create?:
        | XOR<
            superinvestor_sector_analysisCreateWithoutSuperinvestor_holdingsInput,
            superinvestor_sector_analysisUncheckedCreateWithoutSuperinvestor_holdingsInput
          >
        | superinvestor_sector_analysisCreateWithoutSuperinvestor_holdingsInput[]
        | superinvestor_sector_analysisUncheckedCreateWithoutSuperinvestor_holdingsInput[];
      connectOrCreate?:
        | superinvestor_sector_analysisCreateOrConnectWithoutSuperinvestor_holdingsInput
        | superinvestor_sector_analysisCreateOrConnectWithoutSuperinvestor_holdingsInput[];
      createMany?: superinvestor_sector_analysisCreateManySuperinvestor_holdingsInputEnvelope;
      connect?:
        | superinvestor_sector_analysisWhereUniqueInput
        | superinvestor_sector_analysisWhereUniqueInput[];
    };

  export type superinvestor_holdings_listUpdateManyWithoutSuperinvestor_holdingsNestedInput =
    {
      create?:
        | XOR<
            superinvestor_holdings_listCreateWithoutSuperinvestor_holdingsInput,
            superinvestor_holdings_listUncheckedCreateWithoutSuperinvestor_holdingsInput
          >
        | superinvestor_holdings_listCreateWithoutSuperinvestor_holdingsInput[]
        | superinvestor_holdings_listUncheckedCreateWithoutSuperinvestor_holdingsInput[];
      connectOrCreate?:
        | superinvestor_holdings_listCreateOrConnectWithoutSuperinvestor_holdingsInput
        | superinvestor_holdings_listCreateOrConnectWithoutSuperinvestor_holdingsInput[];
      upsert?:
        | superinvestor_holdings_listUpsertWithWhereUniqueWithoutSuperinvestor_holdingsInput
        | superinvestor_holdings_listUpsertWithWhereUniqueWithoutSuperinvestor_holdingsInput[];
      createMany?: superinvestor_holdings_listCreateManySuperinvestor_holdingsInputEnvelope;
      set?:
        | superinvestor_holdings_listWhereUniqueInput
        | superinvestor_holdings_listWhereUniqueInput[];
      disconnect?:
        | superinvestor_holdings_listWhereUniqueInput
        | superinvestor_holdings_listWhereUniqueInput[];
      delete?:
        | superinvestor_holdings_listWhereUniqueInput
        | superinvestor_holdings_listWhereUniqueInput[];
      connect?:
        | superinvestor_holdings_listWhereUniqueInput
        | superinvestor_holdings_listWhereUniqueInput[];
      update?:
        | superinvestor_holdings_listUpdateWithWhereUniqueWithoutSuperinvestor_holdingsInput
        | superinvestor_holdings_listUpdateWithWhereUniqueWithoutSuperinvestor_holdingsInput[];
      updateMany?:
        | superinvestor_holdings_listUpdateManyWithWhereWithoutSuperinvestor_holdingsInput
        | superinvestor_holdings_listUpdateManyWithWhereWithoutSuperinvestor_holdingsInput[];
      deleteMany?:
        | superinvestor_holdings_listScalarWhereInput
        | superinvestor_holdings_listScalarWhereInput[];
    };

  export type superinvestor_sector_analysisUpdateManyWithoutSuperinvestor_holdingsNestedInput =
    {
      create?:
        | XOR<
            superinvestor_sector_analysisCreateWithoutSuperinvestor_holdingsInput,
            superinvestor_sector_analysisUncheckedCreateWithoutSuperinvestor_holdingsInput
          >
        | superinvestor_sector_analysisCreateWithoutSuperinvestor_holdingsInput[]
        | superinvestor_sector_analysisUncheckedCreateWithoutSuperinvestor_holdingsInput[];
      connectOrCreate?:
        | superinvestor_sector_analysisCreateOrConnectWithoutSuperinvestor_holdingsInput
        | superinvestor_sector_analysisCreateOrConnectWithoutSuperinvestor_holdingsInput[];
      upsert?:
        | superinvestor_sector_analysisUpsertWithWhereUniqueWithoutSuperinvestor_holdingsInput
        | superinvestor_sector_analysisUpsertWithWhereUniqueWithoutSuperinvestor_holdingsInput[];
      createMany?: superinvestor_sector_analysisCreateManySuperinvestor_holdingsInputEnvelope;
      set?:
        | superinvestor_sector_analysisWhereUniqueInput
        | superinvestor_sector_analysisWhereUniqueInput[];
      disconnect?:
        | superinvestor_sector_analysisWhereUniqueInput
        | superinvestor_sector_analysisWhereUniqueInput[];
      delete?:
        | superinvestor_sector_analysisWhereUniqueInput
        | superinvestor_sector_analysisWhereUniqueInput[];
      connect?:
        | superinvestor_sector_analysisWhereUniqueInput
        | superinvestor_sector_analysisWhereUniqueInput[];
      update?:
        | superinvestor_sector_analysisUpdateWithWhereUniqueWithoutSuperinvestor_holdingsInput
        | superinvestor_sector_analysisUpdateWithWhereUniqueWithoutSuperinvestor_holdingsInput[];
      updateMany?:
        | superinvestor_sector_analysisUpdateManyWithWhereWithoutSuperinvestor_holdingsInput
        | superinvestor_sector_analysisUpdateManyWithWhereWithoutSuperinvestor_holdingsInput[];
      deleteMany?:
        | superinvestor_sector_analysisScalarWhereInput
        | superinvestor_sector_analysisScalarWhereInput[];
    };

  export type superinvestor_holdings_listUncheckedUpdateManyWithoutSuperinvestor_holdingsNestedInput =
    {
      create?:
        | XOR<
            superinvestor_holdings_listCreateWithoutSuperinvestor_holdingsInput,
            superinvestor_holdings_listUncheckedCreateWithoutSuperinvestor_holdingsInput
          >
        | superinvestor_holdings_listCreateWithoutSuperinvestor_holdingsInput[]
        | superinvestor_holdings_listUncheckedCreateWithoutSuperinvestor_holdingsInput[];
      connectOrCreate?:
        | superinvestor_holdings_listCreateOrConnectWithoutSuperinvestor_holdingsInput
        | superinvestor_holdings_listCreateOrConnectWithoutSuperinvestor_holdingsInput[];
      upsert?:
        | superinvestor_holdings_listUpsertWithWhereUniqueWithoutSuperinvestor_holdingsInput
        | superinvestor_holdings_listUpsertWithWhereUniqueWithoutSuperinvestor_holdingsInput[];
      createMany?: superinvestor_holdings_listCreateManySuperinvestor_holdingsInputEnvelope;
      set?:
        | superinvestor_holdings_listWhereUniqueInput
        | superinvestor_holdings_listWhereUniqueInput[];
      disconnect?:
        | superinvestor_holdings_listWhereUniqueInput
        | superinvestor_holdings_listWhereUniqueInput[];
      delete?:
        | superinvestor_holdings_listWhereUniqueInput
        | superinvestor_holdings_listWhereUniqueInput[];
      connect?:
        | superinvestor_holdings_listWhereUniqueInput
        | superinvestor_holdings_listWhereUniqueInput[];
      update?:
        | superinvestor_holdings_listUpdateWithWhereUniqueWithoutSuperinvestor_holdingsInput
        | superinvestor_holdings_listUpdateWithWhereUniqueWithoutSuperinvestor_holdingsInput[];
      updateMany?:
        | superinvestor_holdings_listUpdateManyWithWhereWithoutSuperinvestor_holdingsInput
        | superinvestor_holdings_listUpdateManyWithWhereWithoutSuperinvestor_holdingsInput[];
      deleteMany?:
        | superinvestor_holdings_listScalarWhereInput
        | superinvestor_holdings_listScalarWhereInput[];
    };

  export type superinvestor_sector_analysisUncheckedUpdateManyWithoutSuperinvestor_holdingsNestedInput =
    {
      create?:
        | XOR<
            superinvestor_sector_analysisCreateWithoutSuperinvestor_holdingsInput,
            superinvestor_sector_analysisUncheckedCreateWithoutSuperinvestor_holdingsInput
          >
        | superinvestor_sector_analysisCreateWithoutSuperinvestor_holdingsInput[]
        | superinvestor_sector_analysisUncheckedCreateWithoutSuperinvestor_holdingsInput[];
      connectOrCreate?:
        | superinvestor_sector_analysisCreateOrConnectWithoutSuperinvestor_holdingsInput
        | superinvestor_sector_analysisCreateOrConnectWithoutSuperinvestor_holdingsInput[];
      upsert?:
        | superinvestor_sector_analysisUpsertWithWhereUniqueWithoutSuperinvestor_holdingsInput
        | superinvestor_sector_analysisUpsertWithWhereUniqueWithoutSuperinvestor_holdingsInput[];
      createMany?: superinvestor_sector_analysisCreateManySuperinvestor_holdingsInputEnvelope;
      set?:
        | superinvestor_sector_analysisWhereUniqueInput
        | superinvestor_sector_analysisWhereUniqueInput[];
      disconnect?:
        | superinvestor_sector_analysisWhereUniqueInput
        | superinvestor_sector_analysisWhereUniqueInput[];
      delete?:
        | superinvestor_sector_analysisWhereUniqueInput
        | superinvestor_sector_analysisWhereUniqueInput[];
      connect?:
        | superinvestor_sector_analysisWhereUniqueInput
        | superinvestor_sector_analysisWhereUniqueInput[];
      update?:
        | superinvestor_sector_analysisUpdateWithWhereUniqueWithoutSuperinvestor_holdingsInput
        | superinvestor_sector_analysisUpdateWithWhereUniqueWithoutSuperinvestor_holdingsInput[];
      updateMany?:
        | superinvestor_sector_analysisUpdateManyWithWhereWithoutSuperinvestor_holdingsInput
        | superinvestor_sector_analysisUpdateManyWithWhereWithoutSuperinvestor_holdingsInput[];
      deleteMany?:
        | superinvestor_sector_analysisScalarWhereInput
        | superinvestor_sector_analysisScalarWhereInput[];
    };

  export type superinvestor_holdingsCreateNestedOneWithoutSuperinvestor_holdings_listInput =
    {
      create?: XOR<
        superinvestor_holdingsCreateWithoutSuperinvestor_holdings_listInput,
        superinvestor_holdingsUncheckedCreateWithoutSuperinvestor_holdings_listInput
      >;
      connectOrCreate?: superinvestor_holdingsCreateOrConnectWithoutSuperinvestor_holdings_listInput;
      connect?: superinvestor_holdingsWhereUniqueInput;
    };

  export type superinvestor_holdingsUpdateOneWithoutSuperinvestor_holdings_listNestedInput =
    {
      create?: XOR<
        superinvestor_holdingsCreateWithoutSuperinvestor_holdings_listInput,
        superinvestor_holdingsUncheckedCreateWithoutSuperinvestor_holdings_listInput
      >;
      connectOrCreate?: superinvestor_holdingsCreateOrConnectWithoutSuperinvestor_holdings_listInput;
      upsert?: superinvestor_holdingsUpsertWithoutSuperinvestor_holdings_listInput;
      disconnect?: superinvestor_holdingsWhereInput | boolean;
      delete?: superinvestor_holdingsWhereInput | boolean;
      connect?: superinvestor_holdingsWhereUniqueInput;
      update?: XOR<
        XOR<
          superinvestor_holdingsUpdateToOneWithWhereWithoutSuperinvestor_holdings_listInput,
          superinvestor_holdingsUpdateWithoutSuperinvestor_holdings_listInput
        >,
        superinvestor_holdingsUncheckedUpdateWithoutSuperinvestor_holdings_listInput
      >;
    };

  export type superinvestor_holdingsCreateNestedOneWithoutSuperinvestor_sector_analysisInput =
    {
      create?: XOR<
        superinvestor_holdingsCreateWithoutSuperinvestor_sector_analysisInput,
        superinvestor_holdingsUncheckedCreateWithoutSuperinvestor_sector_analysisInput
      >;
      connectOrCreate?: superinvestor_holdingsCreateOrConnectWithoutSuperinvestor_sector_analysisInput;
      connect?: superinvestor_holdingsWhereUniqueInput;
    };

  export type superinvestor_holdingsUpdateOneWithoutSuperinvestor_sector_analysisNestedInput =
    {
      create?: XOR<
        superinvestor_holdingsCreateWithoutSuperinvestor_sector_analysisInput,
        superinvestor_holdingsUncheckedCreateWithoutSuperinvestor_sector_analysisInput
      >;
      connectOrCreate?: superinvestor_holdingsCreateOrConnectWithoutSuperinvestor_sector_analysisInput;
      upsert?: superinvestor_holdingsUpsertWithoutSuperinvestor_sector_analysisInput;
      disconnect?: superinvestor_holdingsWhereInput | boolean;
      delete?: superinvestor_holdingsWhereInput | boolean;
      connect?: superinvestor_holdingsWhereUniqueInput;
      update?: XOR<
        XOR<
          superinvestor_holdingsUpdateToOneWithWhereWithoutSuperinvestor_sector_analysisInput,
          superinvestor_holdingsUpdateWithoutSuperinvestor_sector_analysisInput
        >,
        superinvestor_holdingsUncheckedUpdateWithoutSuperinvestor_sector_analysisInput
      >;
    };

  export type subscriptionsCreateNestedOneWithoutUser_subscriptionsInput = {
    create?: XOR<
      subscriptionsCreateWithoutUser_subscriptionsInput,
      subscriptionsUncheckedCreateWithoutUser_subscriptionsInput
    >;
    connectOrCreate?: subscriptionsCreateOrConnectWithoutUser_subscriptionsInput;
    connect?: subscriptionsWhereUniqueInput;
  };

  export type subscriptionsUpdateOneWithoutUser_subscriptionsNestedInput = {
    create?: XOR<
      subscriptionsCreateWithoutUser_subscriptionsInput,
      subscriptionsUncheckedCreateWithoutUser_subscriptionsInput
    >;
    connectOrCreate?: subscriptionsCreateOrConnectWithoutUser_subscriptionsInput;
    upsert?: subscriptionsUpsertWithoutUser_subscriptionsInput;
    disconnect?: subscriptionsWhereInput | boolean;
    delete?: subscriptionsWhereInput | boolean;
    connect?: subscriptionsWhereUniqueInput;
    update?: XOR<
      XOR<
        subscriptionsUpdateToOneWithWhereWithoutUser_subscriptionsInput,
        subscriptionsUpdateWithoutUser_subscriptionsInput
      >,
      subscriptionsUncheckedUpdateWithoutUser_subscriptionsInput
    >;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedUuidFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedBoolNullableFilter<$PrismaModel>;
    _max?: NestedBoolNullableFilter<$PrismaModel>;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>
      >;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
      | null;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>
        | null;
      in?:
        | Decimal[]
        | DecimalJsLike[]
        | number[]
        | string[]
        | ListDecimalFieldRefInput<$PrismaModel>
        | null;
      notIn?:
        | Decimal[]
        | DecimalJsLike[]
        | number[]
        | string[]
        | ListDecimalFieldRefInput<$PrismaModel>
        | null;
      lt?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      lte?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      gt?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      gte?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      not?:
        | NestedDecimalNullableWithAggregatesFilter<$PrismaModel>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _avg?: NestedDecimalNullableFilter<$PrismaModel>;
      _sum?: NestedDecimalNullableFilter<$PrismaModel>;
      _min?: NestedDecimalNullableFilter<$PrismaModel>;
      _max?: NestedDecimalNullableFilter<$PrismaModel>;
    };

  export type NestedEnumasset_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.asset_type | Enumasset_typeFieldRefInput<$PrismaModel>;
    in?: $Enums.asset_type[] | ListEnumasset_typeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.asset_type[] | ListEnumasset_typeFieldRefInput<$PrismaModel>;
    not?: NestedEnumasset_typeFilter<$PrismaModel> | $Enums.asset_type;
  };

  export type NestedEnumalert_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.alert_type | Enumalert_typeFieldRefInput<$PrismaModel>;
    in?: $Enums.alert_type[] | ListEnumalert_typeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.alert_type[] | ListEnumalert_typeFieldRefInput<$PrismaModel>;
    not?: NestedEnumalert_typeFilter<$PrismaModel> | $Enums.alert_type;
  };

  export type NestedEnumalert_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.alert_status | Enumalert_statusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.alert_status[]
      | ListEnumalert_statusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.alert_status[]
      | ListEnumalert_statusFieldRefInput<$PrismaModel>;
    not?: NestedEnumalert_statusFilter<$PrismaModel> | $Enums.alert_status;
  };

  export type NestedEnumasset_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.asset_type | Enumasset_typeFieldRefInput<$PrismaModel>;
    in?: $Enums.asset_type[] | ListEnumasset_typeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.asset_type[] | ListEnumasset_typeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumasset_typeWithAggregatesFilter<$PrismaModel>
      | $Enums.asset_type;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumasset_typeFilter<$PrismaModel>;
    _max?: NestedEnumasset_typeFilter<$PrismaModel>;
  };

  export type NestedEnumalert_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.alert_type | Enumalert_typeFieldRefInput<$PrismaModel>;
    in?: $Enums.alert_type[] | ListEnumalert_typeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.alert_type[] | ListEnumalert_typeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumalert_typeWithAggregatesFilter<$PrismaModel>
      | $Enums.alert_type;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumalert_typeFilter<$PrismaModel>;
    _max?: NestedEnumalert_typeFilter<$PrismaModel>;
  };

  export type NestedEnumalert_statusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.alert_status
        | Enumalert_statusFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.alert_status[]
        | ListEnumalert_statusFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.alert_status[]
        | ListEnumalert_statusFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumalert_statusWithAggregatesFilter<$PrismaModel>
        | $Enums.alert_status;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumalert_statusFilter<$PrismaModel>;
      _max?: NestedEnumalert_statusFilter<$PrismaModel>;
    };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type commentsCreateWithoutOther_commentsInput = {
    symbol: string;
    content: string;
    user_id: number;
    likes?: number | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    comments?: commentsCreateNestedOneWithoutOther_commentsInput;
  };

  export type commentsUncheckedCreateWithoutOther_commentsInput = {
    id?: number;
    symbol: string;
    content: string;
    user_id: number;
    parent_id?: number | null;
    likes?: number | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type commentsCreateOrConnectWithoutOther_commentsInput = {
    where: commentsWhereUniqueInput;
    create: XOR<
      commentsCreateWithoutOther_commentsInput,
      commentsUncheckedCreateWithoutOther_commentsInput
    >;
  };

  export type commentsCreateWithoutCommentsInput = {
    symbol: string;
    content: string;
    user_id: number;
    likes?: number | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    other_comments?: commentsCreateNestedManyWithoutCommentsInput;
  };

  export type commentsUncheckedCreateWithoutCommentsInput = {
    id?: number;
    symbol: string;
    content: string;
    user_id: number;
    likes?: number | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    other_comments?: commentsUncheckedCreateNestedManyWithoutCommentsInput;
  };

  export type commentsCreateOrConnectWithoutCommentsInput = {
    where: commentsWhereUniqueInput;
    create: XOR<
      commentsCreateWithoutCommentsInput,
      commentsUncheckedCreateWithoutCommentsInput
    >;
  };

  export type commentsCreateManyCommentsInputEnvelope = {
    data: commentsCreateManyCommentsInput | commentsCreateManyCommentsInput[];
    skipDuplicates?: boolean;
  };

  export type commentsUpsertWithoutOther_commentsInput = {
    update: XOR<
      commentsUpdateWithoutOther_commentsInput,
      commentsUncheckedUpdateWithoutOther_commentsInput
    >;
    create: XOR<
      commentsCreateWithoutOther_commentsInput,
      commentsUncheckedCreateWithoutOther_commentsInput
    >;
    where?: commentsWhereInput;
  };

  export type commentsUpdateToOneWithWhereWithoutOther_commentsInput = {
    where?: commentsWhereInput;
    data: XOR<
      commentsUpdateWithoutOther_commentsInput,
      commentsUncheckedUpdateWithoutOther_commentsInput
    >;
  };

  export type commentsUpdateWithoutOther_commentsInput = {
    symbol?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    likes?: NullableIntFieldUpdateOperationsInput | number | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    comments?: commentsUpdateOneWithoutOther_commentsNestedInput;
  };

  export type commentsUncheckedUpdateWithoutOther_commentsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null;
    likes?: NullableIntFieldUpdateOperationsInput | number | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type commentsUpsertWithWhereUniqueWithoutCommentsInput = {
    where: commentsWhereUniqueInput;
    update: XOR<
      commentsUpdateWithoutCommentsInput,
      commentsUncheckedUpdateWithoutCommentsInput
    >;
    create: XOR<
      commentsCreateWithoutCommentsInput,
      commentsUncheckedCreateWithoutCommentsInput
    >;
  };

  export type commentsUpdateWithWhereUniqueWithoutCommentsInput = {
    where: commentsWhereUniqueInput;
    data: XOR<
      commentsUpdateWithoutCommentsInput,
      commentsUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type commentsUpdateManyWithWhereWithoutCommentsInput = {
    where: commentsScalarWhereInput;
    data: XOR<
      commentsUpdateManyMutationInput,
      commentsUncheckedUpdateManyWithoutCommentsInput
    >;
  };

  export type commentsScalarWhereInput = {
    AND?: commentsScalarWhereInput | commentsScalarWhereInput[];
    OR?: commentsScalarWhereInput[];
    NOT?: commentsScalarWhereInput | commentsScalarWhereInput[];
    id?: IntFilter<'comments'> | number;
    symbol?: StringFilter<'comments'> | string;
    content?: StringFilter<'comments'> | string;
    user_id?: IntFilter<'comments'> | number;
    parent_id?: IntNullableFilter<'comments'> | number | null;
    likes?: IntNullableFilter<'comments'> | number | null;
    created_at?: DateTimeNullableFilter<'comments'> | Date | string | null;
    updated_at?: DateTimeNullableFilter<'comments'> | Date | string | null;
  };

  export type stock_newsCreateWithoutNews_commentsInput = {
    id?: string;
    symbol: string;
    exchange?: string | null;
    title: string;
    content?: string | null;
    summary?: string | null;
    image_url?: string | null;
    source_url?: string | null;
    publisher?: string | null;
    published_date: Date | string;
    language?: string | null;
    view_count?: number | null;
    is_featured?: boolean | null;
    is_hot?: boolean | null;
    tags?: stock_newsCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: number | null;
    share_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    stock_news_read_history?: stock_news_read_historyCreateNestedManyWithoutStock_newsInput;
    stock_news_related_symbols?: stock_news_related_symbolsCreateNestedManyWithoutStock_newsInput;
    stock_news_translation?: stock_news_translationCreateNestedManyWithoutStock_newsInput;
  };

  export type stock_newsUncheckedCreateWithoutNews_commentsInput = {
    id?: string;
    symbol: string;
    exchange?: string | null;
    title: string;
    content?: string | null;
    summary?: string | null;
    image_url?: string | null;
    source_url?: string | null;
    publisher?: string | null;
    published_date: Date | string;
    language?: string | null;
    view_count?: number | null;
    is_featured?: boolean | null;
    is_hot?: boolean | null;
    tags?: stock_newsCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: number | null;
    share_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    stock_news_read_history?: stock_news_read_historyUncheckedCreateNestedManyWithoutStock_newsInput;
    stock_news_related_symbols?: stock_news_related_symbolsUncheckedCreateNestedManyWithoutStock_newsInput;
    stock_news_translation?: stock_news_translationUncheckedCreateNestedManyWithoutStock_newsInput;
  };

  export type stock_newsCreateOrConnectWithoutNews_commentsInput = {
    where: stock_newsWhereUniqueInput;
    create: XOR<
      stock_newsCreateWithoutNews_commentsInput,
      stock_newsUncheckedCreateWithoutNews_commentsInput
    >;
  };

  export type news_commentsCreateWithoutOther_news_commentsInput = {
    content: string;
    like_count?: number | null;
    reply_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    user_id: number;
    stock_news: stock_newsCreateNestedOneWithoutNews_commentsInput;
    news_comments?: news_commentsCreateNestedOneWithoutOther_news_commentsInput;
  };

  export type news_commentsUncheckedCreateWithoutOther_news_commentsInput = {
    id?: number;
    news_id: string;
    parent_comment_id?: number | null;
    content: string;
    like_count?: number | null;
    reply_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    user_id: number;
  };

  export type news_commentsCreateOrConnectWithoutOther_news_commentsInput = {
    where: news_commentsWhereUniqueInput;
    create: XOR<
      news_commentsCreateWithoutOther_news_commentsInput,
      news_commentsUncheckedCreateWithoutOther_news_commentsInput
    >;
  };

  export type news_commentsCreateWithoutNews_commentsInput = {
    content: string;
    like_count?: number | null;
    reply_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    user_id: number;
    stock_news: stock_newsCreateNestedOneWithoutNews_commentsInput;
    other_news_comments?: news_commentsCreateNestedManyWithoutNews_commentsInput;
  };

  export type news_commentsUncheckedCreateWithoutNews_commentsInput = {
    id?: number;
    news_id: string;
    content: string;
    like_count?: number | null;
    reply_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    user_id: number;
    other_news_comments?: news_commentsUncheckedCreateNestedManyWithoutNews_commentsInput;
  };

  export type news_commentsCreateOrConnectWithoutNews_commentsInput = {
    where: news_commentsWhereUniqueInput;
    create: XOR<
      news_commentsCreateWithoutNews_commentsInput,
      news_commentsUncheckedCreateWithoutNews_commentsInput
    >;
  };

  export type news_commentsCreateManyNews_commentsInputEnvelope = {
    data:
      | news_commentsCreateManyNews_commentsInput
      | news_commentsCreateManyNews_commentsInput[];
    skipDuplicates?: boolean;
  };

  export type stock_newsUpsertWithoutNews_commentsInput = {
    update: XOR<
      stock_newsUpdateWithoutNews_commentsInput,
      stock_newsUncheckedUpdateWithoutNews_commentsInput
    >;
    create: XOR<
      stock_newsCreateWithoutNews_commentsInput,
      stock_newsUncheckedCreateWithoutNews_commentsInput
    >;
    where?: stock_newsWhereInput;
  };

  export type stock_newsUpdateToOneWithWhereWithoutNews_commentsInput = {
    where?: stock_newsWhereInput;
    data: XOR<
      stock_newsUpdateWithoutNews_commentsInput,
      stock_newsUncheckedUpdateWithoutNews_commentsInput
    >;
  };

  export type stock_newsUpdateWithoutNews_commentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    image_url?: NullableStringFieldUpdateOperationsInput | string | null;
    source_url?: NullableStringFieldUpdateOperationsInput | string | null;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    view_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_featured?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    is_hot?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    tags?: stock_newsUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    share_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    stock_news_read_history?: stock_news_read_historyUpdateManyWithoutStock_newsNestedInput;
    stock_news_related_symbols?: stock_news_related_symbolsUpdateManyWithoutStock_newsNestedInput;
    stock_news_translation?: stock_news_translationUpdateManyWithoutStock_newsNestedInput;
  };

  export type stock_newsUncheckedUpdateWithoutNews_commentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    image_url?: NullableStringFieldUpdateOperationsInput | string | null;
    source_url?: NullableStringFieldUpdateOperationsInput | string | null;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    view_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_featured?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    is_hot?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    tags?: stock_newsUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    share_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    stock_news_read_history?: stock_news_read_historyUncheckedUpdateManyWithoutStock_newsNestedInput;
    stock_news_related_symbols?: stock_news_related_symbolsUncheckedUpdateManyWithoutStock_newsNestedInput;
    stock_news_translation?: stock_news_translationUncheckedUpdateManyWithoutStock_newsNestedInput;
  };

  export type news_commentsUpsertWithoutOther_news_commentsInput = {
    update: XOR<
      news_commentsUpdateWithoutOther_news_commentsInput,
      news_commentsUncheckedUpdateWithoutOther_news_commentsInput
    >;
    create: XOR<
      news_commentsCreateWithoutOther_news_commentsInput,
      news_commentsUncheckedCreateWithoutOther_news_commentsInput
    >;
    where?: news_commentsWhereInput;
  };

  export type news_commentsUpdateToOneWithWhereWithoutOther_news_commentsInput =
    {
      where?: news_commentsWhereInput;
      data: XOR<
        news_commentsUpdateWithoutOther_news_commentsInput,
        news_commentsUncheckedUpdateWithoutOther_news_commentsInput
      >;
    };

  export type news_commentsUpdateWithoutOther_news_commentsInput = {
    content?: StringFieldUpdateOperationsInput | string;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    reply_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    user_id?: IntFieldUpdateOperationsInput | number;
    stock_news?: stock_newsUpdateOneRequiredWithoutNews_commentsNestedInput;
    news_comments?: news_commentsUpdateOneWithoutOther_news_commentsNestedInput;
  };

  export type news_commentsUncheckedUpdateWithoutOther_news_commentsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    news_id?: StringFieldUpdateOperationsInput | string;
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null;
    content?: StringFieldUpdateOperationsInput | string;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    reply_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    user_id?: IntFieldUpdateOperationsInput | number;
  };

  export type news_commentsUpsertWithWhereUniqueWithoutNews_commentsInput = {
    where: news_commentsWhereUniqueInput;
    update: XOR<
      news_commentsUpdateWithoutNews_commentsInput,
      news_commentsUncheckedUpdateWithoutNews_commentsInput
    >;
    create: XOR<
      news_commentsCreateWithoutNews_commentsInput,
      news_commentsUncheckedCreateWithoutNews_commentsInput
    >;
  };

  export type news_commentsUpdateWithWhereUniqueWithoutNews_commentsInput = {
    where: news_commentsWhereUniqueInput;
    data: XOR<
      news_commentsUpdateWithoutNews_commentsInput,
      news_commentsUncheckedUpdateWithoutNews_commentsInput
    >;
  };

  export type news_commentsUpdateManyWithWhereWithoutNews_commentsInput = {
    where: news_commentsScalarWhereInput;
    data: XOR<
      news_commentsUpdateManyMutationInput,
      news_commentsUncheckedUpdateManyWithoutNews_commentsInput
    >;
  };

  export type news_commentsScalarWhereInput = {
    AND?: news_commentsScalarWhereInput | news_commentsScalarWhereInput[];
    OR?: news_commentsScalarWhereInput[];
    NOT?: news_commentsScalarWhereInput | news_commentsScalarWhereInput[];
    id?: IntFilter<'news_comments'> | number;
    news_id?: UuidFilter<'news_comments'> | string;
    parent_comment_id?: IntNullableFilter<'news_comments'> | number | null;
    content?: StringFilter<'news_comments'> | string;
    like_count?: IntNullableFilter<'news_comments'> | number | null;
    reply_count?: IntNullableFilter<'news_comments'> | number | null;
    is_active?: BoolNullableFilter<'news_comments'> | boolean | null;
    created_at?: DateTimeNullableFilter<'news_comments'> | Date | string | null;
    updated_at?: DateTimeNullableFilter<'news_comments'> | Date | string | null;
    user_id?: IntFilter<'news_comments'> | number;
  };

  export type subscriptionsCreateWithoutPermissionsInput = {
    name?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    features?: NullableJsonNullValueInput | InputJsonValue;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    stripe_price_id?: string | null;
    price_amount?: string | null;
    currency?: string | null;
    billing_interval?: string | null;
    is_active?: boolean | null;
    trial_days?: number | null;
    user_subscriptions?: user_subscriptionsCreateNestedManyWithoutSubscriptionsInput;
  };

  export type subscriptionsUncheckedCreateWithoutPermissionsInput = {
    subscription_id?: number;
    name?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    features?: NullableJsonNullValueInput | InputJsonValue;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    stripe_price_id?: string | null;
    price_amount?: string | null;
    currency?: string | null;
    billing_interval?: string | null;
    is_active?: boolean | null;
    trial_days?: number | null;
    user_subscriptions?: user_subscriptionsUncheckedCreateNestedManyWithoutSubscriptionsInput;
  };

  export type subscriptionsCreateOrConnectWithoutPermissionsInput = {
    where: subscriptionsWhereUniqueInput;
    create: XOR<
      subscriptionsCreateWithoutPermissionsInput,
      subscriptionsUncheckedCreateWithoutPermissionsInput
    >;
  };

  export type subscriptionsUpsertWithoutPermissionsInput = {
    update: XOR<
      subscriptionsUpdateWithoutPermissionsInput,
      subscriptionsUncheckedUpdateWithoutPermissionsInput
    >;
    create: XOR<
      subscriptionsCreateWithoutPermissionsInput,
      subscriptionsUncheckedCreateWithoutPermissionsInput
    >;
    where?: subscriptionsWhereInput;
  };

  export type subscriptionsUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: subscriptionsWhereInput;
    data: XOR<
      subscriptionsUpdateWithoutPermissionsInput,
      subscriptionsUncheckedUpdateWithoutPermissionsInput
    >;
  };

  export type subscriptionsUpdateWithoutPermissionsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    features?: NullableJsonNullValueInput | InputJsonValue;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    stripe_price_id?: NullableStringFieldUpdateOperationsInput | string | null;
    price_amount?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_interval?: NullableStringFieldUpdateOperationsInput | string | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    trial_days?: NullableIntFieldUpdateOperationsInput | number | null;
    user_subscriptions?: user_subscriptionsUpdateManyWithoutSubscriptionsNestedInput;
  };

  export type subscriptionsUncheckedUpdateWithoutPermissionsInput = {
    subscription_id?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    features?: NullableJsonNullValueInput | InputJsonValue;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    stripe_price_id?: NullableStringFieldUpdateOperationsInput | string | null;
    price_amount?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_interval?: NullableStringFieldUpdateOperationsInput | string | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    trial_days?: NullableIntFieldUpdateOperationsInput | number | null;
    user_subscriptions?: user_subscriptionsUncheckedUpdateManyWithoutSubscriptionsNestedInput;
  };

  export type news_commentsCreateWithoutStock_newsInput = {
    content: string;
    like_count?: number | null;
    reply_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    user_id: number;
    news_comments?: news_commentsCreateNestedOneWithoutOther_news_commentsInput;
    other_news_comments?: news_commentsCreateNestedManyWithoutNews_commentsInput;
  };

  export type news_commentsUncheckedCreateWithoutStock_newsInput = {
    id?: number;
    parent_comment_id?: number | null;
    content: string;
    like_count?: number | null;
    reply_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    user_id: number;
    other_news_comments?: news_commentsUncheckedCreateNestedManyWithoutNews_commentsInput;
  };

  export type news_commentsCreateOrConnectWithoutStock_newsInput = {
    where: news_commentsWhereUniqueInput;
    create: XOR<
      news_commentsCreateWithoutStock_newsInput,
      news_commentsUncheckedCreateWithoutStock_newsInput
    >;
  };

  export type news_commentsCreateManyStock_newsInputEnvelope = {
    data:
      | news_commentsCreateManyStock_newsInput
      | news_commentsCreateManyStock_newsInput[];
    skipDuplicates?: boolean;
  };

  export type stock_news_read_historyCreateWithoutStock_newsInput = {
    id?: string;
    user_id?: string | null;
    session_id?: string | null;
    read_at?: Date | string | null;
    language_read?: string | null;
    read_duration?: number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type stock_news_read_historyUncheckedCreateWithoutStock_newsInput = {
    id?: string;
    user_id?: string | null;
    session_id?: string | null;
    read_at?: Date | string | null;
    language_read?: string | null;
    read_duration?: number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type stock_news_read_historyCreateOrConnectWithoutStock_newsInput = {
    where: stock_news_read_historyWhereUniqueInput;
    create: XOR<
      stock_news_read_historyCreateWithoutStock_newsInput,
      stock_news_read_historyUncheckedCreateWithoutStock_newsInput
    >;
  };

  export type stock_news_read_historyCreateManyStock_newsInputEnvelope = {
    data:
      | stock_news_read_historyCreateManyStock_newsInput
      | stock_news_read_historyCreateManyStock_newsInput[];
    skipDuplicates?: boolean;
  };

  export type stock_news_related_symbolsCreateWithoutStock_newsInput = {
    id?: string;
    related_symbol: string;
    related_exchange?: string | null;
    is_primary?: boolean | null;
  };

  export type stock_news_related_symbolsUncheckedCreateWithoutStock_newsInput =
    {
      id?: string;
      related_symbol: string;
      related_exchange?: string | null;
      is_primary?: boolean | null;
    };

  export type stock_news_related_symbolsCreateOrConnectWithoutStock_newsInput =
    {
      where: stock_news_related_symbolsWhereUniqueInput;
      create: XOR<
        stock_news_related_symbolsCreateWithoutStock_newsInput,
        stock_news_related_symbolsUncheckedCreateWithoutStock_newsInput
      >;
    };

  export type stock_news_related_symbolsCreateManyStock_newsInputEnvelope = {
    data:
      | stock_news_related_symbolsCreateManyStock_newsInput
      | stock_news_related_symbolsCreateManyStock_newsInput[];
    skipDuplicates?: boolean;
  };

  export type stock_news_translationCreateWithoutStock_newsInput = {
    id?: string;
    language: string;
    title: string;
    content?: string | null;
    summary?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type stock_news_translationUncheckedCreateWithoutStock_newsInput = {
    id?: string;
    language: string;
    title: string;
    content?: string | null;
    summary?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type stock_news_translationCreateOrConnectWithoutStock_newsInput = {
    where: stock_news_translationWhereUniqueInput;
    create: XOR<
      stock_news_translationCreateWithoutStock_newsInput,
      stock_news_translationUncheckedCreateWithoutStock_newsInput
    >;
  };

  export type stock_news_translationCreateManyStock_newsInputEnvelope = {
    data:
      | stock_news_translationCreateManyStock_newsInput
      | stock_news_translationCreateManyStock_newsInput[];
    skipDuplicates?: boolean;
  };

  export type news_commentsUpsertWithWhereUniqueWithoutStock_newsInput = {
    where: news_commentsWhereUniqueInput;
    update: XOR<
      news_commentsUpdateWithoutStock_newsInput,
      news_commentsUncheckedUpdateWithoutStock_newsInput
    >;
    create: XOR<
      news_commentsCreateWithoutStock_newsInput,
      news_commentsUncheckedCreateWithoutStock_newsInput
    >;
  };

  export type news_commentsUpdateWithWhereUniqueWithoutStock_newsInput = {
    where: news_commentsWhereUniqueInput;
    data: XOR<
      news_commentsUpdateWithoutStock_newsInput,
      news_commentsUncheckedUpdateWithoutStock_newsInput
    >;
  };

  export type news_commentsUpdateManyWithWhereWithoutStock_newsInput = {
    where: news_commentsScalarWhereInput;
    data: XOR<
      news_commentsUpdateManyMutationInput,
      news_commentsUncheckedUpdateManyWithoutStock_newsInput
    >;
  };

  export type stock_news_read_historyUpsertWithWhereUniqueWithoutStock_newsInput =
    {
      where: stock_news_read_historyWhereUniqueInput;
      update: XOR<
        stock_news_read_historyUpdateWithoutStock_newsInput,
        stock_news_read_historyUncheckedUpdateWithoutStock_newsInput
      >;
      create: XOR<
        stock_news_read_historyCreateWithoutStock_newsInput,
        stock_news_read_historyUncheckedCreateWithoutStock_newsInput
      >;
    };

  export type stock_news_read_historyUpdateWithWhereUniqueWithoutStock_newsInput =
    {
      where: stock_news_read_historyWhereUniqueInput;
      data: XOR<
        stock_news_read_historyUpdateWithoutStock_newsInput,
        stock_news_read_historyUncheckedUpdateWithoutStock_newsInput
      >;
    };

  export type stock_news_read_historyUpdateManyWithWhereWithoutStock_newsInput =
    {
      where: stock_news_read_historyScalarWhereInput;
      data: XOR<
        stock_news_read_historyUpdateManyMutationInput,
        stock_news_read_historyUncheckedUpdateManyWithoutStock_newsInput
      >;
    };

  export type stock_news_read_historyScalarWhereInput = {
    AND?:
      | stock_news_read_historyScalarWhereInput
      | stock_news_read_historyScalarWhereInput[];
    OR?: stock_news_read_historyScalarWhereInput[];
    NOT?:
      | stock_news_read_historyScalarWhereInput
      | stock_news_read_historyScalarWhereInput[];
    id?: UuidFilter<'stock_news_read_history'> | string;
    news_id?: UuidFilter<'stock_news_read_history'> | string;
    user_id?: StringNullableFilter<'stock_news_read_history'> | string | null;
    session_id?:
      | StringNullableFilter<'stock_news_read_history'>
      | string
      | null;
    read_at?:
      | DateTimeNullableFilter<'stock_news_read_history'>
      | Date
      | string
      | null;
    language_read?:
      | StringNullableFilter<'stock_news_read_history'>
      | string
      | null;
    read_duration?:
      | IntNullableFilter<'stock_news_read_history'>
      | number
      | null;
    metadata?: JsonNullableFilter<'stock_news_read_history'>;
  };

  export type stock_news_related_symbolsUpsertWithWhereUniqueWithoutStock_newsInput =
    {
      where: stock_news_related_symbolsWhereUniqueInput;
      update: XOR<
        stock_news_related_symbolsUpdateWithoutStock_newsInput,
        stock_news_related_symbolsUncheckedUpdateWithoutStock_newsInput
      >;
      create: XOR<
        stock_news_related_symbolsCreateWithoutStock_newsInput,
        stock_news_related_symbolsUncheckedCreateWithoutStock_newsInput
      >;
    };

  export type stock_news_related_symbolsUpdateWithWhereUniqueWithoutStock_newsInput =
    {
      where: stock_news_related_symbolsWhereUniqueInput;
      data: XOR<
        stock_news_related_symbolsUpdateWithoutStock_newsInput,
        stock_news_related_symbolsUncheckedUpdateWithoutStock_newsInput
      >;
    };

  export type stock_news_related_symbolsUpdateManyWithWhereWithoutStock_newsInput =
    {
      where: stock_news_related_symbolsScalarWhereInput;
      data: XOR<
        stock_news_related_symbolsUpdateManyMutationInput,
        stock_news_related_symbolsUncheckedUpdateManyWithoutStock_newsInput
      >;
    };

  export type stock_news_related_symbolsScalarWhereInput = {
    AND?:
      | stock_news_related_symbolsScalarWhereInput
      | stock_news_related_symbolsScalarWhereInput[];
    OR?: stock_news_related_symbolsScalarWhereInput[];
    NOT?:
      | stock_news_related_symbolsScalarWhereInput
      | stock_news_related_symbolsScalarWhereInput[];
    id?: UuidFilter<'stock_news_related_symbols'> | string;
    news_id?: UuidFilter<'stock_news_related_symbols'> | string;
    related_symbol?: StringFilter<'stock_news_related_symbols'> | string;
    related_exchange?:
      | StringNullableFilter<'stock_news_related_symbols'>
      | string
      | null;
    is_primary?:
      | BoolNullableFilter<'stock_news_related_symbols'>
      | boolean
      | null;
  };

  export type stock_news_translationUpsertWithWhereUniqueWithoutStock_newsInput =
    {
      where: stock_news_translationWhereUniqueInput;
      update: XOR<
        stock_news_translationUpdateWithoutStock_newsInput,
        stock_news_translationUncheckedUpdateWithoutStock_newsInput
      >;
      create: XOR<
        stock_news_translationCreateWithoutStock_newsInput,
        stock_news_translationUncheckedCreateWithoutStock_newsInput
      >;
    };

  export type stock_news_translationUpdateWithWhereUniqueWithoutStock_newsInput =
    {
      where: stock_news_translationWhereUniqueInput;
      data: XOR<
        stock_news_translationUpdateWithoutStock_newsInput,
        stock_news_translationUncheckedUpdateWithoutStock_newsInput
      >;
    };

  export type stock_news_translationUpdateManyWithWhereWithoutStock_newsInput =
    {
      where: stock_news_translationScalarWhereInput;
      data: XOR<
        stock_news_translationUpdateManyMutationInput,
        stock_news_translationUncheckedUpdateManyWithoutStock_newsInput
      >;
    };

  export type stock_news_translationScalarWhereInput = {
    AND?:
      | stock_news_translationScalarWhereInput
      | stock_news_translationScalarWhereInput[];
    OR?: stock_news_translationScalarWhereInput[];
    NOT?:
      | stock_news_translationScalarWhereInput
      | stock_news_translationScalarWhereInput[];
    id?: UuidFilter<'stock_news_translation'> | string;
    news_id?: UuidFilter<'stock_news_translation'> | string;
    language?: StringFilter<'stock_news_translation'> | string;
    title?: StringFilter<'stock_news_translation'> | string;
    content?: StringNullableFilter<'stock_news_translation'> | string | null;
    summary?: StringNullableFilter<'stock_news_translation'> | string | null;
    created_at?:
      | DateTimeNullableFilter<'stock_news_translation'>
      | Date
      | string
      | null;
    updated_at?:
      | DateTimeNullableFilter<'stock_news_translation'>
      | Date
      | string
      | null;
  };

  export type stock_newsCreateWithoutStock_news_read_historyInput = {
    id?: string;
    symbol: string;
    exchange?: string | null;
    title: string;
    content?: string | null;
    summary?: string | null;
    image_url?: string | null;
    source_url?: string | null;
    publisher?: string | null;
    published_date: Date | string;
    language?: string | null;
    view_count?: number | null;
    is_featured?: boolean | null;
    is_hot?: boolean | null;
    tags?: stock_newsCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: number | null;
    share_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    news_comments?: news_commentsCreateNestedManyWithoutStock_newsInput;
    stock_news_related_symbols?: stock_news_related_symbolsCreateNestedManyWithoutStock_newsInput;
    stock_news_translation?: stock_news_translationCreateNestedManyWithoutStock_newsInput;
  };

  export type stock_newsUncheckedCreateWithoutStock_news_read_historyInput = {
    id?: string;
    symbol: string;
    exchange?: string | null;
    title: string;
    content?: string | null;
    summary?: string | null;
    image_url?: string | null;
    source_url?: string | null;
    publisher?: string | null;
    published_date: Date | string;
    language?: string | null;
    view_count?: number | null;
    is_featured?: boolean | null;
    is_hot?: boolean | null;
    tags?: stock_newsCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: number | null;
    share_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    news_comments?: news_commentsUncheckedCreateNestedManyWithoutStock_newsInput;
    stock_news_related_symbols?: stock_news_related_symbolsUncheckedCreateNestedManyWithoutStock_newsInput;
    stock_news_translation?: stock_news_translationUncheckedCreateNestedManyWithoutStock_newsInput;
  };

  export type stock_newsCreateOrConnectWithoutStock_news_read_historyInput = {
    where: stock_newsWhereUniqueInput;
    create: XOR<
      stock_newsCreateWithoutStock_news_read_historyInput,
      stock_newsUncheckedCreateWithoutStock_news_read_historyInput
    >;
  };

  export type stock_newsUpsertWithoutStock_news_read_historyInput = {
    update: XOR<
      stock_newsUpdateWithoutStock_news_read_historyInput,
      stock_newsUncheckedUpdateWithoutStock_news_read_historyInput
    >;
    create: XOR<
      stock_newsCreateWithoutStock_news_read_historyInput,
      stock_newsUncheckedCreateWithoutStock_news_read_historyInput
    >;
    where?: stock_newsWhereInput;
  };

  export type stock_newsUpdateToOneWithWhereWithoutStock_news_read_historyInput =
    {
      where?: stock_newsWhereInput;
      data: XOR<
        stock_newsUpdateWithoutStock_news_read_historyInput,
        stock_newsUncheckedUpdateWithoutStock_news_read_historyInput
      >;
    };

  export type stock_newsUpdateWithoutStock_news_read_historyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    image_url?: NullableStringFieldUpdateOperationsInput | string | null;
    source_url?: NullableStringFieldUpdateOperationsInput | string | null;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    view_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_featured?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    is_hot?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    tags?: stock_newsUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    share_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    news_comments?: news_commentsUpdateManyWithoutStock_newsNestedInput;
    stock_news_related_symbols?: stock_news_related_symbolsUpdateManyWithoutStock_newsNestedInput;
    stock_news_translation?: stock_news_translationUpdateManyWithoutStock_newsNestedInput;
  };

  export type stock_newsUncheckedUpdateWithoutStock_news_read_historyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    image_url?: NullableStringFieldUpdateOperationsInput | string | null;
    source_url?: NullableStringFieldUpdateOperationsInput | string | null;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    view_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_featured?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    is_hot?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    tags?: stock_newsUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    share_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    news_comments?: news_commentsUncheckedUpdateManyWithoutStock_newsNestedInput;
    stock_news_related_symbols?: stock_news_related_symbolsUncheckedUpdateManyWithoutStock_newsNestedInput;
    stock_news_translation?: stock_news_translationUncheckedUpdateManyWithoutStock_newsNestedInput;
  };

  export type stock_newsCreateWithoutStock_news_related_symbolsInput = {
    id?: string;
    symbol: string;
    exchange?: string | null;
    title: string;
    content?: string | null;
    summary?: string | null;
    image_url?: string | null;
    source_url?: string | null;
    publisher?: string | null;
    published_date: Date | string;
    language?: string | null;
    view_count?: number | null;
    is_featured?: boolean | null;
    is_hot?: boolean | null;
    tags?: stock_newsCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: number | null;
    share_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    news_comments?: news_commentsCreateNestedManyWithoutStock_newsInput;
    stock_news_read_history?: stock_news_read_historyCreateNestedManyWithoutStock_newsInput;
    stock_news_translation?: stock_news_translationCreateNestedManyWithoutStock_newsInput;
  };

  export type stock_newsUncheckedCreateWithoutStock_news_related_symbolsInput =
    {
      id?: string;
      symbol: string;
      exchange?: string | null;
      title: string;
      content?: string | null;
      summary?: string | null;
      image_url?: string | null;
      source_url?: string | null;
      publisher?: string | null;
      published_date: Date | string;
      language?: string | null;
      view_count?: number | null;
      is_featured?: boolean | null;
      is_hot?: boolean | null;
      tags?: stock_newsCreatetagsInput | string[];
      metadata?: NullableJsonNullValueInput | InputJsonValue;
      like_count?: number | null;
      share_count?: number | null;
      is_active?: boolean | null;
      created_at?: Date | string | null;
      updated_at?: Date | string | null;
      categories?: NullableJsonNullValueInput | InputJsonValue;
      news_comments?: news_commentsUncheckedCreateNestedManyWithoutStock_newsInput;
      stock_news_read_history?: stock_news_read_historyUncheckedCreateNestedManyWithoutStock_newsInput;
      stock_news_translation?: stock_news_translationUncheckedCreateNestedManyWithoutStock_newsInput;
    };

  export type stock_newsCreateOrConnectWithoutStock_news_related_symbolsInput =
    {
      where: stock_newsWhereUniqueInput;
      create: XOR<
        stock_newsCreateWithoutStock_news_related_symbolsInput,
        stock_newsUncheckedCreateWithoutStock_news_related_symbolsInput
      >;
    };

  export type stock_newsUpsertWithoutStock_news_related_symbolsInput = {
    update: XOR<
      stock_newsUpdateWithoutStock_news_related_symbolsInput,
      stock_newsUncheckedUpdateWithoutStock_news_related_symbolsInput
    >;
    create: XOR<
      stock_newsCreateWithoutStock_news_related_symbolsInput,
      stock_newsUncheckedCreateWithoutStock_news_related_symbolsInput
    >;
    where?: stock_newsWhereInput;
  };

  export type stock_newsUpdateToOneWithWhereWithoutStock_news_related_symbolsInput =
    {
      where?: stock_newsWhereInput;
      data: XOR<
        stock_newsUpdateWithoutStock_news_related_symbolsInput,
        stock_newsUncheckedUpdateWithoutStock_news_related_symbolsInput
      >;
    };

  export type stock_newsUpdateWithoutStock_news_related_symbolsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    image_url?: NullableStringFieldUpdateOperationsInput | string | null;
    source_url?: NullableStringFieldUpdateOperationsInput | string | null;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    view_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_featured?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    is_hot?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    tags?: stock_newsUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    share_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    news_comments?: news_commentsUpdateManyWithoutStock_newsNestedInput;
    stock_news_read_history?: stock_news_read_historyUpdateManyWithoutStock_newsNestedInput;
    stock_news_translation?: stock_news_translationUpdateManyWithoutStock_newsNestedInput;
  };

  export type stock_newsUncheckedUpdateWithoutStock_news_related_symbolsInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      symbol?: StringFieldUpdateOperationsInput | string;
      exchange?: NullableStringFieldUpdateOperationsInput | string | null;
      title?: StringFieldUpdateOperationsInput | string;
      content?: NullableStringFieldUpdateOperationsInput | string | null;
      summary?: NullableStringFieldUpdateOperationsInput | string | null;
      image_url?: NullableStringFieldUpdateOperationsInput | string | null;
      source_url?: NullableStringFieldUpdateOperationsInput | string | null;
      publisher?: NullableStringFieldUpdateOperationsInput | string | null;
      published_date?: DateTimeFieldUpdateOperationsInput | Date | string;
      language?: NullableStringFieldUpdateOperationsInput | string | null;
      view_count?: NullableIntFieldUpdateOperationsInput | number | null;
      is_featured?: NullableBoolFieldUpdateOperationsInput | boolean | null;
      is_hot?: NullableBoolFieldUpdateOperationsInput | boolean | null;
      tags?: stock_newsUpdatetagsInput | string[];
      metadata?: NullableJsonNullValueInput | InputJsonValue;
      like_count?: NullableIntFieldUpdateOperationsInput | number | null;
      share_count?: NullableIntFieldUpdateOperationsInput | number | null;
      is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
      created_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      updated_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      categories?: NullableJsonNullValueInput | InputJsonValue;
      news_comments?: news_commentsUncheckedUpdateManyWithoutStock_newsNestedInput;
      stock_news_read_history?: stock_news_read_historyUncheckedUpdateManyWithoutStock_newsNestedInput;
      stock_news_translation?: stock_news_translationUncheckedUpdateManyWithoutStock_newsNestedInput;
    };

  export type stock_newsCreateWithoutStock_news_translationInput = {
    id?: string;
    symbol: string;
    exchange?: string | null;
    title: string;
    content?: string | null;
    summary?: string | null;
    image_url?: string | null;
    source_url?: string | null;
    publisher?: string | null;
    published_date: Date | string;
    language?: string | null;
    view_count?: number | null;
    is_featured?: boolean | null;
    is_hot?: boolean | null;
    tags?: stock_newsCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: number | null;
    share_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    news_comments?: news_commentsCreateNestedManyWithoutStock_newsInput;
    stock_news_read_history?: stock_news_read_historyCreateNestedManyWithoutStock_newsInput;
    stock_news_related_symbols?: stock_news_related_symbolsCreateNestedManyWithoutStock_newsInput;
  };

  export type stock_newsUncheckedCreateWithoutStock_news_translationInput = {
    id?: string;
    symbol: string;
    exchange?: string | null;
    title: string;
    content?: string | null;
    summary?: string | null;
    image_url?: string | null;
    source_url?: string | null;
    publisher?: string | null;
    published_date: Date | string;
    language?: string | null;
    view_count?: number | null;
    is_featured?: boolean | null;
    is_hot?: boolean | null;
    tags?: stock_newsCreatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: number | null;
    share_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    news_comments?: news_commentsUncheckedCreateNestedManyWithoutStock_newsInput;
    stock_news_read_history?: stock_news_read_historyUncheckedCreateNestedManyWithoutStock_newsInput;
    stock_news_related_symbols?: stock_news_related_symbolsUncheckedCreateNestedManyWithoutStock_newsInput;
  };

  export type stock_newsCreateOrConnectWithoutStock_news_translationInput = {
    where: stock_newsWhereUniqueInput;
    create: XOR<
      stock_newsCreateWithoutStock_news_translationInput,
      stock_newsUncheckedCreateWithoutStock_news_translationInput
    >;
  };

  export type stock_newsUpsertWithoutStock_news_translationInput = {
    update: XOR<
      stock_newsUpdateWithoutStock_news_translationInput,
      stock_newsUncheckedUpdateWithoutStock_news_translationInput
    >;
    create: XOR<
      stock_newsCreateWithoutStock_news_translationInput,
      stock_newsUncheckedCreateWithoutStock_news_translationInput
    >;
    where?: stock_newsWhereInput;
  };

  export type stock_newsUpdateToOneWithWhereWithoutStock_news_translationInput =
    {
      where?: stock_newsWhereInput;
      data: XOR<
        stock_newsUpdateWithoutStock_news_translationInput,
        stock_newsUncheckedUpdateWithoutStock_news_translationInput
      >;
    };

  export type stock_newsUpdateWithoutStock_news_translationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    image_url?: NullableStringFieldUpdateOperationsInput | string | null;
    source_url?: NullableStringFieldUpdateOperationsInput | string | null;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    view_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_featured?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    is_hot?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    tags?: stock_newsUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    share_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    news_comments?: news_commentsUpdateManyWithoutStock_newsNestedInput;
    stock_news_read_history?: stock_news_read_historyUpdateManyWithoutStock_newsNestedInput;
    stock_news_related_symbols?: stock_news_related_symbolsUpdateManyWithoutStock_newsNestedInput;
  };

  export type stock_newsUncheckedUpdateWithoutStock_news_translationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    symbol?: StringFieldUpdateOperationsInput | string;
    exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    image_url?: NullableStringFieldUpdateOperationsInput | string | null;
    source_url?: NullableStringFieldUpdateOperationsInput | string | null;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    view_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_featured?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    is_hot?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    tags?: stock_newsUpdatetagsInput | string[];
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    share_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    categories?: NullableJsonNullValueInput | InputJsonValue;
    news_comments?: news_commentsUncheckedUpdateManyWithoutStock_newsNestedInput;
    stock_news_read_history?: stock_news_read_historyUncheckedUpdateManyWithoutStock_newsNestedInput;
    stock_news_related_symbols?: stock_news_related_symbolsUncheckedUpdateManyWithoutStock_newsNestedInput;
  };

  export type permissionsCreateWithoutSubscriptionsInput = {
    feature?: string | null;
    is_enabled?: boolean | null;
    limit_access?: string | null;
  };

  export type permissionsUncheckedCreateWithoutSubscriptionsInput = {
    permission_id?: number;
    feature?: string | null;
    is_enabled?: boolean | null;
    limit_access?: string | null;
  };

  export type permissionsCreateOrConnectWithoutSubscriptionsInput = {
    where: permissionsWhereUniqueInput;
    create: XOR<
      permissionsCreateWithoutSubscriptionsInput,
      permissionsUncheckedCreateWithoutSubscriptionsInput
    >;
  };

  export type permissionsCreateManySubscriptionsInputEnvelope = {
    data:
      | permissionsCreateManySubscriptionsInput
      | permissionsCreateManySubscriptionsInput[];
    skipDuplicates?: boolean;
  };

  export type user_subscriptionsCreateWithoutSubscriptionsInput = {
    user_id?: number | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    is_active?: boolean | null;
    stripe_subscription_id?: string | null;
    stripe_payment_intent_id?: string | null;
    payment_status?: string | null;
    last_payment_date?: Date | string | null;
    next_billing_date?: Date | string | null;
    cancellation_date?: Date | string | null;
    trial_end_date?: Date | string | null;
    last_payment_attempt_date?: Date | string | null;
    payment_method_id?: string | null;
    redeem_code?: string | null;
  };

  export type user_subscriptionsUncheckedCreateWithoutSubscriptionsInput = {
    user_subscription_id?: number;
    user_id?: number | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    is_active?: boolean | null;
    stripe_subscription_id?: string | null;
    stripe_payment_intent_id?: string | null;
    payment_status?: string | null;
    last_payment_date?: Date | string | null;
    next_billing_date?: Date | string | null;
    cancellation_date?: Date | string | null;
    trial_end_date?: Date | string | null;
    last_payment_attempt_date?: Date | string | null;
    payment_method_id?: string | null;
    redeem_code?: string | null;
  };

  export type user_subscriptionsCreateOrConnectWithoutSubscriptionsInput = {
    where: user_subscriptionsWhereUniqueInput;
    create: XOR<
      user_subscriptionsCreateWithoutSubscriptionsInput,
      user_subscriptionsUncheckedCreateWithoutSubscriptionsInput
    >;
  };

  export type user_subscriptionsCreateManySubscriptionsInputEnvelope = {
    data:
      | user_subscriptionsCreateManySubscriptionsInput
      | user_subscriptionsCreateManySubscriptionsInput[];
    skipDuplicates?: boolean;
  };

  export type permissionsUpsertWithWhereUniqueWithoutSubscriptionsInput = {
    where: permissionsWhereUniqueInput;
    update: XOR<
      permissionsUpdateWithoutSubscriptionsInput,
      permissionsUncheckedUpdateWithoutSubscriptionsInput
    >;
    create: XOR<
      permissionsCreateWithoutSubscriptionsInput,
      permissionsUncheckedCreateWithoutSubscriptionsInput
    >;
  };

  export type permissionsUpdateWithWhereUniqueWithoutSubscriptionsInput = {
    where: permissionsWhereUniqueInput;
    data: XOR<
      permissionsUpdateWithoutSubscriptionsInput,
      permissionsUncheckedUpdateWithoutSubscriptionsInput
    >;
  };

  export type permissionsUpdateManyWithWhereWithoutSubscriptionsInput = {
    where: permissionsScalarWhereInput;
    data: XOR<
      permissionsUpdateManyMutationInput,
      permissionsUncheckedUpdateManyWithoutSubscriptionsInput
    >;
  };

  export type permissionsScalarWhereInput = {
    AND?: permissionsScalarWhereInput | permissionsScalarWhereInput[];
    OR?: permissionsScalarWhereInput[];
    NOT?: permissionsScalarWhereInput | permissionsScalarWhereInput[];
    permission_id?: IntFilter<'permissions'> | number;
    subscription_id?: IntNullableFilter<'permissions'> | number | null;
    feature?: StringNullableFilter<'permissions'> | string | null;
    is_enabled?: BoolNullableFilter<'permissions'> | boolean | null;
    limit_access?: StringNullableFilter<'permissions'> | string | null;
  };

  export type user_subscriptionsUpsertWithWhereUniqueWithoutSubscriptionsInput =
    {
      where: user_subscriptionsWhereUniqueInput;
      update: XOR<
        user_subscriptionsUpdateWithoutSubscriptionsInput,
        user_subscriptionsUncheckedUpdateWithoutSubscriptionsInput
      >;
      create: XOR<
        user_subscriptionsCreateWithoutSubscriptionsInput,
        user_subscriptionsUncheckedCreateWithoutSubscriptionsInput
      >;
    };

  export type user_subscriptionsUpdateWithWhereUniqueWithoutSubscriptionsInput =
    {
      where: user_subscriptionsWhereUniqueInput;
      data: XOR<
        user_subscriptionsUpdateWithoutSubscriptionsInput,
        user_subscriptionsUncheckedUpdateWithoutSubscriptionsInput
      >;
    };

  export type user_subscriptionsUpdateManyWithWhereWithoutSubscriptionsInput = {
    where: user_subscriptionsScalarWhereInput;
    data: XOR<
      user_subscriptionsUpdateManyMutationInput,
      user_subscriptionsUncheckedUpdateManyWithoutSubscriptionsInput
    >;
  };

  export type user_subscriptionsScalarWhereInput = {
    AND?:
      | user_subscriptionsScalarWhereInput
      | user_subscriptionsScalarWhereInput[];
    OR?: user_subscriptionsScalarWhereInput[];
    NOT?:
      | user_subscriptionsScalarWhereInput
      | user_subscriptionsScalarWhereInput[];
    user_subscription_id?: IntFilter<'user_subscriptions'> | number;
    user_id?: IntNullableFilter<'user_subscriptions'> | number | null;
    subscription_id?: IntNullableFilter<'user_subscriptions'> | number | null;
    start_date?:
      | DateTimeNullableFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    end_date?:
      | DateTimeNullableFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    is_active?: BoolNullableFilter<'user_subscriptions'> | boolean | null;
    stripe_subscription_id?:
      | StringNullableFilter<'user_subscriptions'>
      | string
      | null;
    stripe_payment_intent_id?:
      | StringNullableFilter<'user_subscriptions'>
      | string
      | null;
    payment_status?: StringNullableFilter<'user_subscriptions'> | string | null;
    last_payment_date?:
      | DateTimeNullableFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    next_billing_date?:
      | DateTimeNullableFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    cancellation_date?:
      | DateTimeNullableFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    trial_end_date?:
      | DateTimeNullableFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    last_payment_attempt_date?:
      | DateTimeNullableFilter<'user_subscriptions'>
      | Date
      | string
      | null;
    payment_method_id?:
      | StringNullableFilter<'user_subscriptions'>
      | string
      | null;
    redeem_code?: StringNullableFilter<'user_subscriptions'> | string | null;
  };

  export type superinvestor_holdings_listCreateWithoutSuperinvestor_holdingsInput =
    {
      symbol?: string | null;
      percentage_of_portfolio?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      recent_activity?: string | null;
      share_raw?: string | null;
      share_value?: Decimal | DecimalJsLike | number | string | null;
      reported_price_raw?: string | null;
      reported_price_value?: Decimal | DecimalJsLike | number | string | null;
      value_raw?: string | null;
      value?: Decimal | DecimalJsLike | number | string | null;
    };

  export type superinvestor_holdings_listUncheckedCreateWithoutSuperinvestor_holdingsInput =
    {
      id?: number;
      symbol?: string | null;
      percentage_of_portfolio?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      recent_activity?: string | null;
      share_raw?: string | null;
      share_value?: Decimal | DecimalJsLike | number | string | null;
      reported_price_raw?: string | null;
      reported_price_value?: Decimal | DecimalJsLike | number | string | null;
      value_raw?: string | null;
      value?: Decimal | DecimalJsLike | number | string | null;
    };

  export type superinvestor_holdings_listCreateOrConnectWithoutSuperinvestor_holdingsInput =
    {
      where: superinvestor_holdings_listWhereUniqueInput;
      create: XOR<
        superinvestor_holdings_listCreateWithoutSuperinvestor_holdingsInput,
        superinvestor_holdings_listUncheckedCreateWithoutSuperinvestor_holdingsInput
      >;
    };

  export type superinvestor_holdings_listCreateManySuperinvestor_holdingsInputEnvelope =
    {
      data:
        | superinvestor_holdings_listCreateManySuperinvestor_holdingsInput
        | superinvestor_holdings_listCreateManySuperinvestor_holdingsInput[];
      skipDuplicates?: boolean;
    };

  export type superinvestor_sector_analysisCreateWithoutSuperinvestor_holdingsInput =
    {
      sector_name?: string | null;
      sector_percentage?: Decimal | DecimalJsLike | number | string | null;
    };

  export type superinvestor_sector_analysisUncheckedCreateWithoutSuperinvestor_holdingsInput =
    {
      id?: number;
      sector_name?: string | null;
      sector_percentage?: Decimal | DecimalJsLike | number | string | null;
    };

  export type superinvestor_sector_analysisCreateOrConnectWithoutSuperinvestor_holdingsInput =
    {
      where: superinvestor_sector_analysisWhereUniqueInput;
      create: XOR<
        superinvestor_sector_analysisCreateWithoutSuperinvestor_holdingsInput,
        superinvestor_sector_analysisUncheckedCreateWithoutSuperinvestor_holdingsInput
      >;
    };

  export type superinvestor_sector_analysisCreateManySuperinvestor_holdingsInputEnvelope =
    {
      data:
        | superinvestor_sector_analysisCreateManySuperinvestor_holdingsInput
        | superinvestor_sector_analysisCreateManySuperinvestor_holdingsInput[];
      skipDuplicates?: boolean;
    };

  export type superinvestor_holdings_listUpsertWithWhereUniqueWithoutSuperinvestor_holdingsInput =
    {
      where: superinvestor_holdings_listWhereUniqueInput;
      update: XOR<
        superinvestor_holdings_listUpdateWithoutSuperinvestor_holdingsInput,
        superinvestor_holdings_listUncheckedUpdateWithoutSuperinvestor_holdingsInput
      >;
      create: XOR<
        superinvestor_holdings_listCreateWithoutSuperinvestor_holdingsInput,
        superinvestor_holdings_listUncheckedCreateWithoutSuperinvestor_holdingsInput
      >;
    };

  export type superinvestor_holdings_listUpdateWithWhereUniqueWithoutSuperinvestor_holdingsInput =
    {
      where: superinvestor_holdings_listWhereUniqueInput;
      data: XOR<
        superinvestor_holdings_listUpdateWithoutSuperinvestor_holdingsInput,
        superinvestor_holdings_listUncheckedUpdateWithoutSuperinvestor_holdingsInput
      >;
    };

  export type superinvestor_holdings_listUpdateManyWithWhereWithoutSuperinvestor_holdingsInput =
    {
      where: superinvestor_holdings_listScalarWhereInput;
      data: XOR<
        superinvestor_holdings_listUpdateManyMutationInput,
        superinvestor_holdings_listUncheckedUpdateManyWithoutSuperinvestor_holdingsInput
      >;
    };

  export type superinvestor_holdings_listScalarWhereInput = {
    AND?:
      | superinvestor_holdings_listScalarWhereInput
      | superinvestor_holdings_listScalarWhereInput[];
    OR?: superinvestor_holdings_listScalarWhereInput[];
    NOT?:
      | superinvestor_holdings_listScalarWhereInput
      | superinvestor_holdings_listScalarWhereInput[];
    id?: IntFilter<'superinvestor_holdings_list'> | number;
    manager_id?:
      | IntNullableFilter<'superinvestor_holdings_list'>
      | number
      | null;
    symbol?:
      | StringNullableFilter<'superinvestor_holdings_list'>
      | string
      | null;
    percentage_of_portfolio?:
      | DecimalNullableFilter<'superinvestor_holdings_list'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    recent_activity?:
      | StringNullableFilter<'superinvestor_holdings_list'>
      | string
      | null;
    share_raw?:
      | StringNullableFilter<'superinvestor_holdings_list'>
      | string
      | null;
    share_value?:
      | DecimalNullableFilter<'superinvestor_holdings_list'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    reported_price_raw?:
      | StringNullableFilter<'superinvestor_holdings_list'>
      | string
      | null;
    reported_price_value?:
      | DecimalNullableFilter<'superinvestor_holdings_list'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    value_raw?:
      | StringNullableFilter<'superinvestor_holdings_list'>
      | string
      | null;
    value?:
      | DecimalNullableFilter<'superinvestor_holdings_list'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type superinvestor_sector_analysisUpsertWithWhereUniqueWithoutSuperinvestor_holdingsInput =
    {
      where: superinvestor_sector_analysisWhereUniqueInput;
      update: XOR<
        superinvestor_sector_analysisUpdateWithoutSuperinvestor_holdingsInput,
        superinvestor_sector_analysisUncheckedUpdateWithoutSuperinvestor_holdingsInput
      >;
      create: XOR<
        superinvestor_sector_analysisCreateWithoutSuperinvestor_holdingsInput,
        superinvestor_sector_analysisUncheckedCreateWithoutSuperinvestor_holdingsInput
      >;
    };

  export type superinvestor_sector_analysisUpdateWithWhereUniqueWithoutSuperinvestor_holdingsInput =
    {
      where: superinvestor_sector_analysisWhereUniqueInput;
      data: XOR<
        superinvestor_sector_analysisUpdateWithoutSuperinvestor_holdingsInput,
        superinvestor_sector_analysisUncheckedUpdateWithoutSuperinvestor_holdingsInput
      >;
    };

  export type superinvestor_sector_analysisUpdateManyWithWhereWithoutSuperinvestor_holdingsInput =
    {
      where: superinvestor_sector_analysisScalarWhereInput;
      data: XOR<
        superinvestor_sector_analysisUpdateManyMutationInput,
        superinvestor_sector_analysisUncheckedUpdateManyWithoutSuperinvestor_holdingsInput
      >;
    };

  export type superinvestor_sector_analysisScalarWhereInput = {
    AND?:
      | superinvestor_sector_analysisScalarWhereInput
      | superinvestor_sector_analysisScalarWhereInput[];
    OR?: superinvestor_sector_analysisScalarWhereInput[];
    NOT?:
      | superinvestor_sector_analysisScalarWhereInput
      | superinvestor_sector_analysisScalarWhereInput[];
    id?: IntFilter<'superinvestor_sector_analysis'> | number;
    manager_id?:
      | IntNullableFilter<'superinvestor_sector_analysis'>
      | number
      | null;
    sector_name?:
      | StringNullableFilter<'superinvestor_sector_analysis'>
      | string
      | null;
    sector_percentage?:
      | DecimalNullableFilter<'superinvestor_sector_analysis'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type superinvestor_holdingsCreateWithoutSuperinvestor_holdings_listInput =
    {
      manager_name?: string | null;
      portfolio_value_raw?: string | null;
      number_of_stocks?: number | null;
      manager_link?: string | null;
      image?: string | null;
      information_en?: string | null;
      information_th?: string | null;
      created_at?: Date | string | null;
      updated_at?: Date | string | null;
      portfolio_value?: Decimal | DecimalJsLike | number | string | null;
      superinvestor_sector_analysis?: superinvestor_sector_analysisCreateNestedManyWithoutSuperinvestor_holdingsInput;
    };

  export type superinvestor_holdingsUncheckedCreateWithoutSuperinvestor_holdings_listInput =
    {
      id?: number;
      manager_name?: string | null;
      portfolio_value_raw?: string | null;
      number_of_stocks?: number | null;
      manager_link?: string | null;
      image?: string | null;
      information_en?: string | null;
      information_th?: string | null;
      created_at?: Date | string | null;
      updated_at?: Date | string | null;
      portfolio_value?: Decimal | DecimalJsLike | number | string | null;
      superinvestor_sector_analysis?: superinvestor_sector_analysisUncheckedCreateNestedManyWithoutSuperinvestor_holdingsInput;
    };

  export type superinvestor_holdingsCreateOrConnectWithoutSuperinvestor_holdings_listInput =
    {
      where: superinvestor_holdingsWhereUniqueInput;
      create: XOR<
        superinvestor_holdingsCreateWithoutSuperinvestor_holdings_listInput,
        superinvestor_holdingsUncheckedCreateWithoutSuperinvestor_holdings_listInput
      >;
    };

  export type superinvestor_holdingsUpsertWithoutSuperinvestor_holdings_listInput =
    {
      update: XOR<
        superinvestor_holdingsUpdateWithoutSuperinvestor_holdings_listInput,
        superinvestor_holdingsUncheckedUpdateWithoutSuperinvestor_holdings_listInput
      >;
      create: XOR<
        superinvestor_holdingsCreateWithoutSuperinvestor_holdings_listInput,
        superinvestor_holdingsUncheckedCreateWithoutSuperinvestor_holdings_listInput
      >;
      where?: superinvestor_holdingsWhereInput;
    };

  export type superinvestor_holdingsUpdateToOneWithWhereWithoutSuperinvestor_holdings_listInput =
    {
      where?: superinvestor_holdingsWhereInput;
      data: XOR<
        superinvestor_holdingsUpdateWithoutSuperinvestor_holdings_listInput,
        superinvestor_holdingsUncheckedUpdateWithoutSuperinvestor_holdings_listInput
      >;
    };

  export type superinvestor_holdingsUpdateWithoutSuperinvestor_holdings_listInput =
    {
      manager_name?: NullableStringFieldUpdateOperationsInput | string | null;
      portfolio_value_raw?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      number_of_stocks?: NullableIntFieldUpdateOperationsInput | number | null;
      manager_link?: NullableStringFieldUpdateOperationsInput | string | null;
      image?: NullableStringFieldUpdateOperationsInput | string | null;
      information_en?: NullableStringFieldUpdateOperationsInput | string | null;
      information_th?: NullableStringFieldUpdateOperationsInput | string | null;
      created_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      updated_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      portfolio_value?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      superinvestor_sector_analysis?: superinvestor_sector_analysisUpdateManyWithoutSuperinvestor_holdingsNestedInput;
    };

  export type superinvestor_holdingsUncheckedUpdateWithoutSuperinvestor_holdings_listInput =
    {
      id?: IntFieldUpdateOperationsInput | number;
      manager_name?: NullableStringFieldUpdateOperationsInput | string | null;
      portfolio_value_raw?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      number_of_stocks?: NullableIntFieldUpdateOperationsInput | number | null;
      manager_link?: NullableStringFieldUpdateOperationsInput | string | null;
      image?: NullableStringFieldUpdateOperationsInput | string | null;
      information_en?: NullableStringFieldUpdateOperationsInput | string | null;
      information_th?: NullableStringFieldUpdateOperationsInput | string | null;
      created_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      updated_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      portfolio_value?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      superinvestor_sector_analysis?: superinvestor_sector_analysisUncheckedUpdateManyWithoutSuperinvestor_holdingsNestedInput;
    };

  export type superinvestor_holdingsCreateWithoutSuperinvestor_sector_analysisInput =
    {
      manager_name?: string | null;
      portfolio_value_raw?: string | null;
      number_of_stocks?: number | null;
      manager_link?: string | null;
      image?: string | null;
      information_en?: string | null;
      information_th?: string | null;
      created_at?: Date | string | null;
      updated_at?: Date | string | null;
      portfolio_value?: Decimal | DecimalJsLike | number | string | null;
      superinvestor_holdings_list?: superinvestor_holdings_listCreateNestedManyWithoutSuperinvestor_holdingsInput;
    };

  export type superinvestor_holdingsUncheckedCreateWithoutSuperinvestor_sector_analysisInput =
    {
      id?: number;
      manager_name?: string | null;
      portfolio_value_raw?: string | null;
      number_of_stocks?: number | null;
      manager_link?: string | null;
      image?: string | null;
      information_en?: string | null;
      information_th?: string | null;
      created_at?: Date | string | null;
      updated_at?: Date | string | null;
      portfolio_value?: Decimal | DecimalJsLike | number | string | null;
      superinvestor_holdings_list?: superinvestor_holdings_listUncheckedCreateNestedManyWithoutSuperinvestor_holdingsInput;
    };

  export type superinvestor_holdingsCreateOrConnectWithoutSuperinvestor_sector_analysisInput =
    {
      where: superinvestor_holdingsWhereUniqueInput;
      create: XOR<
        superinvestor_holdingsCreateWithoutSuperinvestor_sector_analysisInput,
        superinvestor_holdingsUncheckedCreateWithoutSuperinvestor_sector_analysisInput
      >;
    };

  export type superinvestor_holdingsUpsertWithoutSuperinvestor_sector_analysisInput =
    {
      update: XOR<
        superinvestor_holdingsUpdateWithoutSuperinvestor_sector_analysisInput,
        superinvestor_holdingsUncheckedUpdateWithoutSuperinvestor_sector_analysisInput
      >;
      create: XOR<
        superinvestor_holdingsCreateWithoutSuperinvestor_sector_analysisInput,
        superinvestor_holdingsUncheckedCreateWithoutSuperinvestor_sector_analysisInput
      >;
      where?: superinvestor_holdingsWhereInput;
    };

  export type superinvestor_holdingsUpdateToOneWithWhereWithoutSuperinvestor_sector_analysisInput =
    {
      where?: superinvestor_holdingsWhereInput;
      data: XOR<
        superinvestor_holdingsUpdateWithoutSuperinvestor_sector_analysisInput,
        superinvestor_holdingsUncheckedUpdateWithoutSuperinvestor_sector_analysisInput
      >;
    };

  export type superinvestor_holdingsUpdateWithoutSuperinvestor_sector_analysisInput =
    {
      manager_name?: NullableStringFieldUpdateOperationsInput | string | null;
      portfolio_value_raw?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      number_of_stocks?: NullableIntFieldUpdateOperationsInput | number | null;
      manager_link?: NullableStringFieldUpdateOperationsInput | string | null;
      image?: NullableStringFieldUpdateOperationsInput | string | null;
      information_en?: NullableStringFieldUpdateOperationsInput | string | null;
      information_th?: NullableStringFieldUpdateOperationsInput | string | null;
      created_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      updated_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      portfolio_value?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      superinvestor_holdings_list?: superinvestor_holdings_listUpdateManyWithoutSuperinvestor_holdingsNestedInput;
    };

  export type superinvestor_holdingsUncheckedUpdateWithoutSuperinvestor_sector_analysisInput =
    {
      id?: IntFieldUpdateOperationsInput | number;
      manager_name?: NullableStringFieldUpdateOperationsInput | string | null;
      portfolio_value_raw?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      number_of_stocks?: NullableIntFieldUpdateOperationsInput | number | null;
      manager_link?: NullableStringFieldUpdateOperationsInput | string | null;
      image?: NullableStringFieldUpdateOperationsInput | string | null;
      information_en?: NullableStringFieldUpdateOperationsInput | string | null;
      information_th?: NullableStringFieldUpdateOperationsInput | string | null;
      created_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      updated_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      portfolio_value?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      superinvestor_holdings_list?: superinvestor_holdings_listUncheckedUpdateManyWithoutSuperinvestor_holdingsNestedInput;
    };

  export type subscriptionsCreateWithoutUser_subscriptionsInput = {
    name?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    features?: NullableJsonNullValueInput | InputJsonValue;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    stripe_price_id?: string | null;
    price_amount?: string | null;
    currency?: string | null;
    billing_interval?: string | null;
    is_active?: boolean | null;
    trial_days?: number | null;
    permissions?: permissionsCreateNestedManyWithoutSubscriptionsInput;
  };

  export type subscriptionsUncheckedCreateWithoutUser_subscriptionsInput = {
    subscription_id?: number;
    name?: string | null;
    price?: Decimal | DecimalJsLike | number | string | null;
    features?: NullableJsonNullValueInput | InputJsonValue;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    stripe_price_id?: string | null;
    price_amount?: string | null;
    currency?: string | null;
    billing_interval?: string | null;
    is_active?: boolean | null;
    trial_days?: number | null;
    permissions?: permissionsUncheckedCreateNestedManyWithoutSubscriptionsInput;
  };

  export type subscriptionsCreateOrConnectWithoutUser_subscriptionsInput = {
    where: subscriptionsWhereUniqueInput;
    create: XOR<
      subscriptionsCreateWithoutUser_subscriptionsInput,
      subscriptionsUncheckedCreateWithoutUser_subscriptionsInput
    >;
  };

  export type subscriptionsUpsertWithoutUser_subscriptionsInput = {
    update: XOR<
      subscriptionsUpdateWithoutUser_subscriptionsInput,
      subscriptionsUncheckedUpdateWithoutUser_subscriptionsInput
    >;
    create: XOR<
      subscriptionsCreateWithoutUser_subscriptionsInput,
      subscriptionsUncheckedCreateWithoutUser_subscriptionsInput
    >;
    where?: subscriptionsWhereInput;
  };

  export type subscriptionsUpdateToOneWithWhereWithoutUser_subscriptionsInput =
    {
      where?: subscriptionsWhereInput;
      data: XOR<
        subscriptionsUpdateWithoutUser_subscriptionsInput,
        subscriptionsUncheckedUpdateWithoutUser_subscriptionsInput
      >;
    };

  export type subscriptionsUpdateWithoutUser_subscriptionsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    features?: NullableJsonNullValueInput | InputJsonValue;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    stripe_price_id?: NullableStringFieldUpdateOperationsInput | string | null;
    price_amount?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_interval?: NullableStringFieldUpdateOperationsInput | string | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    trial_days?: NullableIntFieldUpdateOperationsInput | number | null;
    permissions?: permissionsUpdateManyWithoutSubscriptionsNestedInput;
  };

  export type subscriptionsUncheckedUpdateWithoutUser_subscriptionsInput = {
    subscription_id?: IntFieldUpdateOperationsInput | number;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    price?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    features?: NullableJsonNullValueInput | InputJsonValue;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    stripe_price_id?: NullableStringFieldUpdateOperationsInput | string | null;
    price_amount?: NullableStringFieldUpdateOperationsInput | string | null;
    currency?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_interval?: NullableStringFieldUpdateOperationsInput | string | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    trial_days?: NullableIntFieldUpdateOperationsInput | number | null;
    permissions?: permissionsUncheckedUpdateManyWithoutSubscriptionsNestedInput;
  };

  export type commentsCreateManyCommentsInput = {
    id?: number;
    symbol: string;
    content: string;
    user_id: number;
    likes?: number | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type commentsUpdateWithoutCommentsInput = {
    symbol?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    likes?: NullableIntFieldUpdateOperationsInput | number | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    other_comments?: commentsUpdateManyWithoutCommentsNestedInput;
  };

  export type commentsUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    likes?: NullableIntFieldUpdateOperationsInput | number | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    other_comments?: commentsUncheckedUpdateManyWithoutCommentsNestedInput;
  };

  export type commentsUncheckedUpdateManyWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    symbol?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    user_id?: IntFieldUpdateOperationsInput | number;
    likes?: NullableIntFieldUpdateOperationsInput | number | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type news_commentsCreateManyNews_commentsInput = {
    id?: number;
    news_id: string;
    content: string;
    like_count?: number | null;
    reply_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    user_id: number;
  };

  export type news_commentsUpdateWithoutNews_commentsInput = {
    content?: StringFieldUpdateOperationsInput | string;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    reply_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    user_id?: IntFieldUpdateOperationsInput | number;
    stock_news?: stock_newsUpdateOneRequiredWithoutNews_commentsNestedInput;
    other_news_comments?: news_commentsUpdateManyWithoutNews_commentsNestedInput;
  };

  export type news_commentsUncheckedUpdateWithoutNews_commentsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    news_id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    reply_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    user_id?: IntFieldUpdateOperationsInput | number;
    other_news_comments?: news_commentsUncheckedUpdateManyWithoutNews_commentsNestedInput;
  };

  export type news_commentsUncheckedUpdateManyWithoutNews_commentsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    news_id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    reply_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    user_id?: IntFieldUpdateOperationsInput | number;
  };

  export type news_commentsCreateManyStock_newsInput = {
    id?: number;
    parent_comment_id?: number | null;
    content: string;
    like_count?: number | null;
    reply_count?: number | null;
    is_active?: boolean | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
    user_id: number;
  };

  export type stock_news_read_historyCreateManyStock_newsInput = {
    id?: string;
    user_id?: string | null;
    session_id?: string | null;
    read_at?: Date | string | null;
    language_read?: string | null;
    read_duration?: number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type stock_news_related_symbolsCreateManyStock_newsInput = {
    id?: string;
    related_symbol: string;
    related_exchange?: string | null;
    is_primary?: boolean | null;
  };

  export type stock_news_translationCreateManyStock_newsInput = {
    id?: string;
    language: string;
    title: string;
    content?: string | null;
    summary?: string | null;
    created_at?: Date | string | null;
    updated_at?: Date | string | null;
  };

  export type news_commentsUpdateWithoutStock_newsInput = {
    content?: StringFieldUpdateOperationsInput | string;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    reply_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    user_id?: IntFieldUpdateOperationsInput | number;
    news_comments?: news_commentsUpdateOneWithoutOther_news_commentsNestedInput;
    other_news_comments?: news_commentsUpdateManyWithoutNews_commentsNestedInput;
  };

  export type news_commentsUncheckedUpdateWithoutStock_newsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null;
    content?: StringFieldUpdateOperationsInput | string;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    reply_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    user_id?: IntFieldUpdateOperationsInput | number;
    other_news_comments?: news_commentsUncheckedUpdateManyWithoutNews_commentsNestedInput;
  };

  export type news_commentsUncheckedUpdateManyWithoutStock_newsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null;
    content?: StringFieldUpdateOperationsInput | string;
    like_count?: NullableIntFieldUpdateOperationsInput | number | null;
    reply_count?: NullableIntFieldUpdateOperationsInput | number | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    user_id?: IntFieldUpdateOperationsInput | number;
  };

  export type stock_news_read_historyUpdateWithoutStock_newsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: NullableStringFieldUpdateOperationsInput | string | null;
    session_id?: NullableStringFieldUpdateOperationsInput | string | null;
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    language_read?: NullableStringFieldUpdateOperationsInput | string | null;
    read_duration?: NullableIntFieldUpdateOperationsInput | number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type stock_news_read_historyUncheckedUpdateWithoutStock_newsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: NullableStringFieldUpdateOperationsInput | string | null;
    session_id?: NullableStringFieldUpdateOperationsInput | string | null;
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    language_read?: NullableStringFieldUpdateOperationsInput | string | null;
    read_duration?: NullableIntFieldUpdateOperationsInput | number | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type stock_news_read_historyUncheckedUpdateManyWithoutStock_newsInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      user_id?: NullableStringFieldUpdateOperationsInput | string | null;
      session_id?: NullableStringFieldUpdateOperationsInput | string | null;
      read_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      language_read?: NullableStringFieldUpdateOperationsInput | string | null;
      read_duration?: NullableIntFieldUpdateOperationsInput | number | null;
      metadata?: NullableJsonNullValueInput | InputJsonValue;
    };

  export type stock_news_related_symbolsUpdateWithoutStock_newsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    related_symbol?: StringFieldUpdateOperationsInput | string;
    related_exchange?: NullableStringFieldUpdateOperationsInput | string | null;
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null;
  };

  export type stock_news_related_symbolsUncheckedUpdateWithoutStock_newsInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      related_symbol?: StringFieldUpdateOperationsInput | string;
      related_exchange?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    };

  export type stock_news_related_symbolsUncheckedUpdateManyWithoutStock_newsInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      related_symbol?: StringFieldUpdateOperationsInput | string;
      related_exchange?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    };

  export type stock_news_translationUpdateWithoutStock_newsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type stock_news_translationUncheckedUpdateWithoutStock_newsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: NullableStringFieldUpdateOperationsInput | string | null;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updated_at?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type stock_news_translationUncheckedUpdateManyWithoutStock_newsInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      language?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      content?: NullableStringFieldUpdateOperationsInput | string | null;
      summary?: NullableStringFieldUpdateOperationsInput | string | null;
      created_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      updated_at?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    };

  export type permissionsCreateManySubscriptionsInput = {
    permission_id?: number;
    feature?: string | null;
    is_enabled?: boolean | null;
    limit_access?: string | null;
  };

  export type user_subscriptionsCreateManySubscriptionsInput = {
    user_subscription_id?: number;
    user_id?: number | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    is_active?: boolean | null;
    stripe_subscription_id?: string | null;
    stripe_payment_intent_id?: string | null;
    payment_status?: string | null;
    last_payment_date?: Date | string | null;
    next_billing_date?: Date | string | null;
    cancellation_date?: Date | string | null;
    trial_end_date?: Date | string | null;
    last_payment_attempt_date?: Date | string | null;
    payment_method_id?: string | null;
    redeem_code?: string | null;
  };

  export type permissionsUpdateWithoutSubscriptionsInput = {
    feature?: NullableStringFieldUpdateOperationsInput | string | null;
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    limit_access?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type permissionsUncheckedUpdateWithoutSubscriptionsInput = {
    permission_id?: IntFieldUpdateOperationsInput | number;
    feature?: NullableStringFieldUpdateOperationsInput | string | null;
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    limit_access?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type permissionsUncheckedUpdateManyWithoutSubscriptionsInput = {
    permission_id?: IntFieldUpdateOperationsInput | number;
    feature?: NullableStringFieldUpdateOperationsInput | string | null;
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    limit_access?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type user_subscriptionsUpdateWithoutSubscriptionsInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    stripe_subscription_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    stripe_payment_intent_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null;
    last_payment_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    next_billing_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cancellation_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    trial_end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    last_payment_attempt_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    payment_method_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    redeem_code?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type user_subscriptionsUncheckedUpdateWithoutSubscriptionsInput = {
    user_subscription_id?: IntFieldUpdateOperationsInput | number;
    user_id?: NullableIntFieldUpdateOperationsInput | number | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    stripe_subscription_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    stripe_payment_intent_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null;
    last_payment_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    next_billing_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cancellation_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    trial_end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    last_payment_attempt_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    payment_method_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    redeem_code?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type user_subscriptionsUncheckedUpdateManyWithoutSubscriptionsInput = {
    user_subscription_id?: IntFieldUpdateOperationsInput | number;
    user_id?: NullableIntFieldUpdateOperationsInput | number | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    stripe_subscription_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    stripe_payment_intent_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null;
    last_payment_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    next_billing_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cancellation_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    trial_end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    last_payment_attempt_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    payment_method_id?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    redeem_code?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type superinvestor_holdings_listCreateManySuperinvestor_holdingsInput =
    {
      id?: number;
      symbol?: string | null;
      percentage_of_portfolio?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      recent_activity?: string | null;
      share_raw?: string | null;
      share_value?: Decimal | DecimalJsLike | number | string | null;
      reported_price_raw?: string | null;
      reported_price_value?: Decimal | DecimalJsLike | number | string | null;
      value_raw?: string | null;
      value?: Decimal | DecimalJsLike | number | string | null;
    };

  export type superinvestor_sector_analysisCreateManySuperinvestor_holdingsInput =
    {
      id?: number;
      sector_name?: string | null;
      sector_percentage?: Decimal | DecimalJsLike | number | string | null;
    };

  export type superinvestor_holdings_listUpdateWithoutSuperinvestor_holdingsInput =
    {
      symbol?: NullableStringFieldUpdateOperationsInput | string | null;
      percentage_of_portfolio?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      recent_activity?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      share_raw?: NullableStringFieldUpdateOperationsInput | string | null;
      share_value?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      reported_price_raw?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      reported_price_value?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      value_raw?: NullableStringFieldUpdateOperationsInput | string | null;
      value?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
    };

  export type superinvestor_holdings_listUncheckedUpdateWithoutSuperinvestor_holdingsInput =
    {
      id?: IntFieldUpdateOperationsInput | number;
      symbol?: NullableStringFieldUpdateOperationsInput | string | null;
      percentage_of_portfolio?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      recent_activity?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      share_raw?: NullableStringFieldUpdateOperationsInput | string | null;
      share_value?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      reported_price_raw?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      reported_price_value?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      value_raw?: NullableStringFieldUpdateOperationsInput | string | null;
      value?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
    };

  export type superinvestor_holdings_listUncheckedUpdateManyWithoutSuperinvestor_holdingsInput =
    {
      id?: IntFieldUpdateOperationsInput | number;
      symbol?: NullableStringFieldUpdateOperationsInput | string | null;
      percentage_of_portfolio?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      recent_activity?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      share_raw?: NullableStringFieldUpdateOperationsInput | string | null;
      share_value?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      reported_price_raw?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      reported_price_value?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      value_raw?: NullableStringFieldUpdateOperationsInput | string | null;
      value?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
    };

  export type superinvestor_sector_analysisUpdateWithoutSuperinvestor_holdingsInput =
    {
      sector_name?: NullableStringFieldUpdateOperationsInput | string | null;
      sector_percentage?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
    };

  export type superinvestor_sector_analysisUncheckedUpdateWithoutSuperinvestor_holdingsInput =
    {
      id?: IntFieldUpdateOperationsInput | number;
      sector_name?: NullableStringFieldUpdateOperationsInput | string | null;
      sector_percentage?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
    };

  export type superinvestor_sector_analysisUncheckedUpdateManyWithoutSuperinvestor_holdingsInput =
    {
      id?: IntFieldUpdateOperationsInput | number;
      sector_name?: NullableStringFieldUpdateOperationsInput | string | null;
      sector_percentage?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
    };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
